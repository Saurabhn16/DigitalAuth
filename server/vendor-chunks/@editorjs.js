/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@editorjs";
exports.ids = ["vendor-chunks/@editorjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@editorjs/attaches/dist/bundle.js":
/*!********************************************************!*\
  !*** ./node_modules/@editorjs/attaches/dist/bundle.js ***!
  \********************************************************/
/***/ ((module) => {

eval("!function(e,t){ true?module.exports=t():0}(window,(function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"/\",n(n.s=6)}([function(e,t,n){window,e.exports=function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=3)}([function(e,t){var n;n=function(){return this}();try{n=n||new Function(\"return this\")()}catch(e){\"object\"==typeof window&&(n=window)}e.exports=n},function(e,t,n){\"use strict\";(function(e){var r=n(2),o=setTimeout;function i(){}function a(e){if(!(this instanceof a))throw new TypeError(\"Promises must be constructed via new\");if(\"function\"!=typeof e)throw new TypeError(\"not a function\");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],d(e,this)}function s(e,t){for(;3===e._state;)e=e._value;0!==e._state?(e._handled=!0,a._immediateFn((function(){var n=1===e._state?t.onFulfilled:t.onRejected;if(null!==n){var r;try{r=n(e._value)}catch(e){return void l(t.promise,e)}c(t.promise,r)}else(1===e._state?c:l)(t.promise,e._value)}))):e._deferreds.push(t)}function c(e,t){try{if(t===e)throw new TypeError(\"A promise cannot be resolved with itself.\");if(t&&(\"object\"==typeof t||\"function\"==typeof t)){var n=t.then;if(t instanceof a)return e._state=3,e._value=t,void u(e);if(\"function\"==typeof n)return void d((r=n,o=t,function(){r.apply(o,arguments)}),e)}e._state=1,e._value=t,u(e)}catch(t){l(e,t)}var r,o}function l(e,t){e._state=2,e._value=t,u(e)}function u(e){2===e._state&&0===e._deferreds.length&&a._immediateFn((function(){e._handled||a._unhandledRejectionFn(e._value)}));for(var t=0,n=e._deferreds.length;t<n;t++)s(e,e._deferreds[t]);e._deferreds=null}function f(e,t,n){this.onFulfilled=\"function\"==typeof e?e:null,this.onRejected=\"function\"==typeof t?t:null,this.promise=n}function d(e,t){var n=!1;try{e((function(e){n||(n=!0,c(t,e))}),(function(e){n||(n=!0,l(t,e))}))}catch(e){if(n)return;n=!0,l(t,e)}}a.prototype.catch=function(e){return this.then(null,e)},a.prototype.then=function(e,t){var n=new this.constructor(i);return s(this,new f(e,t,n)),n},a.prototype.finally=r.a,a.all=function(e){return new a((function(t,n){if(!e||void 0===e.length)throw new TypeError(\"Promise.all accepts an array\");var r=Array.prototype.slice.call(e);if(0===r.length)return t([]);var o=r.length;function i(e,a){try{if(a&&(\"object\"==typeof a||\"function\"==typeof a)){var s=a.then;if(\"function\"==typeof s)return void s.call(a,(function(t){i(e,t)}),n)}r[e]=a,0==--o&&t(r)}catch(e){n(e)}}for(var a=0;a<r.length;a++)i(a,r[a])}))},a.resolve=function(e){return e&&\"object\"==typeof e&&e.constructor===a?e:new a((function(t){t(e)}))},a.reject=function(e){return new a((function(t,n){n(e)}))},a.race=function(e){return new a((function(t,n){for(var r=0,o=e.length;r<o;r++)e[r].then(t,n)}))},a._immediateFn=\"function\"==typeof e&&function(t){e(t)}||function(e){o(e,0)},a._unhandledRejectionFn=function(e){\"undefined\"!=typeof console&&console&&console.warn(\"Possible Unhandled Promise Rejection:\",e)},t.a=a}).call(this,n(5).setImmediate)},function(e,t,n){\"use strict\";t.a=function(e){var t=this.constructor;return this.then((function(n){return t.resolve(e()).then((function(){return n}))}),(function(n){return t.resolve(e()).then((function(){return t.reject(n)}))}))}},function(e,t,n){\"use strict\";function r(e){return(r=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}n(4);var o,i,a,s,c,l,u,f=n(8),d=(i=function(e){return new Promise((function(t,n){e=s(e),(e=c(e)).beforeSend&&e.beforeSend();var r=window.XMLHttpRequest?new window.XMLHttpRequest:new window.ActiveXObject(\"Microsoft.XMLHTTP\");r.open(e.method,e.url),r.setRequestHeader(\"X-Requested-With\",\"XMLHttpRequest\"),Object.keys(e.headers).forEach((function(t){var n=e.headers[t];r.setRequestHeader(t,n)}));var o=e.ratio;r.upload.addEventListener(\"progress\",(function(t){var n=Math.round(t.loaded/t.total*100),r=Math.ceil(n*o/100);e.progress(Math.min(r,100))}),!1),r.addEventListener(\"progress\",(function(t){var n=Math.round(t.loaded/t.total*100),r=Math.ceil(n*(100-o)/100)+o;e.progress(Math.min(r,100))}),!1),r.onreadystatechange=function(){if(4===r.readyState){var e=r.response;try{e=JSON.parse(e)}catch(e){}var o=f.parseHeaders(r.getAllResponseHeaders()),i={body:e,code:r.status,headers:o};u(r.status)?t(i):n(i)}},r.send(e.data)}))},a=function(e){return e.method=\"POST\",i(e)},s=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.url&&\"string\"!=typeof e.url)throw new Error(\"Url must be a string\");if(e.url=e.url||\"\",e.method&&\"string\"!=typeof e.method)throw new Error(\"`method` must be a string or null\");if(e.method=e.method?e.method.toUpperCase():\"GET\",e.headers&&\"object\"!==r(e.headers))throw new Error(\"`headers` must be an object or null\");if(e.headers=e.headers||{},e.type&&(\"string\"!=typeof e.type||!Object.values(o).includes(e.type)))throw new Error(\"`type` must be taken from module's «contentType» library\");if(e.progress&&\"function\"!=typeof e.progress)throw new Error(\"`progress` must be a function or null\");if(e.progress=e.progress||function(e){},e.beforeSend=e.beforeSend||function(e){},e.ratio&&\"number\"!=typeof e.ratio)throw new Error(\"`ratio` must be a number\");if(e.ratio<0||e.ratio>100)throw new Error(\"`ratio` must be in a 0-100 interval\");if(e.ratio=e.ratio||90,e.accept&&\"string\"!=typeof e.accept)throw new Error(\"`accept` must be a string with a list of allowed mime-types\");if(e.accept=e.accept||\"*/*\",e.multiple&&\"boolean\"!=typeof e.multiple)throw new Error(\"`multiple` must be a true or false\");if(e.multiple=e.multiple||!1,e.fieldName&&\"string\"!=typeof e.fieldName)throw new Error(\"`fieldName` must be a string\");return e.fieldName=e.fieldName||\"files\",e},c=function(e){switch(e.method){case\"GET\":var t=l(e.data,o.URLENCODED);delete e.data,e.url=/\\?/.test(e.url)?e.url+\"&\"+t:e.url+\"?\"+t;break;case\"POST\":case\"PUT\":case\"DELETE\":case\"UPDATE\":var n=function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}).type||o.JSON}(e);(f.isFormData(e.data)||f.isFormElement(e.data))&&(n=o.FORM),e.data=l(e.data,n),n!==d.contentType.FORM&&(e.headers[\"content-type\"]=n)}return e},l=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};switch(arguments.length>1?arguments[1]:void 0){case o.URLENCODED:return f.urlEncode(e);case o.JSON:return f.jsonEncode(e);case o.FORM:return f.formEncode(e);default:return e}},u=function(e){return e>=200&&e<300},{contentType:o={URLENCODED:\"application/x-www-form-urlencoded; charset=utf-8\",FORM:\"multipart/form-data\",JSON:\"application/json; charset=utf-8\"},request:i,get:function(e){return e.method=\"GET\",i(e)},post:a,transport:function(e){return e=s(e),f.selectFiles(e).then((function(t){for(var n=new FormData,r=0;r<t.length;r++)n.append(e.fieldName,t[r],t[r].name);f.isObject(e.data)&&Object.keys(e.data).forEach((function(t){var r=e.data[t];n.append(t,r)}));var o=e.beforeSend;return e.beforeSend=function(){return o(t)},e.data=n,a(e)}))},selectFiles:function(e){return delete(e=s(e)).beforeSend,f.selectFiles(e)}});e.exports=d},function(e,t,n){\"use strict\";n.r(t);var r=n(1);window.Promise=window.Promise||r.a},function(e,t,n){(function(e){var r=void 0!==e&&e||\"undefined\"!=typeof self&&self||window,o=Function.prototype.apply;function i(e,t){this._id=e,this._clearFn=t}t.setTimeout=function(){return new i(o.call(setTimeout,r,arguments),clearTimeout)},t.setInterval=function(){return new i(o.call(setInterval,r,arguments),clearInterval)},t.clearTimeout=t.clearInterval=function(e){e&&e.close()},i.prototype.unref=i.prototype.ref=function(){},i.prototype.close=function(){this._clearFn.call(r,this._id)},t.enroll=function(e,t){clearTimeout(e._idleTimeoutId),e._idleTimeout=t},t.unenroll=function(e){clearTimeout(e._idleTimeoutId),e._idleTimeout=-1},t._unrefActive=t.active=function(e){clearTimeout(e._idleTimeoutId);var t=e._idleTimeout;t>=0&&(e._idleTimeoutId=setTimeout((function(){e._onTimeout&&e._onTimeout()}),t))},n(6),t.setImmediate=\"undefined\"!=typeof self&&self.setImmediate||void 0!==e&&e.setImmediate||this&&this.setImmediate,t.clearImmediate=\"undefined\"!=typeof self&&self.clearImmediate||void 0!==e&&e.clearImmediate||this&&this.clearImmediate}).call(this,n(0))},function(e,t,n){(function(e,t){!function(e,n){\"use strict\";if(!e.setImmediate){var r,o,i,a,s,c=1,l={},u=!1,f=e.document,d=Object.getPrototypeOf&&Object.getPrototypeOf(e);d=d&&d.setTimeout?d:e,\"[object process]\"==={}.toString.call(e.process)?r=function(e){t.nextTick((function(){h(e)}))}:function(){if(e.postMessage&&!e.importScripts){var t=!0,n=e.onmessage;return e.onmessage=function(){t=!1},e.postMessage(\"\",\"*\"),e.onmessage=n,t}}()?(a=\"setImmediate$\"+Math.random()+\"$\",s=function(t){t.source===e&&\"string\"==typeof t.data&&0===t.data.indexOf(a)&&h(+t.data.slice(a.length))},e.addEventListener?e.addEventListener(\"message\",s,!1):e.attachEvent(\"onmessage\",s),r=function(t){e.postMessage(a+t,\"*\")}):e.MessageChannel?((i=new MessageChannel).port1.onmessage=function(e){h(e.data)},r=function(e){i.port2.postMessage(e)}):f&&\"onreadystatechange\"in f.createElement(\"script\")?(o=f.documentElement,r=function(e){var t=f.createElement(\"script\");t.onreadystatechange=function(){h(e),t.onreadystatechange=null,o.removeChild(t),t=null},o.appendChild(t)}):r=function(e){setTimeout(h,0,e)},d.setImmediate=function(e){\"function\"!=typeof e&&(e=new Function(\"\"+e));for(var t=new Array(arguments.length-1),n=0;n<t.length;n++)t[n]=arguments[n+1];var o={callback:e,args:t};return l[c]=o,r(c),c++},d.clearImmediate=p}function p(e){delete l[e]}function h(e){if(u)setTimeout(h,0,e);else{var t=l[e];if(t){u=!0;try{!function(e){var t=e.callback,n=e.args;switch(n.length){case 0:t();break;case 1:t(n[0]);break;case 2:t(n[0],n[1]);break;case 3:t(n[0],n[1],n[2]);break;default:t.apply(void 0,n)}}(t)}finally{p(e),u=!1}}}}}(\"undefined\"==typeof self?void 0===e?this:e:self)}).call(this,n(0),n(7))},function(e,t){var n,r,o=e.exports={};function i(){throw new Error(\"setTimeout has not been defined\")}function a(){throw new Error(\"clearTimeout has not been defined\")}function s(e){if(n===setTimeout)return setTimeout(e,0);if((n===i||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n=\"function\"==typeof setTimeout?setTimeout:i}catch(e){n=i}try{r=\"function\"==typeof clearTimeout?clearTimeout:a}catch(e){r=a}}();var c,l=[],u=!1,f=-1;function d(){u&&c&&(u=!1,c.length?l=c.concat(l):f=-1,l.length&&p())}function p(){if(!u){var e=s(d);u=!0;for(var t=l.length;t;){for(c=l,l=[];++f<t;)c&&c[f].run();f=-1,t=l.length}c=null,u=!1,function(e){if(r===clearTimeout)return clearTimeout(e);if((r===a||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(e);try{r(e)}catch(t){try{return r.call(null,e)}catch(t){return r.call(this,e)}}}(e)}}function h(e,t){this.fun=e,this.array=t}function m(){}o.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];l.push(new h(e,t)),1!==l.length||u||s(p)},h.prototype.run=function(){this.fun.apply(null,this.array)},o.title=\"browser\",o.browser=!0,o.env={},o.argv=[],o.version=\"\",o.versions={},o.on=m,o.addListener=m,o.once=m,o.off=m,o.removeListener=m,o.removeAllListeners=m,o.emit=m,o.prependListener=m,o.prependOnceListener=m,o.listeners=function(e){return[]},o.binding=function(e){throw new Error(\"process.binding is not supported\")},o.cwd=function(){return\"/\"},o.chdir=function(e){throw new Error(\"process.chdir is not supported\")},o.umask=function(){return 0}},function(e,t,n){function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var o=n(9);e.exports=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e)}var t,n;return t=e,(n=[{key:\"urlEncode\",value:function(e){return o(e)}},{key:\"jsonEncode\",value:function(e){return JSON.stringify(e)}},{key:\"formEncode\",value:function(e){if(this.isFormData(e))return e;if(this.isFormElement(e))return new FormData(e);if(this.isObject(e)){var t=new FormData;return Object.keys(e).forEach((function(n){var r=e[n];t.append(n,r)})),t}throw new Error(\"`data` must be an instance of Object, FormData or <FORM> HTMLElement\")}},{key:\"isObject\",value:function(e){return\"[object Object]\"===Object.prototype.toString.call(e)}},{key:\"isFormData\",value:function(e){return e instanceof FormData}},{key:\"isFormElement\",value:function(e){return e instanceof HTMLFormElement}},{key:\"selectFiles\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new Promise((function(t,n){var r=document.createElement(\"INPUT\");r.type=\"file\",e.multiple&&r.setAttribute(\"multiple\",\"multiple\"),e.accept&&r.setAttribute(\"accept\",e.accept),r.style.display=\"none\",document.body.appendChild(r),r.addEventListener(\"change\",(function(e){var n=e.target.files;t(n),document.body.removeChild(r)}),!1),r.click()}))}},{key:\"parseHeaders\",value:function(e){var t=e.trim().split(/[\\r\\n]+/),n={};return t.forEach((function(e){var t=e.split(\": \"),r=t.shift(),o=t.join(\": \");r&&(n[r]=o)})),n}}])&&r(t,n),e}()},function(e,t){var n=function(e){return encodeURIComponent(e).replace(/[!'()*]/g,escape).replace(/%20/g,\"+\")},r=function(e,t,o,i){return t=t||null,o=o||\"&\",i=i||null,e?function(e){for(var t=new Array,n=0;n<e.length;n++)e[n]&&t.push(e[n]);return t}(Object.keys(e).map((function(a){var s,c,l=a;if(i&&(l=i+\"[\"+l+\"]\"),\"object\"==typeof e[a]&&null!==e[a])s=r(e[a],null,o,l);else{t&&(c=l,l=!isNaN(parseFloat(c))&&isFinite(c)?t+Number(l):l);var u=e[a];u=(u=0===(u=!1===(u=!0===u?\"1\":u)?\"0\":u)?\"0\":u)||\"\",s=n(l)+\"=\"+n(u)}return s}))).join(o).replace(/[!'()*]/g,\"\"):\"\"};e.exports=r}])},function(e,t,n){var r=n(2);\"string\"==typeof r&&(r=[[e.i,r,\"\"]]);var o={hmr:!0,transform:void 0,insertInto:void 0};n(4)(r,o);r.locals&&(e.exports=r.locals)},function(e,t,n){(e.exports=n(3)(!1)).push([e.i,\".cdx-attaches {\\n  --color-line: #EFF0F1;\\n  --color-bg: #fff;\\n  --color-bg-secondary: #F8F8F8;\\n  --color-bg-secondary--hover: #f2f2f2;\\n  --color-text-secondary: #707684;\\n}\\n\\n  .cdx-attaches--with-file {\\n    display: flex;\\n    align-items: center;\\n    padding: 10px 12px;\\n    border: 1px solid var(--color-line);\\n    border-radius: 7px;\\n    background: var(--color-bg);\\n  }\\n\\n  .cdx-attaches--with-file .cdx-attaches__file-info {\\n      display: grid;\\n      grid-gap: 4px;\\n      max-width: calc(100% - 80px);\\n      margin: auto 0;\\n      flex-grow: 2;\\n    }\\n\\n  .cdx-attaches--with-file .cdx-attaches__download-button {\\n      display: flex;\\n      align-items: center;\\n      background: var(--color-bg-secondary);\\n      padding: 6px;\\n      border-radius: 6px;\\n      margin: auto 0 auto auto;\\n    }\\n\\n  .cdx-attaches--with-file .cdx-attaches__download-button:hover {\\n        background: var(--color-bg-secondary--hover);\\n      }\\n\\n  .cdx-attaches--with-file .cdx-attaches__download-button svg {\\n        width: 20px;\\n        height: 20px;\\n        fill: none;\\n      }\\n\\n  .cdx-attaches--with-file .cdx-attaches__file-icon {\\n      position: relative;\\n    }\\n\\n  .cdx-attaches--with-file .cdx-attaches__file-icon-background {\\n        background-color: #333;\\n\\n        width: 27px;\\n        height: 30px;\\n        margin-right: 12px;\\n        border-radius: 8px;\\n        display: flex;\\n        align-items: center;\\n        justify-content: center;\\n      }\\n\\n  @supports(-webkit-mask-box-image: url('')){\\n\\n  .cdx-attaches--with-file .cdx-attaches__file-icon-background {\\n          border-radius: 0;\\n          -webkit-mask-box-image: url(\\\"data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 10.3872C0 1.83334 1.83334 0 10.3872 0H13.6128C22.1667 0 24 1.83334 24 10.3872V13.6128C24 22.1667 22.1667 24 13.6128 24H10.3872C1.83334 24 0 22.1667 0 13.6128V10.3872Z' fill='black'/%3E%3C/svg%3E%0A\\\") 48% 41% 37.9% 53.3%\\n      };\\n        }\\n\\n  .cdx-attaches--with-file .cdx-attaches__file-icon-label {\\n        position: absolute;\\n        left: 3px;\\n        top: 11px;\\n        background: inherit;\\n        text-transform: uppercase;\\n        line-height: 1em;\\n        color: #fff;\\n        padding: 1px 2px;\\n        border-radius: 3px;\\n        font-size: 10px;\\n        font-weight: bold;\\n        /* box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.22); */\\n        font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;\\n        letter-spacing: 0.02em;\\n      }\\n\\n  .cdx-attaches--with-file .cdx-attaches__file-icon svg {\\n        width: 20px;\\n        height: 20px;\\n      }\\n\\n  .cdx-attaches--with-file .cdx-attaches__file-icon path {\\n        stroke: #fff;\\n      }\\n\\n  .cdx-attaches--with-file .cdx-attaches__size {\\n      color: var(--color-text-secondary);\\n      font-size: 12px;\\n      line-height: 1em;\\n    }\\n\\n  .cdx-attaches--with-file .cdx-attaches__size::after {\\n        content: attr(data-size);\\n        margin-left: 0.2em;\\n      }\\n\\n  .cdx-attaches--with-file .cdx-attaches__title {\\n      white-space: nowrap;\\n      text-overflow: ellipsis;\\n      overflow: hidden;\\n      outline: none;\\n      max-width: 90%;\\n      font-size: 14px;\\n      font-weight: 500;\\n      line-height: 1em;\\n    }\\n\\n  .cdx-attaches--with-file .cdx-attaches__title:empty::before {\\n      content: attr(data-placeholder);\\n      color: #7b7e89;\\n    }\\n\\n  .cdx-attaches--loading .cdx-attaches__title,\\n    .cdx-attaches--loading .cdx-attaches__file-icon,\\n    .cdx-attaches--loading .cdx-attaches__size,\\n    .cdx-attaches--loading .cdx-attaches__download-button,\\n    .cdx-attaches--loading .cdx-attaches__button {\\n      opacity: 0;\\n      font-size: 0;\\n    }\\n\\n  .cdx-attaches__button {\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n    color: #000;\\n    border-radius: 7px;\\n    font-weight: 500;\\n  }\\n\\n  .cdx-attaches__button svg {\\n      margin-top: 0;\\n    }\\n\",\"\"])},function(e,t){e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=function(e,t){var n=e[1]||\"\",r=e[3];if(!r)return n;if(t&&\"function\"==typeof btoa){var o=(a=r,\"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(a))))+\" */\"),i=r.sources.map((function(e){return\"/*# sourceURL=\"+r.sourceRoot+e+\" */\"}));return[n].concat(i).concat([o]).join(\"\\n\")}var a;return[n].join(\"\\n\")}(t,e);return t[2]?\"@media \"+t[2]+\"{\"+n+\"}\":n})).join(\"\")},t.i=function(e,n){\"string\"==typeof e&&(e=[[null,e,\"\"]]);for(var r={},o=0;o<this.length;o++){var i=this[o][0];\"number\"==typeof i&&(r[i]=!0)}for(o=0;o<e.length;o++){var a=e[o];\"number\"==typeof a[0]&&r[a[0]]||(n&&!a[2]?a[2]=n:n&&(a[2]=\"(\"+a[2]+\") and (\"+n+\")\"),t.push(a))}},t}},function(e,t,n){var r,o,i={},a=(r=function(){return window&&document&&document.all&&!window.atob},function(){return void 0===o&&(o=r.apply(this,arguments)),o}),s=function(e){return document.querySelector(e)},c=function(e){var t={};return function(e){if(\"function\"==typeof e)return e();if(void 0===t[e]){var n=s.call(this,e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}}(),l=null,u=0,f=[],d=n(5);function p(e,t){for(var n=0;n<e.length;n++){var r=e[n],o=i[r.id];if(o){o.refs++;for(var a=0;a<o.parts.length;a++)o.parts[a](r.parts[a]);for(;a<r.parts.length;a++)o.parts.push(b(r.parts[a],t))}else{var s=[];for(a=0;a<r.parts.length;a++)s.push(b(r.parts[a],t));i[r.id]={id:r.id,refs:1,parts:s}}}}function h(e,t){for(var n=[],r={},o=0;o<e.length;o++){var i=e[o],a=t.base?i[0]+t.base:i[0],s={css:i[1],media:i[2],sourceMap:i[3]};r[a]?r[a].parts.push(s):n.push(r[a]={id:a,parts:[s]})}return n}function m(e,t){var n=c(e.insertInto);if(!n)throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");var r=f[f.length-1];if(\"top\"===e.insertAt)r?r.nextSibling?n.insertBefore(t,r.nextSibling):n.appendChild(t):n.insertBefore(t,n.firstChild),f.push(t);else if(\"bottom\"===e.insertAt)n.appendChild(t);else{if(\"object\"!=typeof e.insertAt||!e.insertAt.before)throw new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");var o=c(e.insertInto+\" \"+e.insertAt.before);n.insertBefore(t,o)}}function v(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e);var t=f.indexOf(e);t>=0&&f.splice(t,1)}function y(e){var t=document.createElement(\"style\");return void 0===e.attrs.type&&(e.attrs.type=\"text/css\"),g(t,e.attrs),m(e,t),t}function g(e,t){Object.keys(t).forEach((function(n){e.setAttribute(n,t[n])}))}function b(e,t){var n,r,o,i;if(t.transform&&e.css){if(!(i=t.transform(e.css)))return function(){};e.css=i}if(t.singleton){var a=u++;n=l||(l=y(t)),r=_.bind(null,n,a,!1),o=_.bind(null,n,a,!0)}else e.sourceMap&&\"function\"==typeof URL&&\"function\"==typeof URL.createObjectURL&&\"function\"==typeof URL.revokeObjectURL&&\"function\"==typeof Blob&&\"function\"==typeof btoa?(n=function(e){var t=document.createElement(\"link\");return void 0===e.attrs.type&&(e.attrs.type=\"text/css\"),e.attrs.rel=\"stylesheet\",g(t,e.attrs),m(e,t),t}(t),r=E.bind(null,n,t),o=function(){v(n),n.href&&URL.revokeObjectURL(n.href)}):(n=y(t),r=S.bind(null,n),o=function(){v(n)});return r(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;r(e=t)}else o()}}e.exports=function(e,t){if(\"undefined\"!=typeof DEBUG&&DEBUG&&\"object\"!=typeof document)throw new Error(\"The style-loader cannot be used in a non-browser environment\");(t=t||{}).attrs=\"object\"==typeof t.attrs?t.attrs:{},t.singleton||\"boolean\"==typeof t.singleton||(t.singleton=a()),t.insertInto||(t.insertInto=\"head\"),t.insertAt||(t.insertAt=\"bottom\");var n=h(e,t);return p(n,t),function(e){for(var r=[],o=0;o<n.length;o++){var a=n[o];(s=i[a.id]).refs--,r.push(s)}e&&p(h(e,t),t);for(o=0;o<r.length;o++){var s;if(0===(s=r[o]).refs){for(var c=0;c<s.parts.length;c++)s.parts[c]();delete i[s.id]}}}};var w,x=(w=[],function(e,t){return w[e]=t,w.filter(Boolean).join(\"\\n\")});function _(e,t,n,r){var o=n?\"\":r.css;if(e.styleSheet)e.styleSheet.cssText=x(t,o);else{var i=document.createTextNode(o),a=e.childNodes;a[t]&&e.removeChild(a[t]),a.length?e.insertBefore(i,a[t]):e.appendChild(i)}}function S(e,t){var n=t.css,r=t.media;if(r&&e.setAttribute(\"media\",r),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}function E(e,t,n){var r=n.css,o=n.sourceMap,i=void 0===t.convertToAbsoluteUrls&&o;(t.convertToAbsoluteUrls||i)&&(r=d(r)),o&&(r+=\"\\n/*# sourceMappingURL=data:application/json;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(o))))+\" */\");var a=new Blob([r],{type:\"text/css\"}),s=e.href;e.href=URL.createObjectURL(a),s&&URL.revokeObjectURL(s)}},function(e,t){e.exports=function(e){var t=\"undefined\"!=typeof window&&window.location;if(!t)throw new Error(\"fixUrls requires window.location\");if(!e||\"string\"!=typeof e)return e;var n=t.protocol+\"//\"+t.host,r=n+t.pathname.replace(/\\/[^\\/]*$/,\"/\");return e.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi,(function(e,t){var o,i=t.trim().replace(/^\"(.*)\"$/,(function(e,t){return t})).replace(/^'(.*)'$/,(function(e,t){return t}));return/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(i)?e:(o=0===i.indexOf(\"//\")?i:0===i.indexOf(\"/\")?n+i:r+i.replace(/^\\.\\//,\"\"),\"url(\"+JSON.stringify(o)+\")\")}))}},function(e,t,n){\"use strict\";n.r(t),n.d(t,\"default\",(function(){return p}));n(1);var r=n(0),o=n.n(r);function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var a=function(){function e(t){var n=t.config,r=t.onUpload,o=t.onError;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.config=n,this.onUpload=r,this.onError=o}var t,n,r;return t=e,(n=[{key:\"uploadSelectedFile\",value:function(e){var t=this,n=e.onPreview;(this.config.uploader&&\"function\"==typeof this.config.uploader.uploadByFile?o.a.selectFiles({accept:this.config.types}).then((function(e){n();var r,o=t.config.uploader.uploadByFile(e[0]);return(r=o)&&\"function\"==typeof r.then||console.warn(\"Custom uploader method uploadByFile should return a Promise\"),o})):o.a.transport({url:this.config.endpoint,accept:this.config.types,beforeSend:function(){return n()},fieldName:this.config.field,headers:this.config.additionalRequestHeaders||{}}).then((function(e){return e.body}))).then((function(e){t.onUpload(e)})).catch((function(e){var n=e.body,r=n&&n.message?n.message:t.config.errorMessage;t.onError(r)}))}}])&&i(t.prototype,n),r&&i(t,r),e}();function s(e){return function(e){if(Array.isArray(e))return c(e)}(e)||function(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)}(e)||function(e,t){if(!e)return;if(\"string\"==typeof e)return c(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);\"Object\"===n&&e.constructor&&(n=e.constructor.name);if(\"Map\"===n||\"Set\"===n)return Array.from(e);if(\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return c(e,t)}(e)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function c(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function l(e){var t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=document.createElement(e);Array.isArray(n)?(t=o.classList).add.apply(t,s(n)):n&&o.classList.add(n);for(var i in r)o[i]=r[i];return o}function u(e){return 0===Object.keys(e).length}const f='<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13.3236 8.43554L9.49533 12.1908C9.13119 12.5505 8.93118 13.043 8.9393 13.5598C8.94741 14.0767 9.163 14.5757 9.53862 14.947C9.91424 15.3182 10.4191 15.5314 10.9422 15.5397C11.4653 15.5479 11.9637 15.3504 12.3279 14.9908L16.1562 11.2355C16.8845 10.5161 17.2845 9.53123 17.2682 8.4975C17.252 7.46376 16.8208 6.46583 16.0696 5.72324C15.3184 4.98066 14.3086 4.55425 13.2624 4.53782C12.2162 4.52138 11.2193 4.91627 10.4911 5.63562L6.66277 9.39093C5.57035 10.4699 4.97032 11.9473 4.99467 13.4979C5.01903 15.0485 5.66578 16.5454 6.79264 17.6592C7.9195 18.7731 9.43417 19.4127 11.0034 19.4374C12.5727 19.462 14.068 18.8697 15.1604 17.7907L18.9887 14.0354\"/></svg>';function d(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var p=function(){function e(t){var n=this,r=t.data,o=t.config,i=t.api,s=t.readOnly;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.api=i,this.readOnly=s,this.nodes={wrapper:null,button:null,title:null},this._data={file:{},title:\"\"},this.config={endpoint:o.endpoint||\"\",field:o.field||\"file\",types:o.types||\"*\",buttonText:o.buttonText||\"Select file to upload\",errorMessage:o.errorMessage||\"File upload failed\",uploader:o.uploader||void 0,additionalRequestHeaders:o.additionalRequestHeaders||{}},void 0===r||u(r)||(this.data=r),this.uploader=new a({config:this.config,onUpload:function(e){return n.onUpload(e)},onError:function(e){return n.uploadingFailed(e)}}),this.enableFileUpload=this.enableFileUpload.bind(this)}var t,n,r;return t=e,r=[{key:\"toolbox\",get:function(){return{icon:f,title:\"Attachment\"}}},{key:\"isReadOnlySupported\",get:function(){return!0}}],(n=[{key:\"CSS\",get:function(){return{baseClass:this.api.styles.block,apiButton:this.api.styles.button,loader:this.api.styles.loader,wrapper:\"cdx-attaches\",wrapperWithFile:\"cdx-attaches--with-file\",wrapperLoading:\"cdx-attaches--loading\",button:\"cdx-attaches__button\",title:\"cdx-attaches__title\",size:\"cdx-attaches__size\",downloadButton:\"cdx-attaches__download-button\",fileInfo:\"cdx-attaches__file-info\",fileIcon:\"cdx-attaches__file-icon\",fileIconBackground:\"cdx-attaches__file-icon-background\",fileIconLabel:\"cdx-attaches__file-icon-label\"}}},{key:\"EXTENSIONS\",get:function(){return{doc:\"#1483E9\",docx:\"#1483E9\",odt:\"#1483E9\",pdf:\"#DB2F2F\",rtf:\"#744FDC\",tex:\"#5a5a5b\",txt:\"#5a5a5b\",pptx:\"#E35200\",ppt:\"#E35200\",mp3:\"#eab456\",mp4:\"#f676a6\",xls:\"#11AE3D\",html:\"#2988f0\",htm:\"#2988f0\",png:\"#AA2284\",jpg:\"#D13359\",jpeg:\"#D13359\",gif:\"#f6af76\",zip:\"#4f566f\",rar:\"#4f566f\",exe:\"#e26f6f\",svg:\"#bf5252\",key:\"#00B2FF\",sketch:\"#FFC700\",ai:\"#FB601D\",psd:\"#388ae5\",dmg:\"#e26f6f\",json:\"#2988f0\",csv:\"#11AE3D\"}}},{key:\"validate\",value:function(e){return!u(e.file)}},{key:\"save\",value:function(e){if(this.pluginHasData()){var t=e.querySelector(\".\".concat(this.CSS.title));t&&Object.assign(this.data,{title:t.innerHTML})}return this.data}},{key:\"render\",value:function(){var e=l(\"div\",this.CSS.baseClass);return this.nodes.wrapper=l(\"div\",this.CSS.wrapper),this.pluginHasData()?this.showFileData():this.prepareUploadButton(),e.appendChild(this.nodes.wrapper),e}},{key:\"prepareUploadButton\",value:function(){this.nodes.button=l(\"div\",[this.CSS.apiButton,this.CSS.button]),this.nodes.button.innerHTML=\"\".concat(f,\" \").concat(this.config.buttonText),this.readOnly||this.nodes.button.addEventListener(\"click\",this.enableFileUpload),this.nodes.wrapper.appendChild(this.nodes.button)}},{key:\"appendCallback\",value:function(){this.nodes.button.click()}},{key:\"pluginHasData\",value:function(){return\"\"!==this.data.title||Object.values(this.data.file).some((function(e){return void 0!==e}))}},{key:\"enableFileUpload\",value:function(){var e=this;this.uploader.uploadSelectedFile({onPreview:function(){e.nodes.wrapper.classList.add(e.CSS.wrapperLoading,e.CSS.loader)}})}},{key:\"onUpload\",value:function(e){var t,n,r,o=e;try{o.success&&void 0!==o.file&&!u(o.file)?(this.data={file:o.file,title:o.file.title||\"\"},this.nodes.button.remove(),this.showFileData(),t=this.nodes.title,n=document.createRange(),r=window.getSelection(),n.selectNodeContents(t),n.collapse(!1),r.removeAllRanges(),r.addRange(n),this.removeLoader()):this.uploadingFailed(this.config.errorMessage)}catch(e){console.error(\"Attaches tool error:\",e),this.uploadingFailed(this.config.errorMessage)}this.api.blocks.getBlockByIndex(this.api.blocks.getCurrentBlockIndex()).dispatchChange()}},{key:\"appendFileIcon\",value:function(e){var t,n=e.extension||(void 0===(t=e.name)?\"\":t.split(\".\").pop()),r=this.EXTENSIONS[n],o=l(\"div\",this.CSS.fileIcon),i=l(\"div\",this.CSS.fileIconBackground);if(r&&(i.style.backgroundColor=r),o.appendChild(i),n){var a=n;n.length>4&&(a=n.substring(0,4)+\"…\");var s=l(\"div\",this.CSS.fileIconLabel,{textContent:a,title:n});r&&(s.style.backgroundColor=r),o.appendChild(s)}else i.innerHTML=f;this.nodes.wrapper.appendChild(o)}},{key:\"removeLoader\",value:function(){var e=this;setTimeout((function(){return e.nodes.wrapper.classList.remove(e.CSS.wrapperLoading,e.CSS.loader)}),500)}},{key:\"showFileData\",value:function(){this.nodes.wrapper.classList.add(this.CSS.wrapperWithFile);var e=this.data,t=e.file,n=e.title;this.appendFileIcon(t);var r=l(\"div\",this.CSS.fileInfo);if(this.nodes.title=l(\"div\",this.CSS.title,{contentEditable:!1===this.readOnly}),this.nodes.title.dataset.placeholder=this.api.i18n.t(\"File title\"),this.nodes.title.textContent=n||\"\",r.appendChild(this.nodes.title),t.size){var o,i,a=l(\"div\",this.CSS.size);Math.log10(+t.size)>=6?(o=\"MiB\",i=t.size/Math.pow(2,20)):(o=\"KiB\",i=t.size/Math.pow(2,10)),a.textContent=i.toFixed(1),a.setAttribute(\"data-size\",o),r.appendChild(a)}if(this.nodes.wrapper.appendChild(r),void 0!==t.url){var s=l(\"a\",this.CSS.downloadButton,{innerHTML:'<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 10L11.8586 14.8586C11.9367 14.9367 12.0633 14.9367 12.1414 14.8586L17 10\"/></svg>',href:t.url,target:\"_blank\",rel:\"nofollow noindex noreferrer\"});this.nodes.wrapper.appendChild(s)}}},{key:\"uploadingFailed\",value:function(e){this.api.notifier.show({message:e,style:\"error\"}),this.removeLoader()}},{key:\"data\",get:function(){return this._data},set:function(e){var t=e.file,n=e.title;this._data={file:t,title:n}}}])&&d(t.prototype,n),r&&d(t,r),e}()}]).default}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2F0dGFjaGVzL2Rpc3QvYnVuZGxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsS0FBaUQsb0JBQW9CLENBQXVILENBQUMsb0JBQW9CLG1CQUFtQixTQUFTLGNBQWMsNEJBQTRCLFlBQVkscUJBQXFCLDJEQUEyRCx1Q0FBdUMscUNBQXFDLG9CQUFvQixFQUFFLGlCQUFpQiw0RkFBNEYsZUFBZSx3Q0FBd0MsU0FBUyxFQUFFLG1CQUFtQiw4QkFBOEIscURBQXFELDBCQUEwQiw2Q0FBNkMsc0JBQXNCLDZEQUE2RCxZQUFZLGVBQWUsU0FBUyxpQkFBaUIsaUNBQWlDLGlCQUFpQixZQUFZLFVBQVUsc0JBQXNCLG1CQUFtQixpREFBaUQsa0JBQWtCLGtCQUFrQiw2QkFBNkIsU0FBUyxjQUFjLDRCQUE0QixZQUFZLHFCQUFxQiwyREFBMkQsdUNBQXVDLHFDQUFxQyxvQkFBb0IsRUFBRSxpQkFBaUIsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsRUFBRSxtQkFBbUIsOEJBQThCLHFEQUFxRCwwQkFBMEIsNkNBQTZDLHNCQUFzQiw2REFBNkQsWUFBWSxlQUFlLFNBQVMsaUJBQWlCLGlDQUFpQyxpQkFBaUIsWUFBWSxVQUFVLHNCQUFzQixtQkFBbUIsaURBQWlELGlCQUFpQixnQkFBZ0IsTUFBTSxhQUFhLFlBQVksR0FBRyxJQUFJLG1DQUFtQyxTQUFTLG9DQUFvQyxZQUFZLGlCQUFpQixhQUFhLGFBQWEsd0JBQXdCLGNBQWMsY0FBYyxvRkFBb0YsOERBQThELCtFQUErRSxnQkFBZ0IsS0FBSyxhQUFhLFlBQVksdURBQXVELDhDQUE4QyxhQUFhLE1BQU0sSUFBSSxjQUFjLFNBQVMsMkJBQTJCLGVBQWUsMkNBQTJDLHlCQUF5QixnQkFBZ0IsSUFBSSwwRUFBMEUsa0RBQWtELGFBQWEseURBQXlELDBEQUEwRCxxQkFBcUIsS0FBSywyQkFBMkIsU0FBUyxPQUFPLFFBQVEsZ0JBQWdCLDJCQUEyQixjQUFjLGtFQUFrRSw4Q0FB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RSw2QkFBNkIseUJBQXlCLGtEQUFrRCw0QkFBNEIsa0JBQWtCLEVBQUUsa0JBQWtCLEVBQUUsOEJBQThCLGtDQUFrQyw2SkFBNkosRUFBRSwyQ0FBMkMsZ1JBQWdSLEVBQUUsc0NBQXNDLDJCQUEyQixFQUFFLHFDQUFxQyw0RUFBNEUsa0JBQWtCLElBQUksRUFBRSx3Q0FBd0MsV0FBVyxrQ0FBa0MscUJBQXFCLGtFQUFrRSxHQUFHLEVBQUUsaUNBQWlDLGNBQWMsSUFBSSxtREFBbUQsbUNBQW1DLGlRQUFpUSxTQUFTLHVGQUF1RiwwRkFBMEYsRUFBRSx1Q0FBdUMsMEpBQTBKLHNEQUFzRCxRQUFRLHFDQUFxQyxzQ0FBc0Msc0JBQXNCLEVBQUUsZ0RBQWdELG1CQUFtQixtQ0FBbUMsRUFBRSxvQ0FBb0MsV0FBVyx1QkFBdUIsMkVBQTJFLFFBQVEsRUFBRSxvQ0FBb0MsMkRBQTJELG1DQUFtQyx1QkFBdUIsaUNBQWlDLDRDQUE0QyxtQ0FBbUMsZ0pBQWdKLGlDQUFpQyxxS0FBcUsscURBQXFELHFDQUFxQyxvVUFBb1UsRUFBRSxvQ0FBb0MsRUFBRSx3Q0FBd0Msd0JBQXdCLHdCQUF3Qix1QkFBdUIsRUFBRSwwQkFBMEIsa0JBQWtCLGlCQUFpQix1QkFBdUIsWUFBWSxpQkFBaUIsaUNBQWlDLEdBQUcsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVkaXRvcmpzLWFwcC8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvYXR0YWNoZXMvZGlzdC9idW5kbGUuanM/YmFjYyJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLkF0dGFjaGVzVG9vbD10KCk6ZS5BdHRhY2hlc1Rvb2w9dCgpfSh3aW5kb3csKGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PXt9O2Z1bmN0aW9uIG4ocil7aWYodFtyXSlyZXR1cm4gdFtyXS5leHBvcnRzO3ZhciBvPXRbcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW3JdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLG4pLG8ubD0hMCxvLmV4cG9ydHN9cmV0dXJuIG4ubT1lLG4uYz10LG4uZD1mdW5jdGlvbihlLHQscil7bi5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0OnJ9KX0sbi5yPWZ1bmN0aW9uKGUpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LG4udD1mdW5jdGlvbihlLHQpe2lmKDEmdCYmKGU9bihlKSksOCZ0KXJldHVybiBlO2lmKDQmdCYmXCJvYmplY3RcIj09dHlwZW9mIGUmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgcj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKG4ucihyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTplfSksMiZ0JiZcInN0cmluZ1wiIT10eXBlb2YgZSlmb3IodmFyIG8gaW4gZSluLmQocixvLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfS5iaW5kKG51bGwsbykpO3JldHVybiByfSxuLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIG4uZCh0LFwiYVwiLHQpLHR9LG4ubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sbi5wPVwiL1wiLG4obi5zPTYpfShbZnVuY3Rpb24oZSx0LG4pe3dpbmRvdyxlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gbihyKXtpZih0W3JdKXJldHVybiB0W3JdLmV4cG9ydHM7dmFyIG89dFtyXT17aTpyLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbcl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsbiksby5sPSEwLG8uZXhwb3J0c31yZXR1cm4gbi5tPWUsbi5jPXQsbi5kPWZ1bmN0aW9uKGUsdCxyKXtuLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6cn0pfSxuLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sbi50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1uKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciByPU9iamVjdC5jcmVhdGUobnVsbCk7aWYobi5yKHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgbyBpbiBlKW4uZChyLG8sZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxvKSk7cmV0dXJuIHJ9LG4ubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gbi5kKHQsXCJhXCIsdCksdH0sbi5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxuLnA9XCJcIixuKG4ucz0zKX0oW2Z1bmN0aW9uKGUsdCl7dmFyIG47bj1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtuPW58fG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl9Y2F0Y2goZSl7XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmKG49d2luZG93KX1lLmV4cG9ydHM9bn0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbihlKXt2YXIgcj1uKDIpLG89c2V0VGltZW91dDtmdW5jdGlvbiBpKCl7fWZ1bmN0aW9uIGEoZSl7aWYoISh0aGlzIGluc3RhbmNlb2YgYSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ld1wiKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgYSBmdW5jdGlvblwiKTt0aGlzLl9zdGF0ZT0wLHRoaXMuX2hhbmRsZWQ9ITEsdGhpcy5fdmFsdWU9dm9pZCAwLHRoaXMuX2RlZmVycmVkcz1bXSxkKGUsdGhpcyl9ZnVuY3Rpb24gcyhlLHQpe2Zvcig7Mz09PWUuX3N0YXRlOyllPWUuX3ZhbHVlOzAhPT1lLl9zdGF0ZT8oZS5faGFuZGxlZD0hMCxhLl9pbW1lZGlhdGVGbigoZnVuY3Rpb24oKXt2YXIgbj0xPT09ZS5fc3RhdGU/dC5vbkZ1bGZpbGxlZDp0Lm9uUmVqZWN0ZWQ7aWYobnVsbCE9PW4pe3ZhciByO3RyeXtyPW4oZS5fdmFsdWUpfWNhdGNoKGUpe3JldHVybiB2b2lkIGwodC5wcm9taXNlLGUpfWModC5wcm9taXNlLHIpfWVsc2UoMT09PWUuX3N0YXRlP2M6bCkodC5wcm9taXNlLGUuX3ZhbHVlKX0pKSk6ZS5fZGVmZXJyZWRzLnB1c2godCl9ZnVuY3Rpb24gYyhlLHQpe3RyeXtpZih0PT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi5cIik7aWYodCYmKFwib2JqZWN0XCI9PXR5cGVvZiB0fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KSl7dmFyIG49dC50aGVuO2lmKHQgaW5zdGFuY2VvZiBhKXJldHVybiBlLl9zdGF0ZT0zLGUuX3ZhbHVlPXQsdm9pZCB1KGUpO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4pcmV0dXJuIHZvaWQgZCgocj1uLG89dCxmdW5jdGlvbigpe3IuYXBwbHkobyxhcmd1bWVudHMpfSksZSl9ZS5fc3RhdGU9MSxlLl92YWx1ZT10LHUoZSl9Y2F0Y2godCl7bChlLHQpfXZhciByLG99ZnVuY3Rpb24gbChlLHQpe2UuX3N0YXRlPTIsZS5fdmFsdWU9dCx1KGUpfWZ1bmN0aW9uIHUoZSl7Mj09PWUuX3N0YXRlJiYwPT09ZS5fZGVmZXJyZWRzLmxlbmd0aCYmYS5faW1tZWRpYXRlRm4oKGZ1bmN0aW9uKCl7ZS5faGFuZGxlZHx8YS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4oZS5fdmFsdWUpfSkpO2Zvcih2YXIgdD0wLG49ZS5fZGVmZXJyZWRzLmxlbmd0aDt0PG47dCsrKXMoZSxlLl9kZWZlcnJlZHNbdF0pO2UuX2RlZmVycmVkcz1udWxsfWZ1bmN0aW9uIGYoZSx0LG4pe3RoaXMub25GdWxmaWxsZWQ9XCJmdW5jdGlvblwiPT10eXBlb2YgZT9lOm51bGwsdGhpcy5vblJlamVjdGVkPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDpudWxsLHRoaXMucHJvbWlzZT1ufWZ1bmN0aW9uIGQoZSx0KXt2YXIgbj0hMTt0cnl7ZSgoZnVuY3Rpb24oZSl7bnx8KG49ITAsYyh0LGUpKX0pLChmdW5jdGlvbihlKXtufHwobj0hMCxsKHQsZSkpfSkpfWNhdGNoKGUpe2lmKG4pcmV0dXJuO249ITAsbCh0LGUpfX1hLnByb3RvdHlwZS5jYXRjaD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aGVuKG51bGwsZSl9LGEucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oZSx0KXt2YXIgbj1uZXcgdGhpcy5jb25zdHJ1Y3RvcihpKTtyZXR1cm4gcyh0aGlzLG5ldyBmKGUsdCxuKSksbn0sYS5wcm90b3R5cGUuZmluYWxseT1yLmEsYS5hbGw9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBhKChmdW5jdGlvbih0LG4pe2lmKCFlfHx2b2lkIDA9PT1lLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvbWlzZS5hbGwgYWNjZXB0cyBhbiBhcnJheVwiKTt2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKTtpZigwPT09ci5sZW5ndGgpcmV0dXJuIHQoW10pO3ZhciBvPXIubGVuZ3RoO2Z1bmN0aW9uIGkoZSxhKXt0cnl7aWYoYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBhKSl7dmFyIHM9YS50aGVuO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMpcmV0dXJuIHZvaWQgcy5jYWxsKGEsKGZ1bmN0aW9uKHQpe2koZSx0KX0pLG4pfXJbZV09YSwwPT0tLW8mJnQocil9Y2F0Y2goZSl7bihlKX19Zm9yKHZhciBhPTA7YTxyLmxlbmd0aDthKyspaShhLHJbYV0pfSkpfSxhLnJlc29sdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlLmNvbnN0cnVjdG9yPT09YT9lOm5ldyBhKChmdW5jdGlvbih0KXt0KGUpfSkpfSxhLnJlamVjdD1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IGEoKGZ1bmN0aW9uKHQsbil7bihlKX0pKX0sYS5yYWNlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgYSgoZnVuY3Rpb24odCxuKXtmb3IodmFyIHI9MCxvPWUubGVuZ3RoO3I8bztyKyspZVtyXS50aGVuKHQsbil9KSl9LGEuX2ltbWVkaWF0ZUZuPVwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmZ1bmN0aW9uKHQpe2UodCl9fHxmdW5jdGlvbihlKXtvKGUsMCl9LGEuX3VuaGFuZGxlZFJlamVjdGlvbkZuPWZ1bmN0aW9uKGUpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBjb25zb2xlJiZjb25zb2xlJiZjb25zb2xlLndhcm4oXCJQb3NzaWJsZSBVbmhhbmRsZWQgUHJvbWlzZSBSZWplY3Rpb246XCIsZSl9LHQuYT1hfSkuY2FsbCh0aGlzLG4oNSkuc2V0SW1tZWRpYXRlKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3QuYT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmNvbnN0cnVjdG9yO3JldHVybiB0aGlzLnRoZW4oKGZ1bmN0aW9uKG4pe3JldHVybiB0LnJlc29sdmUoZSgpKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBufSkpfSksKGZ1bmN0aW9uKG4pe3JldHVybiB0LnJlc29sdmUoZSgpKS50aGVuKChmdW5jdGlvbigpe3JldHVybiB0LnJlamVjdChuKX0pKX0pKX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybihyPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1uKDQpO3ZhciBvLGksYSxzLGMsbCx1LGY9big4KSxkPShpPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxuKXtlPXMoZSksKGU9YyhlKSkuYmVmb3JlU2VuZCYmZS5iZWZvcmVTZW5kKCk7dmFyIHI9d2luZG93LlhNTEh0dHBSZXF1ZXN0P25ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3Q6bmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7ci5vcGVuKGUubWV0aG9kLGUudXJsKSxyLnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsXCJYTUxIdHRwUmVxdWVzdFwiKSxPYmplY3Qua2V5cyhlLmhlYWRlcnMpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBuPWUuaGVhZGVyc1t0XTtyLnNldFJlcXVlc3RIZWFkZXIodCxuKX0pKTt2YXIgbz1lLnJhdGlvO3IudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLChmdW5jdGlvbih0KXt2YXIgbj1NYXRoLnJvdW5kKHQubG9hZGVkL3QudG90YWwqMTAwKSxyPU1hdGguY2VpbChuKm8vMTAwKTtlLnByb2dyZXNzKE1hdGgubWluKHIsMTAwKSl9KSwhMSksci5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwoZnVuY3Rpb24odCl7dmFyIG49TWF0aC5yb3VuZCh0LmxvYWRlZC90LnRvdGFsKjEwMCkscj1NYXRoLmNlaWwobiooMTAwLW8pLzEwMCkrbztlLnByb2dyZXNzKE1hdGgubWluKHIsMTAwKSl9KSwhMSksci5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZig0PT09ci5yZWFkeVN0YXRlKXt2YXIgZT1yLnJlc3BvbnNlO3RyeXtlPUpTT04ucGFyc2UoZSl9Y2F0Y2goZSl7fXZhciBvPWYucGFyc2VIZWFkZXJzKHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLGk9e2JvZHk6ZSxjb2RlOnIuc3RhdHVzLGhlYWRlcnM6b307dShyLnN0YXR1cyk/dChpKTpuKGkpfX0sci5zZW5kKGUuZGF0YSl9KSl9LGE9ZnVuY3Rpb24oZSl7cmV0dXJuIGUubWV0aG9kPVwiUE9TVFwiLGkoZSl9LHM9ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307aWYoZS51cmwmJlwic3RyaW5nXCIhPXR5cGVvZiBlLnVybCl0aHJvdyBuZXcgRXJyb3IoXCJVcmwgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZihlLnVybD1lLnVybHx8XCJcIixlLm1ldGhvZCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUubWV0aG9kKXRocm93IG5ldyBFcnJvcihcImBtZXRob2RgIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbFwiKTtpZihlLm1ldGhvZD1lLm1ldGhvZD9lLm1ldGhvZC50b1VwcGVyQ2FzZSgpOlwiR0VUXCIsZS5oZWFkZXJzJiZcIm9iamVjdFwiIT09cihlLmhlYWRlcnMpKXRocm93IG5ldyBFcnJvcihcImBoZWFkZXJzYCBtdXN0IGJlIGFuIG9iamVjdCBvciBudWxsXCIpO2lmKGUuaGVhZGVycz1lLmhlYWRlcnN8fHt9LGUudHlwZSYmKFwic3RyaW5nXCIhPXR5cGVvZiBlLnR5cGV8fCFPYmplY3QudmFsdWVzKG8pLmluY2x1ZGVzKGUudHlwZSkpKXRocm93IG5ldyBFcnJvcihcImB0eXBlYCBtdXN0IGJlIHRha2VuIGZyb20gbW9kdWxlJ3Mgwqtjb250ZW50VHlwZcK7IGxpYnJhcnlcIik7aWYoZS5wcm9ncmVzcyYmXCJmdW5jdGlvblwiIT10eXBlb2YgZS5wcm9ncmVzcyl0aHJvdyBuZXcgRXJyb3IoXCJgcHJvZ3Jlc3NgIG11c3QgYmUgYSBmdW5jdGlvbiBvciBudWxsXCIpO2lmKGUucHJvZ3Jlc3M9ZS5wcm9ncmVzc3x8ZnVuY3Rpb24oZSl7fSxlLmJlZm9yZVNlbmQ9ZS5iZWZvcmVTZW5kfHxmdW5jdGlvbihlKXt9LGUucmF0aW8mJlwibnVtYmVyXCIhPXR5cGVvZiBlLnJhdGlvKXRocm93IG5ldyBFcnJvcihcImByYXRpb2AgbXVzdCBiZSBhIG51bWJlclwiKTtpZihlLnJhdGlvPDB8fGUucmF0aW8+MTAwKXRocm93IG5ldyBFcnJvcihcImByYXRpb2AgbXVzdCBiZSBpbiBhIDAtMTAwIGludGVydmFsXCIpO2lmKGUucmF0aW89ZS5yYXRpb3x8OTAsZS5hY2NlcHQmJlwic3RyaW5nXCIhPXR5cGVvZiBlLmFjY2VwdCl0aHJvdyBuZXcgRXJyb3IoXCJgYWNjZXB0YCBtdXN0IGJlIGEgc3RyaW5nIHdpdGggYSBsaXN0IG9mIGFsbG93ZWQgbWltZS10eXBlc1wiKTtpZihlLmFjY2VwdD1lLmFjY2VwdHx8XCIqLypcIixlLm11bHRpcGxlJiZcImJvb2xlYW5cIiE9dHlwZW9mIGUubXVsdGlwbGUpdGhyb3cgbmV3IEVycm9yKFwiYG11bHRpcGxlYCBtdXN0IGJlIGEgdHJ1ZSBvciBmYWxzZVwiKTtpZihlLm11bHRpcGxlPWUubXVsdGlwbGV8fCExLGUuZmllbGROYW1lJiZcInN0cmluZ1wiIT10eXBlb2YgZS5maWVsZE5hbWUpdGhyb3cgbmV3IEVycm9yKFwiYGZpZWxkTmFtZWAgbXVzdCBiZSBhIHN0cmluZ1wiKTtyZXR1cm4gZS5maWVsZE5hbWU9ZS5maWVsZE5hbWV8fFwiZmlsZXNcIixlfSxjPWZ1bmN0aW9uKGUpe3N3aXRjaChlLm1ldGhvZCl7Y2FzZVwiR0VUXCI6dmFyIHQ9bChlLmRhdGEsby5VUkxFTkNPREVEKTtkZWxldGUgZS5kYXRhLGUudXJsPS9cXD8vLnRlc3QoZS51cmwpP2UudXJsK1wiJlwiK3Q6ZS51cmwrXCI/XCIrdDticmVhaztjYXNlXCJQT1NUXCI6Y2FzZVwiUFVUXCI6Y2FzZVwiREVMRVRFXCI6Y2FzZVwiVVBEQVRFXCI6dmFyIG49ZnVuY3Rpb24oKXtyZXR1cm4oYXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9KS50eXBlfHxvLkpTT059KGUpOyhmLmlzRm9ybURhdGEoZS5kYXRhKXx8Zi5pc0Zvcm1FbGVtZW50KGUuZGF0YSkpJiYobj1vLkZPUk0pLGUuZGF0YT1sKGUuZGF0YSxuKSxuIT09ZC5jb250ZW50VHlwZS5GT1JNJiYoZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdPW4pfXJldHVybiBlfSxsPWZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O3N3aXRjaChhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl7Y2FzZSBvLlVSTEVOQ09ERUQ6cmV0dXJuIGYudXJsRW5jb2RlKGUpO2Nhc2Ugby5KU09OOnJldHVybiBmLmpzb25FbmNvZGUoZSk7Y2FzZSBvLkZPUk06cmV0dXJuIGYuZm9ybUVuY29kZShlKTtkZWZhdWx0OnJldHVybiBlfX0sdT1mdW5jdGlvbihlKXtyZXR1cm4gZT49MjAwJiZlPDMwMH0se2NvbnRlbnRUeXBlOm89e1VSTEVOQ09ERUQ6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9dXRmLThcIixGT1JNOlwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLEpTT046XCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJ9LHJlcXVlc3Q6aSxnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUubWV0aG9kPVwiR0VUXCIsaShlKX0scG9zdDphLHRyYW5zcG9ydDpmdW5jdGlvbihlKXtyZXR1cm4gZT1zKGUpLGYuc2VsZWN0RmlsZXMoZSkudGhlbigoZnVuY3Rpb24odCl7Zm9yKHZhciBuPW5ldyBGb3JtRGF0YSxyPTA7cjx0Lmxlbmd0aDtyKyspbi5hcHBlbmQoZS5maWVsZE5hbWUsdFtyXSx0W3JdLm5hbWUpO2YuaXNPYmplY3QoZS5kYXRhKSYmT2JqZWN0LmtleXMoZS5kYXRhKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgcj1lLmRhdGFbdF07bi5hcHBlbmQodCxyKX0pKTt2YXIgbz1lLmJlZm9yZVNlbmQ7cmV0dXJuIGUuYmVmb3JlU2VuZD1mdW5jdGlvbigpe3JldHVybiBvKHQpfSxlLmRhdGE9bixhKGUpfSkpfSxzZWxlY3RGaWxlczpmdW5jdGlvbihlKXtyZXR1cm4gZGVsZXRlKGU9cyhlKSkuYmVmb3JlU2VuZCxmLnNlbGVjdEZpbGVzKGUpfX0pO2UuZXhwb3J0cz1kfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKHQpO3ZhciByPW4oMSk7d2luZG93LlByb21pc2U9d2luZG93LlByb21pc2V8fHIuYX0sZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbihlKXt2YXIgcj12b2lkIDAhPT1lJiZlfHxcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZnx8d2luZG93LG89RnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O2Z1bmN0aW9uIGkoZSx0KXt0aGlzLl9pZD1lLHRoaXMuX2NsZWFyRm49dH10LnNldFRpbWVvdXQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGkoby5jYWxsKHNldFRpbWVvdXQscixhcmd1bWVudHMpLGNsZWFyVGltZW91dCl9LHQuc2V0SW50ZXJ2YWw9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGkoby5jYWxsKHNldEludGVydmFsLHIsYXJndW1lbnRzKSxjbGVhckludGVydmFsKX0sdC5jbGVhclRpbWVvdXQ9dC5jbGVhckludGVydmFsPWZ1bmN0aW9uKGUpe2UmJmUuY2xvc2UoKX0saS5wcm90b3R5cGUudW5yZWY9aS5wcm90b3R5cGUucmVmPWZ1bmN0aW9uKCl7fSxpLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpe3RoaXMuX2NsZWFyRm4uY2FsbChyLHRoaXMuX2lkKX0sdC5lbnJvbGw9ZnVuY3Rpb24oZSx0KXtjbGVhclRpbWVvdXQoZS5faWRsZVRpbWVvdXRJZCksZS5faWRsZVRpbWVvdXQ9dH0sdC51bmVucm9sbD1mdW5jdGlvbihlKXtjbGVhclRpbWVvdXQoZS5faWRsZVRpbWVvdXRJZCksZS5faWRsZVRpbWVvdXQ9LTF9LHQuX3VucmVmQWN0aXZlPXQuYWN0aXZlPWZ1bmN0aW9uKGUpe2NsZWFyVGltZW91dChlLl9pZGxlVGltZW91dElkKTt2YXIgdD1lLl9pZGxlVGltZW91dDt0Pj0wJiYoZS5faWRsZVRpbWVvdXRJZD1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2UuX29uVGltZW91dCYmZS5fb25UaW1lb3V0KCl9KSx0KSl9LG4oNiksdC5zZXRJbW1lZGlhdGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGYuc2V0SW1tZWRpYXRlfHx2b2lkIDAhPT1lJiZlLnNldEltbWVkaWF0ZXx8dGhpcyYmdGhpcy5zZXRJbW1lZGlhdGUsdC5jbGVhckltbWVkaWF0ZT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZi5jbGVhckltbWVkaWF0ZXx8dm9pZCAwIT09ZSYmZS5jbGVhckltbWVkaWF0ZXx8dGhpcyYmdGhpcy5jbGVhckltbWVkaWF0ZX0pLmNhbGwodGhpcyxuKDApKX0sZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbihlLHQpeyFmdW5jdGlvbihlLG4pe1widXNlIHN0cmljdFwiO2lmKCFlLnNldEltbWVkaWF0ZSl7dmFyIHIsbyxpLGEscyxjPTEsbD17fSx1PSExLGY9ZS5kb2N1bWVudCxkPU9iamVjdC5nZXRQcm90b3R5cGVPZiYmT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO2Q9ZCYmZC5zZXRUaW1lb3V0P2Q6ZSxcIltvYmplY3QgcHJvY2Vzc11cIj09PXt9LnRvU3RyaW5nLmNhbGwoZS5wcm9jZXNzKT9yPWZ1bmN0aW9uKGUpe3QubmV4dFRpY2soKGZ1bmN0aW9uKCl7aChlKX0pKX06ZnVuY3Rpb24oKXtpZihlLnBvc3RNZXNzYWdlJiYhZS5pbXBvcnRTY3JpcHRzKXt2YXIgdD0hMCxuPWUub25tZXNzYWdlO3JldHVybiBlLm9ubWVzc2FnZT1mdW5jdGlvbigpe3Q9ITF9LGUucG9zdE1lc3NhZ2UoXCJcIixcIipcIiksZS5vbm1lc3NhZ2U9bix0fX0oKT8oYT1cInNldEltbWVkaWF0ZSRcIitNYXRoLnJhbmRvbSgpK1wiJFwiLHM9ZnVuY3Rpb24odCl7dC5zb3VyY2U9PT1lJiZcInN0cmluZ1wiPT10eXBlb2YgdC5kYXRhJiYwPT09dC5kYXRhLmluZGV4T2YoYSkmJmgoK3QuZGF0YS5zbGljZShhLmxlbmd0aCkpfSxlLmFkZEV2ZW50TGlzdGVuZXI/ZS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHMsITEpOmUuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIixzKSxyPWZ1bmN0aW9uKHQpe2UucG9zdE1lc3NhZ2UoYSt0LFwiKlwiKX0pOmUuTWVzc2FnZUNoYW5uZWw/KChpPW5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEub25tZXNzYWdlPWZ1bmN0aW9uKGUpe2goZS5kYXRhKX0scj1mdW5jdGlvbihlKXtpLnBvcnQyLnBvc3RNZXNzYWdlKGUpfSk6ZiYmXCJvbnJlYWR5c3RhdGVjaGFuZ2VcImluIGYuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKT8obz1mLmRvY3VtZW50RWxlbWVudCxyPWZ1bmN0aW9uKGUpe3ZhciB0PWYuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTt0Lm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2goZSksdC5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxvLnJlbW92ZUNoaWxkKHQpLHQ9bnVsbH0sby5hcHBlbmRDaGlsZCh0KX0pOnI9ZnVuY3Rpb24oZSl7c2V0VGltZW91dChoLDAsZSl9LGQuc2V0SW1tZWRpYXRlPWZ1bmN0aW9uKGUpe1wiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJihlPW5ldyBGdW5jdGlvbihcIlwiK2UpKTtmb3IodmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksbj0wO248dC5sZW5ndGg7bisrKXRbbl09YXJndW1lbnRzW24rMV07dmFyIG89e2NhbGxiYWNrOmUsYXJnczp0fTtyZXR1cm4gbFtjXT1vLHIoYyksYysrfSxkLmNsZWFySW1tZWRpYXRlPXB9ZnVuY3Rpb24gcChlKXtkZWxldGUgbFtlXX1mdW5jdGlvbiBoKGUpe2lmKHUpc2V0VGltZW91dChoLDAsZSk7ZWxzZXt2YXIgdD1sW2VdO2lmKHQpe3U9ITA7dHJ5eyFmdW5jdGlvbihlKXt2YXIgdD1lLmNhbGxiYWNrLG49ZS5hcmdzO3N3aXRjaChuLmxlbmd0aCl7Y2FzZSAwOnQoKTticmVhaztjYXNlIDE6dChuWzBdKTticmVhaztjYXNlIDI6dChuWzBdLG5bMV0pO2JyZWFrO2Nhc2UgMzp0KG5bMF0sblsxXSxuWzJdKTticmVhaztkZWZhdWx0OnQuYXBwbHkodm9pZCAwLG4pfX0odCl9ZmluYWxseXtwKGUpLHU9ITF9fX19fShcInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj92b2lkIDA9PT1lP3RoaXM6ZTpzZWxmKX0pLmNhbGwodGhpcyxuKDApLG4oNykpfSxmdW5jdGlvbihlLHQpe3ZhciBuLHIsbz1lLmV4cG9ydHM9e307ZnVuY3Rpb24gaSgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gYSgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBzKGUpe2lmKG49PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KGUsMCk7aWYoKG49PT1pfHwhbikmJnNldFRpbWVvdXQpcmV0dXJuIG49c2V0VGltZW91dCxzZXRUaW1lb3V0KGUsMCk7dHJ5e3JldHVybiBuKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlLDApfX19IWZ1bmN0aW9uKCl7dHJ5e249XCJmdW5jdGlvblwiPT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0Oml9Y2F0Y2goZSl7bj1pfXRyeXtyPVwiZnVuY3Rpb25cIj09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6YX1jYXRjaChlKXtyPWF9fSgpO3ZhciBjLGw9W10sdT0hMSxmPS0xO2Z1bmN0aW9uIGQoKXt1JiZjJiYodT0hMSxjLmxlbmd0aD9sPWMuY29uY2F0KGwpOmY9LTEsbC5sZW5ndGgmJnAoKSl9ZnVuY3Rpb24gcCgpe2lmKCF1KXt2YXIgZT1zKGQpO3U9ITA7Zm9yKHZhciB0PWwubGVuZ3RoO3Q7KXtmb3IoYz1sLGw9W107KytmPHQ7KWMmJmNbZl0ucnVuKCk7Zj0tMSx0PWwubGVuZ3RofWM9bnVsbCx1PSExLGZ1bmN0aW9uKGUpe2lmKHI9PT1jbGVhclRpbWVvdXQpcmV0dXJuIGNsZWFyVGltZW91dChlKTtpZigocj09PWF8fCFyKSYmY2xlYXJUaW1lb3V0KXJldHVybiByPWNsZWFyVGltZW91dCxjbGVhclRpbWVvdXQoZSk7dHJ5e3IoZSl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSl9fX0oZSl9fWZ1bmN0aW9uIGgoZSx0KXt0aGlzLmZ1bj1lLHRoaXMuYXJyYXk9dH1mdW5jdGlvbiBtKCl7fW8ubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuLTFdPWFyZ3VtZW50c1tuXTtsLnB1c2gobmV3IGgoZSx0KSksMSE9PWwubGVuZ3RofHx1fHxzKHApfSxoLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfSxvLnRpdGxlPVwiYnJvd3NlclwiLG8uYnJvd3Nlcj0hMCxvLmVudj17fSxvLmFyZ3Y9W10sby52ZXJzaW9uPVwiXCIsby52ZXJzaW9ucz17fSxvLm9uPW0sby5hZGRMaXN0ZW5lcj1tLG8ub25jZT1tLG8ub2ZmPW0sby5yZW1vdmVMaXN0ZW5lcj1tLG8ucmVtb3ZlQWxsTGlzdGVuZXJzPW0sby5lbWl0PW0sby5wcmVwZW5kTGlzdGVuZXI9bSxvLnByZXBlbmRPbmNlTGlzdGVuZXI9bSxvLmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX0sby5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfSxvLmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifSxvLmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX0sby51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0sZnVuY3Rpb24oZSx0LG4pe2Z1bmN0aW9uIHIoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXZhciBvPW4oOSk7ZS5leHBvcnRzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSl9dmFyIHQsbjtyZXR1cm4gdD1lLChuPVt7a2V5OlwidXJsRW5jb2RlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIG8oZSl9fSx7a2V5OlwianNvbkVuY29kZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBKU09OLnN0cmluZ2lmeShlKX19LHtrZXk6XCJmb3JtRW5jb2RlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYodGhpcy5pc0Zvcm1EYXRhKGUpKXJldHVybiBlO2lmKHRoaXMuaXNGb3JtRWxlbWVudChlKSlyZXR1cm4gbmV3IEZvcm1EYXRhKGUpO2lmKHRoaXMuaXNPYmplY3QoZSkpe3ZhciB0PW5ldyBGb3JtRGF0YTtyZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoZnVuY3Rpb24obil7dmFyIHI9ZVtuXTt0LmFwcGVuZChuLHIpfSkpLHR9dGhyb3cgbmV3IEVycm9yKFwiYGRhdGFgIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgT2JqZWN0LCBGb3JtRGF0YSBvciA8Rk9STT4gSFRNTEVsZW1lbnRcIil9fSx7a2V5OlwiaXNPYmplY3RcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpfX0se2tleTpcImlzRm9ybURhdGFcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEZvcm1EYXRhfX0se2tleTpcImlzRm9ybUVsZW1lbnRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudH19LHtrZXk6XCJzZWxlY3RGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxuKXt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiSU5QVVRcIik7ci50eXBlPVwiZmlsZVwiLGUubXVsdGlwbGUmJnIuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIixcIm11bHRpcGxlXCIpLGUuYWNjZXB0JiZyLnNldEF0dHJpYnV0ZShcImFjY2VwdFwiLGUuYWNjZXB0KSxyLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyKSxyLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwoZnVuY3Rpb24oZSl7dmFyIG49ZS50YXJnZXQuZmlsZXM7dChuKSxkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHIpfSksITEpLHIuY2xpY2soKX0pKX19LHtrZXk6XCJwYXJzZUhlYWRlcnNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rLyksbj17fTtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdD1lLnNwbGl0KFwiOiBcIikscj10LnNoaWZ0KCksbz10LmpvaW4oXCI6IFwiKTtyJiYobltyXT1vKX0pKSxufX1dKSYmcih0LG4pLGV9KCl9LGZ1bmN0aW9uKGUsdCl7dmFyIG49ZnVuY3Rpb24oZSl7cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlKS5yZXBsYWNlKC9bIScoKSpdL2csZXNjYXBlKS5yZXBsYWNlKC8lMjAvZyxcIitcIil9LHI9ZnVuY3Rpb24oZSx0LG8saSl7cmV0dXJuIHQ9dHx8bnVsbCxvPW98fFwiJlwiLGk9aXx8bnVsbCxlP2Z1bmN0aW9uKGUpe2Zvcih2YXIgdD1uZXcgQXJyYXksbj0wO248ZS5sZW5ndGg7bisrKWVbbl0mJnQucHVzaChlW25dKTtyZXR1cm4gdH0oT2JqZWN0LmtleXMoZSkubWFwKChmdW5jdGlvbihhKXt2YXIgcyxjLGw9YTtpZihpJiYobD1pK1wiW1wiK2wrXCJdXCIpLFwib2JqZWN0XCI9PXR5cGVvZiBlW2FdJiZudWxsIT09ZVthXSlzPXIoZVthXSxudWxsLG8sbCk7ZWxzZXt0JiYoYz1sLGw9IWlzTmFOKHBhcnNlRmxvYXQoYykpJiZpc0Zpbml0ZShjKT90K051bWJlcihsKTpsKTt2YXIgdT1lW2FdO3U9KHU9MD09PSh1PSExPT09KHU9ITA9PT11P1wiMVwiOnUpP1wiMFwiOnUpP1wiMFwiOnUpfHxcIlwiLHM9bihsKStcIj1cIituKHUpfXJldHVybiBzfSkpKS5qb2luKG8pLnJlcGxhY2UoL1shJygpKl0vZyxcIlwiKTpcIlwifTtlLmV4cG9ydHM9cn1dKX0sZnVuY3Rpb24oZSx0LG4pe3ZhciByPW4oMik7XCJzdHJpbmdcIj09dHlwZW9mIHImJihyPVtbZS5pLHIsXCJcIl1dKTt2YXIgbz17aG1yOiEwLHRyYW5zZm9ybTp2b2lkIDAsaW5zZXJ0SW50bzp2b2lkIDB9O24oNCkocixvKTtyLmxvY2FscyYmKGUuZXhwb3J0cz1yLmxvY2Fscyl9LGZ1bmN0aW9uKGUsdCxuKXsoZS5leHBvcnRzPW4oMykoITEpKS5wdXNoKFtlLmksXCIuY2R4LWF0dGFjaGVzIHtcXG4gIC0tY29sb3ItbGluZTogI0VGRjBGMTtcXG4gIC0tY29sb3ItYmc6ICNmZmY7XFxuICAtLWNvbG9yLWJnLXNlY29uZGFyeTogI0Y4RjhGODtcXG4gIC0tY29sb3ItYmctc2Vjb25kYXJ5LS1ob3ZlcjogI2YyZjJmMjtcXG4gIC0tY29sb3ItdGV4dC1zZWNvbmRhcnk6ICM3MDc2ODQ7XFxufVxcblxcbiAgLmNkeC1hdHRhY2hlcy0td2l0aC1maWxlIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZzogMTBweCAxMnB4O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1jb2xvci1saW5lKTtcXG4gICAgYm9yZGVyLXJhZGl1czogN3B4O1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jb2xvci1iZyk7XFxuICB9XFxuXFxuICAuY2R4LWF0dGFjaGVzLS13aXRoLWZpbGUgLmNkeC1hdHRhY2hlc19fZmlsZS1pbmZvIHtcXG4gICAgICBkaXNwbGF5OiBncmlkO1xcbiAgICAgIGdyaWQtZ2FwOiA0cHg7XFxuICAgICAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSA4MHB4KTtcXG4gICAgICBtYXJnaW46IGF1dG8gMDtcXG4gICAgICBmbGV4LWdyb3c6IDI7XFxuICAgIH1cXG5cXG4gIC5jZHgtYXR0YWNoZXMtLXdpdGgtZmlsZSAuY2R4LWF0dGFjaGVzX19kb3dubG9hZC1idXR0b24ge1xcbiAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jb2xvci1iZy1zZWNvbmRhcnkpO1xcbiAgICAgIHBhZGRpbmc6IDZweDtcXG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICAgICAgbWFyZ2luOiBhdXRvIDAgYXV0byBhdXRvO1xcbiAgICB9XFxuXFxuICAuY2R4LWF0dGFjaGVzLS13aXRoLWZpbGUgLmNkeC1hdHRhY2hlc19fZG93bmxvYWQtYnV0dG9uOmhvdmVyIHtcXG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLWNvbG9yLWJnLXNlY29uZGFyeS0taG92ZXIpO1xcbiAgICAgIH1cXG5cXG4gIC5jZHgtYXR0YWNoZXMtLXdpdGgtZmlsZSAuY2R4LWF0dGFjaGVzX19kb3dubG9hZC1idXR0b24gc3ZnIHtcXG4gICAgICAgIHdpZHRoOiAyMHB4O1xcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xcbiAgICAgICAgZmlsbDogbm9uZTtcXG4gICAgICB9XFxuXFxuICAuY2R4LWF0dGFjaGVzLS13aXRoLWZpbGUgLmNkeC1hdHRhY2hlc19fZmlsZS1pY29uIHtcXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIH1cXG5cXG4gIC5jZHgtYXR0YWNoZXMtLXdpdGgtZmlsZSAuY2R4LWF0dGFjaGVzX19maWxlLWljb24tYmFja2dyb3VuZCB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xcblxcbiAgICAgICAgd2lkdGg6IDI3cHg7XFxuICAgICAgICBoZWlnaHQ6IDMwcHg7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDEycHg7XFxuICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICAgIH1cXG5cXG4gIEBzdXBwb3J0cygtd2Via2l0LW1hc2stYm94LWltYWdlOiB1cmwoJycpKXtcXG5cXG4gIC5jZHgtYXR0YWNoZXMtLXdpdGgtZmlsZSAuY2R4LWF0dGFjaGVzX19maWxlLWljb24tYmFja2dyb3VuZCB7XFxuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgICAgICAgIC13ZWJraXQtbWFzay1ib3gtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB3aWR0aD0nMjQnIGhlaWdodD0nMjQnIHZpZXdCb3g9JzAgMCAyNCAyNCcgZmlsbD0nbm9uZScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyUzRSUzQ3BhdGggZD0nTTAgMTAuMzg3MkMwIDEuODMzMzQgMS44MzMzNCAwIDEwLjM4NzIgMEgxMy42MTI4QzIyLjE2NjcgMCAyNCAxLjgzMzM0IDI0IDEwLjM4NzJWMTMuNjEyOEMyNCAyMi4xNjY3IDIyLjE2NjcgMjQgMTMuNjEyOCAyNEgxMC4zODcyQzEuODMzMzQgMjQgMCAyMi4xNjY3IDAgMTMuNjEyOFYxMC4zODcyWicgZmlsbD0nYmxhY2snLyUzRSUzQy9zdmclM0UlMEFcXFwiKSA0OCUgNDElIDM3LjklIDUzLjMlXFxuICAgICAgfTtcXG4gICAgICAgIH1cXG5cXG4gIC5jZHgtYXR0YWNoZXMtLXdpdGgtZmlsZSAuY2R4LWF0dGFjaGVzX19maWxlLWljb24tbGFiZWwge1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgbGVmdDogM3B4O1xcbiAgICAgICAgdG9wOiAxMXB4O1xcbiAgICAgICAgYmFja2dyb3VuZDogaW5oZXJpdDtcXG4gICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICAgICAgICBsaW5lLWhlaWdodDogMWVtO1xcbiAgICAgICAgY29sb3I6ICNmZmY7XFxuICAgICAgICBwYWRkaW5nOiAxcHggMnB4O1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICAgICAgZm9udC1zaXplOiAxMHB4O1xcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgICAgICAvKiBib3gtc2hhZG93OiAwcHggNHB4IDZweCByZ2JhKDAsIDAsIDAsIDAuMjIpOyAqL1xcbiAgICAgICAgZm9udC1mYW1pbHk6IHVpLW1vbm9zcGFjZSxTRk1vbm8tUmVndWxhcixTRiBNb25vLE1lbmxvLENvbnNvbGFzLExpYmVyYXRpb24gTW9ubyxtb25vc3BhY2U7XFxuICAgICAgICBsZXR0ZXItc3BhY2luZzogMC4wMmVtO1xcbiAgICAgIH1cXG5cXG4gIC5jZHgtYXR0YWNoZXMtLXdpdGgtZmlsZSAuY2R4LWF0dGFjaGVzX19maWxlLWljb24gc3ZnIHtcXG4gICAgICAgIHdpZHRoOiAyMHB4O1xcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xcbiAgICAgIH1cXG5cXG4gIC5jZHgtYXR0YWNoZXMtLXdpdGgtZmlsZSAuY2R4LWF0dGFjaGVzX19maWxlLWljb24gcGF0aCB7XFxuICAgICAgICBzdHJva2U6ICNmZmY7XFxuICAgICAgfVxcblxcbiAgLmNkeC1hdHRhY2hlcy0td2l0aC1maWxlIC5jZHgtYXR0YWNoZXNfX3NpemUge1xcbiAgICAgIGNvbG9yOiB2YXIoLS1jb2xvci10ZXh0LXNlY29uZGFyeSk7XFxuICAgICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAxZW07XFxuICAgIH1cXG5cXG4gIC5jZHgtYXR0YWNoZXMtLXdpdGgtZmlsZSAuY2R4LWF0dGFjaGVzX19zaXplOjphZnRlciB7XFxuICAgICAgICBjb250ZW50OiBhdHRyKGRhdGEtc2l6ZSk7XFxuICAgICAgICBtYXJnaW4tbGVmdDogMC4yZW07XFxuICAgICAgfVxcblxcbiAgLmNkeC1hdHRhY2hlcy0td2l0aC1maWxlIC5jZHgtYXR0YWNoZXNfX3RpdGxlIHtcXG4gICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgb3V0bGluZTogbm9uZTtcXG4gICAgICBtYXgtd2lkdGg6IDkwJTtcXG4gICAgICBmb250LXNpemU6IDE0cHg7XFxuICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgICBsaW5lLWhlaWdodDogMWVtO1xcbiAgICB9XFxuXFxuICAuY2R4LWF0dGFjaGVzLS13aXRoLWZpbGUgLmNkeC1hdHRhY2hlc19fdGl0bGU6ZW1wdHk6OmJlZm9yZSB7XFxuICAgICAgY29udGVudDogYXR0cihkYXRhLXBsYWNlaG9sZGVyKTtcXG4gICAgICBjb2xvcjogIzdiN2U4OTtcXG4gICAgfVxcblxcbiAgLmNkeC1hdHRhY2hlcy0tbG9hZGluZyAuY2R4LWF0dGFjaGVzX190aXRsZSxcXG4gICAgLmNkeC1hdHRhY2hlcy0tbG9hZGluZyAuY2R4LWF0dGFjaGVzX19maWxlLWljb24sXFxuICAgIC5jZHgtYXR0YWNoZXMtLWxvYWRpbmcgLmNkeC1hdHRhY2hlc19fc2l6ZSxcXG4gICAgLmNkeC1hdHRhY2hlcy0tbG9hZGluZyAuY2R4LWF0dGFjaGVzX19kb3dubG9hZC1idXR0b24sXFxuICAgIC5jZHgtYXR0YWNoZXMtLWxvYWRpbmcgLmNkeC1hdHRhY2hlc19fYnV0dG9uIHtcXG4gICAgICBvcGFjaXR5OiAwO1xcbiAgICAgIGZvbnQtc2l6ZTogMDtcXG4gICAgfVxcblxcbiAgLmNkeC1hdHRhY2hlc19fYnV0dG9uIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGNvbG9yOiAjMDAwO1xcbiAgICBib3JkZXItcmFkaXVzOiA3cHg7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICB9XFxuXFxuICAuY2R4LWF0dGFjaGVzX19idXR0b24gc3ZnIHtcXG4gICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICB9XFxuXCIsXCJcIl0pfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1bXTtyZXR1cm4gdC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcCgoZnVuY3Rpb24odCl7dmFyIG49ZnVuY3Rpb24oZSx0KXt2YXIgbj1lWzFdfHxcIlwiLHI9ZVszXTtpZighcilyZXR1cm4gbjtpZih0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBidG9hKXt2YXIgbz0oYT1yLFwiLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiK2J0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGEpKSkpK1wiICovXCIpLGk9ci5zb3VyY2VzLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuXCIvKiMgc291cmNlVVJMPVwiK3Iuc291cmNlUm9vdCtlK1wiICovXCJ9KSk7cmV0dXJuW25dLmNvbmNhdChpKS5jb25jYXQoW29dKS5qb2luKFwiXFxuXCIpfXZhciBhO3JldHVybltuXS5qb2luKFwiXFxuXCIpfSh0LGUpO3JldHVybiB0WzJdP1wiQG1lZGlhIFwiK3RbMl0rXCJ7XCIrbitcIn1cIjpufSkpLmpvaW4oXCJcIil9LHQuaT1mdW5jdGlvbihlLG4pe1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1bW251bGwsZSxcIlwiXV0pO2Zvcih2YXIgcj17fSxvPTA7bzx0aGlzLmxlbmd0aDtvKyspe3ZhciBpPXRoaXNbb11bMF07XCJudW1iZXJcIj09dHlwZW9mIGkmJihyW2ldPSEwKX1mb3Iobz0wO288ZS5sZW5ndGg7bysrKXt2YXIgYT1lW29dO1wibnVtYmVyXCI9PXR5cGVvZiBhWzBdJiZyW2FbMF1dfHwobiYmIWFbMl0/YVsyXT1uOm4mJihhWzJdPVwiKFwiK2FbMl0rXCIpIGFuZCAoXCIrbitcIilcIiksdC5wdXNoKGEpKX19LHR9fSxmdW5jdGlvbihlLHQsbil7dmFyIHIsbyxpPXt9LGE9KHI9ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93JiZkb2N1bWVudCYmZG9jdW1lbnQuYWxsJiYhd2luZG93LmF0b2J9LGZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PW8mJihvPXIuYXBwbHkodGhpcyxhcmd1bWVudHMpKSxvfSkscz1mdW5jdGlvbihlKXtyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKX0sYz1mdW5jdGlvbihlKXt2YXIgdD17fTtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZSlyZXR1cm4gZSgpO2lmKHZvaWQgMD09PXRbZV0pe3ZhciBuPXMuY2FsbCh0aGlzLGUpO2lmKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCYmbiBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCl0cnl7bj1uLmNvbnRlbnREb2N1bWVudC5oZWFkfWNhdGNoKGUpe249bnVsbH10W2VdPW59cmV0dXJuIHRbZV19fSgpLGw9bnVsbCx1PTAsZj1bXSxkPW4oNSk7ZnVuY3Rpb24gcChlLHQpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dLG89aVtyLmlkXTtpZihvKXtvLnJlZnMrKztmb3IodmFyIGE9MDthPG8ucGFydHMubGVuZ3RoO2ErKylvLnBhcnRzW2FdKHIucGFydHNbYV0pO2Zvcig7YTxyLnBhcnRzLmxlbmd0aDthKyspby5wYXJ0cy5wdXNoKGIoci5wYXJ0c1thXSx0KSl9ZWxzZXt2YXIgcz1bXTtmb3IoYT0wO2E8ci5wYXJ0cy5sZW5ndGg7YSsrKXMucHVzaChiKHIucGFydHNbYV0sdCkpO2lbci5pZF09e2lkOnIuaWQscmVmczoxLHBhcnRzOnN9fX19ZnVuY3Rpb24gaChlLHQpe2Zvcih2YXIgbj1bXSxyPXt9LG89MDtvPGUubGVuZ3RoO28rKyl7dmFyIGk9ZVtvXSxhPXQuYmFzZT9pWzBdK3QuYmFzZTppWzBdLHM9e2NzczppWzFdLG1lZGlhOmlbMl0sc291cmNlTWFwOmlbM119O3JbYV0/clthXS5wYXJ0cy5wdXNoKHMpOm4ucHVzaChyW2FdPXtpZDphLHBhcnRzOltzXX0pfXJldHVybiBufWZ1bmN0aW9uIG0oZSx0KXt2YXIgbj1jKGUuaW5zZXJ0SW50byk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7dmFyIHI9ZltmLmxlbmd0aC0xXTtpZihcInRvcFwiPT09ZS5pbnNlcnRBdClyP3IubmV4dFNpYmxpbmc/bi5pbnNlcnRCZWZvcmUodCxyLm5leHRTaWJsaW5nKTpuLmFwcGVuZENoaWxkKHQpOm4uaW5zZXJ0QmVmb3JlKHQsbi5maXJzdENoaWxkKSxmLnB1c2godCk7ZWxzZSBpZihcImJvdHRvbVwiPT09ZS5pbnNlcnRBdCluLmFwcGVuZENoaWxkKHQpO2Vsc2V7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuaW5zZXJ0QXR8fCFlLmluc2VydEF0LmJlZm9yZSl0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTt2YXIgbz1jKGUuaW5zZXJ0SW50bytcIiBcIitlLmluc2VydEF0LmJlZm9yZSk7bi5pbnNlcnRCZWZvcmUodCxvKX19ZnVuY3Rpb24gdihlKXtpZihudWxsPT09ZS5wYXJlbnROb2RlKXJldHVybiExO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKTt2YXIgdD1mLmluZGV4T2YoZSk7dD49MCYmZi5zcGxpY2UodCwxKX1mdW5jdGlvbiB5KGUpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtyZXR1cm4gdm9pZCAwPT09ZS5hdHRycy50eXBlJiYoZS5hdHRycy50eXBlPVwidGV4dC9jc3NcIiksZyh0LGUuYXR0cnMpLG0oZSx0KSx0fWZ1bmN0aW9uIGcoZSx0KXtPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChmdW5jdGlvbihuKXtlLnNldEF0dHJpYnV0ZShuLHRbbl0pfSkpfWZ1bmN0aW9uIGIoZSx0KXt2YXIgbixyLG8saTtpZih0LnRyYW5zZm9ybSYmZS5jc3Mpe2lmKCEoaT10LnRyYW5zZm9ybShlLmNzcykpKXJldHVybiBmdW5jdGlvbigpe307ZS5jc3M9aX1pZih0LnNpbmdsZXRvbil7dmFyIGE9dSsrO249bHx8KGw9eSh0KSkscj1fLmJpbmQobnVsbCxuLGEsITEpLG89Xy5iaW5kKG51bGwsbixhLCEwKX1lbHNlIGUuc291cmNlTWFwJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBVUkwmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEJsb2ImJlwiZnVuY3Rpb25cIj09dHlwZW9mIGJ0b2E/KG49ZnVuY3Rpb24oZSl7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7cmV0dXJuIHZvaWQgMD09PWUuYXR0cnMudHlwZSYmKGUuYXR0cnMudHlwZT1cInRleHQvY3NzXCIpLGUuYXR0cnMucmVsPVwic3R5bGVzaGVldFwiLGcodCxlLmF0dHJzKSxtKGUsdCksdH0odCkscj1FLmJpbmQobnVsbCxuLHQpLG89ZnVuY3Rpb24oKXt2KG4pLG4uaHJlZiYmVVJMLnJldm9rZU9iamVjdFVSTChuLmhyZWYpfSk6KG49eSh0KSxyPVMuYmluZChudWxsLG4pLG89ZnVuY3Rpb24oKXt2KG4pfSk7cmV0dXJuIHIoZSksZnVuY3Rpb24odCl7aWYodCl7aWYodC5jc3M9PT1lLmNzcyYmdC5tZWRpYT09PWUubWVkaWEmJnQuc291cmNlTWFwPT09ZS5zb3VyY2VNYXApcmV0dXJuO3IoZT10KX1lbHNlIG8oKX19ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIERFQlVHJiZERUJVRyYmXCJvYmplY3RcIiE9dHlwZW9mIGRvY3VtZW50KXRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTsodD10fHx7fSkuYXR0cnM9XCJvYmplY3RcIj09dHlwZW9mIHQuYXR0cnM/dC5hdHRyczp7fSx0LnNpbmdsZXRvbnx8XCJib29sZWFuXCI9PXR5cGVvZiB0LnNpbmdsZXRvbnx8KHQuc2luZ2xldG9uPWEoKSksdC5pbnNlcnRJbnRvfHwodC5pbnNlcnRJbnRvPVwiaGVhZFwiKSx0Lmluc2VydEF0fHwodC5pbnNlcnRBdD1cImJvdHRvbVwiKTt2YXIgbj1oKGUsdCk7cmV0dXJuIHAobix0KSxmdW5jdGlvbihlKXtmb3IodmFyIHI9W10sbz0wO288bi5sZW5ndGg7bysrKXt2YXIgYT1uW29dOyhzPWlbYS5pZF0pLnJlZnMtLSxyLnB1c2gocyl9ZSYmcChoKGUsdCksdCk7Zm9yKG89MDtvPHIubGVuZ3RoO28rKyl7dmFyIHM7aWYoMD09PShzPXJbb10pLnJlZnMpe2Zvcih2YXIgYz0wO2M8cy5wYXJ0cy5sZW5ndGg7YysrKXMucGFydHNbY10oKTtkZWxldGUgaVtzLmlkXX19fX07dmFyIHcseD0odz1bXSxmdW5jdGlvbihlLHQpe3JldHVybiB3W2VdPXQsdy5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKX0pO2Z1bmN0aW9uIF8oZSx0LG4scil7dmFyIG89bj9cIlwiOnIuY3NzO2lmKGUuc3R5bGVTaGVldCllLnN0eWxlU2hlZXQuY3NzVGV4dD14KHQsbyk7ZWxzZXt2YXIgaT1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShvKSxhPWUuY2hpbGROb2RlczthW3RdJiZlLnJlbW92ZUNoaWxkKGFbdF0pLGEubGVuZ3RoP2UuaW5zZXJ0QmVmb3JlKGksYVt0XSk6ZS5hcHBlbmRDaGlsZChpKX19ZnVuY3Rpb24gUyhlLHQpe3ZhciBuPXQuY3NzLHI9dC5tZWRpYTtpZihyJiZlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsciksZS5zdHlsZVNoZWV0KWUuc3R5bGVTaGVldC5jc3NUZXh0PW47ZWxzZXtmb3IoO2UuZmlyc3RDaGlsZDspZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobikpfX1mdW5jdGlvbiBFKGUsdCxuKXt2YXIgcj1uLmNzcyxvPW4uc291cmNlTWFwLGk9dm9pZCAwPT09dC5jb252ZXJ0VG9BYnNvbHV0ZVVybHMmJm87KHQuY29udmVydFRvQWJzb2x1dGVVcmxzfHxpKSYmKHI9ZChyKSksbyYmKHIrPVwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIitidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShvKSkpKStcIiAqL1wiKTt2YXIgYT1uZXcgQmxvYihbcl0se3R5cGU6XCJ0ZXh0L2Nzc1wifSkscz1lLmhyZWY7ZS5ocmVmPVVSTC5jcmVhdGVPYmplY3RVUkwoYSkscyYmVVJMLnJldm9rZU9iamVjdFVSTChzKX19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5sb2NhdGlvbjtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtpZighZXx8XCJzdHJpbmdcIiE9dHlwZW9mIGUpcmV0dXJuIGU7dmFyIG49dC5wcm90b2NvbCtcIi8vXCIrdC5ob3N0LHI9bit0LnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLyxcIi9cIik7cmV0dXJuIGUucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksKGZ1bmN0aW9uKGUsdCl7dmFyIG8saT10LnRyaW0oKS5yZXBsYWNlKC9eXCIoLiopXCIkLywoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH0pKS5yZXBsYWNlKC9eJyguKiknJC8sKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9KSk7cmV0dXJuL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdChpKT9lOihvPTA9PT1pLmluZGV4T2YoXCIvL1wiKT9pOjA9PT1pLmluZGV4T2YoXCIvXCIpP24raTpyK2kucmVwbGFjZSgvXlxcLlxcLy8sXCJcIiksXCJ1cmwoXCIrSlNPTi5zdHJpbmdpZnkobykrXCIpXCIpfSkpfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO24ucih0KSxuLmQodCxcImRlZmF1bHRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gcH0pKTtuKDEpO3ZhciByPW4oMCksbz1uLm4ocik7ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3ZhciBuPXQuY29uZmlnLHI9dC5vblVwbG9hZCxvPXQub25FcnJvcjshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMuY29uZmlnPW4sdGhpcy5vblVwbG9hZD1yLHRoaXMub25FcnJvcj1vfXZhciB0LG4scjtyZXR1cm4gdD1lLChuPVt7a2V5OlwidXBsb2FkU2VsZWN0ZWRGaWxlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPWUub25QcmV2aWV3Oyh0aGlzLmNvbmZpZy51cGxvYWRlciYmXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5jb25maWcudXBsb2FkZXIudXBsb2FkQnlGaWxlP28uYS5zZWxlY3RGaWxlcyh7YWNjZXB0OnRoaXMuY29uZmlnLnR5cGVzfSkudGhlbigoZnVuY3Rpb24oZSl7bigpO3ZhciByLG89dC5jb25maWcudXBsb2FkZXIudXBsb2FkQnlGaWxlKGVbMF0pO3JldHVybihyPW8pJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiByLnRoZW58fGNvbnNvbGUud2FybihcIkN1c3RvbSB1cGxvYWRlciBtZXRob2QgdXBsb2FkQnlGaWxlIHNob3VsZCByZXR1cm4gYSBQcm9taXNlXCIpLG99KSk6by5hLnRyYW5zcG9ydCh7dXJsOnRoaXMuY29uZmlnLmVuZHBvaW50LGFjY2VwdDp0aGlzLmNvbmZpZy50eXBlcyxiZWZvcmVTZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIG4oKX0sZmllbGROYW1lOnRoaXMuY29uZmlnLmZpZWxkLGhlYWRlcnM6dGhpcy5jb25maWcuYWRkaXRpb25hbFJlcXVlc3RIZWFkZXJzfHx7fX0pLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBlLmJvZHl9KSkpLnRoZW4oKGZ1bmN0aW9uKGUpe3Qub25VcGxvYWQoZSl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe3ZhciBuPWUuYm9keSxyPW4mJm4ubWVzc2FnZT9uLm1lc3NhZ2U6dC5jb25maWcuZXJyb3JNZXNzYWdlO3Qub25FcnJvcihyKX0pKX19XSkmJmkodC5wcm90b3R5cGUsbiksciYmaSh0LHIpLGV9KCk7ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gYyhlKX0oZSl8fGZ1bmN0aW9uKGUpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJm51bGwhPWVbU3ltYm9sLml0ZXJhdG9yXXx8bnVsbCE9ZVtcIkBAaXRlcmF0b3JcIl0pcmV0dXJuIEFycmF5LmZyb20oZSl9KGUpfHxmdW5jdGlvbihlLHQpe2lmKCFlKXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gYyhlLHQpO3ZhciBuPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LC0xKTtcIk9iamVjdFwiPT09biYmZS5jb25zdHJ1Y3RvciYmKG49ZS5jb25zdHJ1Y3Rvci5uYW1lKTtpZihcIk1hcFwiPT09bnx8XCJTZXRcIj09PW4pcmV0dXJuIEFycmF5LmZyb20oZSk7aWYoXCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKXJldHVybiBjKGUsdCl9KGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfWZ1bmN0aW9uIGMoZSx0KXsobnVsbD09dHx8dD5lLmxlbmd0aCkmJih0PWUubGVuZ3RoKTtmb3IodmFyIG49MCxyPW5ldyBBcnJheSh0KTtuPHQ7bisrKXJbbl09ZVtuXTtyZXR1cm4gcn1mdW5jdGlvbiBsKGUpe3ZhciB0LG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOm51bGwscj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e30sbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpO0FycmF5LmlzQXJyYXkobik/KHQ9by5jbGFzc0xpc3QpLmFkZC5hcHBseSh0LHMobikpOm4mJm8uY2xhc3NMaXN0LmFkZChuKTtmb3IodmFyIGkgaW4gcilvW2ldPXJbaV07cmV0dXJuIG99ZnVuY3Rpb24gdShlKXtyZXR1cm4gMD09PU9iamVjdC5rZXlzKGUpLmxlbmd0aH1jb25zdCBmPSc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMy4zMjM2IDguNDM1NTRMOS40OTUzMyAxMi4xOTA4QzkuMTMxMTkgMTIuNTUwNSA4LjkzMTE4IDEzLjA0MyA4LjkzOTMgMTMuNTU5OEM4Ljk0NzQxIDE0LjA3NjcgOS4xNjMgMTQuNTc1NyA5LjUzODYyIDE0Ljk0N0M5LjkxNDI0IDE1LjMxODIgMTAuNDE5MSAxNS41MzE0IDEwLjk0MjIgMTUuNTM5N0MxMS40NjUzIDE1LjU0NzkgMTEuOTYzNyAxNS4zNTA0IDEyLjMyNzkgMTQuOTkwOEwxNi4xNTYyIDExLjIzNTVDMTYuODg0NSAxMC41MTYxIDE3LjI4NDUgOS41MzEyMyAxNy4yNjgyIDguNDk3NUMxNy4yNTIgNy40NjM3NiAxNi44MjA4IDYuNDY1ODMgMTYuMDY5NiA1LjcyMzI0QzE1LjMxODQgNC45ODA2NiAxNC4zMDg2IDQuNTU0MjUgMTMuMjYyNCA0LjUzNzgyQzEyLjIxNjIgNC41MjEzOCAxMS4yMTkzIDQuOTE2MjcgMTAuNDkxMSA1LjYzNTYyTDYuNjYyNzcgOS4zOTA5M0M1LjU3MDM1IDEwLjQ2OTkgNC45NzAzMiAxMS45NDczIDQuOTk0NjcgMTMuNDk3OUM1LjAxOTAzIDE1LjA0ODUgNS42NjU3OCAxNi41NDU0IDYuNzkyNjQgMTcuNjU5MkM3LjkxOTUgMTguNzczMSA5LjQzNDE3IDE5LjQxMjcgMTEuMDAzNCAxOS40Mzc0QzEyLjU3MjcgMTkuNDYyIDE0LjA2OCAxOC44Njk3IDE1LjE2MDQgMTcuNzkwN0wxOC45ODg3IDE0LjAzNTRcIi8+PC9zdmc+JztmdW5jdGlvbiBkKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX12YXIgcD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIG49dGhpcyxyPXQuZGF0YSxvPXQuY29uZmlnLGk9dC5hcGkscz10LnJlYWRPbmx5OyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5hcGk9aSx0aGlzLnJlYWRPbmx5PXMsdGhpcy5ub2Rlcz17d3JhcHBlcjpudWxsLGJ1dHRvbjpudWxsLHRpdGxlOm51bGx9LHRoaXMuX2RhdGE9e2ZpbGU6e30sdGl0bGU6XCJcIn0sdGhpcy5jb25maWc9e2VuZHBvaW50Om8uZW5kcG9pbnR8fFwiXCIsZmllbGQ6by5maWVsZHx8XCJmaWxlXCIsdHlwZXM6by50eXBlc3x8XCIqXCIsYnV0dG9uVGV4dDpvLmJ1dHRvblRleHR8fFwiU2VsZWN0IGZpbGUgdG8gdXBsb2FkXCIsZXJyb3JNZXNzYWdlOm8uZXJyb3JNZXNzYWdlfHxcIkZpbGUgdXBsb2FkIGZhaWxlZFwiLHVwbG9hZGVyOm8udXBsb2FkZXJ8fHZvaWQgMCxhZGRpdGlvbmFsUmVxdWVzdEhlYWRlcnM6by5hZGRpdGlvbmFsUmVxdWVzdEhlYWRlcnN8fHt9fSx2b2lkIDA9PT1yfHx1KHIpfHwodGhpcy5kYXRhPXIpLHRoaXMudXBsb2FkZXI9bmV3IGEoe2NvbmZpZzp0aGlzLmNvbmZpZyxvblVwbG9hZDpmdW5jdGlvbihlKXtyZXR1cm4gbi5vblVwbG9hZChlKX0sb25FcnJvcjpmdW5jdGlvbihlKXtyZXR1cm4gbi51cGxvYWRpbmdGYWlsZWQoZSl9fSksdGhpcy5lbmFibGVGaWxlVXBsb2FkPXRoaXMuZW5hYmxlRmlsZVVwbG9hZC5iaW5kKHRoaXMpfXZhciB0LG4scjtyZXR1cm4gdD1lLHI9W3trZXk6XCJ0b29sYm94XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJue2ljb246Zix0aXRsZTpcIkF0dGFjaG1lbnRcIn19fSx7a2V5OlwiaXNSZWFkT25seVN1cHBvcnRlZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiEwfX1dLChuPVt7a2V5OlwiQ1NTXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJue2Jhc2VDbGFzczp0aGlzLmFwaS5zdHlsZXMuYmxvY2ssYXBpQnV0dG9uOnRoaXMuYXBpLnN0eWxlcy5idXR0b24sbG9hZGVyOnRoaXMuYXBpLnN0eWxlcy5sb2FkZXIsd3JhcHBlcjpcImNkeC1hdHRhY2hlc1wiLHdyYXBwZXJXaXRoRmlsZTpcImNkeC1hdHRhY2hlcy0td2l0aC1maWxlXCIsd3JhcHBlckxvYWRpbmc6XCJjZHgtYXR0YWNoZXMtLWxvYWRpbmdcIixidXR0b246XCJjZHgtYXR0YWNoZXNfX2J1dHRvblwiLHRpdGxlOlwiY2R4LWF0dGFjaGVzX190aXRsZVwiLHNpemU6XCJjZHgtYXR0YWNoZXNfX3NpemVcIixkb3dubG9hZEJ1dHRvbjpcImNkeC1hdHRhY2hlc19fZG93bmxvYWQtYnV0dG9uXCIsZmlsZUluZm86XCJjZHgtYXR0YWNoZXNfX2ZpbGUtaW5mb1wiLGZpbGVJY29uOlwiY2R4LWF0dGFjaGVzX19maWxlLWljb25cIixmaWxlSWNvbkJhY2tncm91bmQ6XCJjZHgtYXR0YWNoZXNfX2ZpbGUtaWNvbi1iYWNrZ3JvdW5kXCIsZmlsZUljb25MYWJlbDpcImNkeC1hdHRhY2hlc19fZmlsZS1pY29uLWxhYmVsXCJ9fX0se2tleTpcIkVYVEVOU0lPTlNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm57ZG9jOlwiIzE0ODNFOVwiLGRvY3g6XCIjMTQ4M0U5XCIsb2R0OlwiIzE0ODNFOVwiLHBkZjpcIiNEQjJGMkZcIixydGY6XCIjNzQ0RkRDXCIsdGV4OlwiIzVhNWE1YlwiLHR4dDpcIiM1YTVhNWJcIixwcHR4OlwiI0UzNTIwMFwiLHBwdDpcIiNFMzUyMDBcIixtcDM6XCIjZWFiNDU2XCIsbXA0OlwiI2Y2NzZhNlwiLHhsczpcIiMxMUFFM0RcIixodG1sOlwiIzI5ODhmMFwiLGh0bTpcIiMyOTg4ZjBcIixwbmc6XCIjQUEyMjg0XCIsanBnOlwiI0QxMzM1OVwiLGpwZWc6XCIjRDEzMzU5XCIsZ2lmOlwiI2Y2YWY3NlwiLHppcDpcIiM0ZjU2NmZcIixyYXI6XCIjNGY1NjZmXCIsZXhlOlwiI2UyNmY2ZlwiLHN2ZzpcIiNiZjUyNTJcIixrZXk6XCIjMDBCMkZGXCIsc2tldGNoOlwiI0ZGQzcwMFwiLGFpOlwiI0ZCNjAxRFwiLHBzZDpcIiMzODhhZTVcIixkbWc6XCIjZTI2ZjZmXCIsanNvbjpcIiMyOTg4ZjBcIixjc3Y6XCIjMTFBRTNEXCJ9fX0se2tleTpcInZhbGlkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIXUoZS5maWxlKX19LHtrZXk6XCJzYXZlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYodGhpcy5wbHVnaW5IYXNEYXRhKCkpe3ZhciB0PWUucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQodGhpcy5DU1MudGl0bGUpKTt0JiZPYmplY3QuYXNzaWduKHRoaXMuZGF0YSx7dGl0bGU6dC5pbm5lckhUTUx9KX1yZXR1cm4gdGhpcy5kYXRhfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9bChcImRpdlwiLHRoaXMuQ1NTLmJhc2VDbGFzcyk7cmV0dXJuIHRoaXMubm9kZXMud3JhcHBlcj1sKFwiZGl2XCIsdGhpcy5DU1Mud3JhcHBlciksdGhpcy5wbHVnaW5IYXNEYXRhKCk/dGhpcy5zaG93RmlsZURhdGEoKTp0aGlzLnByZXBhcmVVcGxvYWRCdXR0b24oKSxlLmFwcGVuZENoaWxkKHRoaXMubm9kZXMud3JhcHBlciksZX19LHtrZXk6XCJwcmVwYXJlVXBsb2FkQnV0dG9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm5vZGVzLmJ1dHRvbj1sKFwiZGl2XCIsW3RoaXMuQ1NTLmFwaUJ1dHRvbix0aGlzLkNTUy5idXR0b25dKSx0aGlzLm5vZGVzLmJ1dHRvbi5pbm5lckhUTUw9XCJcIi5jb25jYXQoZixcIiBcIikuY29uY2F0KHRoaXMuY29uZmlnLmJ1dHRvblRleHQpLHRoaXMucmVhZE9ubHl8fHRoaXMubm9kZXMuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuZW5hYmxlRmlsZVVwbG9hZCksdGhpcy5ub2Rlcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMuYnV0dG9uKX19LHtrZXk6XCJhcHBlbmRDYWxsYmFja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5ub2Rlcy5idXR0b24uY2xpY2soKX19LHtrZXk6XCJwbHVnaW5IYXNEYXRhXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm5cIlwiIT09dGhpcy5kYXRhLnRpdGxlfHxPYmplY3QudmFsdWVzKHRoaXMuZGF0YS5maWxlKS5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09ZX0pKX19LHtrZXk6XCJlbmFibGVGaWxlVXBsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMudXBsb2FkZXIudXBsb2FkU2VsZWN0ZWRGaWxlKHtvblByZXZpZXc6ZnVuY3Rpb24oKXtlLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmFkZChlLkNTUy53cmFwcGVyTG9hZGluZyxlLkNTUy5sb2FkZXIpfX0pfX0se2tleTpcIm9uVXBsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQsbixyLG89ZTt0cnl7by5zdWNjZXNzJiZ2b2lkIDAhPT1vLmZpbGUmJiF1KG8uZmlsZSk/KHRoaXMuZGF0YT17ZmlsZTpvLmZpbGUsdGl0bGU6by5maWxlLnRpdGxlfHxcIlwifSx0aGlzLm5vZGVzLmJ1dHRvbi5yZW1vdmUoKSx0aGlzLnNob3dGaWxlRGF0YSgpLHQ9dGhpcy5ub2Rlcy50aXRsZSxuPWRvY3VtZW50LmNyZWF0ZVJhbmdlKCkscj13aW5kb3cuZ2V0U2VsZWN0aW9uKCksbi5zZWxlY3ROb2RlQ29udGVudHModCksbi5jb2xsYXBzZSghMSksci5yZW1vdmVBbGxSYW5nZXMoKSxyLmFkZFJhbmdlKG4pLHRoaXMucmVtb3ZlTG9hZGVyKCkpOnRoaXMudXBsb2FkaW5nRmFpbGVkKHRoaXMuY29uZmlnLmVycm9yTWVzc2FnZSl9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihcIkF0dGFjaGVzIHRvb2wgZXJyb3I6XCIsZSksdGhpcy51cGxvYWRpbmdGYWlsZWQodGhpcy5jb25maWcuZXJyb3JNZXNzYWdlKX10aGlzLmFwaS5ibG9ja3MuZ2V0QmxvY2tCeUluZGV4KHRoaXMuYXBpLmJsb2Nrcy5nZXRDdXJyZW50QmxvY2tJbmRleCgpKS5kaXNwYXRjaENoYW5nZSgpfX0se2tleTpcImFwcGVuZEZpbGVJY29uXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQsbj1lLmV4dGVuc2lvbnx8KHZvaWQgMD09PSh0PWUubmFtZSk/XCJcIjp0LnNwbGl0KFwiLlwiKS5wb3AoKSkscj10aGlzLkVYVEVOU0lPTlNbbl0sbz1sKFwiZGl2XCIsdGhpcy5DU1MuZmlsZUljb24pLGk9bChcImRpdlwiLHRoaXMuQ1NTLmZpbGVJY29uQmFja2dyb3VuZCk7aWYociYmKGkuc3R5bGUuYmFja2dyb3VuZENvbG9yPXIpLG8uYXBwZW5kQ2hpbGQoaSksbil7dmFyIGE9bjtuLmxlbmd0aD40JiYoYT1uLnN1YnN0cmluZygwLDQpK1wi4oCmXCIpO3ZhciBzPWwoXCJkaXZcIix0aGlzLkNTUy5maWxlSWNvbkxhYmVsLHt0ZXh0Q29udGVudDphLHRpdGxlOm59KTtyJiYocy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9ciksby5hcHBlbmRDaGlsZChzKX1lbHNlIGkuaW5uZXJIVE1MPWY7dGhpcy5ub2Rlcy53cmFwcGVyLmFwcGVuZENoaWxkKG8pfX0se2tleTpcInJlbW92ZUxvYWRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztzZXRUaW1lb3V0KChmdW5jdGlvbigpe3JldHVybiBlLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShlLkNTUy53cmFwcGVyTG9hZGluZyxlLkNTUy5sb2FkZXIpfSksNTAwKX19LHtrZXk6XCJzaG93RmlsZURhdGFcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLndyYXBwZXJXaXRoRmlsZSk7dmFyIGU9dGhpcy5kYXRhLHQ9ZS5maWxlLG49ZS50aXRsZTt0aGlzLmFwcGVuZEZpbGVJY29uKHQpO3ZhciByPWwoXCJkaXZcIix0aGlzLkNTUy5maWxlSW5mbyk7aWYodGhpcy5ub2Rlcy50aXRsZT1sKFwiZGl2XCIsdGhpcy5DU1MudGl0bGUse2NvbnRlbnRFZGl0YWJsZTohMT09PXRoaXMucmVhZE9ubHl9KSx0aGlzLm5vZGVzLnRpdGxlLmRhdGFzZXQucGxhY2Vob2xkZXI9dGhpcy5hcGkuaTE4bi50KFwiRmlsZSB0aXRsZVwiKSx0aGlzLm5vZGVzLnRpdGxlLnRleHRDb250ZW50PW58fFwiXCIsci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLnRpdGxlKSx0LnNpemUpe3ZhciBvLGksYT1sKFwiZGl2XCIsdGhpcy5DU1Muc2l6ZSk7TWF0aC5sb2cxMCgrdC5zaXplKT49Nj8obz1cIk1pQlwiLGk9dC5zaXplL01hdGgucG93KDIsMjApKToobz1cIktpQlwiLGk9dC5zaXplL01hdGgucG93KDIsMTApKSxhLnRleHRDb250ZW50PWkudG9GaXhlZCgxKSxhLnNldEF0dHJpYnV0ZShcImRhdGEtc2l6ZVwiLG8pLHIuYXBwZW5kQ2hpbGQoYSl9aWYodGhpcy5ub2Rlcy53cmFwcGVyLmFwcGVuZENoaWxkKHIpLHZvaWQgMCE9PXQudXJsKXt2YXIgcz1sKFwiYVwiLHRoaXMuQ1NTLmRvd25sb2FkQnV0dG9uLHtpbm5lckhUTUw6JzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk03IDEwTDExLjg1ODYgMTQuODU4NkMxMS45MzY3IDE0LjkzNjcgMTIuMDYzMyAxNC45MzY3IDEyLjE0MTQgMTQuODU4NkwxNyAxMFwiLz48L3N2Zz4nLGhyZWY6dC51cmwsdGFyZ2V0OlwiX2JsYW5rXCIscmVsOlwibm9mb2xsb3cgbm9pbmRleCBub3JlZmVycmVyXCJ9KTt0aGlzLm5vZGVzLndyYXBwZXIuYXBwZW5kQ2hpbGQocyl9fX0se2tleTpcInVwbG9hZGluZ0ZhaWxlZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuYXBpLm5vdGlmaWVyLnNob3coe21lc3NhZ2U6ZSxzdHlsZTpcImVycm9yXCJ9KSx0aGlzLnJlbW92ZUxvYWRlcigpfX0se2tleTpcImRhdGFcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGF0YX0sc2V0OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZmlsZSxuPWUudGl0bGU7dGhpcy5fZGF0YT17ZmlsZTp0LHRpdGxlOm59fX1dKSYmZCh0LnByb3RvdHlwZSxuKSxyJiZkKHQsciksZX0oKX1dKS5kZWZhdWx0fSkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/attaches/dist/bundle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/code/dist/code.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@editorjs/code/dist/code.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ d)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-code__textarea{min-height:200px;font-family:Menlo,Monaco,Consolas,Courier New,monospace;color:#41314e;line-height:1.6em;font-size:12px;background:#f8f7fa;border:1px solid #f1f1f4;box-shadow:none;white-space:pre;word-wrap:normal;overflow-x:auto;resize:vertical}\")),document.head.appendChild(e)}}catch(o){console.error(\"vite-plugin-css-injected-by-js\",o)}})();\nfunction l(c, t) {\n  let r = \"\";\n  for (; r !== `\n` && t > 0; )\n    t = t - 1, r = c.substr(t, 1);\n  return r === `\n` && (t += 1), t;\n}\nconst h = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 8L5 12L9 16\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 8L19 12L15 16\"/></svg>';\n/**\n * CodeTool for Editor.js\n *\n * @author CodeX (team@ifmo.su)\n * @copyright CodeX 2018\n * @license MIT\n * @version 2.0.0\n */\nclass d {\n  /**\n   * Notify core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Allow to press Enter inside the CodeTool textarea\n   *\n   * @returns {boolean}\n   * @public\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * @typedef {object} CodeData — plugin saved data\n   * @property {string} code - previously saved plugin code\n   */\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} options - tool constricting options\n   * @param {CodeData} options.data — previously saved plugin code\n   * @param {object} options.config - user config for Tool\n   * @param {object} options.api - Editor.js API\n   * @param {boolean} options.readOnly - read only mode flag\n   */\n  constructor({ data: t, config: e, api: r, readOnly: a }) {\n    this.api = r, this.readOnly = a, this.placeholder = this.api.i18n.t(e.placeholder || d.DEFAULT_PLACEHOLDER), this.CSS = {\n      baseClass: this.api.styles.block,\n      input: this.api.styles.input,\n      wrapper: \"ce-code\",\n      textarea: \"ce-code__textarea\"\n    }, this.nodes = {\n      holder: null,\n      textarea: null\n    }, this.data = {\n      code: t.code || \"\"\n    }, this.nodes.holder = this.drawView();\n  }\n  /**\n   * Create Tool's view\n   *\n   * @returns {HTMLElement}\n   * @private\n   */\n  drawView() {\n    const t = document.createElement(\"div\"), e = document.createElement(\"textarea\");\n    return t.classList.add(this.CSS.baseClass, this.CSS.wrapper), e.classList.add(this.CSS.textarea, this.CSS.input), e.textContent = this.data.code, e.placeholder = this.placeholder, this.readOnly && (e.disabled = !0), t.appendChild(e), e.addEventListener(\"keydown\", (r) => {\n      switch (r.code) {\n        case \"Tab\":\n          this.tabHandler(r);\n          break;\n      }\n    }), this.nodes.textarea = e, t;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement} this.nodes.holder - Code's wrapper\n   * @public\n   */\n  render() {\n    return this.nodes.holder;\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLDivElement} codeWrapper - CodeTool's wrapper, containing textarea with code\n   * @returns {CodeData} - saved plugin code\n   * @public\n   */\n  save(t) {\n    return {\n      code: t.querySelector(\"textarea\").value\n    };\n  }\n  /**\n   * onPaste callback fired from Editor`s core\n   *\n   * @param {PasteEvent} event - event with pasted content\n   */\n  onPaste(t) {\n    const e = t.detail.data;\n    this.data = {\n      code: e.textContent\n    };\n  }\n  /**\n   * Returns Tool`s data from private property\n   *\n   * @returns {CodeData}\n   */\n  get data() {\n    return this._data;\n  }\n  /**\n   * Set Tool`s data to private property and update view\n   *\n   * @param {CodeData} data - saved tool data\n   */\n  set data(t) {\n    this._data = t, this.nodes.textarea && (this.nodes.textarea.textContent = t.code);\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: h,\n      title: \"Code\"\n    };\n  }\n  /**\n   * Default placeholder for CodeTool's textarea\n   *\n   * @public\n   * @returns {string}\n   */\n  static get DEFAULT_PLACEHOLDER() {\n    return \"Enter a code\";\n  }\n  /**\n   *  Used by Editor.js paste handling API.\n   *  Provides configuration to handle CODE tag.\n   *\n   * @static\n   * @returns {{tags: string[]}}\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"pre\"]\n    };\n  }\n  /**\n   * Automatic sanitize config\n   *\n   * @returns {{code: boolean}}\n   */\n  static get sanitize() {\n    return {\n      code: !0\n      // Allow HTML tags\n    };\n  }\n  /**\n   * Handles Tab key pressing (adds/removes indentations)\n   *\n   * @private\n   * @param {KeyboardEvent} event - keydown\n   * @returns {void}\n   */\n  tabHandler(t) {\n    t.stopPropagation(), t.preventDefault();\n    const e = t.target, r = t.shiftKey, a = e.selectionStart, s = e.value, n = \"  \";\n    let i;\n    if (!r)\n      i = a + n.length, e.value = s.substring(0, a) + n + s.substring(a);\n    else {\n      const o = l(s, a);\n      if (s.substr(o, n.length) !== n)\n        return;\n      e.value = s.substring(0, o) + s.substring(o + n.length), i = a - n.length;\n    }\n    e.setSelectionRange(i, i);\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2NvZGUvZGlzdC9jb2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsWUFBWSxhQUFhLElBQUksd0JBQXdCLHNDQUFzQywwREFBMEQsaUJBQWlCLHdEQUF3RCxjQUFjLGtCQUFrQixlQUFlLG1CQUFtQix5QkFBeUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsZ0JBQWdCLGdCQUFnQixrQ0FBa0MsU0FBUyxtREFBbUQ7QUFDeGU7QUFDQTtBQUNBLFNBQVM7QUFDVCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVkaXRvcmpzLWFwcC8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvY29kZS9kaXN0L2NvZGUubWpzPzYyMWEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIil7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuY2UtY29kZV9fdGV4dGFyZWF7bWluLWhlaWdodDoyMDBweDtmb250LWZhbWlseTpNZW5sbyxNb25hY28sQ29uc29sYXMsQ291cmllciBOZXcsbW9ub3NwYWNlO2NvbG9yOiM0MTMxNGU7bGluZS1oZWlnaHQ6MS42ZW07Zm9udC1zaXplOjEycHg7YmFja2dyb3VuZDojZjhmN2ZhO2JvcmRlcjoxcHggc29saWQgI2YxZjFmNDtib3gtc2hhZG93Om5vbmU7d2hpdGUtc3BhY2U6cHJlO3dvcmQtd3JhcDpub3JtYWw7b3ZlcmZsb3cteDphdXRvO3Jlc2l6ZTp2ZXJ0aWNhbH1cIikpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZSl9fWNhdGNoKG8pe2NvbnNvbGUuZXJyb3IoXCJ2aXRlLXBsdWdpbi1jc3MtaW5qZWN0ZWQtYnktanNcIixvKX19KSgpO1xuZnVuY3Rpb24gbChjLCB0KSB7XG4gIGxldCByID0gXCJcIjtcbiAgZm9yICg7IHIgIT09IGBcbmAgJiYgdCA+IDA7IClcbiAgICB0ID0gdCAtIDEsIHIgPSBjLnN1YnN0cih0LCAxKTtcbiAgcmV0dXJuIHIgPT09IGBcbmAgJiYgKHQgKz0gMSksIHQ7XG59XG5jb25zdCBoID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTkgOEw1IDEyTDkgMTZcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTUgOEwxOSAxMkwxNSAxNlwiLz48L3N2Zz4nO1xuLyoqXG4gKiBDb2RlVG9vbCBmb3IgRWRpdG9yLmpzXG4gKlxuICogQGF1dGhvciBDb2RlWCAodGVhbUBpZm1vLnN1KVxuICogQGNvcHlyaWdodCBDb2RlWCAyMDE4XG4gKiBAbGljZW5zZSBNSVRcbiAqIEB2ZXJzaW9uIDIuMC4wXG4gKi9cbmNsYXNzIGQge1xuICAvKipcbiAgICogTm90aWZ5IGNvcmUgdGhhdCByZWFkLW9ubHkgbW9kZSBpcyBzdXBwb3J0ZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvdyB0byBwcmVzcyBFbnRlciBpbnNpZGUgdGhlIENvZGVUb29sIHRleHRhcmVhXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZ2V0IGVuYWJsZUxpbmVCcmVha3MoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBDb2RlRGF0YSDigJQgcGx1Z2luIHNhdmVkIGRhdGFcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgLSBwcmV2aW91c2x5IHNhdmVkIHBsdWdpbiBjb2RlXG4gICAqL1xuICAvKipcbiAgICogUmVuZGVyIHBsdWdpbmBzIG1haW4gRWxlbWVudCBhbmQgZmlsbCBpdCB3aXRoIHNhdmVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB0b29sIGNvbnN0cmljdGluZyBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29kZURhdGF9IG9wdGlvbnMuZGF0YSDigJQgcHJldmlvdXNseSBzYXZlZCBwbHVnaW4gY29kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jb25maWcgLSB1c2VyIGNvbmZpZyBmb3IgVG9vbFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5hcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5yZWFkT25seSAtIHJlYWQgb25seSBtb2RlIGZsYWdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogdCwgY29uZmlnOiBlLCBhcGk6IHIsIHJlYWRPbmx5OiBhIH0pIHtcbiAgICB0aGlzLmFwaSA9IHIsIHRoaXMucmVhZE9ubHkgPSBhLCB0aGlzLnBsYWNlaG9sZGVyID0gdGhpcy5hcGkuaTE4bi50KGUucGxhY2Vob2xkZXIgfHwgZC5ERUZBVUxUX1BMQUNFSE9MREVSKSwgdGhpcy5DU1MgPSB7XG4gICAgICBiYXNlQ2xhc3M6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcbiAgICAgIGlucHV0OiB0aGlzLmFwaS5zdHlsZXMuaW5wdXQsXG4gICAgICB3cmFwcGVyOiBcImNlLWNvZGVcIixcbiAgICAgIHRleHRhcmVhOiBcImNlLWNvZGVfX3RleHRhcmVhXCJcbiAgICB9LCB0aGlzLm5vZGVzID0ge1xuICAgICAgaG9sZGVyOiBudWxsLFxuICAgICAgdGV4dGFyZWE6IG51bGxcbiAgICB9LCB0aGlzLmRhdGEgPSB7XG4gICAgICBjb2RlOiB0LmNvZGUgfHwgXCJcIlxuICAgIH0sIHRoaXMubm9kZXMuaG9sZGVyID0gdGhpcy5kcmF3VmlldygpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgVG9vbCdzIHZpZXdcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHJhd1ZpZXcoKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgcmV0dXJuIHQuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5iYXNlQ2xhc3MsIHRoaXMuQ1NTLndyYXBwZXIpLCBlLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MudGV4dGFyZWEsIHRoaXMuQ1NTLmlucHV0KSwgZS50ZXh0Q29udGVudCA9IHRoaXMuZGF0YS5jb2RlLCBlLnBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciwgdGhpcy5yZWFkT25seSAmJiAoZS5kaXNhYmxlZCA9ICEwKSwgdC5hcHBlbmRDaGlsZChlKSwgZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAocikgPT4ge1xuICAgICAgc3dpdGNoIChyLmNvZGUpIHtcbiAgICAgICAgY2FzZSBcIlRhYlwiOlxuICAgICAgICAgIHRoaXMudGFiSGFuZGxlcihyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5ub2Rlcy50ZXh0YXJlYSA9IGUsIHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBUb29sJ3Mgdmlld1xuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTERpdkVsZW1lbnR9IHRoaXMubm9kZXMuaG9sZGVyIC0gQ29kZSdzIHdyYXBwZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmhvbGRlcjtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBUb29sJ3MgZGF0YSBmcm9tIHRoZSB2aWV3XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGNvZGVXcmFwcGVyIC0gQ29kZVRvb2wncyB3cmFwcGVyLCBjb250YWluaW5nIHRleHRhcmVhIHdpdGggY29kZVxuICAgKiBAcmV0dXJucyB7Q29kZURhdGF9IC0gc2F2ZWQgcGx1Z2luIGNvZGVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2F2ZSh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IHQucXVlcnlTZWxlY3RvcihcInRleHRhcmVhXCIpLnZhbHVlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogb25QYXN0ZSBjYWxsYmFjayBmaXJlZCBmcm9tIEVkaXRvcmBzIGNvcmVcbiAgICpcbiAgICogQHBhcmFtIHtQYXN0ZUV2ZW50fSBldmVudCAtIGV2ZW50IHdpdGggcGFzdGVkIGNvbnRlbnRcbiAgICovXG4gIG9uUGFzdGUodCkge1xuICAgIGNvbnN0IGUgPSB0LmRldGFpbC5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgIGNvZGU6IGUudGV4dENvbnRlbnRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRvb2xgcyBkYXRhIGZyb20gcHJpdmF0ZSBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29kZURhdGF9XG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKipcbiAgICogU2V0IFRvb2xgcyBkYXRhIHRvIHByaXZhdGUgcHJvcGVydHkgYW5kIHVwZGF0ZSB2aWV3XG4gICAqXG4gICAqIEBwYXJhbSB7Q29kZURhdGF9IGRhdGEgLSBzYXZlZCB0b29sIGRhdGFcbiAgICovXG4gIHNldCBkYXRhKHQpIHtcbiAgICB0aGlzLl9kYXRhID0gdCwgdGhpcy5ub2Rlcy50ZXh0YXJlYSAmJiAodGhpcy5ub2Rlcy50ZXh0YXJlYS50ZXh0Q29udGVudCA9IHQuY29kZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBUb29sIHRvb2xib3ggc2V0dGluZ3NcbiAgICogaWNvbiAtIFRvb2wgaWNvbidzIFNWR1xuICAgKiB0aXRsZSAtIHRpdGxlIHRvIHNob3cgaW4gdG9vbGJveFxuICAgKlxuICAgKiBAcmV0dXJucyB7e2ljb246IHN0cmluZywgdGl0bGU6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IGgsXG4gICAgICB0aXRsZTogXCJDb2RlXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWZhdWx0IHBsYWNlaG9sZGVyIGZvciBDb2RlVG9vbCdzIHRleHRhcmVhXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgREVGQVVMVF9QTEFDRUhPTERFUigpIHtcbiAgICByZXR1cm4gXCJFbnRlciBhIGNvZGVcIjtcbiAgfVxuICAvKipcbiAgICogIFVzZWQgYnkgRWRpdG9yLmpzIHBhc3RlIGhhbmRsaW5nIEFQSS5cbiAgICogIFByb3ZpZGVzIGNvbmZpZ3VyYXRpb24gdG8gaGFuZGxlIENPREUgdGFnLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm5zIHt7dGFnczogc3RyaW5nW119fVxuICAgKi9cbiAgc3RhdGljIGdldCBwYXN0ZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnczogW1wicHJlXCJdXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQXV0b21hdGljIHNhbml0aXplIGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7e2NvZGU6IGJvb2xlYW59fVxuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogITBcbiAgICAgIC8vIEFsbG93IEhUTUwgdGFnc1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgVGFiIGtleSBwcmVzc2luZyAoYWRkcy9yZW1vdmVzIGluZGVudGF0aW9ucylcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICB0YWJIYW5kbGVyKHQpIHtcbiAgICB0LnN0b3BQcm9wYWdhdGlvbigpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgZSA9IHQudGFyZ2V0LCByID0gdC5zaGlmdEtleSwgYSA9IGUuc2VsZWN0aW9uU3RhcnQsIHMgPSBlLnZhbHVlLCBuID0gXCIgIFwiO1xuICAgIGxldCBpO1xuICAgIGlmICghcilcbiAgICAgIGkgPSBhICsgbi5sZW5ndGgsIGUudmFsdWUgPSBzLnN1YnN0cmluZygwLCBhKSArIG4gKyBzLnN1YnN0cmluZyhhKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG8gPSBsKHMsIGEpO1xuICAgICAgaWYgKHMuc3Vic3RyKG8sIG4ubGVuZ3RoKSAhPT0gbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZS52YWx1ZSA9IHMuc3Vic3RyaW5nKDAsIG8pICsgcy5zdWJzdHJpbmcobyArIG4ubGVuZ3RoKSwgaSA9IGEgLSBuLmxlbmd0aDtcbiAgICB9XG4gICAgZS5zZXRTZWxlY3Rpb25SYW5nZShpLCBpKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgZCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/code/dist/code.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/editorjs/dist/editorjs.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@editorjs/editorjs/dist/editorjs.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Bi)\n/* harmony export */ });\nvar Rt = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction Pe(s) {\n  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, \"default\") ? s.default : s;\n}\nfunction Te() {\n}\nObject.assign(Te, {\n  default: Te,\n  register: Te,\n  revert: function() {\n  },\n  __esModule: !0\n});\nElement.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s) {\n  const e = (this.document || this.ownerDocument).querySelectorAll(s);\n  let t = e.length;\n  for (; --t >= 0 && e.item(t) !== this; )\n    ;\n  return t > -1;\n});\nElement.prototype.closest || (Element.prototype.closest = function(s) {\n  let e = this;\n  if (!document.documentElement.contains(e))\n    return null;\n  do {\n    if (e.matches(s))\n      return e;\n    e = e.parentElement || e.parentNode;\n  } while (e !== null);\n  return null;\n});\nElement.prototype.prepend || (Element.prototype.prepend = function(e) {\n  const t = document.createDocumentFragment();\n  Array.isArray(e) || (e = [e]), e.forEach((o) => {\n    const i = o instanceof Node;\n    t.appendChild(i ? o : document.createTextNode(o));\n  }), this.insertBefore(t, this.firstChild);\n});\nElement.prototype.scrollIntoViewIfNeeded || (Element.prototype.scrollIntoViewIfNeeded = function(s) {\n  s = arguments.length === 0 ? !0 : !!s;\n  const e = this.parentNode, t = window.getComputedStyle(e, null), o = parseInt(t.getPropertyValue(\"border-top-width\")), i = parseInt(t.getPropertyValue(\"border-left-width\")), n = this.offsetTop - e.offsetTop < e.scrollTop, r = this.offsetTop - e.offsetTop + this.clientHeight - o > e.scrollTop + e.clientHeight, a = this.offsetLeft - e.offsetLeft < e.scrollLeft, l = this.offsetLeft - e.offsetLeft + this.clientWidth - i > e.scrollLeft + e.clientWidth, d = n && !r;\n  (n || r) && s && (e.scrollTop = this.offsetTop - e.offsetTop - e.clientHeight / 2 - o + this.clientHeight / 2), (a || l) && s && (e.scrollLeft = this.offsetLeft - e.offsetLeft - e.clientWidth / 2 - i + this.clientWidth / 2), (n || r || a || l) && !s && this.scrollIntoView(d);\n});\nwindow.requestIdleCallback = window.requestIdleCallback || function(s) {\n  const e = Date.now();\n  return setTimeout(function() {\n    s({\n      didTimeout: !1,\n      timeRemaining: function() {\n        return Math.max(0, 50 - (Date.now() - e));\n      }\n    });\n  }, 1);\n};\nwindow.cancelIdleCallback = window.cancelIdleCallback || function(s) {\n  clearTimeout(s);\n};\nlet Dt = (s = 21) => crypto.getRandomValues(new Uint8Array(s)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += \"-\" : e += \"_\", e), \"\");\nvar at = /* @__PURE__ */ ((s) => (s.VERBOSE = \"VERBOSE\", s.INFO = \"INFO\", s.WARN = \"WARN\", s.ERROR = \"ERROR\", s))(at || {});\nconst v = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  ESC: 27,\n  SPACE: 32,\n  LEFT: 37,\n  UP: 38,\n  DOWN: 40,\n  RIGHT: 39,\n  DELETE: 46,\n  META: 91,\n  SLASH: 191\n}, Pt = {\n  LEFT: 0,\n  WHEEL: 1,\n  RIGHT: 2,\n  BACKWARD: 3,\n  FORWARD: 4\n};\nfunction me(s, e, t = \"log\", o, i = \"color: inherit\") {\n  if (!(\"console\" in window) || !window.console[t])\n    return;\n  const n = [\"info\", \"log\", \"warn\", \"error\"].includes(t), r = [];\n  switch (me.logLevel) {\n    case \"ERROR\":\n      if (t !== \"error\")\n        return;\n      break;\n    case \"WARN\":\n      if (![\"error\", \"warn\"].includes(t))\n        return;\n      break;\n    case \"INFO\":\n      if (!n || s)\n        return;\n      break;\n  }\n  o && r.push(o);\n  const a = \"Editor.js 2.29.1\", l = `line-height: 1em;\n            color: #006FEA;\n            display: inline-block;\n            font-size: 11px;\n            line-height: 1em;\n            background-color: #fff;\n            padding: 4px 9px;\n            border-radius: 30px;\n            border: 1px solid rgba(56, 138, 229, 0.16);\n            margin: 4px 5px 4px 0;`;\n  s && (n ? (r.unshift(l, i), e = `%c${a}%c ${e}`) : e = `( ${a} )${e}`);\n  try {\n    n ? o ? console[t](`${e} %o`, ...r) : console[t](e, ...r) : console[t](e);\n  } catch {\n  }\n}\nme.logLevel = \"VERBOSE\";\nfunction Ft(s) {\n  me.logLevel = s;\n}\nconst T = me.bind(window, !1), Y = me.bind(window, !0);\nfunction oe(s) {\n  return Object.prototype.toString.call(s).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}\nfunction M(s) {\n  return oe(s) === \"function\" || oe(s) === \"asyncfunction\";\n}\nfunction D(s) {\n  return oe(s) === \"object\";\n}\nfunction G(s) {\n  return oe(s) === \"string\";\n}\nfunction Ht(s) {\n  return oe(s) === \"boolean\";\n}\nfunction Je(s) {\n  return oe(s) === \"number\";\n}\nfunction Qe(s) {\n  return oe(s) === \"undefined\";\n}\nfunction W(s) {\n  return s ? Object.keys(s).length === 0 && s.constructor === Object : !0;\n}\nfunction lt(s) {\n  return s > 47 && s < 58 || // number keys\n  s === 32 || s === 13 || // Space bar & return key(s)\n  s === 229 || // processing key input for certain languages — Chinese, Japanese, etc.\n  s > 64 && s < 91 || // letter keys\n  s > 95 && s < 112 || // Numpad keys\n  s > 185 && s < 193 || // ;=,-./` (in order)\n  s > 218 && s < 223;\n}\nasync function zt(s, e = () => {\n}, t = () => {\n}) {\n  async function o(i, n, r) {\n    try {\n      await i.function(i.data), await n(Qe(i.data) ? {} : i.data);\n    } catch {\n      r(Qe(i.data) ? {} : i.data);\n    }\n  }\n  return s.reduce(async (i, n) => (await i, o(n, e, t)), Promise.resolve());\n}\nfunction ct(s) {\n  return Array.prototype.slice.call(s);\n}\nfunction xe(s, e) {\n  return function() {\n    const t = this, o = arguments;\n    window.setTimeout(() => s.apply(t, o), e);\n  };\n}\nfunction Ut(s) {\n  return s.name.split(\".\").pop();\n}\nfunction jt(s) {\n  return /^[-\\w]+\\/([-+\\w]+|\\*)$/.test(s);\n}\nfunction et(s, e, t) {\n  let o;\n  return (...i) => {\n    const n = this, r = () => {\n      o = null, t || s.apply(n, i);\n    }, a = t && !o;\n    window.clearTimeout(o), o = window.setTimeout(r, e), a && s.apply(n, i);\n  };\n}\nfunction Ie(s, e, t = void 0) {\n  let o, i, n, r = null, a = 0;\n  t || (t = {});\n  const l = function() {\n    a = t.leading === !1 ? 0 : Date.now(), r = null, n = s.apply(o, i), r || (o = i = null);\n  };\n  return function() {\n    const d = Date.now();\n    !a && t.leading === !1 && (a = d);\n    const u = e - (d - a);\n    return o = this, i = arguments, u <= 0 || u > e ? (r && (clearTimeout(r), r = null), a = d, n = s.apply(o, i), r || (o = i = null)) : !r && t.trailing !== !1 && (r = setTimeout(l, u)), n;\n  };\n}\nfunction $t() {\n  const s = {\n    win: !1,\n    mac: !1,\n    x11: !1,\n    linux: !1\n  }, e = Object.keys(s).find((t) => window.navigator.appVersion.toLowerCase().indexOf(t) !== -1);\n  return e && (s[e] = !0), s;\n}\nfunction re(s) {\n  return s[0].toUpperCase() + s.slice(1);\n}\nfunction Me(s, ...e) {\n  if (!e.length)\n    return s;\n  const t = e.shift();\n  if (D(s) && D(t))\n    for (const o in t)\n      D(t[o]) ? (s[o] || Object.assign(s, { [o]: {} }), Me(s[o], t[o])) : Object.assign(s, { [o]: t[o] });\n  return Me(s, ...e);\n}\nfunction ye(s) {\n  const e = $t();\n  return s = s.replace(/shift/gi, \"⇧\").replace(/backspace/gi, \"⌫\").replace(/enter/gi, \"⏎\").replace(/up/gi, \"↑\").replace(/left/gi, \"→\").replace(/down/gi, \"↓\").replace(/right/gi, \"←\").replace(/escape/gi, \"⎋\").replace(/insert/gi, \"Ins\").replace(/delete/gi, \"␡\").replace(/\\+/gi, \" + \"), e.mac ? s = s.replace(/ctrl|cmd/gi, \"⌘\").replace(/alt/gi, \"⌥\") : s = s.replace(/cmd/gi, \"Ctrl\").replace(/windows/gi, \"WIN\"), s;\n}\nfunction Wt(s) {\n  try {\n    return new URL(s).href;\n  } catch {\n  }\n  return s.substring(0, 2) === \"//\" ? window.location.protocol + s : window.location.origin + s;\n}\nfunction Yt() {\n  return Dt(10);\n}\nfunction Kt(s) {\n  window.open(s, \"_blank\");\n}\nfunction Xt(s = \"\") {\n  return `${s}${Math.floor(Math.random() * 1e8).toString(16)}`;\n}\nfunction Le(s, e, t) {\n  const o = `«${e}» is deprecated and will be removed in the next major release. Please use the «${t}» instead.`;\n  s && Y(o, \"warn\");\n}\nfunction le(s, e, t) {\n  const o = t.value ? \"value\" : \"get\", i = t[o], n = `#${e}Cache`;\n  if (t[o] = function(...r) {\n    return this[n] === void 0 && (this[n] = i.apply(this, ...r)), this[n];\n  }, o === \"get\" && t.set) {\n    const r = t.set;\n    t.set = function(a) {\n      delete s[n], r.apply(this, a);\n    };\n  }\n  return t;\n}\nconst dt = 650;\nfunction te() {\n  return window.matchMedia(`(max-width: ${dt}px)`).matches;\n}\nconst tt = typeof window < \"u\" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === \"MacIntel\" && window.navigator.maxTouchPoints > 1);\nfunction Vt(s, e) {\n  const t = Array.isArray(s) || D(s), o = Array.isArray(e) || D(e);\n  return t || o ? JSON.stringify(s) === JSON.stringify(e) : s === e;\n}\nclass c {\n  /**\n   * Check if passed tag has no closed tag\n   *\n   * @param {HTMLElement} tag - element to check\n   * @returns {boolean}\n   */\n  static isSingleTag(e) {\n    return e.tagName && [\n      \"AREA\",\n      \"BASE\",\n      \"BR\",\n      \"COL\",\n      \"COMMAND\",\n      \"EMBED\",\n      \"HR\",\n      \"IMG\",\n      \"INPUT\",\n      \"KEYGEN\",\n      \"LINK\",\n      \"META\",\n      \"PARAM\",\n      \"SOURCE\",\n      \"TRACK\",\n      \"WBR\"\n    ].includes(e.tagName);\n  }\n  /**\n   * Check if element is BR or WBR\n   *\n   * @param {HTMLElement} element - element to check\n   * @returns {boolean}\n   */\n  static isLineBreakTag(e) {\n    return e && e.tagName && [\n      \"BR\",\n      \"WBR\"\n    ].includes(e.tagName);\n  }\n  /**\n   * Helper for making Elements with class name and attributes\n   *\n   * @param  {string} tagName - new Element tag name\n   * @param  {string[]|string} [classNames] - list or name of CSS class name(s)\n   * @param  {object} [attributes] - any attributes\n   * @returns {HTMLElement}\n   */\n  static make(e, t = null, o = {}) {\n    const i = document.createElement(e);\n    Array.isArray(t) ? i.classList.add(...t) : t && i.classList.add(t);\n    for (const n in o)\n      Object.prototype.hasOwnProperty.call(o, n) && (i[n] = o[n]);\n    return i;\n  }\n  /**\n   * Creates Text Node with the passed content\n   *\n   * @param {string} content - text content\n   * @returns {Text}\n   */\n  static text(e) {\n    return document.createTextNode(e);\n  }\n  /**\n   * Append one or several elements to the parent\n   *\n   * @param  {Element|DocumentFragment} parent - where to append\n   * @param  {Element|Element[]|DocumentFragment|Text|Text[]} elements - element or elements list\n   */\n  static append(e, t) {\n    Array.isArray(t) ? t.forEach((o) => e.appendChild(o)) : e.appendChild(t);\n  }\n  /**\n   * Append element or a couple to the beginning of the parent elements\n   *\n   * @param {Element} parent - where to append\n   * @param {Element|Element[]} elements - element or elements list\n   */\n  static prepend(e, t) {\n    Array.isArray(t) ? (t = t.reverse(), t.forEach((o) => e.prepend(o))) : e.prepend(t);\n  }\n  /**\n   * Swap two elements in parent\n   *\n   * @param {HTMLElement} el1 - from\n   * @param {HTMLElement} el2 - to\n   * @deprecated\n   */\n  static swap(e, t) {\n    const o = document.createElement(\"div\"), i = e.parentNode;\n    i.insertBefore(o, e), i.insertBefore(e, t), i.insertBefore(t, o), i.removeChild(o);\n  }\n  /**\n   * Selector Decorator\n   *\n   * Returns first match\n   *\n   * @param {Element} el - element we searching inside. Default - DOM Document\n   * @param {string} selector - searching string\n   * @returns {Element}\n   */\n  static find(e = document, t) {\n    return e.querySelector(t);\n  }\n  /**\n   * Get Element by Id\n   *\n   * @param {string} id - id to find\n   * @returns {HTMLElement | null}\n   */\n  static get(e) {\n    return document.getElementById(e);\n  }\n  /**\n   * Selector Decorator.\n   *\n   * Returns all matches\n   *\n   * @param {Element|Document} el - element we searching inside. Default - DOM Document\n   * @param {string} selector - searching string\n   * @returns {NodeList}\n   */\n  static findAll(e = document, t) {\n    return e.querySelectorAll(t);\n  }\n  /**\n   * Returns CSS selector for all text inputs\n   */\n  static get allInputsSelector() {\n    return \"[contenteditable=true], textarea, input:not([type]), \" + [\"text\", \"password\", \"email\", \"number\", \"search\", \"tel\", \"url\"].map((t) => `input[type=\"${t}\"]`).join(\", \");\n  }\n  /**\n   * Find all contenteditable, textarea and editable input elements passed holder contains\n   *\n   * @param holder - element where to find inputs\n   */\n  static findAllInputs(e) {\n    return ct(e.querySelectorAll(c.allInputsSelector)).reduce((t, o) => c.isNativeInput(o) || c.containsOnlyInlineElements(o) ? [...t, o] : [...t, ...c.getDeepestBlockElements(o)], []);\n  }\n  /**\n   * Search for deepest node which is Leaf.\n   * Leaf is the vertex that doesn't have any child nodes\n   *\n   * @description Method recursively goes throw the all Node until it finds the Leaf\n   * @param {Node} node - root Node. From this vertex we start Deep-first search\n   *                      {@link https://en.wikipedia.org/wiki/Depth-first_search}\n   * @param {boolean} [atLast] - find last text node\n   * @returns {Node} - it can be text Node or Element Node, so that caret will able to work with it\n   */\n  static getDeepestNode(e, t = !1) {\n    const o = t ? \"lastChild\" : \"firstChild\", i = t ? \"previousSibling\" : \"nextSibling\";\n    if (e && e.nodeType === Node.ELEMENT_NODE && e[o]) {\n      let n = e[o];\n      if (c.isSingleTag(n) && !c.isNativeInput(n) && !c.isLineBreakTag(n))\n        if (n[i])\n          n = n[i];\n        else if (n.parentNode[i])\n          n = n.parentNode[i];\n        else\n          return n.parentNode;\n      return this.getDeepestNode(n, t);\n    }\n    return e;\n  }\n  /**\n   * Check if object is DOM node\n   *\n   * @param {*} node - object to check\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isElement(e) {\n    return Je(e) ? !1 : e && e.nodeType && e.nodeType === Node.ELEMENT_NODE;\n  }\n  /**\n   * Check if object is DocumentFragment node\n   *\n   * @param {object} node - object to check\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isFragment(e) {\n    return Je(e) ? !1 : e && e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n  }\n  /**\n   * Check if passed element is contenteditable\n   *\n   * @param {HTMLElement} element - html element to check\n   * @returns {boolean}\n   */\n  static isContentEditable(e) {\n    return e.contentEditable === \"true\";\n  }\n  /**\n   * Checks target if it is native input\n   *\n   * @param {*} target - HTML element or string\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isNativeInput(e) {\n    const t = [\n      \"INPUT\",\n      \"TEXTAREA\"\n    ];\n    return e && e.tagName ? t.includes(e.tagName) : !1;\n  }\n  /**\n   * Checks if we can set caret\n   *\n   * @param {HTMLElement} target - target to check\n   * @returns {boolean}\n   */\n  static canSetCaret(e) {\n    let t = !0;\n    if (c.isNativeInput(e))\n      switch (e.type) {\n        case \"file\":\n        case \"checkbox\":\n        case \"radio\":\n        case \"hidden\":\n        case \"submit\":\n        case \"button\":\n        case \"image\":\n        case \"reset\":\n          t = !1;\n          break;\n      }\n    else\n      t = c.isContentEditable(e);\n    return t;\n  }\n  /**\n   * Checks node if it is empty\n   *\n   * @description Method checks simple Node without any childs for emptiness\n   * If you have Node with 2 or more children id depth, you better use {@link Dom#isEmpty} method\n   * @param {Node} node - node to check\n   * @param {string} [ignoreChars] - char or substring to treat as empty\n   * @returns {boolean} true if it is empty\n   */\n  static isNodeEmpty(e, t) {\n    let o;\n    return this.isSingleTag(e) && !this.isLineBreakTag(e) ? !1 : (this.isElement(e) && this.isNativeInput(e) ? o = e.value : o = e.textContent.replace(\"​\", \"\"), t && (o = o.replace(new RegExp(t, \"g\"), \"\")), o.trim().length === 0);\n  }\n  /**\n   * checks node if it is doesn't have any child nodes\n   *\n   * @param {Node} node - node to check\n   * @returns {boolean}\n   */\n  static isLeaf(e) {\n    return e ? e.childNodes.length === 0 : !1;\n  }\n  /**\n   * breadth-first search (BFS)\n   * {@link https://en.wikipedia.org/wiki/Breadth-first_search}\n   *\n   * @description Pushes to stack all DOM leafs and checks for emptiness\n   * @param {Node} node - node to check\n   * @param {string} [ignoreChars] - char or substring to treat as empty\n   * @returns {boolean}\n   */\n  static isEmpty(e, t) {\n    e.normalize();\n    const o = [e];\n    for (; o.length > 0; )\n      if (e = o.shift(), !!e) {\n        if (this.isLeaf(e) && !this.isNodeEmpty(e, t))\n          return !1;\n        e.childNodes && o.push(...Array.from(e.childNodes));\n      }\n    return !0;\n  }\n  /**\n   * Check if string contains html elements\n   *\n   * @param {string} str - string to check\n   * @returns {boolean}\n   */\n  static isHTMLString(e) {\n    const t = c.make(\"div\");\n    return t.innerHTML = e, t.childElementCount > 0;\n  }\n  /**\n   * Return length of node`s text content\n   *\n   * @param {Node} node - node with content\n   * @returns {number}\n   */\n  static getContentLength(e) {\n    return c.isNativeInput(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : e.textContent.length;\n  }\n  /**\n   * Return array of names of block html elements\n   *\n   * @returns {string[]}\n   */\n  static get blockElements() {\n    return [\n      \"address\",\n      \"article\",\n      \"aside\",\n      \"blockquote\",\n      \"canvas\",\n      \"div\",\n      \"dl\",\n      \"dt\",\n      \"fieldset\",\n      \"figcaption\",\n      \"figure\",\n      \"footer\",\n      \"form\",\n      \"h1\",\n      \"h2\",\n      \"h3\",\n      \"h4\",\n      \"h5\",\n      \"h6\",\n      \"header\",\n      \"hgroup\",\n      \"hr\",\n      \"li\",\n      \"main\",\n      \"nav\",\n      \"noscript\",\n      \"ol\",\n      \"output\",\n      \"p\",\n      \"pre\",\n      \"ruby\",\n      \"section\",\n      \"table\",\n      \"tbody\",\n      \"thead\",\n      \"tr\",\n      \"tfoot\",\n      \"ul\",\n      \"video\"\n    ];\n  }\n  /**\n   * Check if passed content includes only inline elements\n   *\n   * @param {string|HTMLElement} data - element or html string\n   * @returns {boolean}\n   */\n  static containsOnlyInlineElements(e) {\n    let t;\n    G(e) ? (t = document.createElement(\"div\"), t.innerHTML = e) : t = e;\n    const o = (i) => !c.blockElements.includes(i.tagName.toLowerCase()) && Array.from(i.children).every(o);\n    return Array.from(t.children).every(o);\n  }\n  /**\n   * Find and return all block elements in the passed parent (including subtree)\n   *\n   * @param {HTMLElement} parent - root element\n   * @returns {HTMLElement[]}\n   */\n  static getDeepestBlockElements(e) {\n    return c.containsOnlyInlineElements(e) ? [e] : Array.from(e.children).reduce((t, o) => [...t, ...c.getDeepestBlockElements(o)], []);\n  }\n  /**\n   * Helper for get holder from {string} or return HTMLElement\n   *\n   * @param {string | HTMLElement} element - holder's id or holder's HTML Element\n   * @returns {HTMLElement}\n   */\n  static getHolder(e) {\n    return G(e) ? document.getElementById(e) : e;\n  }\n  /**\n   * Returns true if element is anchor (is A tag)\n   *\n   * @param {Element} element - element to check\n   * @returns {boolean}\n   */\n  static isAnchor(e) {\n    return e.tagName.toLowerCase() === \"a\";\n  }\n  /**\n   * Return element's offset related to the document\n   *\n   * @todo handle case when editor initialized in scrollable popup\n   * @param el - element to compute offset\n   */\n  static offset(e) {\n    const t = e.getBoundingClientRect(), o = window.pageXOffset || document.documentElement.scrollLeft, i = window.pageYOffset || document.documentElement.scrollTop, n = t.top + i, r = t.left + o;\n    return {\n      top: n,\n      left: r,\n      bottom: n + t.height,\n      right: r + t.width\n    };\n  }\n}\nconst qt = {\n  blockTunes: {\n    toggler: {\n      \"Click to tune\": \"\",\n      \"or drag to move\": \"\"\n    }\n  },\n  inlineToolbar: {\n    converter: {\n      \"Convert to\": \"\"\n    }\n  },\n  toolbar: {\n    toolbox: {\n      Add: \"\"\n    }\n  },\n  popover: {\n    Filter: \"\",\n    \"Nothing found\": \"\"\n  }\n}, Zt = {\n  Text: \"\",\n  Link: \"\",\n  Bold: \"\",\n  Italic: \"\"\n}, Gt = {\n  link: {\n    \"Add a link\": \"\"\n  },\n  stub: {\n    \"The block can not be displayed correctly.\": \"\"\n  }\n}, Jt = {\n  delete: {\n    Delete: \"\",\n    \"Click to delete\": \"\"\n  },\n  moveUp: {\n    \"Move up\": \"\"\n  },\n  moveDown: {\n    \"Move down\": \"\"\n  }\n}, ht = {\n  ui: qt,\n  toolNames: Zt,\n  tools: Gt,\n  blockTunes: Jt\n}, ie = class {\n  /**\n   * Type-safe translation for internal UI texts:\n   * Perform translation of the string by namespace and a key\n   *\n   * @example I18n.ui(I18nInternalNS.ui.blockTunes.toggler, 'Click to tune')\n   * @param internalNamespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static ui(s, e) {\n    return ie._t(s, e);\n  }\n  /**\n   * Translate for external strings that is not presented in default dictionary.\n   * For example, for user-specified tool names\n   *\n   * @param namespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static t(s, e) {\n    return ie._t(s, e);\n  }\n  /**\n   * Adjust module for using external dictionary\n   *\n   * @param dictionary - new messages list to override default\n   */\n  static setDictionary(s) {\n    ie.currentDictionary = s;\n  }\n  /**\n   * Perform translation both for internal and external namespaces\n   * If there is no translation found, returns passed key as a translated message\n   *\n   * @param namespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static _t(s, e) {\n    const t = ie.getNamespace(s);\n    return !t || !t[e] ? e : t[e];\n  }\n  /**\n   * Find messages section by namespace path\n   *\n   * @param namespace - path to section\n   */\n  static getNamespace(s) {\n    return s.split(\".\").reduce((t, o) => !t || !Object.keys(t).length ? {} : t[o], ie.currentDictionary);\n  }\n};\nlet z = ie;\nz.currentDictionary = ht;\nclass ut extends Error {\n}\nclass Ee {\n  constructor() {\n    this.subscribers = {};\n  }\n  /**\n   * Subscribe any event on callback\n   *\n   * @param eventName - event name\n   * @param callback - subscriber\n   */\n  on(e, t) {\n    e in this.subscribers || (this.subscribers[e] = []), this.subscribers[e].push(t);\n  }\n  /**\n   * Subscribe any event on callback. Callback will be called once and be removed from subscribers array after call.\n   *\n   * @param eventName - event name\n   * @param callback - subscriber\n   */\n  once(e, t) {\n    e in this.subscribers || (this.subscribers[e] = []);\n    const o = (i) => {\n      const n = t(i), r = this.subscribers[e].indexOf(o);\n      return r !== -1 && this.subscribers[e].splice(r, 1), n;\n    };\n    this.subscribers[e].push(o);\n  }\n  /**\n   * Emit callbacks with passed data\n   *\n   * @param eventName - event name\n   * @param data - subscribers get this data when they were fired\n   */\n  emit(e, t) {\n    W(this.subscribers) || !this.subscribers[e] || this.subscribers[e].reduce((o, i) => {\n      const n = i(o);\n      return n !== void 0 ? n : o;\n    }, t);\n  }\n  /**\n   * Unsubscribe callback from event\n   *\n   * @param eventName - event name\n   * @param callback - event handler\n   */\n  off(e, t) {\n    if (this.subscribers[e] === void 0) {\n      console.warn(`EventDispatcher .off(): there is no subscribers for event \"${e.toString()}\". Probably, .off() called before .on()`);\n      return;\n    }\n    for (let o = 0; o < this.subscribers[e].length; o++)\n      if (this.subscribers[e][o] === t) {\n        delete this.subscribers[e][o];\n        break;\n      }\n  }\n  /**\n   * Destroyer\n   * clears subscribers list\n   */\n  destroy() {\n    this.subscribers = {};\n  }\n}\nfunction ee(s) {\n  Object.setPrototypeOf(this, {\n    /**\n     * Block id\n     *\n     * @returns {string}\n     */\n    get id() {\n      return s.id;\n    },\n    /**\n     * Tool name\n     *\n     * @returns {string}\n     */\n    get name() {\n      return s.name;\n    },\n    /**\n     * Tool config passed on Editor's initialization\n     *\n     * @returns {ToolConfig}\n     */\n    get config() {\n      return s.config;\n    },\n    /**\n     * .ce-block element, that wraps plugin contents\n     *\n     * @returns {HTMLElement}\n     */\n    get holder() {\n      return s.holder;\n    },\n    /**\n     * True if Block content is empty\n     *\n     * @returns {boolean}\n     */\n    get isEmpty() {\n      return s.isEmpty;\n    },\n    /**\n     * True if Block is selected with Cross-Block selection\n     *\n     * @returns {boolean}\n     */\n    get selected() {\n      return s.selected;\n    },\n    /**\n     * Set Block's stretch state\n     *\n     * @param {boolean} state — state to set\n     */\n    set stretched(t) {\n      s.stretched = t;\n    },\n    /**\n     * True if Block is stretched\n     *\n     * @returns {boolean}\n     */\n    get stretched() {\n      return s.stretched;\n    },\n    /**\n     * True if Block has inputs to be focused\n     */\n    get focusable() {\n      return s.focusable;\n    },\n    /**\n     * Call Tool method with errors handler under-the-hood\n     *\n     * @param {string} methodName - method to call\n     * @param {object} param - object with parameters\n     * @returns {unknown}\n     */\n    call(t, o) {\n      return s.call(t, o);\n    },\n    /**\n     * Save Block content\n     *\n     * @returns {Promise<void|SavedData>}\n     */\n    save() {\n      return s.save();\n    },\n    /**\n     * Validate Block data\n     *\n     * @param {BlockToolData} data - data to validate\n     * @returns {Promise<boolean>}\n     */\n    validate(t) {\n      return s.validate(t);\n    },\n    /**\n     * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback\n     * Can be useful for block changes invisible for editor core.\n     */\n    dispatchChange() {\n      s.dispatchChange();\n    }\n  });\n}\nclass Fe {\n  constructor() {\n    this.allListeners = [];\n  }\n  /**\n   * Assigns event listener on element and returns unique identifier\n   *\n   * @param {EventTarget} element - DOM element that needs to be listened\n   * @param {string} eventType - event type\n   * @param {Function} handler - method that will be fired on event\n   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}\n   */\n  on(e, t, o, i = !1) {\n    const n = Xt(\"l\"), r = {\n      id: n,\n      element: e,\n      eventType: t,\n      handler: o,\n      options: i\n    };\n    if (!this.findOne(e, t, o))\n      return this.allListeners.push(r), e.addEventListener(t, o, i), n;\n  }\n  /**\n   * Removes event listener from element\n   *\n   * @param {EventTarget} element - DOM element that we removing listener\n   * @param {string} eventType - event type\n   * @param {Function} handler - remove handler, if element listens several handlers on the same event type\n   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}\n   */\n  off(e, t, o, i) {\n    const n = this.findAll(e, t, o);\n    n.forEach((r, a) => {\n      const l = this.allListeners.indexOf(n[a]);\n      l > -1 && (this.allListeners.splice(l, 1), r.element.removeEventListener(r.eventType, r.handler, r.options));\n    });\n  }\n  /**\n   * Removes listener by id\n   *\n   * @param {string} id - listener identifier\n   */\n  offById(e) {\n    const t = this.findById(e);\n    t && t.element.removeEventListener(t.eventType, t.handler, t.options);\n  }\n  /**\n   * Finds and returns first listener by passed params\n   *\n   * @param {EventTarget} element - event target\n   * @param {string} [eventType] - event type\n   * @param {Function} [handler] - event handler\n   * @returns {ListenerData|null}\n   */\n  findOne(e, t, o) {\n    const i = this.findAll(e, t, o);\n    return i.length > 0 ? i[0] : null;\n  }\n  /**\n   * Return all stored listeners by passed params\n   *\n   * @param {EventTarget} element - event target\n   * @param {string} eventType - event type\n   * @param {Function} handler - event handler\n   * @returns {ListenerData[]}\n   */\n  findAll(e, t, o) {\n    let i;\n    const n = e ? this.findByEventTarget(e) : [];\n    return e && t && o ? i = n.filter((r) => r.eventType === t && r.handler === o) : e && t ? i = n.filter((r) => r.eventType === t) : i = n, i;\n  }\n  /**\n   * Removes all listeners\n   */\n  removeAll() {\n    this.allListeners.map((e) => {\n      e.element.removeEventListener(e.eventType, e.handler, e.options);\n    }), this.allListeners = [];\n  }\n  /**\n   * Module cleanup on destruction\n   */\n  destroy() {\n    this.removeAll();\n  }\n  /**\n   * Search method: looks for listener by passed element\n   *\n   * @param {EventTarget} element - searching element\n   * @returns {Array} listeners that found on element\n   */\n  findByEventTarget(e) {\n    return this.allListeners.filter((t) => {\n      if (t.element === e)\n        return t;\n    });\n  }\n  /**\n   * Search method: looks for listener by passed event type\n   *\n   * @param {string} eventType - event type\n   * @returns {ListenerData[]} listeners that found on element\n   */\n  findByType(e) {\n    return this.allListeners.filter((t) => {\n      if (t.eventType === e)\n        return t;\n    });\n  }\n  /**\n   * Search method: looks for listener by passed handler\n   *\n   * @param {Function} handler - event handler\n   * @returns {ListenerData[]} listeners that found on element\n   */\n  findByHandler(e) {\n    return this.allListeners.filter((t) => {\n      if (t.handler === e)\n        return t;\n    });\n  }\n  /**\n   * Returns listener data found by id\n   *\n   * @param {string} id - listener identifier\n   * @returns {ListenerData}\n   */\n  findById(e) {\n    return this.allListeners.find((t) => t.id === e);\n  }\n}\nclass y {\n  /**\n   * @class\n   * @param options - Module options\n   * @param options.config - Module config\n   * @param options.eventsDispatcher - Common event bus\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    if (this.nodes = {}, this.listeners = new Fe(), this.readOnlyMutableListeners = {\n      /**\n       * Assigns event listener on DOM element and pushes into special array that might be removed\n       *\n       * @param {EventTarget} element - DOM Element\n       * @param {string} eventType - Event name\n       * @param {Function} handler - Event handler\n       * @param {boolean|AddEventListenerOptions} options - Listening options\n       */\n      on: (o, i, n, r = !1) => {\n        this.mutableListenerIds.push(\n          this.listeners.on(o, i, n, r)\n        );\n      },\n      /**\n       * Clears all mutable listeners\n       */\n      clearAll: () => {\n        for (const o of this.mutableListenerIds)\n          this.listeners.offById(o);\n        this.mutableListenerIds = [];\n      }\n    }, this.mutableListenerIds = [], new.target === y)\n      throw new TypeError(\"Constructors for abstract class Module are not allowed.\");\n    this.config = e, this.eventsDispatcher = t;\n  }\n  /**\n   * Editor modules setter\n   *\n   * @param {EditorModules} Editor - Editor's Modules\n   */\n  set state(e) {\n    this.Editor = e;\n  }\n  /**\n   * Remove memorized nodes\n   */\n  removeAllNodes() {\n    for (const e in this.nodes) {\n      const t = this.nodes[e];\n      t instanceof HTMLElement && t.remove();\n    }\n  }\n  /**\n   * Returns true if current direction is RTL (Right-To-Left)\n   */\n  get isRtl() {\n    return this.config.i18n.direction === \"rtl\";\n  }\n}\nclass b {\n  constructor() {\n    this.instance = null, this.selection = null, this.savedSelectionRange = null, this.isFakeBackgroundEnabled = !1, this.commandBackground = \"backColor\", this.commandRemoveFormat = \"removeFormat\";\n  }\n  /**\n   * Editor styles\n   *\n   * @returns {{editorWrapper: string, editorZone: string}}\n   */\n  static get CSS() {\n    return {\n      editorWrapper: \"codex-editor\",\n      editorZone: \"codex-editor__redactor\"\n    };\n  }\n  /**\n   * Returns selected anchor\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorNode}\n   *\n   * @returns {Node|null}\n   */\n  static get anchorNode() {\n    const e = window.getSelection();\n    return e ? e.anchorNode : null;\n  }\n  /**\n   * Returns selected anchor element\n   *\n   * @returns {Element|null}\n   */\n  static get anchorElement() {\n    const e = window.getSelection();\n    if (!e)\n      return null;\n    const t = e.anchorNode;\n    return t ? c.isElement(t) ? t : t.parentElement : null;\n  }\n  /**\n   * Returns selection offset according to the anchor node\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorOffset}\n   *\n   * @returns {number|null}\n   */\n  static get anchorOffset() {\n    const e = window.getSelection();\n    return e ? e.anchorOffset : null;\n  }\n  /**\n   * Is current selection range collapsed\n   *\n   * @returns {boolean|null}\n   */\n  static get isCollapsed() {\n    const e = window.getSelection();\n    return e ? e.isCollapsed : null;\n  }\n  /**\n   * Check current selection if it is at Editor's zone\n   *\n   * @returns {boolean}\n   */\n  static get isAtEditor() {\n    return this.isSelectionAtEditor(b.get());\n  }\n  /**\n   * Check if passed selection is at Editor's zone\n   *\n   * @param selection - Selection object to check\n   */\n  static isSelectionAtEditor(e) {\n    if (!e)\n      return !1;\n    let t = e.anchorNode || e.focusNode;\n    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);\n    let o = null;\n    return t && t instanceof Element && (o = t.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;\n  }\n  /**\n   * Check if passed range at Editor zone\n   *\n   * @param range - range to check\n   */\n  static isRangeAtEditor(e) {\n    if (!e)\n      return;\n    let t = e.startContainer;\n    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);\n    let o = null;\n    return t && t instanceof Element && (o = t.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;\n  }\n  /**\n   * Methods return boolean that true if selection exists on the page\n   */\n  static get isSelectionExists() {\n    return !!b.get().anchorNode;\n  }\n  /**\n   * Return first range\n   *\n   * @returns {Range|null}\n   */\n  static get range() {\n    return this.getRangeFromSelection(this.get());\n  }\n  /**\n   * Returns range from passed Selection object\n   *\n   * @param selection - Selection object to get Range from\n   */\n  static getRangeFromSelection(e) {\n    return e && e.rangeCount ? e.getRangeAt(0) : null;\n  }\n  /**\n   * Calculates position and size of selected text\n   *\n   * @returns {DOMRect | ClientRect}\n   */\n  static get rect() {\n    let e = document.selection, t, o = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    if (e && e.type !== \"Control\")\n      return e = e, t = e.createRange(), o.x = t.boundingLeft, o.y = t.boundingTop, o.width = t.boundingWidth, o.height = t.boundingHeight, o;\n    if (!window.getSelection)\n      return T(\"Method window.getSelection is not supported\", \"warn\"), o;\n    if (e = window.getSelection(), e.rangeCount === null || isNaN(e.rangeCount))\n      return T(\"Method SelectionUtils.rangeCount is not supported\", \"warn\"), o;\n    if (e.rangeCount === 0)\n      return o;\n    if (t = e.getRangeAt(0).cloneRange(), t.getBoundingClientRect && (o = t.getBoundingClientRect()), o.x === 0 && o.y === 0) {\n      const i = document.createElement(\"span\");\n      if (i.getBoundingClientRect) {\n        i.appendChild(document.createTextNode(\"​\")), t.insertNode(i), o = i.getBoundingClientRect();\n        const n = i.parentNode;\n        n.removeChild(i), n.normalize();\n      }\n    }\n    return o;\n  }\n  /**\n   * Returns selected text as String\n   *\n   * @returns {string}\n   */\n  static get text() {\n    return window.getSelection ? window.getSelection().toString() : \"\";\n  }\n  /**\n   * Returns window SelectionUtils\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Window/getSelection}\n   *\n   * @returns {Selection}\n   */\n  static get() {\n    return window.getSelection();\n  }\n  /**\n   * Set focus to contenteditable or native input element\n   *\n   * @param element - element where to set focus\n   * @param offset - offset of cursor\n   */\n  static setCursor(e, t = 0) {\n    const o = document.createRange(), i = window.getSelection();\n    return c.isNativeInput(e) ? c.canSetCaret(e) ? (e.focus(), e.selectionStart = e.selectionEnd = t, e.getBoundingClientRect()) : void 0 : (o.setStart(e, t), o.setEnd(e, t), i.removeAllRanges(), i.addRange(o), o.getBoundingClientRect());\n  }\n  /**\n   * Check if current range exists and belongs to container\n   *\n   * @param container - where range should be\n   */\n  static isRangeInsideContainer(e) {\n    const t = b.range;\n    return t === null ? !1 : e.contains(t.startContainer);\n  }\n  /**\n   * Adds fake cursor to the current range\n   */\n  static addFakeCursor() {\n    const e = b.range;\n    if (e === null)\n      return;\n    const t = c.make(\"span\", \"codex-editor__fake-cursor\");\n    t.dataset.mutationFree = \"true\", e.collapse(), e.insertNode(t);\n  }\n  /**\n   * Check if passed element contains a fake cursor\n   *\n   * @param el - where to check\n   */\n  static isFakeCursorInsideContainer(e) {\n    return c.find(e, \".codex-editor__fake-cursor\") !== null;\n  }\n  /**\n   * Removes fake cursor from a container\n   *\n   * @param container - container to look for\n   */\n  static removeFakeCursor(e = document.body) {\n    const t = c.find(e, \".codex-editor__fake-cursor\");\n    t && t.remove();\n  }\n  /**\n   * Removes fake background\n   */\n  removeFakeBackground() {\n    this.isFakeBackgroundEnabled && (this.isFakeBackgroundEnabled = !1, document.execCommand(this.commandRemoveFormat));\n  }\n  /**\n   * Sets fake background\n   */\n  setFakeBackground() {\n    document.execCommand(this.commandBackground, !1, \"#a8d6ff\"), this.isFakeBackgroundEnabled = !0;\n  }\n  /**\n   * Save SelectionUtils's range\n   */\n  save() {\n    this.savedSelectionRange = b.range;\n  }\n  /**\n   * Restore saved SelectionUtils's range\n   */\n  restore() {\n    if (!this.savedSelectionRange)\n      return;\n    const e = window.getSelection();\n    e.removeAllRanges(), e.addRange(this.savedSelectionRange);\n  }\n  /**\n   * Clears saved selection\n   */\n  clearSaved() {\n    this.savedSelectionRange = null;\n  }\n  /**\n   * Collapse current selection\n   */\n  collapseToEnd() {\n    const e = window.getSelection(), t = document.createRange();\n    t.selectNodeContents(e.focusNode), t.collapse(!1), e.removeAllRanges(), e.addRange(t);\n  }\n  /**\n   * Looks ahead to find passed tag from current selection\n   *\n   * @param  {string} tagName       - tag to found\n   * @param  {string} [className]   - tag's class name\n   * @param  {number} [searchDepth] - count of tags that can be included. For better performance.\n   * @returns {HTMLElement|null}\n   */\n  findParentTag(e, t, o = 10) {\n    const i = window.getSelection();\n    let n = null;\n    return !i || !i.anchorNode || !i.focusNode ? null : ([\n      /** the Node in which the selection begins */\n      i.anchorNode,\n      /** the Node in which the selection ends */\n      i.focusNode\n    ].forEach((a) => {\n      let l = o;\n      for (; l > 0 && a.parentNode && !(a.tagName === e && (n = a, t && a.classList && !a.classList.contains(t) && (n = null), n)); )\n        a = a.parentNode, l--;\n    }), n);\n  }\n  /**\n   * Expands selection range to the passed parent node\n   *\n   * @param {HTMLElement} element - element which contents should be selected\n   */\n  expandToTag(e) {\n    const t = window.getSelection();\n    t.removeAllRanges();\n    const o = document.createRange();\n    o.selectNodeContents(e), t.addRange(o);\n  }\n}\nfunction Qt(s, e) {\n  const { type: t, target: o, addedNodes: i, removedNodes: n } = s;\n  if (o === e)\n    return !0;\n  if ([\"characterData\", \"attributes\"].includes(t)) {\n    const l = o.nodeType === Node.TEXT_NODE ? o.parentNode : o;\n    return e.contains(l);\n  }\n  const r = Array.from(i).some((l) => e.contains(l)), a = Array.from(n).some((l) => e.contains(l));\n  return r || a;\n}\nconst Ae = \"redactor dom changed\", pt = \"block changed\", ft = \"fake cursor is about to be toggled\", gt = \"fake cursor have been set\";\nfunction ot(s, e) {\n  return s.mergeable && s.name === e.name;\n}\nfunction eo(s, e) {\n  const t = e == null ? void 0 : e.export;\n  return M(t) ? t(s) : G(t) ? s[t] : (t !== void 0 && T(\"Conversion «export» property must be a string or function. String means key of saved data object to export. Function should export processed string to export.\"), \"\");\n}\nfunction to(s, e) {\n  const t = e == null ? void 0 : e.import;\n  return M(t) ? t(s) : G(t) ? {\n    [t]: s\n  } : (t !== void 0 && T(\"Conversion «import» property must be a string or function. String means key of tool data to import. Function accepts a imported string and return composed tool data.\"), {});\n}\nvar X = /* @__PURE__ */ ((s) => (s.APPEND_CALLBACK = \"appendCallback\", s.RENDERED = \"rendered\", s.MOVED = \"moved\", s.UPDATED = \"updated\", s.REMOVED = \"removed\", s.ON_PASTE = \"onPaste\", s))(X || {});\nclass R extends Ee {\n  /**\n   * @param options - block constructor options\n   * @param [options.id] - block's id. Will be generated if omitted.\n   * @param options.data - Tool's initial data\n   * @param options.tool — block's tool\n   * @param options.api - Editor API module for pass it to the Block Tunes\n   * @param options.readOnly - Read-Only flag\n   * @param [eventBus] - Editor common event bus. Allows to subscribe on some Editor events. Could be omitted when \"virtual\" Block is created. See BlocksAPI@composeBlockData.\n   */\n  constructor({\n    id: e = Yt(),\n    data: t,\n    tool: o,\n    api: i,\n    readOnly: n,\n    tunesData: r\n  }, a) {\n    super(), this.cachedInputs = [], this.toolRenderedElement = null, this.tunesInstances = /* @__PURE__ */ new Map(), this.defaultTunesInstances = /* @__PURE__ */ new Map(), this.unavailableTunesData = {}, this.inputIndex = 0, this.editorEventBus = null, this.handleFocus = () => {\n      this.dropInputsCache(), this.updateCurrentInput();\n    }, this.didMutated = (l = void 0) => {\n      const d = l === void 0, u = l instanceof InputEvent;\n      !d && !u && this.detectToolRootChange(l);\n      let h;\n      d || u ? h = !0 : h = !(l.length > 0 && l.every((x) => {\n        const { addedNodes: p, removedNodes: m, target: L } = x;\n        return [\n          ...Array.from(p),\n          ...Array.from(m),\n          L\n        ].some((S) => (c.isElement(S) || (S = S.parentElement), S && S.closest('[data-mutation-free=\"true\"]') !== null));\n      })), h && (this.dropInputsCache(), this.updateCurrentInput(), this.call(\n        \"updated\"\n        /* UPDATED */\n      ), this.emit(\"didMutated\", this));\n    }, this.name = o.name, this.id = e, this.settings = o.settings, this.config = o.settings.config || {}, this.api = i, this.editorEventBus = a || null, this.blockAPI = new ee(this), this.tool = o, this.toolInstance = o.create(t, this.blockAPI, n), this.tunes = o.tunes, this.composeTunes(r), this.holder = this.compose(), window.requestIdleCallback(() => {\n      this.watchBlockMutations(), this.addInputEvents();\n    });\n  }\n  /**\n   * CSS classes for the Block\n   *\n   * @returns {{wrapper: string, content: string}}\n   */\n  static get CSS() {\n    return {\n      wrapper: \"ce-block\",\n      wrapperStretched: \"ce-block--stretched\",\n      content: \"ce-block__content\",\n      selected: \"ce-block--selected\",\n      dropTarget: \"ce-block--drop-target\"\n    };\n  }\n  /**\n   * Find and return all editable elements (contenteditable and native inputs) in the Tool HTML\n   *\n   * @returns {HTMLElement[]}\n   */\n  get inputs() {\n    if (this.cachedInputs.length !== 0)\n      return this.cachedInputs;\n    const e = c.findAllInputs(this.holder);\n    return this.inputIndex > e.length - 1 && (this.inputIndex = e.length - 1), this.cachedInputs = e, e;\n  }\n  /**\n   * Return current Tool`s input\n   *\n   * @returns {HTMLElement}\n   */\n  get currentInput() {\n    return this.inputs[this.inputIndex];\n  }\n  /**\n   * Set input index to the passed element\n   *\n   * @param {HTMLElement | Node} element - HTML Element to set as current input\n   */\n  set currentInput(e) {\n    const t = this.inputs.findIndex((o) => o === e || o.contains(e));\n    t !== -1 && (this.inputIndex = t);\n  }\n  /**\n   * Return first Tool`s input\n   *\n   * @returns {HTMLElement}\n   */\n  get firstInput() {\n    return this.inputs[0];\n  }\n  /**\n   * Return first Tool`s input\n   *\n   * @returns {HTMLElement}\n   */\n  get lastInput() {\n    const e = this.inputs;\n    return e[e.length - 1];\n  }\n  /**\n   * Return next Tool`s input or undefined if it doesn't exist\n   *\n   * @returns {HTMLElement}\n   */\n  get nextInput() {\n    return this.inputs[this.inputIndex + 1];\n  }\n  /**\n   * Return previous Tool`s input or undefined if it doesn't exist\n   *\n   * @returns {HTMLElement}\n   */\n  get previousInput() {\n    return this.inputs[this.inputIndex - 1];\n  }\n  /**\n   * Get Block's JSON data\n   *\n   * @returns {object}\n   */\n  get data() {\n    return this.save().then((e) => e && !W(e.data) ? e.data : {});\n  }\n  /**\n   * Returns tool's sanitizer config\n   *\n   * @returns {object}\n   */\n  get sanitize() {\n    return this.tool.sanitizeConfig;\n  }\n  /**\n   * is block mergeable\n   * We plugin have merge function then we call it mergeable\n   *\n   * @returns {boolean}\n   */\n  get mergeable() {\n    return M(this.toolInstance.merge);\n  }\n  /**\n   * If Block contains inputs, it is focusable\n   */\n  get focusable() {\n    return this.inputs.length !== 0;\n  }\n  /**\n   * Check block for emptiness\n   *\n   * @returns {boolean}\n   */\n  get isEmpty() {\n    const e = c.isEmpty(this.pluginsContent, \"/\"), t = !this.hasMedia;\n    return e && t;\n  }\n  /**\n   * Check if block has a media content such as images, iframe and other\n   *\n   * @returns {boolean}\n   */\n  get hasMedia() {\n    const e = [\n      \"img\",\n      \"iframe\",\n      \"video\",\n      \"audio\",\n      \"source\",\n      \"input\",\n      \"textarea\",\n      \"twitterwidget\"\n    ];\n    return !!this.holder.querySelector(e.join(\",\"));\n  }\n  /**\n   * Set selected state\n   * We don't need to mark Block as Selected when it is empty\n   *\n   * @param {boolean} state - 'true' to select, 'false' to remove selection\n   */\n  set selected(e) {\n    var i, n;\n    this.holder.classList.toggle(R.CSS.selected, e);\n    const t = e === !0 && b.isRangeInsideContainer(this.holder), o = e === !1 && b.isFakeCursorInsideContainer(this.holder);\n    (t || o) && ((i = this.editorEventBus) == null || i.emit(ft, { state: e }), t ? b.addFakeCursor() : b.removeFakeCursor(this.holder), (n = this.editorEventBus) == null || n.emit(gt, { state: e }));\n  }\n  /**\n   * Returns True if it is Selected\n   *\n   * @returns {boolean}\n   */\n  get selected() {\n    return this.holder.classList.contains(R.CSS.selected);\n  }\n  /**\n   * Set stretched state\n   *\n   * @param {boolean} state - 'true' to enable, 'false' to disable stretched state\n   */\n  set stretched(e) {\n    this.holder.classList.toggle(R.CSS.wrapperStretched, e);\n  }\n  /**\n   * Return Block's stretched state\n   *\n   * @returns {boolean}\n   */\n  get stretched() {\n    return this.holder.classList.contains(R.CSS.wrapperStretched);\n  }\n  /**\n   * Toggle drop target state\n   *\n   * @param {boolean} state - 'true' if block is drop target, false otherwise\n   */\n  set dropTarget(e) {\n    this.holder.classList.toggle(R.CSS.dropTarget, e);\n  }\n  /**\n   * Returns Plugins content\n   *\n   * @returns {HTMLElement}\n   */\n  get pluginsContent() {\n    return this.toolRenderedElement;\n  }\n  /**\n   * Calls Tool's method\n   *\n   * Method checks tool property {MethodName}. Fires method with passes params If it is instance of Function\n   *\n   * @param {string} methodName - method to call\n   * @param {object} params - method argument\n   */\n  call(e, t) {\n    if (M(this.toolInstance[e])) {\n      e === \"appendCallback\" && T(\n        \"`appendCallback` hook is deprecated and will be removed in the next major release. Use `rendered` hook instead\",\n        \"warn\"\n      );\n      try {\n        this.toolInstance[e].call(this.toolInstance, t);\n      } catch (o) {\n        T(`Error during '${e}' call: ${o.message}`, \"error\");\n      }\n    }\n  }\n  /**\n   * Call plugins merge method\n   *\n   * @param {BlockToolData} data - data to merge\n   */\n  async mergeWith(e) {\n    await this.toolInstance.merge(e);\n  }\n  /**\n   * Extracts data from Block\n   * Groups Tool's save processing time\n   *\n   * @returns {object}\n   */\n  async save() {\n    const e = await this.toolInstance.save(this.pluginsContent), t = this.unavailableTunesData;\n    [\n      ...this.tunesInstances.entries(),\n      ...this.defaultTunesInstances.entries()\n    ].forEach(([n, r]) => {\n      if (M(r.save))\n        try {\n          t[n] = r.save();\n        } catch (a) {\n          T(`Tune ${r.constructor.name} save method throws an Error %o`, \"warn\", a);\n        }\n    });\n    const o = window.performance.now();\n    let i;\n    return Promise.resolve(e).then((n) => (i = window.performance.now(), {\n      id: this.id,\n      tool: this.name,\n      data: n,\n      tunes: t,\n      time: i - o\n    })).catch((n) => {\n      T(`Saving process for ${this.name} tool failed due to the ${n}`, \"log\", \"red\");\n    });\n  }\n  /**\n   * Uses Tool's validation method to check the correctness of output data\n   * Tool's validation method is optional\n   *\n   * @description Method returns true|false whether data passed the validation or not\n   * @param {BlockToolData} data - data to validate\n   * @returns {Promise<boolean>} valid\n   */\n  async validate(e) {\n    let t = !0;\n    return this.toolInstance.validate instanceof Function && (t = await this.toolInstance.validate(e)), t;\n  }\n  /**\n   * Returns data to render in tunes menu.\n   * Splits block tunes settings into 2 groups: popover items and custom html.\n   */\n  getTunes() {\n    const e = document.createElement(\"div\"), t = [], o = typeof this.toolInstance.renderSettings == \"function\" ? this.toolInstance.renderSettings() : [], i = [\n      ...this.tunesInstances.values(),\n      ...this.defaultTunesInstances.values()\n    ].map((n) => n.render());\n    return [o, i].flat().forEach((n) => {\n      c.isElement(n) ? e.appendChild(n) : Array.isArray(n) ? t.push(...n) : t.push(n);\n    }), [t, e];\n  }\n  /**\n   * Update current input index with selection anchor node\n   */\n  updateCurrentInput() {\n    this.currentInput = c.isNativeInput(document.activeElement) || !b.anchorNode ? document.activeElement : b.anchorNode;\n  }\n  /**\n   * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback\n   * Can be useful for block changes invisible for editor core.\n   */\n  dispatchChange() {\n    this.didMutated();\n  }\n  /**\n   * Call Tool instance destroy method\n   */\n  destroy() {\n    this.unwatchBlockMutations(), this.removeInputEvents(), super.destroy(), M(this.toolInstance.destroy) && this.toolInstance.destroy();\n  }\n  /**\n   * Tool could specify several entries to be displayed at the Toolbox (for example, \"Heading 1\", \"Heading 2\", \"Heading 3\")\n   * This method returns the entry that is related to the Block (depended on the Block data)\n   */\n  async getActiveToolboxEntry() {\n    const e = this.tool.toolbox;\n    if (e.length === 1)\n      return Promise.resolve(this.tool.toolbox[0]);\n    const t = await this.data;\n    return e.find((i) => Object.entries(i.data).some(([n, r]) => t[n] && Vt(t[n], r)));\n  }\n  /**\n   * Exports Block data as string using conversion config\n   */\n  async exportDataAsString() {\n    const e = await this.data;\n    return eo(e, this.tool.conversionConfig);\n  }\n  /**\n   * Make default Block wrappers and put Tool`s content there\n   *\n   * @returns {HTMLDivElement}\n   */\n  compose() {\n    const e = c.make(\"div\", R.CSS.wrapper), t = c.make(\"div\", R.CSS.content), o = this.toolInstance.render();\n    e.dataset.id = this.id, this.toolRenderedElement = o, t.appendChild(this.toolRenderedElement);\n    let i = t;\n    return [...this.tunesInstances.values(), ...this.defaultTunesInstances.values()].forEach((n) => {\n      if (M(n.wrap))\n        try {\n          i = n.wrap(i);\n        } catch (r) {\n          T(`Tune ${n.constructor.name} wrap method throws an Error %o`, \"warn\", r);\n        }\n    }), e.appendChild(i), e;\n  }\n  /**\n   * Instantiate Block Tunes\n   *\n   * @param tunesData - current Block tunes data\n   * @private\n   */\n  composeTunes(e) {\n    Array.from(this.tunes.values()).forEach((t) => {\n      (t.isInternal ? this.defaultTunesInstances : this.tunesInstances).set(t.name, t.create(e[t.name], this.blockAPI));\n    }), Object.entries(e).forEach(([t, o]) => {\n      this.tunesInstances.has(t) || (this.unavailableTunesData[t] = o);\n    });\n  }\n  /**\n   * Adds focus event listeners to all inputs and contenteditable\n   */\n  addInputEvents() {\n    this.inputs.forEach((e) => {\n      e.addEventListener(\"focus\", this.handleFocus), c.isNativeInput(e) && e.addEventListener(\"input\", this.didMutated);\n    });\n  }\n  /**\n   * removes focus event listeners from all inputs and contenteditable\n   */\n  removeInputEvents() {\n    this.inputs.forEach((e) => {\n      e.removeEventListener(\"focus\", this.handleFocus), c.isNativeInput(e) && e.removeEventListener(\"input\", this.didMutated);\n    });\n  }\n  /**\n   * Listen common editor Dom Changed event and detect mutations related to the  Block\n   */\n  watchBlockMutations() {\n    var e;\n    this.redactorDomChangedCallback = (t) => {\n      const { mutations: o } = t;\n      o.some((n) => Qt(n, this.toolRenderedElement)) && this.didMutated(o);\n    }, (e = this.editorEventBus) == null || e.on(Ae, this.redactorDomChangedCallback);\n  }\n  /**\n   * Remove redactor dom change event listener\n   */\n  unwatchBlockMutations() {\n    var e;\n    (e = this.editorEventBus) == null || e.off(Ae, this.redactorDomChangedCallback);\n  }\n  /**\n   * Sometimes Tool can replace own main element, for example H2 -> H4 or UL -> OL\n   * We need to detect such changes and update a link to tools main element with the new one\n   *\n   * @param mutations - records of block content mutations\n   */\n  detectToolRootChange(e) {\n    e.forEach((t) => {\n      if (Array.from(t.removedNodes).includes(this.toolRenderedElement)) {\n        const i = t.addedNodes[t.addedNodes.length - 1];\n        this.toolRenderedElement = i;\n      }\n    });\n  }\n  /**\n   * Clears inputs cached value\n   */\n  dropInputsCache() {\n    this.cachedInputs = [];\n  }\n}\nclass oo extends y {\n  constructor() {\n    super(...arguments), this.insert = (e = this.config.defaultBlock, t = {}, o = {}, i, n, r, a) => {\n      const l = this.Editor.BlockManager.insert({\n        id: a,\n        tool: e,\n        data: t,\n        index: i,\n        needToFocus: n,\n        replace: r\n      });\n      return new ee(l);\n    }, this.composeBlockData = async (e) => {\n      const t = this.Editor.Tools.blockTools.get(e);\n      return new R({\n        tool: t,\n        api: this.Editor.API,\n        readOnly: !0,\n        data: {},\n        tunesData: {}\n      }).data;\n    }, this.update = async (e, t) => {\n      const { BlockManager: o } = this.Editor, i = o.getBlockById(e);\n      if (i === void 0)\n        throw new Error(`Block with id \"${e}\" not found`);\n      const n = await o.update(i, t);\n      return new ee(n);\n    }, this.convert = (e, t, o) => {\n      var h, f;\n      const { BlockManager: i, Tools: n } = this.Editor, r = i.getBlockById(e);\n      if (!r)\n        throw new Error(`Block with id \"${e}\" not found`);\n      const a = n.blockTools.get(r.name), l = n.blockTools.get(t);\n      if (!l)\n        throw new Error(`Block Tool with type \"${t}\" not found`);\n      const d = ((h = a == null ? void 0 : a.conversionConfig) == null ? void 0 : h.export) !== void 0, u = ((f = l.conversionConfig) == null ? void 0 : f.import) !== void 0;\n      if (d && u)\n        i.convert(r, t, o);\n      else {\n        const x = [\n          d ? !1 : re(r.name),\n          u ? !1 : re(t)\n        ].filter(Boolean).join(\" and \");\n        throw new Error(`Conversion from \"${r.name}\" to \"${t}\" is not possible. ${x} tool(s) should provide a \"conversionConfig\"`);\n      }\n    }, this.insertMany = (e, t = this.Editor.BlockManager.blocks.length - 1) => {\n      this.validateIndex(t);\n      const o = e.map(({ id: i, type: n, data: r }) => this.Editor.BlockManager.composeBlock({\n        id: i,\n        tool: n || this.config.defaultBlock,\n        data: r\n      }));\n      return this.Editor.BlockManager.insertMany(o, t), o.map((i) => new ee(i));\n    };\n  }\n  /**\n   * Available methods\n   *\n   * @returns {Blocks}\n   */\n  get methods() {\n    return {\n      clear: () => this.clear(),\n      render: (e) => this.render(e),\n      renderFromHTML: (e) => this.renderFromHTML(e),\n      delete: (e) => this.delete(e),\n      swap: (e, t) => this.swap(e, t),\n      move: (e, t) => this.move(e, t),\n      getBlockByIndex: (e) => this.getBlockByIndex(e),\n      getById: (e) => this.getById(e),\n      getCurrentBlockIndex: () => this.getCurrentBlockIndex(),\n      getBlockIndex: (e) => this.getBlockIndex(e),\n      getBlocksCount: () => this.getBlocksCount(),\n      stretchBlock: (e, t = !0) => this.stretchBlock(e, t),\n      insertNewBlock: () => this.insertNewBlock(),\n      insert: this.insert,\n      insertMany: this.insertMany,\n      update: this.update,\n      composeBlockData: this.composeBlockData,\n      convert: this.convert\n    };\n  }\n  /**\n   * Returns Blocks count\n   *\n   * @returns {number}\n   */\n  getBlocksCount() {\n    return this.Editor.BlockManager.blocks.length;\n  }\n  /**\n   * Returns current block index\n   *\n   * @returns {number}\n   */\n  getCurrentBlockIndex() {\n    return this.Editor.BlockManager.currentBlockIndex;\n  }\n  /**\n   * Returns the index of Block by id;\n   *\n   * @param id - block id\n   */\n  getBlockIndex(e) {\n    const t = this.Editor.BlockManager.getBlockById(e);\n    if (!t) {\n      Y(\"There is no block with id `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return this.Editor.BlockManager.getBlockIndex(t);\n  }\n  /**\n   * Returns BlockAPI object by Block index\n   *\n   * @param {number} index - index to get\n   */\n  getBlockByIndex(e) {\n    const t = this.Editor.BlockManager.getBlockByIndex(e);\n    if (t === void 0) {\n      Y(\"There is no block at index `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return new ee(t);\n  }\n  /**\n   * Returns BlockAPI object by Block id\n   *\n   * @param id - id of block to get\n   */\n  getById(e) {\n    const t = this.Editor.BlockManager.getBlockById(e);\n    return t === void 0 ? (Y(\"There is no block with id `\" + e + \"`\", \"warn\"), null) : new ee(t);\n  }\n  /**\n   * Call Block Manager method that swap Blocks\n   *\n   * @param {number} fromIndex - position of first Block\n   * @param {number} toIndex - position of second Block\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    T(\n      \"`blocks.swap()` method is deprecated and will be removed in the next major release. Use `block.move()` method instead\",\n      \"info\"\n    ), this.Editor.BlockManager.swap(e, t);\n  }\n  /**\n   * Move block from one index to another\n   *\n   * @param {number} toIndex - index to move to\n   * @param {number} fromIndex - index to move from\n   */\n  move(e, t) {\n    this.Editor.BlockManager.move(e, t);\n  }\n  /**\n   * Deletes Block\n   *\n   * @param {number} blockIndex - index of Block to delete\n   */\n  delete(e = this.Editor.BlockManager.currentBlockIndex) {\n    try {\n      const t = this.Editor.BlockManager.getBlockByIndex(e);\n      this.Editor.BlockManager.removeBlock(t);\n    } catch (t) {\n      Y(t, \"warn\");\n      return;\n    }\n    this.Editor.BlockManager.blocks.length === 0 && this.Editor.BlockManager.insert(), this.Editor.BlockManager.currentBlock && this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END), this.Editor.Toolbar.close();\n  }\n  /**\n   * Clear Editor's area\n   */\n  async clear() {\n    await this.Editor.BlockManager.clear(!0), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * Fills Editor with Blocks data\n   *\n   * @param {OutputData} data — Saved Editor data\n   */\n  async render(e) {\n    if (e === void 0 || e.blocks === void 0)\n      throw new Error(\"Incorrect data passed to the render() method\");\n    this.Editor.ModificationsObserver.disable(), await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(e.blocks), this.Editor.ModificationsObserver.enable();\n  }\n  /**\n   * Render passed HTML string\n   *\n   * @param {string} data - HTML string to render\n   * @returns {Promise<void>}\n   */\n  renderFromHTML(e) {\n    return this.Editor.BlockManager.clear(), this.Editor.Paste.processText(e, !0);\n  }\n  /**\n   * Stretch Block's content\n   *\n   * @param {number} index - index of Block to stretch\n   * @param {boolean} status - true to enable, false to disable\n   * @deprecated Use BlockAPI interface to stretch Blocks\n   */\n  stretchBlock(e, t = !0) {\n    Le(\n      !0,\n      \"blocks.stretchBlock()\",\n      \"BlockAPI\"\n    );\n    const o = this.Editor.BlockManager.getBlockByIndex(e);\n    o && (o.stretched = t);\n  }\n  /**\n   * Insert new Block\n   * After set caret to this Block\n   *\n   * @todo remove in 3.0.0\n   * @deprecated with insert() method\n   */\n  insertNewBlock() {\n    T(\"Method blocks.insertNewBlock() is deprecated and it will be removed in the next major release. Use blocks.insert() instead.\", \"warn\"), this.insert();\n  }\n  /**\n   * Validated block index and throws an error if it's invalid\n   *\n   * @param index - index to validate\n   */\n  validateIndex(e) {\n    if (typeof e != \"number\")\n      throw new Error(\"Index should be a number\");\n    if (e < 0)\n      throw new Error(\"Index should be greater than or equal to 0\");\n    if (e === null)\n      throw new Error(\"Index should be greater than or equal to 0\");\n  }\n}\nclass io extends y {\n  constructor() {\n    super(...arguments), this.setToFirstBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.firstBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.firstBlock, e, t), !0) : !1, this.setToLastBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.lastBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.lastBlock, e, t), !0) : !1, this.setToPreviousBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.previousBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.previousBlock, e, t), !0) : !1, this.setToNextBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.nextBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.nextBlock, e, t), !0) : !1, this.setToBlock = (e, t = this.Editor.Caret.positions.DEFAULT, o = 0) => this.Editor.BlockManager.blocks[e] ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.blocks[e], t, o), !0) : !1, this.focus = (e = !1) => e ? this.setToLastBlock(this.Editor.Caret.positions.END) : this.setToFirstBlock(this.Editor.Caret.positions.START);\n  }\n  /**\n   * Available methods\n   *\n   * @returns {Caret}\n   */\n  get methods() {\n    return {\n      setToFirstBlock: this.setToFirstBlock,\n      setToLastBlock: this.setToLastBlock,\n      setToPreviousBlock: this.setToPreviousBlock,\n      setToNextBlock: this.setToNextBlock,\n      setToBlock: this.setToBlock,\n      focus: this.focus\n    };\n  }\n}\nclass no extends y {\n  /**\n   * Available methods\n   *\n   * @returns {Events}\n   */\n  get methods() {\n    return {\n      emit: (e, t) => this.emit(e, t),\n      off: (e, t) => this.off(e, t),\n      on: (e, t) => this.on(e, t)\n    };\n  }\n  /**\n   * Subscribe on Events\n   *\n   * @param {string} eventName - event name to subscribe\n   * @param {Function} callback - event handler\n   */\n  on(e, t) {\n    this.eventsDispatcher.on(e, t);\n  }\n  /**\n   * Emit event with data\n   *\n   * @param {string} eventName - event to emit\n   * @param {object} data - event's data\n   */\n  emit(e, t) {\n    this.eventsDispatcher.emit(e, t);\n  }\n  /**\n   * Unsubscribe from Event\n   *\n   * @param {string} eventName - event to unsubscribe\n   * @param {Function} callback - event handler\n   */\n  off(e, t) {\n    this.eventsDispatcher.off(e, t);\n  }\n}\nclass He extends y {\n  /**\n   * Return namespace section for tool or block tune\n   *\n   * @param tool - tool object\n   */\n  static getNamespace(e) {\n    return e.isTune() ? `blockTunes.${e.name}` : `tools.${e.name}`;\n  }\n  /**\n   * Return I18n API methods with global dictionary access\n   */\n  get methods() {\n    return {\n      t: () => {\n        Y(\"I18n.t() method can be accessed only from Tools\", \"warn\");\n      }\n    };\n  }\n  /**\n   * Return I18n API methods with tool namespaced dictionary\n   *\n   * @param tool - Tool object\n   */\n  getMethodsForTool(e) {\n    return Object.assign(\n      this.methods,\n      {\n        t: (t) => z.t(He.getNamespace(e), t)\n      }\n    );\n  }\n}\nclass so extends y {\n  /**\n   * Editor.js Core API modules\n   */\n  get methods() {\n    return {\n      blocks: this.Editor.BlocksAPI.methods,\n      caret: this.Editor.CaretAPI.methods,\n      events: this.Editor.EventsAPI.methods,\n      listeners: this.Editor.ListenersAPI.methods,\n      notifier: this.Editor.NotifierAPI.methods,\n      sanitizer: this.Editor.SanitizerAPI.methods,\n      saver: this.Editor.SaverAPI.methods,\n      selection: this.Editor.SelectionAPI.methods,\n      styles: this.Editor.StylesAPI.classes,\n      toolbar: this.Editor.ToolbarAPI.methods,\n      inlineToolbar: this.Editor.InlineToolbarAPI.methods,\n      tooltip: this.Editor.TooltipAPI.methods,\n      i18n: this.Editor.I18nAPI.methods,\n      readOnly: this.Editor.ReadOnlyAPI.methods,\n      ui: this.Editor.UiAPI.methods\n    };\n  }\n  /**\n   * Returns Editor.js Core API methods for passed tool\n   *\n   * @param tool - tool object\n   */\n  getMethodsForTool(e) {\n    return Object.assign(\n      this.methods,\n      {\n        i18n: this.Editor.I18nAPI.getMethodsForTool(e)\n      }\n    );\n  }\n}\nclass ro extends y {\n  /**\n   * Available methods\n   *\n   * @returns {InlineToolbar}\n   */\n  get methods() {\n    return {\n      close: () => this.close(),\n      open: () => this.open()\n    };\n  }\n  /**\n   * Open Inline Toolbar\n   */\n  open() {\n    this.Editor.InlineToolbar.tryToShow();\n  }\n  /**\n   * Close Inline Toolbar\n   */\n  close() {\n    this.Editor.InlineToolbar.close();\n  }\n}\nclass ao extends y {\n  /**\n   * Available methods\n   *\n   * @returns {Listeners}\n   */\n  get methods() {\n    return {\n      on: (e, t, o, i) => this.on(e, t, o, i),\n      off: (e, t, o, i) => this.off(e, t, o, i),\n      offById: (e) => this.offById(e)\n    };\n  }\n  /**\n   * Ads a DOM event listener. Return it's id.\n   *\n   * @param {HTMLElement} element - Element to set handler to\n   * @param {string} eventType - event type\n   * @param {() => void} handler - event handler\n   * @param {boolean} useCapture - capture event or not\n   */\n  on(e, t, o, i) {\n    return this.listeners.on(e, t, o, i);\n  }\n  /**\n   * Removes DOM listener from element\n   *\n   * @param {Element} element - Element to remove handler from\n   * @param eventType - event type\n   * @param handler - event handler\n   * @param {boolean} useCapture - capture event or not\n   */\n  off(e, t, o, i) {\n    this.listeners.off(e, t, o, i);\n  }\n  /**\n   * Removes DOM listener by the listener id\n   *\n   * @param id - id of the listener to remove\n   */\n  offById(e) {\n    this.listeners.offById(e);\n  }\n}\nvar _e = {}, lo = {\n  get exports() {\n    return _e;\n  },\n  set exports(s) {\n    _e = s;\n  }\n};\n(function(s, e) {\n  (function(t, o) {\n    s.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(n) {\n        if (o[n])\n          return o[n].exports;\n        var r = o[n] = { i: n, l: !1, exports: {} };\n        return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(n, r, a) {\n        i.o(n, r) || Object.defineProperty(n, r, { enumerable: !0, get: a });\n      }, i.r = function(n) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(n, \"__esModule\", { value: !0 });\n      }, i.t = function(n, r) {\n        if (1 & r && (n = i(n)), 8 & r || 4 & r && typeof n == \"object\" && n && n.__esModule)\n          return n;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: n }), 2 & r && typeof n != \"string\")\n          for (var l in n)\n            i.d(a, l, function(d) {\n              return n[d];\n            }.bind(null, l));\n        return a;\n      }, i.n = function(n) {\n        var r = n && n.__esModule ? function() {\n          return n.default;\n        } : function() {\n          return n;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(n, r) {\n        return Object.prototype.hasOwnProperty.call(n, r);\n      }, i.p = \"/\", i(i.s = 0);\n    }([function(t, o, i) {\n      i(1), /*!\n       * Codex JavaScript Notification module\n       * https://github.com/codex-team/js-notifier\n       */\n      t.exports = function() {\n        var n = i(6), r = \"cdx-notify--bounce-in\", a = null;\n        return { show: function(l) {\n          if (l.message) {\n            (function() {\n              if (a)\n                return !0;\n              a = n.getWrapper(), document.body.appendChild(a);\n            })();\n            var d = null, u = l.time || 8e3;\n            switch (l.type) {\n              case \"confirm\":\n                d = n.confirm(l);\n                break;\n              case \"prompt\":\n                d = n.prompt(l);\n                break;\n              default:\n                d = n.alert(l), window.setTimeout(function() {\n                  d.remove();\n                }, u);\n            }\n            a.appendChild(d), d.classList.add(r);\n          }\n        } };\n      }();\n    }, function(t, o, i) {\n      var n = i(2);\n      typeof n == \"string\" && (n = [[t.i, n, \"\"]]);\n      var r = { hmr: !0, transform: void 0, insertInto: void 0 };\n      i(4)(n, r), n.locals && (t.exports = n.locals);\n    }, function(t, o, i) {\n      (t.exports = i(3)(!1)).push([t.i, `.cdx-notify--error{background:#fffbfb!important}.cdx-notify--error::before{background:#fb5d5d!important}.cdx-notify__input{max-width:130px;padding:5px 10px;background:#f7f7f7;border:0;border-radius:3px;font-size:13px;color:#656b7c;outline:0}.cdx-notify__input:-ms-input-placeholder{color:#656b7c}.cdx-notify__input::placeholder{color:#656b7c}.cdx-notify__input:focus:-ms-input-placeholder{color:rgba(101,107,124,.3)}.cdx-notify__input:focus::placeholder{color:rgba(101,107,124,.3)}.cdx-notify__button{border:none;border-radius:3px;font-size:13px;padding:5px 10px;cursor:pointer}.cdx-notify__button:last-child{margin-left:10px}.cdx-notify__button--cancel{background:#f2f5f7;box-shadow:0 2px 1px 0 rgba(16,19,29,0);color:#656b7c}.cdx-notify__button--cancel:hover{background:#eee}.cdx-notify__button--confirm{background:#34c992;box-shadow:0 1px 1px 0 rgba(18,49,35,.05);color:#fff}.cdx-notify__button--confirm:hover{background:#33b082}.cdx-notify__btns-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;margin-top:5px}.cdx-notify__cross{position:absolute;top:5px;right:5px;width:10px;height:10px;padding:5px;opacity:.54;cursor:pointer}.cdx-notify__cross::after,.cdx-notify__cross::before{content:'';position:absolute;left:9px;top:5px;height:12px;width:2px;background:#575d67}.cdx-notify__cross::before{transform:rotate(-45deg)}.cdx-notify__cross::after{transform:rotate(45deg)}.cdx-notify__cross:hover{opacity:1}.cdx-notifies{position:fixed;z-index:2;bottom:20px;left:20px;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen,Ubuntu,Cantarell,\"Fira Sans\",\"Droid Sans\",\"Helvetica Neue\",sans-serif}.cdx-notify{position:relative;width:220px;margin-top:15px;padding:13px 16px;background:#fff;box-shadow:0 11px 17px 0 rgba(23,32,61,.13);border-radius:5px;font-size:14px;line-height:1.4em;word-wrap:break-word}.cdx-notify::before{content:'';position:absolute;display:block;top:0;left:0;width:3px;height:calc(100% - 6px);margin:3px;border-radius:5px;background:0 0}@keyframes bounceIn{0%{opacity:0;transform:scale(.3)}50%{opacity:1;transform:scale(1.05)}70%{transform:scale(.9)}100%{transform:scale(1)}}.cdx-notify--bounce-in{animation-name:bounceIn;animation-duration:.6s;animation-iteration-count:1}.cdx-notify--success{background:#fafffe!important}.cdx-notify--success::before{background:#41ffb1!important}`, \"\"]);\n    }, function(t, o) {\n      t.exports = function(i) {\n        var n = [];\n        return n.toString = function() {\n          return this.map(function(r) {\n            var a = function(l, d) {\n              var u = l[1] || \"\", h = l[3];\n              if (!h)\n                return u;\n              if (d && typeof btoa == \"function\") {\n                var f = (p = h, \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(p)))) + \" */\"), x = h.sources.map(function(m) {\n                  return \"/*# sourceURL=\" + h.sourceRoot + m + \" */\";\n                });\n                return [u].concat(x).concat([f]).join(`\n`);\n              }\n              var p;\n              return [u].join(`\n`);\n            }(r, i);\n            return r[2] ? \"@media \" + r[2] + \"{\" + a + \"}\" : a;\n          }).join(\"\");\n        }, n.i = function(r, a) {\n          typeof r == \"string\" && (r = [[null, r, \"\"]]);\n          for (var l = {}, d = 0; d < this.length; d++) {\n            var u = this[d][0];\n            typeof u == \"number\" && (l[u] = !0);\n          }\n          for (d = 0; d < r.length; d++) {\n            var h = r[d];\n            typeof h[0] == \"number\" && l[h[0]] || (a && !h[2] ? h[2] = a : a && (h[2] = \"(\" + h[2] + \") and (\" + a + \")\"), n.push(h));\n          }\n        }, n;\n      };\n    }, function(t, o, i) {\n      var n, r, a = {}, l = (n = function() {\n        return window && document && document.all && !window.atob;\n      }, function() {\n        return r === void 0 && (r = n.apply(this, arguments)), r;\n      }), d = function(k) {\n        var g = {};\n        return function(w) {\n          if (typeof w == \"function\")\n            return w();\n          if (g[w] === void 0) {\n            var E = function(I) {\n              return document.querySelector(I);\n            }.call(this, w);\n            if (window.HTMLIFrameElement && E instanceof window.HTMLIFrameElement)\n              try {\n                E = E.contentDocument.head;\n              } catch {\n                E = null;\n              }\n            g[w] = E;\n          }\n          return g[w];\n        };\n      }(), u = null, h = 0, f = [], x = i(5);\n      function p(k, g) {\n        for (var w = 0; w < k.length; w++) {\n          var E = k[w], I = a[E.id];\n          if (I) {\n            I.refs++;\n            for (var C = 0; C < I.parts.length; C++)\n              I.parts[C](E.parts[C]);\n            for (; C < E.parts.length; C++)\n              I.parts.push(H(E.parts[C], g));\n          } else {\n            var O = [];\n            for (C = 0; C < E.parts.length; C++)\n              O.push(H(E.parts[C], g));\n            a[E.id] = { id: E.id, refs: 1, parts: O };\n          }\n        }\n      }\n      function m(k, g) {\n        for (var w = [], E = {}, I = 0; I < k.length; I++) {\n          var C = k[I], O = g.base ? C[0] + g.base : C[0], B = { css: C[1], media: C[2], sourceMap: C[3] };\n          E[O] ? E[O].parts.push(B) : w.push(E[O] = { id: O, parts: [B] });\n        }\n        return w;\n      }\n      function L(k, g) {\n        var w = d(k.insertInto);\n        if (!w)\n          throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n        var E = f[f.length - 1];\n        if (k.insertAt === \"top\")\n          E ? E.nextSibling ? w.insertBefore(g, E.nextSibling) : w.appendChild(g) : w.insertBefore(g, w.firstChild), f.push(g);\n        else if (k.insertAt === \"bottom\")\n          w.appendChild(g);\n        else {\n          if (typeof k.insertAt != \"object\" || !k.insertAt.before)\n            throw new Error(`[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n`);\n          var I = d(k.insertInto + \" \" + k.insertAt.before);\n          w.insertBefore(g, I);\n        }\n      }\n      function A(k) {\n        if (k.parentNode === null)\n          return !1;\n        k.parentNode.removeChild(k);\n        var g = f.indexOf(k);\n        g >= 0 && f.splice(g, 1);\n      }\n      function S(k) {\n        var g = document.createElement(\"style\");\n        return k.attrs.type === void 0 && (k.attrs.type = \"text/css\"), Z(g, k.attrs), L(k, g), g;\n      }\n      function Z(k, g) {\n        Object.keys(g).forEach(function(w) {\n          k.setAttribute(w, g[w]);\n        });\n      }\n      function H(k, g) {\n        var w, E, I, C;\n        if (g.transform && k.css) {\n          if (!(C = g.transform(k.css)))\n            return function() {\n            };\n          k.css = C;\n        }\n        if (g.singleton) {\n          var O = h++;\n          w = u || (u = S(g)), E = ce.bind(null, w, O, !1), I = ce.bind(null, w, O, !0);\n        } else\n          k.sourceMap && typeof URL == \"function\" && typeof URL.createObjectURL == \"function\" && typeof URL.revokeObjectURL == \"function\" && typeof Blob == \"function\" && typeof btoa == \"function\" ? (w = function(B) {\n            var j = document.createElement(\"link\");\n            return B.attrs.type === void 0 && (B.attrs.type = \"text/css\"), B.attrs.rel = \"stylesheet\", Z(j, B.attrs), L(B, j), j;\n          }(g), E = function(B, j, de) {\n            var Q = de.css, Ce = de.sourceMap, Ot = j.convertToAbsoluteUrls === void 0 && Ce;\n            (j.convertToAbsoluteUrls || Ot) && (Q = x(Q)), Ce && (Q += `\n/*# sourceMappingURL=data:application/json;base64,` + btoa(unescape(encodeURIComponent(JSON.stringify(Ce)))) + \" */\");\n            var Nt = new Blob([Q], { type: \"text/css\" }), Ge = B.href;\n            B.href = URL.createObjectURL(Nt), Ge && URL.revokeObjectURL(Ge);\n          }.bind(null, w, g), I = function() {\n            A(w), w.href && URL.revokeObjectURL(w.href);\n          }) : (w = S(g), E = function(B, j) {\n            var de = j.css, Q = j.media;\n            if (Q && B.setAttribute(\"media\", Q), B.styleSheet)\n              B.styleSheet.cssText = de;\n            else {\n              for (; B.firstChild; )\n                B.removeChild(B.firstChild);\n              B.appendChild(document.createTextNode(de));\n            }\n          }.bind(null, w), I = function() {\n            A(w);\n          });\n        return E(k), function(B) {\n          if (B) {\n            if (B.css === k.css && B.media === k.media && B.sourceMap === k.sourceMap)\n              return;\n            E(k = B);\n          } else\n            I();\n        };\n      }\n      t.exports = function(k, g) {\n        if (typeof DEBUG < \"u\" && DEBUG && typeof document != \"object\")\n          throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n        (g = g || {}).attrs = typeof g.attrs == \"object\" ? g.attrs : {}, g.singleton || typeof g.singleton == \"boolean\" || (g.singleton = l()), g.insertInto || (g.insertInto = \"head\"), g.insertAt || (g.insertAt = \"bottom\");\n        var w = m(k, g);\n        return p(w, g), function(E) {\n          for (var I = [], C = 0; C < w.length; C++) {\n            var O = w[C];\n            (B = a[O.id]).refs--, I.push(B);\n          }\n          for (E && p(m(E, g), g), C = 0; C < I.length; C++) {\n            var B;\n            if ((B = I[C]).refs === 0) {\n              for (var j = 0; j < B.parts.length; j++)\n                B.parts[j]();\n              delete a[B.id];\n            }\n          }\n        };\n      };\n      var U, J = (U = [], function(k, g) {\n        return U[k] = g, U.filter(Boolean).join(`\n`);\n      });\n      function ce(k, g, w, E) {\n        var I = w ? \"\" : E.css;\n        if (k.styleSheet)\n          k.styleSheet.cssText = J(g, I);\n        else {\n          var C = document.createTextNode(I), O = k.childNodes;\n          O[g] && k.removeChild(O[g]), O.length ? k.insertBefore(C, O[g]) : k.appendChild(C);\n        }\n      }\n    }, function(t, o) {\n      t.exports = function(i) {\n        var n = typeof window < \"u\" && window.location;\n        if (!n)\n          throw new Error(\"fixUrls requires window.location\");\n        if (!i || typeof i != \"string\")\n          return i;\n        var r = n.protocol + \"//\" + n.host, a = r + n.pathname.replace(/\\/[^\\/]*$/, \"/\");\n        return i.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(l, d) {\n          var u, h = d.trim().replace(/^\"(.*)\"$/, function(f, x) {\n            return x;\n          }).replace(/^'(.*)'$/, function(f, x) {\n            return x;\n          });\n          return /^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(h) ? l : (u = h.indexOf(\"//\") === 0 ? h : h.indexOf(\"/\") === 0 ? r + h : a + h.replace(/^\\.\\//, \"\"), \"url(\" + JSON.stringify(u) + \")\");\n        });\n      };\n    }, function(t, o, i) {\n      var n, r, a, l, d, u, h, f, x;\n      t.exports = (n = \"cdx-notifies\", r = \"cdx-notify\", a = \"cdx-notify__cross\", l = \"cdx-notify__button--confirm\", d = \"cdx-notify__button--cancel\", u = \"cdx-notify__input\", h = \"cdx-notify__button\", f = \"cdx-notify__btns-wrapper\", { alert: x = function(p) {\n        var m = document.createElement(\"DIV\"), L = document.createElement(\"DIV\"), A = p.message, S = p.style;\n        return m.classList.add(r), S && m.classList.add(r + \"--\" + S), m.innerHTML = A, L.classList.add(a), L.addEventListener(\"click\", m.remove.bind(m)), m.appendChild(L), m;\n      }, confirm: function(p) {\n        var m = x(p), L = document.createElement(\"div\"), A = document.createElement(\"button\"), S = document.createElement(\"button\"), Z = m.querySelector(\".\" + a), H = p.cancelHandler, U = p.okHandler;\n        return L.classList.add(f), A.innerHTML = p.okText || \"Confirm\", S.innerHTML = p.cancelText || \"Cancel\", A.classList.add(h), S.classList.add(h), A.classList.add(l), S.classList.add(d), H && typeof H == \"function\" && (S.addEventListener(\"click\", H), Z.addEventListener(\"click\", H)), U && typeof U == \"function\" && A.addEventListener(\"click\", U), A.addEventListener(\"click\", m.remove.bind(m)), S.addEventListener(\"click\", m.remove.bind(m)), L.appendChild(A), L.appendChild(S), m.appendChild(L), m;\n      }, prompt: function(p) {\n        var m = x(p), L = document.createElement(\"div\"), A = document.createElement(\"button\"), S = document.createElement(\"input\"), Z = m.querySelector(\".\" + a), H = p.cancelHandler, U = p.okHandler;\n        return L.classList.add(f), A.innerHTML = p.okText || \"Ok\", A.classList.add(h), A.classList.add(l), S.classList.add(u), p.placeholder && S.setAttribute(\"placeholder\", p.placeholder), p.default && (S.value = p.default), p.inputType && (S.type = p.inputType), H && typeof H == \"function\" && Z.addEventListener(\"click\", H), U && typeof U == \"function\" && A.addEventListener(\"click\", function() {\n          U(S.value);\n        }), A.addEventListener(\"click\", m.remove.bind(m)), L.appendChild(S), L.appendChild(A), m.appendChild(L), m;\n      }, getWrapper: function() {\n        var p = document.createElement(\"DIV\");\n        return p.classList.add(n), p;\n      } });\n    }]);\n  });\n})(lo);\nconst co = /* @__PURE__ */ Pe(_e);\nclass ho {\n  /**\n   * Show web notification\n   *\n   * @param {NotifierOptions | ConfirmNotifierOptions | PromptNotifierOptions} options - notification options\n   */\n  show(e) {\n    co.show(e);\n  }\n}\nclass uo extends y {\n  /**\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.notifier = new ho();\n  }\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      show: (e) => this.show(e)\n    };\n  }\n  /**\n   * Show notification\n   *\n   * @param {NotifierOptions} options - message option\n   */\n  show(e) {\n    return this.notifier.show(e);\n  }\n}\nclass po extends y {\n  /**\n   * Available methods\n   */\n  get methods() {\n    const e = () => this.isEnabled;\n    return {\n      toggle: (t) => this.toggle(t),\n      get isEnabled() {\n        return e();\n      }\n    };\n  }\n  /**\n   * Set or toggle read-only state\n   *\n   * @param {boolean|undefined} state - set or toggle state\n   * @returns {boolean} current value\n   */\n  toggle(e) {\n    return this.Editor.ReadOnly.toggle(e);\n  }\n  /**\n   * Returns current read-only state\n   */\n  get isEnabled() {\n    return this.Editor.ReadOnly.isEnabled;\n  }\n}\nvar Oe = {}, fo = {\n  get exports() {\n    return Oe;\n  },\n  set exports(s) {\n    Oe = s;\n  }\n};\n(function(s, e) {\n  (function(t, o) {\n    s.exports = o();\n  })(Rt, function() {\n    function t(h) {\n      var f = h.tags, x = Object.keys(f), p = x.map(function(m) {\n        return typeof f[m];\n      }).every(function(m) {\n        return m === \"object\" || m === \"boolean\" || m === \"function\";\n      });\n      if (!p)\n        throw new Error(\"The configuration was invalid\");\n      this.config = h;\n    }\n    var o = [\"P\", \"LI\", \"TD\", \"TH\", \"DIV\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"PRE\"];\n    function i(h) {\n      return o.indexOf(h.nodeName) !== -1;\n    }\n    var n = [\"A\", \"B\", \"STRONG\", \"I\", \"EM\", \"SUB\", \"SUP\", \"U\", \"STRIKE\"];\n    function r(h) {\n      return n.indexOf(h.nodeName) !== -1;\n    }\n    t.prototype.clean = function(h) {\n      const f = document.implementation.createHTMLDocument(), x = f.createElement(\"div\");\n      return x.innerHTML = h, this._sanitize(f, x), x.innerHTML;\n    }, t.prototype._sanitize = function(h, f) {\n      var x = a(h, f), p = x.firstChild();\n      if (p)\n        do {\n          if (p.nodeType === Node.TEXT_NODE)\n            if (p.data.trim() === \"\" && (p.previousElementSibling && i(p.previousElementSibling) || p.nextElementSibling && i(p.nextElementSibling))) {\n              f.removeChild(p), this._sanitize(h, f);\n              break;\n            } else\n              continue;\n          if (p.nodeType === Node.COMMENT_NODE) {\n            f.removeChild(p), this._sanitize(h, f);\n            break;\n          }\n          var m = r(p), L;\n          m && (L = Array.prototype.some.call(p.childNodes, i));\n          var A = !!f.parentNode, S = i(f) && i(p) && A, Z = p.nodeName.toLowerCase(), H = l(this.config, Z, p), U = m && L;\n          if (U || d(p, H) || !this.config.keepNestedBlockElements && S) {\n            if (!(p.nodeName === \"SCRIPT\" || p.nodeName === \"STYLE\"))\n              for (; p.childNodes.length > 0; )\n                f.insertBefore(p.childNodes[0], p);\n            f.removeChild(p), this._sanitize(h, f);\n            break;\n          }\n          for (var J = 0; J < p.attributes.length; J += 1) {\n            var ce = p.attributes[J];\n            u(ce, H, p) && (p.removeAttribute(ce.name), J = J - 1);\n          }\n          this._sanitize(h, p);\n        } while (p = x.nextSibling());\n    };\n    function a(h, f) {\n      return h.createTreeWalker(\n        f,\n        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n        null,\n        !1\n      );\n    }\n    function l(h, f, x) {\n      return typeof h.tags[f] == \"function\" ? h.tags[f](x) : h.tags[f];\n    }\n    function d(h, f) {\n      return typeof f > \"u\" ? !0 : typeof f == \"boolean\" ? !f : !1;\n    }\n    function u(h, f, x) {\n      var p = h.name.toLowerCase();\n      return f === !0 ? !1 : typeof f[p] == \"function\" ? !f[p](h.value, x) : typeof f[p] > \"u\" || f[p] === !1 ? !0 : typeof f[p] == \"string\" ? f[p] !== h.value : !1;\n    }\n    return t;\n  });\n})(fo);\nconst go = Oe;\nfunction bt(s, e) {\n  return s.map((t) => {\n    const o = M(e) ? e(t.tool) : e;\n    return W(o) || (t.data = ze(t.data, o)), t;\n  });\n}\nfunction V(s, e = {}) {\n  const t = {\n    tags: e\n  };\n  return new go(t).clean(s);\n}\nfunction ze(s, e) {\n  return Array.isArray(s) ? bo(s, e) : D(s) ? mo(s, e) : G(s) ? ko(s, e) : s;\n}\nfunction bo(s, e) {\n  return s.map((t) => ze(t, e));\n}\nfunction mo(s, e) {\n  const t = {};\n  for (const o in s) {\n    if (!Object.prototype.hasOwnProperty.call(s, o))\n      continue;\n    const i = s[o], n = vo(e[o]) ? e[o] : e;\n    t[o] = ze(i, n);\n  }\n  return t;\n}\nfunction ko(s, e) {\n  return D(e) ? V(s, e) : e === !1 ? V(s, {}) : s;\n}\nfunction vo(s) {\n  return D(s) || Ht(s) || M(s);\n}\nclass xo extends y {\n  /**\n   * Available methods\n   *\n   * @returns {SanitizerConfig}\n   */\n  get methods() {\n    return {\n      clean: (e, t) => this.clean(e, t)\n    };\n  }\n  /**\n   * Perform sanitizing of a string\n   *\n   * @param {string} taintString - what to sanitize\n   * @param {SanitizerConfig} config - sanitizer config\n   * @returns {string}\n   */\n  clean(e, t) {\n    return V(e, t);\n  }\n}\nclass wo extends y {\n  /**\n   * Available methods\n   *\n   * @returns {Saver}\n   */\n  get methods() {\n    return {\n      save: () => this.save()\n    };\n  }\n  /**\n   * Return Editor's data\n   *\n   * @returns {OutputData}\n   */\n  save() {\n    const e = \"Editor's content can not be saved in read-only mode\";\n    return this.Editor.ReadOnly.isEnabled ? (Y(e, \"warn\"), Promise.reject(new Error(e))) : this.Editor.Saver.save();\n  }\n}\nclass yo extends y {\n  /**\n   * Available methods\n   *\n   * @returns {SelectionAPIInterface}\n   */\n  get methods() {\n    return {\n      findParentTag: (e, t) => this.findParentTag(e, t),\n      expandToTag: (e) => this.expandToTag(e)\n    };\n  }\n  /**\n   * Looks ahead from selection and find passed tag with class name\n   *\n   * @param {string} tagName - tag to find\n   * @param {string} className - tag's class name\n   * @returns {HTMLElement|null}\n   */\n  findParentTag(e, t) {\n    return new b().findParentTag(e, t);\n  }\n  /**\n   * Expand selection to passed tag\n   *\n   * @param {HTMLElement} node - tag that should contain selection\n   */\n  expandToTag(e) {\n    new b().expandToTag(e);\n  }\n}\nclass Eo extends y {\n  /**\n   * Exported classes\n   */\n  get classes() {\n    return {\n      /**\n       * Base Block styles\n       */\n      block: \"cdx-block\",\n      /**\n       * Inline Tools styles\n       */\n      inlineToolButton: \"ce-inline-tool\",\n      inlineToolButtonActive: \"ce-inline-tool--active\",\n      /**\n       * UI elements\n       */\n      input: \"cdx-input\",\n      loader: \"cdx-loader\",\n      button: \"cdx-button\",\n      /**\n       * Settings styles\n       */\n      settingsButton: \"cdx-settings-button\",\n      settingsButtonActive: \"cdx-settings-button--active\"\n    };\n  }\n}\nclass Bo extends y {\n  /**\n   * Available methods\n   *\n   * @returns {Toolbar}\n   */\n  get methods() {\n    return {\n      close: () => this.close(),\n      open: () => this.open(),\n      toggleBlockSettings: (e) => this.toggleBlockSettings(e),\n      toggleToolbox: (e) => this.toggleToolbox(e)\n    };\n  }\n  /**\n   * Open toolbar\n   */\n  open() {\n    this.Editor.Toolbar.moveAndOpen();\n  }\n  /**\n   * Close toolbar and all included elements\n   */\n  close() {\n    this.Editor.Toolbar.close();\n  }\n  /**\n   * Toggles Block Setting of the current block\n   *\n   * @param {boolean} openingState —  opening state of Block Setting\n   */\n  toggleBlockSettings(e) {\n    if (this.Editor.BlockManager.currentBlockIndex === -1) {\n      Y(\"Could't toggle the Toolbar because there is no block selected \", \"warn\");\n      return;\n    }\n    e ?? !this.Editor.BlockSettings.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.open()) : this.Editor.BlockSettings.close();\n  }\n  /**\n   * Open toolbox\n   *\n   * @param {boolean} openingState - Opening state of toolbox\n   */\n  toggleToolbox(e) {\n    if (this.Editor.BlockManager.currentBlockIndex === -1) {\n      Y(\"Could't toggle the Toolbox because there is no block selected \", \"warn\");\n      return;\n    }\n    e ?? !this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open()) : this.Editor.Toolbar.toolbox.close();\n  }\n}\nvar Ne = {}, Co = {\n  get exports() {\n    return Ne;\n  },\n  set exports(s) {\n    Ne = s;\n  }\n};\n/*!\n * CodeX.Tooltips\n * \n * @version 1.0.5\n * \n * @licence MIT\n * @author CodeX <https://codex.so>\n * \n * \n */\n(function(s, e) {\n  (function(t, o) {\n    s.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(n) {\n        if (o[n])\n          return o[n].exports;\n        var r = o[n] = { i: n, l: !1, exports: {} };\n        return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(n, r, a) {\n        i.o(n, r) || Object.defineProperty(n, r, { enumerable: !0, get: a });\n      }, i.r = function(n) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(n, \"__esModule\", { value: !0 });\n      }, i.t = function(n, r) {\n        if (1 & r && (n = i(n)), 8 & r || 4 & r && typeof n == \"object\" && n && n.__esModule)\n          return n;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: n }), 2 & r && typeof n != \"string\")\n          for (var l in n)\n            i.d(a, l, function(d) {\n              return n[d];\n            }.bind(null, l));\n        return a;\n      }, i.n = function(n) {\n        var r = n && n.__esModule ? function() {\n          return n.default;\n        } : function() {\n          return n;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(n, r) {\n        return Object.prototype.hasOwnProperty.call(n, r);\n      }, i.p = \"\", i(i.s = 0);\n    }([function(t, o, i) {\n      t.exports = i(1);\n    }, function(t, o, i) {\n      i.r(o), i.d(o, \"default\", function() {\n        return n;\n      });\n      class n {\n        constructor() {\n          this.nodes = { wrapper: null, content: null }, this.showed = !1, this.offsetTop = 10, this.offsetLeft = 10, this.offsetRight = 10, this.hidingDelay = 0, this.handleWindowScroll = () => {\n            this.showed && this.hide(!0);\n          }, this.loadStyles(), this.prepare(), window.addEventListener(\"scroll\", this.handleWindowScroll, { passive: !0 });\n        }\n        get CSS() {\n          return { tooltip: \"ct\", tooltipContent: \"ct__content\", tooltipShown: \"ct--shown\", placement: { left: \"ct--left\", bottom: \"ct--bottom\", right: \"ct--right\", top: \"ct--top\" } };\n        }\n        show(a, l, d) {\n          this.nodes.wrapper || this.prepare(), this.hidingTimeout && clearTimeout(this.hidingTimeout);\n          const u = Object.assign({ placement: \"bottom\", marginTop: 0, marginLeft: 0, marginRight: 0, marginBottom: 0, delay: 70, hidingDelay: 0 }, d);\n          if (u.hidingDelay && (this.hidingDelay = u.hidingDelay), this.nodes.content.innerHTML = \"\", typeof l == \"string\")\n            this.nodes.content.appendChild(document.createTextNode(l));\n          else {\n            if (!(l instanceof Node))\n              throw Error(\"[CodeX Tooltip] Wrong type of «content» passed. It should be an instance of Node or String. But \" + typeof l + \" given.\");\n            this.nodes.content.appendChild(l);\n          }\n          switch (this.nodes.wrapper.classList.remove(...Object.values(this.CSS.placement)), u.placement) {\n            case \"top\":\n              this.placeTop(a, u);\n              break;\n            case \"left\":\n              this.placeLeft(a, u);\n              break;\n            case \"right\":\n              this.placeRight(a, u);\n              break;\n            case \"bottom\":\n            default:\n              this.placeBottom(a, u);\n          }\n          u && u.delay ? this.showingTimeout = setTimeout(() => {\n            this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0;\n          }, u.delay) : (this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0);\n        }\n        hide(a = !1) {\n          if (this.hidingDelay && !a)\n            return this.hidingTimeout && clearTimeout(this.hidingTimeout), void (this.hidingTimeout = setTimeout(() => {\n              this.hide(!0);\n            }, this.hidingDelay));\n          this.nodes.wrapper.classList.remove(this.CSS.tooltipShown), this.showed = !1, this.showingTimeout && clearTimeout(this.showingTimeout);\n        }\n        onHover(a, l, d) {\n          a.addEventListener(\"mouseenter\", () => {\n            this.show(a, l, d);\n          }), a.addEventListener(\"mouseleave\", () => {\n            this.hide();\n          });\n        }\n        destroy() {\n          this.nodes.wrapper.remove(), window.removeEventListener(\"scroll\", this.handleWindowScroll);\n        }\n        prepare() {\n          this.nodes.wrapper = this.make(\"div\", this.CSS.tooltip), this.nodes.content = this.make(\"div\", this.CSS.tooltipContent), this.append(this.nodes.wrapper, this.nodes.content), this.append(document.body, this.nodes.wrapper);\n        }\n        loadStyles() {\n          const a = \"codex-tooltips-style\";\n          if (document.getElementById(a))\n            return;\n          const l = i(2), d = this.make(\"style\", null, { textContent: l.toString(), id: a });\n          this.prepend(document.head, d);\n        }\n        placeBottom(a, l) {\n          const d = a.getBoundingClientRect(), u = d.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = d.bottom + window.pageYOffset + this.offsetTop + l.marginTop;\n          this.applyPlacement(\"bottom\", u, h);\n        }\n        placeTop(a, l) {\n          const d = a.getBoundingClientRect(), u = d.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = d.top + window.pageYOffset - this.nodes.wrapper.clientHeight - this.offsetTop;\n          this.applyPlacement(\"top\", u, h);\n        }\n        placeLeft(a, l) {\n          const d = a.getBoundingClientRect(), u = d.left - this.nodes.wrapper.offsetWidth - this.offsetLeft - l.marginLeft, h = d.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;\n          this.applyPlacement(\"left\", u, h);\n        }\n        placeRight(a, l) {\n          const d = a.getBoundingClientRect(), u = d.right + this.offsetRight + l.marginRight, h = d.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;\n          this.applyPlacement(\"right\", u, h);\n        }\n        applyPlacement(a, l, d) {\n          this.nodes.wrapper.classList.add(this.CSS.placement[a]), this.nodes.wrapper.style.left = l + \"px\", this.nodes.wrapper.style.top = d + \"px\";\n        }\n        make(a, l = null, d = {}) {\n          const u = document.createElement(a);\n          Array.isArray(l) ? u.classList.add(...l) : l && u.classList.add(l);\n          for (const h in d)\n            d.hasOwnProperty(h) && (u[h] = d[h]);\n          return u;\n        }\n        append(a, l) {\n          Array.isArray(l) ? l.forEach((d) => a.appendChild(d)) : a.appendChild(l);\n        }\n        prepend(a, l) {\n          Array.isArray(l) ? (l = l.reverse()).forEach((d) => a.prepend(d)) : a.prepend(l);\n        }\n      }\n    }, function(t, o) {\n      t.exports = `.ct{z-index:999;opacity:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1),-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);will-change:opacity,top,left;-webkit-box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);border-radius:9px}.ct,.ct:before{position:absolute;top:0;left:0}.ct:before{content:\"\";bottom:0;right:0;background-color:#1d202b;z-index:-1;border-radius:4px}@supports(-webkit-mask-box-image:url(\"\")){.ct:before{border-radius:0;-webkit-mask-box-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\"><path d=\"M10.71 0h2.58c3.02 0 4.64.42 6.1 1.2a8.18 8.18 0 013.4 3.4C23.6 6.07 24 7.7 24 10.71v2.58c0 3.02-.42 4.64-1.2 6.1a8.18 8.18 0 01-3.4 3.4c-1.47.8-3.1 1.21-6.11 1.21H10.7c-3.02 0-4.64-.42-6.1-1.2a8.18 8.18 0 01-3.4-3.4C.4 17.93 0 16.3 0 13.29V10.7c0-3.02.42-4.64 1.2-6.1a8.18 8.18 0 013.4-3.4C6.07.4 7.7 0 10.71 0z\"/></svg>') 48% 41% 37.9% 53.3%}}@media (--mobile){.ct{display:none}}.ct__content{padding:6px 10px;color:#cdd1e0;font-size:12px;text-align:center;letter-spacing:.02em;line-height:1em}.ct:after{content:\"\";width:8px;height:8px;position:absolute;background-color:#1d202b;z-index:-1}.ct--bottom{-webkit-transform:translateY(5px);transform:translateY(5px)}.ct--bottom:after{top:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--top{-webkit-transform:translateY(-5px);transform:translateY(-5px)}.ct--top:after{top:auto;bottom:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--left{-webkit-transform:translateX(-5px);transform:translateX(-5px)}.ct--left:after{top:50%;left:auto;right:0;-webkit-transform:translate(41.6%,-50%) rotate(-45deg);transform:translate(41.6%,-50%) rotate(-45deg)}.ct--right{-webkit-transform:translateX(5px);transform:translateX(5px)}.ct--right:after{top:50%;left:0;-webkit-transform:translate(-41.6%,-50%) rotate(-45deg);transform:translate(-41.6%,-50%) rotate(-45deg)}.ct--shown{opacity:1;-webkit-transform:none;transform:none}`;\n    }]).default;\n  });\n})(Co);\nconst To = /* @__PURE__ */ Pe(Ne);\nlet F = null;\nfunction Ue() {\n  F || (F = new To());\n}\nfunction So(s, e, t) {\n  Ue(), F == null || F.show(s, e, t);\n}\nfunction Re(s = !1) {\n  Ue(), F == null || F.hide(s);\n}\nfunction ge(s, e, t) {\n  Ue(), F == null || F.onHover(s, e, t);\n}\nfunction Io() {\n  F == null || F.destroy(), F = null;\n}\nclass Mo extends y {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    });\n  }\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      show: (e, t, o) => this.show(e, t, o),\n      hide: () => this.hide(),\n      onHover: (e, t, o) => this.onHover(e, t, o)\n    };\n  }\n  /**\n   * Method show tooltip on element with passed HTML content\n   *\n   * @param {HTMLElement} element - element on which tooltip should be shown\n   * @param {TooltipContent} content - tooltip content\n   * @param {TooltipOptions} options - tooltip options\n   */\n  show(e, t, o) {\n    So(e, t, o);\n  }\n  /**\n   * Method hides tooltip on HTML page\n   */\n  hide() {\n    Re();\n  }\n  /**\n   * Decorator for showing Tooltip by mouseenter/mouseleave\n   *\n   * @param {HTMLElement} element - element on which tooltip should be shown\n   * @param {TooltipContent} content - tooltip content\n   * @param {TooltipOptions} options - tooltip options\n   */\n  onHover(e, t, o) {\n    ge(e, t, o);\n  }\n}\nclass Lo extends y {\n  /**\n   * Available methods / getters\n   */\n  get methods() {\n    return {\n      nodes: this.editorNodes\n      /**\n       * There can be added some UI methods, like toggleThinMode() etc\n       */\n    };\n  }\n  /**\n   * Exported classes\n   */\n  get editorNodes() {\n    return {\n      /**\n       * Top-level editor instance wrapper\n       */\n      wrapper: this.Editor.UI.nodes.wrapper,\n      /**\n       * Element that holds all the Blocks\n       */\n      redactor: this.Editor.UI.nodes.redactor\n    };\n  }\n}\nfunction mt(s, e) {\n  const t = {};\n  return Object.entries(s).forEach(([o, i]) => {\n    if (D(i)) {\n      const n = e ? `${e}.${o}` : o;\n      Object.values(i).every((a) => G(a)) ? t[o] = n : t[o] = mt(i, n);\n      return;\n    }\n    t[o] = i;\n  }), t;\n}\nconst K = mt(ht);\nfunction Ao(s, e) {\n  const t = {};\n  return Object.keys(s).forEach((o) => {\n    const i = e[o];\n    i !== void 0 ? t[i] = s[o] : t[o] = s[o];\n  }), t;\n}\nconst _o = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9 12L9 7.1C9 7.04477 9.04477 7 9.1 7H10.4C11.5 7 14 7.1 14 9.5C14 9.5 14 12 11 12M9 12V16.8C9 16.9105 9.08954 17 9.2 17H12.5C14 17 15 16 15 14.5C15 11.7046 11 12 11 12M9 12H11\"/></svg>', kt = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 10L11.8586 14.8586C11.9367 14.9367 12.0633 14.9367 12.1414 14.8586L17 10\"/></svg>', Oo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 15L11.8586 10.1414C11.9367 10.0633 12.0633 10.0633 12.1414 10.1414L17 15\"/></svg>', No = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16\"/></svg>', Ro = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"12\" r=\"4\" stroke=\"currentColor\" stroke-width=\"2\"/></svg>', Do = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M13.34 10C12.4223 12.7337 11 17 11 17\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M14.21 7H14.2\"/></svg>', it = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.5691 6.39509 13.9269 6.25143 12.8271 7.17675L11.3901 8.38588C10.0935 9.47674 9.95706 11.4241 11.0888 12.6852L11.12 12.72\"/></svg>', Po = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.40999 7.29999H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 7.29999H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.30999 12H9.3\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 12H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.40999 16.7H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 16.7H14.59\"/></svg>', Fo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 7V12M12 17V12M17 12H12M12 12H7\"/></svg>', Ho = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><circle cx=\"10.5\" cy=\"10.5\" r=\"5.5\" stroke=\"currentColor\" stroke-width=\"2\"/><line x1=\"15.4142\" x2=\"19\" y1=\"15\" y2=\"18.5858\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>', zo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M15.7795 11.5C15.7795 11.5 16.053 11.1962 16.5497 10.6722C17.4442 9.72856 17.4701 8.2475 16.5781 7.30145V7.30145C15.6482 6.31522 14.0873 6.29227 13.1288 7.25073L11.8796 8.49999\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8.24517 12.3883C8.24517 12.3883 7.97171 12.6922 7.47504 13.2161C6.58051 14.1598 6.55467 15.6408 7.44666 16.5869V16.5869C8.37653 17.5731 9.93744 17.5961 10.8959 16.6376L12.1452 15.3883\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M17.7802 15.1032L16.597 14.9422C16.0109 14.8624 15.4841 15.3059 15.4627 15.8969L15.4199 17.0818\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6.39064 9.03238L7.58432 9.06668C8.17551 9.08366 8.6522 8.58665 8.61056 7.99669L8.5271 6.81397\"/><line x1=\"12.1142\" x2=\"11.7\" y1=\"12.2\" y2=\"11.7858\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>', Uo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/><line x1=\"12\" x2=\"12\" y1=\"9\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 15.02V15.01\"/></svg>';\nclass _ {\n  /**\n   * Constructs popover item instance\n   *\n   * @param params - popover item construction params\n   */\n  constructor(e) {\n    this.nodes = {\n      root: null,\n      icon: null\n    }, this.confirmationState = null, this.removeSpecialFocusBehavior = () => {\n      this.nodes.root.classList.remove(_.CSS.noFocus);\n    }, this.removeSpecialHoverBehavior = () => {\n      this.nodes.root.classList.remove(_.CSS.noHover);\n    }, this.onErrorAnimationEnd = () => {\n      this.nodes.icon.classList.remove(_.CSS.wobbleAnimation), this.nodes.icon.removeEventListener(\"animationend\", this.onErrorAnimationEnd);\n    }, this.params = e, this.nodes.root = this.make(e);\n  }\n  /**\n   * True if item is disabled and hence not clickable\n   */\n  get isDisabled() {\n    return this.params.isDisabled;\n  }\n  /**\n   * Exposes popover item toggle parameter\n   */\n  get toggle() {\n    return this.params.toggle;\n  }\n  /**\n   * Item title\n   */\n  get title() {\n    return this.params.title;\n  }\n  /**\n   * True if popover should close once item is activated\n   */\n  get closeOnActivate() {\n    return this.params.closeOnActivate;\n  }\n  /**\n   * True if confirmation state is enabled for popover item\n   */\n  get isConfirmationStateEnabled() {\n    return this.confirmationState !== null;\n  }\n  /**\n   * True if item is focused in keyboard navigation process\n   */\n  get isFocused() {\n    return this.nodes.root.classList.contains(_.CSS.focused);\n  }\n  /**\n   * Popover item CSS classes\n   */\n  static get CSS() {\n    return {\n      container: \"ce-popover-item\",\n      title: \"ce-popover-item__title\",\n      secondaryTitle: \"ce-popover-item__secondary-title\",\n      icon: \"ce-popover-item__icon\",\n      active: \"ce-popover-item--active\",\n      disabled: \"ce-popover-item--disabled\",\n      focused: \"ce-popover-item--focused\",\n      hidden: \"ce-popover-item--hidden\",\n      confirmationState: \"ce-popover-item--confirmation\",\n      noHover: \"ce-popover-item--no-hover\",\n      noFocus: \"ce-popover-item--no-focus\",\n      wobbleAnimation: \"wobble\"\n    };\n  }\n  /**\n   * Returns popover item root element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Called on popover item click\n   */\n  handleClick() {\n    if (this.isConfirmationStateEnabled) {\n      this.activateOrEnableConfirmationMode(this.confirmationState);\n      return;\n    }\n    this.activateOrEnableConfirmationMode(this.params);\n  }\n  /**\n   * Toggles item active state\n   *\n   * @param isActive - true if item should strictly should become active\n   */\n  toggleActive(e) {\n    this.nodes.root.classList.toggle(_.CSS.active, e);\n  }\n  /**\n   * Toggles item hidden state\n   *\n   * @param isHidden - true if item should be hidden\n   */\n  toggleHidden(e) {\n    this.nodes.root.classList.toggle(_.CSS.hidden, e);\n  }\n  /**\n   * Resets popover item to its original state\n   */\n  reset() {\n    this.isConfirmationStateEnabled && this.disableConfirmationMode();\n  }\n  /**\n   * Method called once item becomes focused during keyboard navigation\n   */\n  onFocus() {\n    this.disableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Constructs HTML element corresponding to popover item params\n   *\n   * @param params - item construction params\n   */\n  make(e) {\n    const t = c.make(\"div\", _.CSS.container);\n    return e.name && (t.dataset.itemName = e.name), this.nodes.icon = c.make(\"div\", _.CSS.icon, {\n      innerHTML: e.icon || Ro\n    }), t.appendChild(this.nodes.icon), t.appendChild(c.make(\"div\", _.CSS.title, {\n      innerHTML: e.title || \"\"\n    })), e.secondaryLabel && t.appendChild(c.make(\"div\", _.CSS.secondaryTitle, {\n      textContent: e.secondaryLabel\n    })), e.isActive && t.classList.add(_.CSS.active), e.isDisabled && t.classList.add(_.CSS.disabled), t;\n  }\n  /**\n   * Activates confirmation mode for the item.\n   *\n   * @param newState - new popover item params that should be applied\n   */\n  enableConfirmationMode(e) {\n    const t = {\n      ...this.params,\n      ...e,\n      confirmation: e.confirmation\n    }, o = this.make(t);\n    this.nodes.root.innerHTML = o.innerHTML, this.nodes.root.classList.add(_.CSS.confirmationState), this.confirmationState = e, this.enableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Returns item to its original state\n   */\n  disableConfirmationMode() {\n    const e = this.make(this.params);\n    this.nodes.root.innerHTML = e.innerHTML, this.nodes.root.classList.remove(_.CSS.confirmationState), this.confirmationState = null, this.disableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Enables special focus and hover behavior for item in confirmation state.\n   * This is needed to prevent item from being highlighted as hovered/focused just after click.\n   */\n  enableSpecialHoverAndFocusBehavior() {\n    this.nodes.root.classList.add(_.CSS.noHover), this.nodes.root.classList.add(_.CSS.noFocus), this.nodes.root.addEventListener(\"mouseleave\", this.removeSpecialHoverBehavior, { once: !0 });\n  }\n  /**\n   * Disables special focus and hover behavior\n   */\n  disableSpecialHoverAndFocusBehavior() {\n    this.removeSpecialFocusBehavior(), this.removeSpecialHoverBehavior(), this.nodes.root.removeEventListener(\"mouseleave\", this.removeSpecialHoverBehavior);\n  }\n  /**\n   * Executes item's onActivate callback if the item has no confirmation configured\n   *\n   * @param item - item to activate or bring to confirmation mode\n   */\n  activateOrEnableConfirmationMode(e) {\n    if (e.confirmation === void 0)\n      try {\n        e.onActivate(e), this.disableConfirmationMode();\n      } catch {\n        this.animateError();\n      }\n    else\n      this.enableConfirmationMode(e.confirmation);\n  }\n  /**\n   * Animates item which symbolizes that error occured while executing 'onActivate()' callback\n   */\n  animateError() {\n    this.nodes.icon.classList.contains(_.CSS.wobbleAnimation) || (this.nodes.icon.classList.add(_.CSS.wobbleAnimation), this.nodes.icon.addEventListener(\"animationend\", this.onErrorAnimationEnd));\n  }\n}\nconst he = class {\n  /**\n   * @param {HTMLElement[]} nodeList — the list of iterable HTML-items\n   * @param {string} focusedCssClass - user-provided CSS-class that will be set in flipping process\n   */\n  constructor(s, e) {\n    this.cursor = -1, this.items = [], this.items = s || [], this.focusedCssClass = e;\n  }\n  /**\n   * Returns Focused button Node\n   *\n   * @returns {HTMLElement}\n   */\n  get currentItem() {\n    return this.cursor === -1 ? null : this.items[this.cursor];\n  }\n  /**\n   * Sets cursor to specified position\n   *\n   * @param cursorPosition - new cursor position\n   */\n  setCursor(s) {\n    s < this.items.length && s >= -1 && (this.dropCursor(), this.cursor = s, this.items[this.cursor].classList.add(this.focusedCssClass));\n  }\n  /**\n   * Sets items. Can be used when iterable items changed dynamically\n   *\n   * @param {HTMLElement[]} nodeList - nodes to iterate\n   */\n  setItems(s) {\n    this.items = s;\n  }\n  /**\n   * Sets cursor next to the current\n   */\n  next() {\n    this.cursor = this.leafNodesAndReturnIndex(he.directions.RIGHT);\n  }\n  /**\n   * Sets cursor before current\n   */\n  previous() {\n    this.cursor = this.leafNodesAndReturnIndex(he.directions.LEFT);\n  }\n  /**\n   * Sets cursor to the default position and removes CSS-class from previously focused item\n   */\n  dropCursor() {\n    this.cursor !== -1 && (this.items[this.cursor].classList.remove(this.focusedCssClass), this.cursor = -1);\n  }\n  /**\n   * Leafs nodes inside the target list from active element\n   *\n   * @param {string} direction - leaf direction. Can be 'left' or 'right'\n   * @returns {number} index of focused node\n   */\n  leafNodesAndReturnIndex(s) {\n    if (this.items.length === 0)\n      return this.cursor;\n    let e = this.cursor;\n    return e === -1 ? e = s === he.directions.RIGHT ? -1 : 0 : this.items[e].classList.remove(this.focusedCssClass), s === he.directions.RIGHT ? e = (e + 1) % this.items.length : e = (this.items.length + e - 1) % this.items.length, c.canSetCaret(this.items[e]) && xe(() => b.setCursor(this.items[e]), 50)(), this.items[e].classList.add(this.focusedCssClass), e;\n  }\n};\nlet ne = he;\nne.directions = {\n  RIGHT: \"right\",\n  LEFT: \"left\"\n};\nclass q {\n  /**\n   * @param {FlipperOptions} options - different constructing settings\n   */\n  constructor(e) {\n    this.iterator = null, this.activated = !1, this.flipCallbacks = [], this.onKeyDown = (t) => {\n      if (this.isEventReadyForHandling(t))\n        switch (q.usedKeys.includes(t.keyCode) && t.preventDefault(), t.keyCode) {\n          case v.TAB:\n            this.handleTabPress(t);\n            break;\n          case v.LEFT:\n          case v.UP:\n            this.flipLeft();\n            break;\n          case v.RIGHT:\n          case v.DOWN:\n            this.flipRight();\n            break;\n          case v.ENTER:\n            this.handleEnterPress(t);\n            break;\n        }\n    }, this.iterator = new ne(e.items, e.focusedItemClass), this.activateCallback = e.activateCallback, this.allowedKeys = e.allowedKeys || q.usedKeys;\n  }\n  /**\n   * True if flipper is currently activated\n   */\n  get isActivated() {\n    return this.activated;\n  }\n  /**\n   * Array of keys (codes) that is handled by Flipper\n   * Used to:\n   *  - preventDefault only for this keys, not all keydowns (@see constructor)\n   *  - to skip external behaviours only for these keys, when filler is activated (@see BlockEvents@arrowRightAndDown)\n   */\n  static get usedKeys() {\n    return [\n      v.TAB,\n      v.LEFT,\n      v.RIGHT,\n      v.ENTER,\n      v.UP,\n      v.DOWN\n    ];\n  }\n  /**\n   * Active tab/arrows handling by flipper\n   *\n   * @param items - Some modules (like, InlineToolbar, BlockSettings) might refresh buttons dynamically\n   * @param cursorPosition - index of the item that should be focused once flipper is activated\n   */\n  activate(e, t) {\n    this.activated = !0, e && this.iterator.setItems(e), t !== void 0 && this.iterator.setCursor(t), document.addEventListener(\"keydown\", this.onKeyDown, !0);\n  }\n  /**\n   * Disable tab/arrows handling by flipper\n   */\n  deactivate() {\n    this.activated = !1, this.dropCursor(), document.removeEventListener(\"keydown\", this.onKeyDown);\n  }\n  /**\n   * Focus first item\n   */\n  focusFirst() {\n    this.dropCursor(), this.flipRight();\n  }\n  /**\n   * Focuses previous flipper iterator item\n   */\n  flipLeft() {\n    this.iterator.previous(), this.flipCallback();\n  }\n  /**\n   * Focuses next flipper iterator item\n   */\n  flipRight() {\n    this.iterator.next(), this.flipCallback();\n  }\n  /**\n   * Return true if some button is focused\n   */\n  hasFocus() {\n    return !!this.iterator.currentItem;\n  }\n  /**\n   * Registeres function that should be executed on each navigation action\n   *\n   * @param cb - function to execute\n   */\n  onFlip(e) {\n    this.flipCallbacks.push(e);\n  }\n  /**\n   * Unregisteres function that is executed on each navigation action\n   *\n   * @param cb - function to stop executing\n   */\n  removeOnFlip(e) {\n    this.flipCallbacks = this.flipCallbacks.filter((t) => t !== e);\n  }\n  /**\n   * Drops flipper's iterator cursor\n   *\n   * @see DomIterator#dropCursor\n   */\n  dropCursor() {\n    this.iterator.dropCursor();\n  }\n  /**\n   * This function is fired before handling flipper keycodes\n   * The result of this function defines if it is need to be handled or not\n   *\n   * @param {KeyboardEvent} event - keydown keyboard event\n   * @returns {boolean}\n   */\n  isEventReadyForHandling(e) {\n    return this.activated && this.allowedKeys.includes(e.keyCode);\n  }\n  /**\n   * When flipper is activated tab press will leaf the items\n   *\n   * @param {KeyboardEvent} event - tab keydown event\n   */\n  handleTabPress(e) {\n    switch (e.shiftKey ? ne.directions.LEFT : ne.directions.RIGHT) {\n      case ne.directions.RIGHT:\n        this.flipRight();\n        break;\n      case ne.directions.LEFT:\n        this.flipLeft();\n        break;\n    }\n  }\n  /**\n   * Enter press will click current item if flipper is activated\n   *\n   * @param {KeyboardEvent} event - enter keydown event\n   */\n  handleEnterPress(e) {\n    this.activated && (this.iterator.currentItem && (e.stopPropagation(), e.preventDefault(), this.iterator.currentItem.click()), M(this.activateCallback) && this.activateCallback(this.iterator.currentItem));\n  }\n  /**\n   * Fired after flipping in any direction\n   */\n  flipCallback() {\n    this.iterator.currentItem && this.iterator.currentItem.scrollIntoViewIfNeeded(), this.flipCallbacks.forEach((e) => e());\n  }\n}\nclass pe {\n  /**\n   * Styles\n   */\n  static get CSS() {\n    return {\n      wrapper: \"cdx-search-field\",\n      icon: \"cdx-search-field__icon\",\n      input: \"cdx-search-field__input\"\n    };\n  }\n  /**\n   * @param options - available config\n   * @param options.items - searchable items list\n   * @param options.onSearch - search callback\n   * @param options.placeholder - input placeholder\n   */\n  constructor({ items: e, onSearch: t, placeholder: o }) {\n    this.listeners = new Fe(), this.items = e, this.onSearch = t, this.render(o);\n  }\n  /**\n   * Returns search field element\n   */\n  getElement() {\n    return this.wrapper;\n  }\n  /**\n   * Sets focus to the input\n   */\n  focus() {\n    this.input.focus();\n  }\n  /**\n   * Clears search query and results\n   */\n  clear() {\n    this.input.value = \"\", this.searchQuery = \"\", this.onSearch(\"\", this.foundItems);\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    this.listeners.removeAll();\n  }\n  /**\n   * Creates the search field\n   *\n   * @param placeholder - input placeholder\n   */\n  render(e) {\n    this.wrapper = c.make(\"div\", pe.CSS.wrapper);\n    const t = c.make(\"div\", pe.CSS.icon, {\n      innerHTML: Ho\n    });\n    this.input = c.make(\"input\", pe.CSS.input, {\n      placeholder: e,\n      /**\n       * Used to prevent focusing on the input by Tab key\n       * (Popover in the Toolbar lays below the blocks,\n       * so Tab in the last block will focus this hidden input if this property is not set)\n       */\n      tabIndex: -1\n    }), this.wrapper.appendChild(t), this.wrapper.appendChild(this.input), this.listeners.on(this.input, \"input\", () => {\n      this.searchQuery = this.input.value, this.onSearch(this.searchQuery, this.foundItems);\n    });\n  }\n  /**\n   * Returns list of found items for the current search query\n   */\n  get foundItems() {\n    return this.items.filter((e) => this.checkItem(e));\n  }\n  /**\n   * Contains logic for checking whether passed item conforms the search query\n   *\n   * @param item - item to be checked\n   */\n  checkItem(e) {\n    var i;\n    const t = ((i = e.title) == null ? void 0 : i.toLowerCase()) || \"\", o = this.searchQuery.toLowerCase();\n    return t.includes(o);\n  }\n}\nconst ue = class {\n  /**\n   * Locks body element scroll\n   */\n  lock() {\n    tt ? this.lockHard() : document.body.classList.add(ue.CSS.scrollLocked);\n  }\n  /**\n   * Unlocks body element scroll\n   */\n  unlock() {\n    tt ? this.unlockHard() : document.body.classList.remove(ue.CSS.scrollLocked);\n  }\n  /**\n   * Locks scroll in a hard way (via setting fixed position to body element)\n   */\n  lockHard() {\n    this.scrollPosition = window.pageYOffset, document.documentElement.style.setProperty(\n      \"--window-scroll-offset\",\n      `${this.scrollPosition}px`\n    ), document.body.classList.add(ue.CSS.scrollLockedHard);\n  }\n  /**\n   * Unlocks hard scroll lock\n   */\n  unlockHard() {\n    document.body.classList.remove(ue.CSS.scrollLockedHard), this.scrollPosition !== null && window.scrollTo(0, this.scrollPosition), this.scrollPosition = null;\n  }\n};\nlet vt = ue;\nvt.CSS = {\n  scrollLocked: \"ce-scroll-locked\",\n  scrollLockedHard: \"ce-scroll-locked--hard\"\n};\nvar jo = Object.defineProperty, $o = Object.getOwnPropertyDescriptor, Wo = (s, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? $o(e, t) : e, n = s.length - 1, r; n >= 0; n--)\n    (r = s[n]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && jo(e, t, i), i;\n}, be = /* @__PURE__ */ ((s) => (s.Close = \"close\", s))(be || {});\nconst N = class extends Ee {\n  /**\n   * Constructs the instance\n   *\n   * @param params - popover construction params\n   */\n  constructor(s) {\n    super(), this.scopeElement = document.body, this.listeners = new Fe(), this.scrollLocker = new vt(), this.nodes = {\n      wrapper: null,\n      popover: null,\n      nothingFoundMessage: null,\n      customContent: null,\n      items: null,\n      overlay: null\n    }, this.messages = {\n      nothingFound: \"Nothing found\",\n      search: \"Search\"\n    }, this.onFlip = () => {\n      this.items.find((t) => t.isFocused).onFocus();\n    }, this.items = s.items.map((e) => new _(e)), s.scopeElement !== void 0 && (this.scopeElement = s.scopeElement), s.messages && (this.messages = {\n      ...this.messages,\n      ...s.messages\n    }), s.customContentFlippableItems && (this.customContentFlippableItems = s.customContentFlippableItems), this.make(), s.customContent && this.addCustomContent(s.customContent), s.searchable && this.addSearch(), this.initializeFlipper();\n  }\n  /**\n   * Popover CSS classes\n   */\n  static get CSS() {\n    return {\n      popover: \"ce-popover\",\n      popoverOpenTop: \"ce-popover--open-top\",\n      popoverOpened: \"ce-popover--opened\",\n      search: \"ce-popover__search\",\n      nothingFoundMessage: \"ce-popover__nothing-found-message\",\n      nothingFoundMessageDisplayed: \"ce-popover__nothing-found-message--displayed\",\n      customContent: \"ce-popover__custom-content\",\n      customContentHidden: \"ce-popover__custom-content--hidden\",\n      items: \"ce-popover__items\",\n      overlay: \"ce-popover__overlay\",\n      overlayHidden: \"ce-popover__overlay--hidden\"\n    };\n  }\n  /**\n   * Returns HTML element corresponding to the popover\n   */\n  getElement() {\n    return this.nodes.wrapper;\n  }\n  /**\n   * Returns true if some item inside popover is focused\n   */\n  hasFocus() {\n    return this.flipper.hasFocus();\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    this.shouldOpenBottom || (this.nodes.popover.style.setProperty(\"--popover-height\", this.height + \"px\"), this.nodes.popover.classList.add(N.CSS.popoverOpenTop)), this.nodes.overlay.classList.remove(N.CSS.overlayHidden), this.nodes.popover.classList.add(N.CSS.popoverOpened), this.flipper.activate(this.flippableElements), this.search !== void 0 && requestAnimationFrame(() => {\n      var s;\n      (s = this.search) == null || s.focus();\n    }), te() && this.scrollLocker.lock();\n  }\n  /**\n   * Closes popover\n   */\n  hide() {\n    this.nodes.popover.classList.remove(N.CSS.popoverOpened), this.nodes.popover.classList.remove(N.CSS.popoverOpenTop), this.nodes.overlay.classList.add(N.CSS.overlayHidden), this.flipper.deactivate(), this.items.forEach((s) => s.reset()), this.search !== void 0 && this.search.clear(), te() && this.scrollLocker.unlock(), this.emit(\n      \"close\"\n      /* Close */\n    );\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    this.flipper.deactivate(), this.listeners.removeAll(), te() && this.scrollLocker.unlock();\n  }\n  /**\n   * Constructs HTML element corresponding to popover\n   */\n  make() {\n    this.nodes.popover = c.make(\"div\", [N.CSS.popover]), this.nodes.nothingFoundMessage = c.make(\"div\", [N.CSS.nothingFoundMessage], {\n      textContent: this.messages.nothingFound\n    }), this.nodes.popover.appendChild(this.nodes.nothingFoundMessage), this.nodes.items = c.make(\"div\", [N.CSS.items]), this.items.forEach((s) => {\n      this.nodes.items.appendChild(s.getElement());\n    }), this.nodes.popover.appendChild(this.nodes.items), this.listeners.on(this.nodes.popover, \"click\", (s) => {\n      const e = this.getTargetItem(s);\n      e !== void 0 && this.handleItemClick(e);\n    }), this.nodes.wrapper = c.make(\"div\"), this.nodes.overlay = c.make(\"div\", [N.CSS.overlay, N.CSS.overlayHidden]), this.listeners.on(this.nodes.overlay, \"click\", () => {\n      this.hide();\n    }), this.nodes.wrapper.appendChild(this.nodes.overlay), this.nodes.wrapper.appendChild(this.nodes.popover);\n  }\n  /**\n   * Adds search to the popover\n   */\n  addSearch() {\n    this.search = new pe({\n      items: this.items,\n      placeholder: this.messages.search,\n      onSearch: (e, t) => {\n        this.items.forEach((i) => {\n          const n = !t.includes(i);\n          i.toggleHidden(n);\n        }), this.toggleNothingFoundMessage(t.length === 0), this.toggleCustomContent(e !== \"\");\n        const o = e === \"\" ? this.flippableElements : t.map((i) => i.getElement());\n        this.flipper.isActivated && (this.flipper.deactivate(), this.flipper.activate(o));\n      }\n    });\n    const s = this.search.getElement();\n    s.classList.add(N.CSS.search), this.nodes.popover.insertBefore(s, this.nodes.popover.firstChild);\n  }\n  /**\n   * Adds custom html content to the popover\n   *\n   * @param content - html content to append\n   */\n  addCustomContent(s) {\n    this.nodes.customContent = s, this.nodes.customContent.classList.add(N.CSS.customContent), this.nodes.popover.insertBefore(s, this.nodes.popover.firstChild);\n  }\n  /**\n   * Retrieves popover item that is the target of the specified event\n   *\n   * @param event - event to retrieve popover item from\n   */\n  getTargetItem(s) {\n    return this.items.find((e) => s.composedPath().includes(e.getElement()));\n  }\n  /**\n   * Handles item clicks\n   *\n   * @param item - item to handle click of\n   */\n  handleItemClick(s) {\n    s.isDisabled || (this.items.filter((e) => e !== s).forEach((e) => e.reset()), s.handleClick(), this.toggleItemActivenessIfNeeded(s), s.closeOnActivate && this.hide());\n  }\n  /**\n   * Creates Flipper instance which allows to navigate between popover items via keyboard\n   */\n  initializeFlipper() {\n    this.flipper = new q({\n      items: this.flippableElements,\n      focusedItemClass: _.CSS.focused,\n      allowedKeys: [\n        v.TAB,\n        v.UP,\n        v.DOWN,\n        v.ENTER\n      ]\n    }), this.flipper.onFlip(this.onFlip);\n  }\n  /**\n   * Returns list of elements available for keyboard navigation.\n   * Contains both usual popover items elements and custom html content.\n   */\n  get flippableElements() {\n    const s = this.items.map((t) => t.getElement());\n    return (this.customContentFlippableItems || []).concat(s);\n  }\n  get height() {\n    let s = 0;\n    if (this.nodes.popover === null)\n      return s;\n    const e = this.nodes.popover.cloneNode(!0);\n    return e.style.visibility = \"hidden\", e.style.position = \"absolute\", e.style.top = \"-1000px\", e.classList.add(N.CSS.popoverOpened), document.body.appendChild(e), s = e.offsetHeight, e.remove(), s;\n  }\n  /**\n   * Checks if popover should be opened bottom.\n   * It should happen when there is enough space below or not enough space above\n   */\n  get shouldOpenBottom() {\n    const s = this.nodes.popover.getBoundingClientRect(), e = this.scopeElement.getBoundingClientRect(), t = this.height, o = s.top + t, i = s.top - t, n = Math.min(window.innerHeight, e.bottom);\n    return i < e.top || o <= n;\n  }\n  /**\n   * Toggles nothing found message visibility\n   *\n   * @param isDisplayed - true if the message should be displayed\n   */\n  toggleNothingFoundMessage(s) {\n    this.nodes.nothingFoundMessage.classList.toggle(N.CSS.nothingFoundMessageDisplayed, s);\n  }\n  /**\n   * Toggles custom content visibility\n   *\n   * @param isDisplayed - true if custom content should be displayed\n   */\n  toggleCustomContent(s) {\n    var e;\n    (e = this.nodes.customContent) == null || e.classList.toggle(N.CSS.customContentHidden, s);\n  }\n  /**\n   * - Toggles item active state, if clicked popover item has property 'toggle' set to true.\n   *\n   * - Performs radiobutton-like behavior if the item has property 'toggle' set to string key.\n   * (All the other items with the same key get inactive, and the item gets active)\n   *\n   * @param clickedItem - popover item that was clicked\n   */\n  toggleItemActivenessIfNeeded(s) {\n    if (s.toggle === !0 && s.toggleActive(), typeof s.toggle == \"string\") {\n      const e = this.items.filter((t) => t.toggle === s.toggle);\n      if (e.length === 1) {\n        s.toggleActive();\n        return;\n      }\n      e.forEach((t) => {\n        t.toggleActive(t === s);\n      });\n    }\n  }\n};\nlet je = N;\nWo([\n  le\n], je.prototype, \"height\", 1);\nclass Yo extends y {\n  constructor() {\n    super(...arguments), this.opened = !1, this.selection = new b(), this.onPopoverClose = () => {\n      this.close();\n    };\n  }\n  /**\n   * Module Events\n   *\n   * @returns {{opened: string, closed: string}}\n   */\n  get events() {\n    return {\n      opened: \"block-settings-opened\",\n      closed: \"block-settings-closed\"\n    };\n  }\n  /**\n   * Block Settings CSS\n   */\n  get CSS() {\n    return {\n      settings: \"ce-settings\"\n    };\n  }\n  /**\n   * Getter for inner popover's flipper instance\n   *\n   * @todo remove once BlockSettings becomes standalone non-module class\n   */\n  get flipper() {\n    var e;\n    return (e = this.popover) == null ? void 0 : e.flipper;\n  }\n  /**\n   * Panel with block settings with 2 sections:\n   *  - Tool's Settings\n   *  - Default Settings [Move, Remove, etc]\n   */\n  make() {\n    this.nodes.wrapper = c.make(\"div\", [this.CSS.settings]);\n  }\n  /**\n   * Destroys module\n   */\n  destroy() {\n    this.removeAllNodes();\n  }\n  /**\n   * Open Block Settings pane\n   *\n   * @param targetBlock - near which Block we should open BlockSettings\n   */\n  open(e = this.Editor.BlockManager.currentBlock) {\n    this.opened = !0, this.selection.save(), this.Editor.BlockSelection.selectBlock(e), this.Editor.BlockSelection.clearCache();\n    const [t, o] = e.getTunes();\n    this.eventsDispatcher.emit(this.events.opened), this.popover = new je({\n      searchable: !0,\n      items: t.map((i) => this.resolveTuneAliases(i)),\n      customContent: o,\n      customContentFlippableItems: this.getControls(o),\n      scopeElement: this.Editor.API.methods.ui.nodes.redactor,\n      messages: {\n        nothingFound: z.ui(K.ui.popover, \"Nothing found\"),\n        search: z.ui(K.ui.popover, \"Filter\")\n      }\n    }), this.popover.on(be.Close, this.onPopoverClose), this.nodes.wrapper.append(this.popover.getElement()), this.popover.show();\n  }\n  /**\n   * Returns root block settings element\n   */\n  getElement() {\n    return this.nodes.wrapper;\n  }\n  /**\n   * Close Block Settings pane\n   */\n  close() {\n    this.opened && (this.opened = !1, b.isAtEditor || this.selection.restore(), this.selection.clearSaved(), !this.Editor.CrossBlockSelection.isCrossBlockSelectionStarted && this.Editor.BlockManager.currentBlock && this.Editor.BlockSelection.unselectBlock(this.Editor.BlockManager.currentBlock), this.eventsDispatcher.emit(this.events.closed), this.popover && (this.popover.off(be.Close, this.onPopoverClose), this.popover.destroy(), this.popover.getElement().remove(), this.popover = null));\n  }\n  /**\n   * Returns list of buttons and inputs inside specified container\n   *\n   * @param container - container to query controls inside of\n   */\n  getControls(e) {\n    const { StylesAPI: t } = this.Editor, o = e.querySelectorAll(\n      `.${t.classes.settingsButton}, ${c.allInputsSelector}`\n    );\n    return Array.from(o);\n  }\n  /**\n   * Resolves aliases in tunes menu items\n   *\n   * @param item - item with resolved aliases\n   */\n  resolveTuneAliases(e) {\n    const t = Ao(e, { label: \"title\" });\n    return e.confirmation && (t.confirmation = this.resolveTuneAliases(e.confirmation)), t;\n  }\n}\nclass $ extends y {\n  constructor() {\n    super(...arguments), this.opened = !1, this.tools = [], this.flipper = null, this.togglingCallback = null;\n  }\n  /**\n   * CSS getter\n   */\n  static get CSS() {\n    return {\n      conversionToolbarWrapper: \"ce-conversion-toolbar\",\n      conversionToolbarShowed: \"ce-conversion-toolbar--showed\",\n      conversionToolbarTools: \"ce-conversion-toolbar__tools\",\n      conversionToolbarLabel: \"ce-conversion-toolbar__label\",\n      conversionTool: \"ce-conversion-tool\",\n      conversionToolHidden: \"ce-conversion-tool--hidden\",\n      conversionToolIcon: \"ce-conversion-tool__icon\",\n      conversionToolSecondaryLabel: \"ce-conversion-tool__secondary-label\",\n      conversionToolFocused: \"ce-conversion-tool--focused\",\n      conversionToolActive: \"ce-conversion-tool--active\"\n    };\n  }\n  /**\n   * Create UI of Conversion Toolbar\n   */\n  make() {\n    this.nodes.wrapper = c.make(\"div\", [\n      $.CSS.conversionToolbarWrapper,\n      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []\n    ]), this.nodes.tools = c.make(\"div\", $.CSS.conversionToolbarTools);\n    const e = c.make(\"div\", $.CSS.conversionToolbarLabel, {\n      textContent: z.ui(K.ui.inlineToolbar.converter, \"Convert to\")\n    });\n    return this.addTools(), this.enableFlipper(), c.append(this.nodes.wrapper, e), c.append(this.nodes.wrapper, this.nodes.tools), this.nodes.wrapper;\n  }\n  /**\n   * Deactivates flipper and removes all nodes\n   */\n  destroy() {\n    this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes();\n  }\n  /**\n   * Toggle conversion dropdown visibility\n   *\n   * @param {Function} [togglingCallback] — callback that will accept opening state\n   */\n  toggle(e) {\n    this.opened ? this.close() : this.open(), M(e) && (this.togglingCallback = e);\n  }\n  /**\n   * Shows Conversion Toolbar\n   */\n  open() {\n    this.filterTools(), this.opened = !0, this.nodes.wrapper.classList.add($.CSS.conversionToolbarShowed), window.requestAnimationFrame(() => {\n      this.flipper.activate(this.tools.map((e) => e.button).filter((e) => !e.classList.contains($.CSS.conversionToolHidden))), this.flipper.focusFirst(), M(this.togglingCallback) && this.togglingCallback(!0);\n    });\n  }\n  /**\n   * Closes Conversion Toolbar\n   */\n  close() {\n    this.opened = !1, this.flipper.deactivate(), this.nodes.wrapper.classList.remove($.CSS.conversionToolbarShowed), M(this.togglingCallback) && this.togglingCallback(!1);\n  }\n  /**\n   * Returns true if it has more than one tool available for convert in\n   */\n  hasTools() {\n    return this.tools.length === 1 ? this.tools[0].name !== this.config.defaultBlock : !0;\n  }\n  /**\n   * Replaces one Block with another\n   * For that Tools must provide import/export methods\n   *\n   * @param {string} replacingToolName - name of Tool which replaces current\n   * @param blockDataOverrides - If this conversion fired by the one of multiple Toolbox items, extend converted data with this item's \"data\" overrides\n   */\n  async replaceWithBlock(e, t) {\n    const { BlockManager: o, BlockSelection: i, InlineToolbar: n, Caret: r } = this.Editor;\n    o.convert(this.Editor.BlockManager.currentBlock, e, t), i.clearSelection(), this.close(), n.close(), window.requestAnimationFrame(() => {\n      r.setToBlock(this.Editor.BlockManager.currentBlock, r.positions.END);\n    });\n  }\n  /**\n   * Iterates existing Tools and inserts to the ConversionToolbar\n   * if tools have ability to import\n   */\n  addTools() {\n    const e = this.Editor.Tools.blockTools;\n    Array.from(e.entries()).forEach(([t, o]) => {\n      var n;\n      const i = o.conversionConfig;\n      !i || !i.import || (n = o.toolbox) == null || n.forEach(\n        (r) => this.addToolIfValid(t, r)\n      );\n    });\n  }\n  /**\n   * Inserts a tool to the ConversionToolbar if the tool's toolbox config is valid\n   *\n   * @param name - tool's name\n   * @param toolboxSettings - tool's single toolbox setting\n   */\n  addToolIfValid(e, t) {\n    W(t) || !t.icon || this.addTool(e, t);\n  }\n  /**\n   * Add tool to the Conversion Toolbar\n   *\n   * @param toolName - name of Tool to add\n   * @param toolboxItem - tool's toolbox item data\n   */\n  addTool(e, t) {\n    var r;\n    const o = c.make(\"div\", [$.CSS.conversionTool]), i = c.make(\"div\", [$.CSS.conversionToolIcon]);\n    o.dataset.tool = e, i.innerHTML = t.icon, c.append(o, i), c.append(o, c.text(z.t(K.toolNames, t.title || re(e))));\n    const n = (r = this.Editor.Tools.blockTools.get(e)) == null ? void 0 : r.shortcut;\n    if (n) {\n      const a = c.make(\"span\", $.CSS.conversionToolSecondaryLabel, {\n        innerText: ye(n)\n      });\n      c.append(o, a);\n    }\n    c.append(this.nodes.tools, o), this.tools.push({\n      name: e,\n      button: o,\n      toolboxItem: t\n    }), this.listeners.on(o, \"click\", async () => {\n      await this.replaceWithBlock(e, t.data);\n    });\n  }\n  /**\n   * Hide current Tool and show others\n   */\n  async filterTools() {\n    const { currentBlock: e } = this.Editor.BlockManager, t = await e.getActiveToolboxEntry();\n    function o(i, n) {\n      return i.icon === n.icon && i.title === n.title;\n    }\n    this.tools.forEach((i) => {\n      let n = !1;\n      if (t) {\n        const r = o(t, i.toolboxItem);\n        n = i.button.dataset.tool === e.name && r;\n      }\n      i.button.hidden = n, i.button.classList.toggle($.CSS.conversionToolHidden, n);\n    });\n  }\n  /**\n   * Prepare Flipper to be able to leaf tools by arrows/tab\n   */\n  enableFlipper() {\n    this.flipper = new q({\n      focusedItemClass: $.CSS.conversionToolFocused\n    });\n  }\n}\nvar De = {}, Ko = {\n  get exports() {\n    return De;\n  },\n  set exports(s) {\n    De = s;\n  }\n};\n/*!\n * Library for handling keyboard shortcuts\n * @copyright CodeX (https://codex.so)\n * @license MIT\n * @author CodeX (https://codex.so)\n * @version 1.2.0\n */\n(function(s, e) {\n  (function(t, o) {\n    s.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(n) {\n        if (o[n])\n          return o[n].exports;\n        var r = o[n] = { i: n, l: !1, exports: {} };\n        return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(n, r, a) {\n        i.o(n, r) || Object.defineProperty(n, r, { enumerable: !0, get: a });\n      }, i.r = function(n) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(n, \"__esModule\", { value: !0 });\n      }, i.t = function(n, r) {\n        if (1 & r && (n = i(n)), 8 & r || 4 & r && typeof n == \"object\" && n && n.__esModule)\n          return n;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: n }), 2 & r && typeof n != \"string\")\n          for (var l in n)\n            i.d(a, l, function(d) {\n              return n[d];\n            }.bind(null, l));\n        return a;\n      }, i.n = function(n) {\n        var r = n && n.__esModule ? function() {\n          return n.default;\n        } : function() {\n          return n;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(n, r) {\n        return Object.prototype.hasOwnProperty.call(n, r);\n      }, i.p = \"\", i(i.s = 0);\n    }([function(t, o, i) {\n      function n(l, d) {\n        for (var u = 0; u < d.length; u++) {\n          var h = d[u];\n          h.enumerable = h.enumerable || !1, h.configurable = !0, \"value\" in h && (h.writable = !0), Object.defineProperty(l, h.key, h);\n        }\n      }\n      function r(l, d, u) {\n        return d && n(l.prototype, d), u && n(l, u), l;\n      }\n      i.r(o);\n      var a = function() {\n        function l(d) {\n          var u = this;\n          (function(h, f) {\n            if (!(h instanceof f))\n              throw new TypeError(\"Cannot call a class as a function\");\n          })(this, l), this.commands = {}, this.keys = {}, this.name = d.name, this.parseShortcutName(d.name), this.element = d.on, this.callback = d.callback, this.executeShortcut = function(h) {\n            u.execute(h);\n          }, this.element.addEventListener(\"keydown\", this.executeShortcut, !1);\n        }\n        return r(l, null, [{ key: \"supportedCommands\", get: function() {\n          return { SHIFT: [\"SHIFT\"], CMD: [\"CMD\", \"CONTROL\", \"COMMAND\", \"WINDOWS\", \"CTRL\"], ALT: [\"ALT\", \"OPTION\"] };\n        } }, { key: \"keyCodes\", get: function() {\n          return { 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, BACKSPACE: 8, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, INSERT: 45, DELETE: 46, \".\": 190 };\n        } }]), r(l, [{ key: \"parseShortcutName\", value: function(d) {\n          d = d.split(\"+\");\n          for (var u = 0; u < d.length; u++) {\n            d[u] = d[u].toUpperCase();\n            var h = !1;\n            for (var f in l.supportedCommands)\n              if (l.supportedCommands[f].includes(d[u])) {\n                h = this.commands[f] = !0;\n                break;\n              }\n            h || (this.keys[d[u]] = !0);\n          }\n          for (var x in l.supportedCommands)\n            this.commands[x] || (this.commands[x] = !1);\n        } }, { key: \"execute\", value: function(d) {\n          var u, h = { CMD: d.ctrlKey || d.metaKey, SHIFT: d.shiftKey, ALT: d.altKey }, f = !0;\n          for (u in this.commands)\n            this.commands[u] !== h[u] && (f = !1);\n          var x, p = !0;\n          for (x in this.keys)\n            p = p && d.keyCode === l.keyCodes[x];\n          f && p && this.callback(d);\n        } }, { key: \"remove\", value: function() {\n          this.element.removeEventListener(\"keydown\", this.executeShortcut);\n        } }]), l;\n      }();\n      o.default = a;\n    }]).default;\n  });\n})(Ko);\nconst Xo = /* @__PURE__ */ Pe(De);\nclass Vo {\n  constructor() {\n    this.registeredShortcuts = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Register shortcut\n   *\n   * @param shortcut - shortcut options\n   */\n  add(e) {\n    if (this.findShortcut(e.on, e.name))\n      throw Error(\n        `Shortcut ${e.name} is already registered for ${e.on}. Please remove it before add a new handler.`\n      );\n    const o = new Xo({\n      name: e.name,\n      on: e.on,\n      callback: e.handler\n    }), i = this.registeredShortcuts.get(e.on) || [];\n    this.registeredShortcuts.set(e.on, [...i, o]);\n  }\n  /**\n   * Remove shortcut\n   *\n   * @param element - Element shortcut is set for\n   * @param name - shortcut name\n   */\n  remove(e, t) {\n    const o = this.findShortcut(e, t);\n    if (!o)\n      return;\n    o.remove();\n    const i = this.registeredShortcuts.get(e);\n    this.registeredShortcuts.set(e, i.filter((n) => n !== o));\n  }\n  /**\n   * Get Shortcut instance if exist\n   *\n   * @param element - Element shorcut is set for\n   * @param shortcut - shortcut name\n   * @returns {number} index - shortcut index if exist\n   */\n  findShortcut(e, t) {\n    return (this.registeredShortcuts.get(e) || []).find(({ name: i }) => i === t);\n  }\n}\nconst ae = new Vo();\nvar qo = Object.defineProperty, Zo = Object.getOwnPropertyDescriptor, xt = (s, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? Zo(e, t) : e, n = s.length - 1, r; n >= 0; n--)\n    (r = s[n]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && qo(e, t, i), i;\n}, ke = /* @__PURE__ */ ((s) => (s.Opened = \"toolbox-opened\", s.Closed = \"toolbox-closed\", s.BlockAdded = \"toolbox-block-added\", s))(ke || {});\nconst wt = class extends Ee {\n  /**\n   * Toolbox constructor\n   *\n   * @param options - available parameters\n   * @param options.api - Editor API methods\n   * @param options.tools - Tools available to check whether some of them should be displayed at the Toolbox or not\n   */\n  constructor({ api: s, tools: e, i18nLabels: t }) {\n    super(), this.opened = !1, this.nodes = {\n      toolbox: null\n    }, this.onPopoverClose = () => {\n      this.opened = !1, this.emit(\n        \"toolbox-closed\"\n        /* Closed */\n      );\n    }, this.api = s, this.tools = e, this.i18nLabels = t;\n  }\n  /**\n   * Returns True if Toolbox is Empty and nothing to show\n   *\n   * @returns {boolean}\n   */\n  get isEmpty() {\n    return this.toolsToBeDisplayed.length === 0;\n  }\n  /**\n   * CSS styles\n   *\n   * @returns {Object<string, string>}\n   */\n  static get CSS() {\n    return {\n      toolbox: \"ce-toolbox\"\n    };\n  }\n  /**\n   * Makes the Toolbox\n   */\n  make() {\n    return this.popover = new je({\n      scopeElement: this.api.ui.nodes.redactor,\n      searchable: !0,\n      messages: {\n        nothingFound: this.i18nLabels.nothingFound,\n        search: this.i18nLabels.filter\n      },\n      items: this.toolboxItemsToBeDisplayed\n    }), this.popover.on(be.Close, this.onPopoverClose), this.enableShortcuts(), this.nodes.toolbox = this.popover.getElement(), this.nodes.toolbox.classList.add(wt.CSS.toolbox), this.nodes.toolbox;\n  }\n  /**\n   * Returns true if the Toolbox has the Flipper activated and the Flipper has selected button\n   */\n  hasFocus() {\n    var s;\n    return (s = this.popover) == null ? void 0 : s.hasFocus();\n  }\n  /**\n   * Destroy Module\n   */\n  destroy() {\n    var s;\n    super.destroy(), this.nodes && this.nodes.toolbox && (this.nodes.toolbox.remove(), this.nodes.toolbox = null), this.removeAllShortcuts(), (s = this.popover) == null || s.off(be.Close, this.onPopoverClose);\n  }\n  /**\n   * Toolbox Tool's button click handler\n   *\n   * @param toolName - tool type to be activated\n   * @param blockDataOverrides - Block data predefined by the activated Toolbox item\n   */\n  toolButtonActivated(s, e) {\n    this.insertNewBlock(s, e);\n  }\n  /**\n   * Open Toolbox with Tools\n   */\n  open() {\n    var s;\n    this.isEmpty || ((s = this.popover) == null || s.show(), this.opened = !0, this.emit(\n      \"toolbox-opened\"\n      /* Opened */\n    ));\n  }\n  /**\n   * Close Toolbox\n   */\n  close() {\n    var s;\n    (s = this.popover) == null || s.hide(), this.opened = !1, this.emit(\n      \"toolbox-closed\"\n      /* Closed */\n    );\n  }\n  /**\n   * Close Toolbox\n   */\n  toggle() {\n    this.opened ? this.close() : this.open();\n  }\n  get toolsToBeDisplayed() {\n    const s = [];\n    return this.tools.forEach((e) => {\n      e.toolbox && s.push(e);\n    }), s;\n  }\n  get toolboxItemsToBeDisplayed() {\n    const s = (e, t) => ({\n      icon: e.icon,\n      title: z.t(K.toolNames, e.title || re(t.name)),\n      name: t.name,\n      onActivate: () => {\n        this.toolButtonActivated(t.name, e.data);\n      },\n      secondaryLabel: t.shortcut ? ye(t.shortcut) : \"\"\n    });\n    return this.toolsToBeDisplayed.reduce((e, t) => (Array.isArray(t.toolbox) ? t.toolbox.forEach((o) => {\n      e.push(s(o, t));\n    }) : t.toolbox !== void 0 && e.push(s(t.toolbox, t)), e), []);\n  }\n  /**\n   * Iterate all tools and enable theirs shortcuts if specified\n   */\n  enableShortcuts() {\n    this.toolsToBeDisplayed.forEach((s) => {\n      const e = s.shortcut;\n      e && this.enableShortcutForTool(s.name, e);\n    });\n  }\n  /**\n   * Enable shortcut Block Tool implemented shortcut\n   *\n   * @param {string} toolName - Tool name\n   * @param {string} shortcut - shortcut according to the ShortcutData Module format\n   */\n  enableShortcutForTool(s, e) {\n    ae.add({\n      name: e,\n      on: this.api.ui.nodes.redactor,\n      handler: (t) => {\n        t.preventDefault();\n        const o = this.api.blocks.getCurrentBlockIndex(), i = this.api.blocks.getBlockByIndex(o);\n        if (i)\n          try {\n            this.api.blocks.convert(i.id, s), window.requestAnimationFrame(() => {\n              this.api.caret.setToBlock(o, \"end\");\n            });\n            return;\n          } catch {\n          }\n        this.insertNewBlock(s);\n      }\n    });\n  }\n  /**\n   * Removes all added shortcuts\n   * Fired when the Read-Only mode is activated\n   */\n  removeAllShortcuts() {\n    this.toolsToBeDisplayed.forEach((s) => {\n      const e = s.shortcut;\n      e && ae.remove(this.api.ui.nodes.redactor, e);\n    });\n  }\n  /**\n   * Inserts new block\n   * Can be called when button clicked on Toolbox or by ShortcutData\n   *\n   * @param {string} toolName - Tool name\n   * @param blockDataOverrides - predefined Block data\n   */\n  async insertNewBlock(s, e) {\n    const t = this.api.blocks.getCurrentBlockIndex(), o = this.api.blocks.getBlockByIndex(t);\n    if (!o)\n      return;\n    const i = o.isEmpty ? t : t + 1;\n    let n;\n    if (e) {\n      const a = await this.api.blocks.composeBlockData(s);\n      n = Object.assign(a, e);\n    }\n    const r = this.api.blocks.insert(\n      s,\n      n,\n      void 0,\n      i,\n      void 0,\n      o.isEmpty\n    );\n    r.call(X.APPEND_CALLBACK), this.api.caret.setToBlock(i), this.emit(\"toolbox-block-added\", {\n      block: r\n    }), this.api.toolbar.close();\n  }\n};\nlet $e = wt;\nxt([\n  le\n], $e.prototype, \"toolsToBeDisplayed\", 1);\nxt([\n  le\n], $e.prototype, \"toolboxItemsToBeDisplayed\", 1);\nconst yt = \"block hovered\";\nasync function Go(s, e) {\n  const t = navigator.keyboard;\n  return t && (await t.getLayoutMap()).get(s) || e;\n}\nclass Jo extends y {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.toolboxInstance = null;\n  }\n  /**\n   * CSS styles\n   *\n   * @returns {object}\n   */\n  get CSS() {\n    return {\n      toolbar: \"ce-toolbar\",\n      content: \"ce-toolbar__content\",\n      actions: \"ce-toolbar__actions\",\n      actionsOpened: \"ce-toolbar__actions--opened\",\n      toolbarOpened: \"ce-toolbar--opened\",\n      openedToolboxHolderModifier: \"codex-editor--toolbox-opened\",\n      plusButton: \"ce-toolbar__plus\",\n      plusButtonShortcut: \"ce-toolbar__plus-shortcut\",\n      settingsToggler: \"ce-toolbar__settings-btn\",\n      settingsTogglerHidden: \"ce-toolbar__settings-btn--hidden\"\n    };\n  }\n  /**\n   * Returns the Toolbar opening state\n   *\n   * @returns {boolean}\n   */\n  get opened() {\n    return this.nodes.wrapper.classList.contains(this.CSS.toolbarOpened);\n  }\n  /**\n   * Public interface for accessing the Toolbox\n   */\n  get toolbox() {\n    var e;\n    return {\n      opened: (e = this.toolboxInstance) == null ? void 0 : e.opened,\n      close: () => {\n        var t;\n        (t = this.toolboxInstance) == null || t.close();\n      },\n      open: () => {\n        if (this.toolboxInstance === null) {\n          T(\"toolbox.open() called before initialization is finished\", \"warn\");\n          return;\n        }\n        this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.open();\n      },\n      toggle: () => {\n        if (this.toolboxInstance === null) {\n          T(\"toolbox.toggle() called before initialization is finished\", \"warn\");\n          return;\n        }\n        this.toolboxInstance.toggle();\n      },\n      hasFocus: () => {\n        var t;\n        return (t = this.toolboxInstance) == null ? void 0 : t.hasFocus();\n      }\n    };\n  }\n  /**\n   * Block actions appearance manipulations\n   */\n  get blockActions() {\n    return {\n      hide: () => {\n        this.nodes.actions.classList.remove(this.CSS.actionsOpened);\n      },\n      show: () => {\n        this.nodes.actions.classList.add(this.CSS.actionsOpened);\n      }\n    };\n  }\n  /**\n   * Methods for working with Block Tunes toggler\n   */\n  get blockTunesToggler() {\n    return {\n      hide: () => this.nodes.settingsToggler.classList.add(this.CSS.settingsTogglerHidden),\n      show: () => this.nodes.settingsToggler.classList.remove(this.CSS.settingsTogglerHidden)\n    };\n  }\n  /**\n   * Toggles read-only mode\n   *\n   * @param {boolean} readOnlyEnabled - read-only mode\n   */\n  toggleReadOnly(e) {\n    e ? (this.destroy(), this.Editor.BlockSettings.destroy(), this.disableModuleBindings()) : window.requestIdleCallback(() => {\n      this.drawUI(), this.enableModuleBindings();\n    }, { timeout: 2e3 });\n  }\n  /**\n   * Move Toolbar to the passed (or current) Block\n   *\n   * @param block - block to move Toolbar near it\n   */\n  moveAndOpen(e = this.Editor.BlockManager.currentBlock) {\n    if (this.toolboxInstance === null) {\n      T(\"Can't open Toolbar since Editor initialization is not finished yet\", \"warn\");\n      return;\n    }\n    if (this.toolboxInstance.opened && this.toolboxInstance.close(), this.Editor.BlockSettings.opened && this.Editor.BlockSettings.close(), !e)\n      return;\n    this.hoveredBlock = e;\n    const t = e.holder, { isMobile: o } = this.Editor.UI, i = e.pluginsContent, n = window.getComputedStyle(i), r = parseInt(n.paddingTop, 10), a = t.offsetHeight;\n    let l;\n    o ? l = t.offsetTop + a : l = t.offsetTop + r, this.nodes.wrapper.style.top = `${Math.floor(l)}px`, this.Editor.BlockManager.blocks.length === 1 && e.isEmpty ? this.blockTunesToggler.hide() : this.blockTunesToggler.show(), this.open();\n  }\n  /**\n   * Close the Toolbar\n   */\n  close() {\n    var e, t;\n    this.Editor.ReadOnly.isEnabled || ((e = this.nodes.wrapper) == null || e.classList.remove(this.CSS.toolbarOpened), this.blockActions.hide(), (t = this.toolboxInstance) == null || t.close(), this.Editor.BlockSettings.close(), this.reset());\n  }\n  /**\n   * Reset the Toolbar position to prevent DOM height growth, for example after blocks deletion\n   */\n  reset() {\n    this.nodes.wrapper.style.top = \"unset\";\n  }\n  /**\n   * Open Toolbar with Plus Button and Actions\n   *\n   * @param {boolean} withBlockActions - by default, Toolbar opens with Block Actions.\n   *                                     This flag allows to open Toolbar without Actions.\n   */\n  open(e = !0) {\n    this.nodes.wrapper.classList.add(this.CSS.toolbarOpened), e ? this.blockActions.show() : this.blockActions.hide();\n  }\n  /**\n   * Draws Toolbar elements\n   */\n  async make() {\n    this.nodes.wrapper = c.make(\"div\", this.CSS.toolbar), [\"content\", \"actions\"].forEach((n) => {\n      this.nodes[n] = c.make(\"div\", this.CSS[n]);\n    }), c.append(this.nodes.wrapper, this.nodes.content), c.append(this.nodes.content, this.nodes.actions), this.nodes.plusButton = c.make(\"div\", this.CSS.plusButton, {\n      innerHTML: Fo\n    }), c.append(this.nodes.actions, this.nodes.plusButton), this.readOnlyMutableListeners.on(this.nodes.plusButton, \"click\", () => {\n      Re(!0), this.plusButtonClicked();\n    }, !1);\n    const e = c.make(\"div\");\n    e.appendChild(document.createTextNode(z.ui(K.ui.toolbar.toolbox, \"Add\"))), e.appendChild(c.make(\"div\", this.CSS.plusButtonShortcut, {\n      textContent: \"/\"\n    })), ge(this.nodes.plusButton, e, {\n      hidingDelay: 400\n    }), this.nodes.settingsToggler = c.make(\"span\", this.CSS.settingsToggler, {\n      innerHTML: Po\n    }), c.append(this.nodes.actions, this.nodes.settingsToggler);\n    const t = c.make(\"div\"), o = c.text(z.ui(K.ui.blockTunes.toggler, \"Click to tune\")), i = await Go(\"Slash\", \"/\");\n    t.appendChild(o), t.appendChild(c.make(\"div\", this.CSS.plusButtonShortcut, {\n      textContent: ye(`CMD + ${i}`)\n    })), ge(this.nodes.settingsToggler, t, {\n      hidingDelay: 400\n    }), c.append(this.nodes.actions, this.makeToolbox()), c.append(this.nodes.actions, this.Editor.BlockSettings.getElement()), c.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);\n  }\n  /**\n   * Creates the Toolbox instance and return it's rendered element\n   */\n  makeToolbox() {\n    return this.toolboxInstance = new $e({\n      api: this.Editor.API.methods,\n      tools: this.Editor.Tools.blockTools,\n      i18nLabels: {\n        filter: z.ui(K.ui.popover, \"Filter\"),\n        nothingFound: z.ui(K.ui.popover, \"Nothing found\")\n      }\n    }), this.toolboxInstance.on(ke.Opened, () => {\n      this.Editor.UI.nodes.wrapper.classList.add(this.CSS.openedToolboxHolderModifier);\n    }), this.toolboxInstance.on(ke.Closed, () => {\n      this.Editor.UI.nodes.wrapper.classList.remove(this.CSS.openedToolboxHolderModifier);\n    }), this.toolboxInstance.on(ke.BlockAdded, ({ block: e }) => {\n      const { BlockManager: t, Caret: o } = this.Editor, i = t.getBlockById(e.id);\n      i.inputs.length === 0 && (i === t.lastBlock ? (t.insertAtEnd(), o.setToBlock(t.lastBlock)) : o.setToBlock(t.nextBlock));\n    }), this.toolboxInstance.make();\n  }\n  /**\n   * Handler for Plus Button\n   */\n  plusButtonClicked() {\n    var e;\n    this.Editor.BlockManager.currentBlock = this.hoveredBlock, (e = this.toolboxInstance) == null || e.toggle();\n  }\n  /**\n   * Enable bindings\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(this.nodes.settingsToggler, \"mousedown\", (e) => {\n      var t;\n      e.stopPropagation(), this.settingsTogglerClicked(), (t = this.toolboxInstance) != null && t.opened && this.toolboxInstance.close(), Re(!0);\n    }, !0), te() || this.eventsDispatcher.on(yt, (e) => {\n      var t;\n      this.Editor.BlockSettings.opened || (t = this.toolboxInstance) != null && t.opened || this.moveAndOpen(e.block);\n    });\n  }\n  /**\n   * Disable bindings\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Clicks on the Block Settings toggler\n   */\n  settingsTogglerClicked() {\n    this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.BlockSettings.open(this.hoveredBlock);\n  }\n  /**\n   * Draws Toolbar UI\n   *\n   * Toolbar contains BlockSettings and Toolbox.\n   * That's why at first we draw its components and then Toolbar itself\n   *\n   * Steps:\n   *  - Make Toolbar dependent components like BlockSettings, Toolbox and so on\n   *  - Make itself and append dependent nodes to itself\n   *\n   */\n  drawUI() {\n    this.Editor.BlockSettings.make(), this.make();\n  }\n  /**\n   * Removes all created and saved HTMLElements\n   * It is used in Read-Only mode\n   */\n  destroy() {\n    this.removeAllNodes(), this.toolboxInstance && this.toolboxInstance.destroy();\n  }\n}\nvar Be = /* @__PURE__ */ ((s) => (s[s.Block = 0] = \"Block\", s[s.Inline = 1] = \"Inline\", s[s.Tune = 2] = \"Tune\", s))(Be || {}), ve = /* @__PURE__ */ ((s) => (s.Shortcut = \"shortcut\", s.Toolbox = \"toolbox\", s.EnabledInlineTools = \"inlineToolbar\", s.EnabledBlockTunes = \"tunes\", s.Config = \"config\", s))(ve || {}), Et = /* @__PURE__ */ ((s) => (s.Shortcut = \"shortcut\", s.SanitizeConfig = \"sanitize\", s))(Et || {}), se = /* @__PURE__ */ ((s) => (s.IsEnabledLineBreaks = \"enableLineBreaks\", s.Toolbox = \"toolbox\", s.ConversionConfig = \"conversionConfig\", s.IsReadOnlySupported = \"isReadOnlySupported\", s.PasteConfig = \"pasteConfig\", s))(se || {}), We = /* @__PURE__ */ ((s) => (s.IsInline = \"isInline\", s.Title = \"title\", s))(We || {}), Bt = /* @__PURE__ */ ((s) => (s.IsTune = \"isTune\", s))(Bt || {});\nclass Ye {\n  /**\n   * @class\n   * @param {ConstructorOptions} options - Constructor options\n   */\n  constructor({\n    name: e,\n    constructable: t,\n    config: o,\n    api: i,\n    isDefault: n,\n    isInternal: r = !1,\n    defaultPlaceholder: a\n  }) {\n    this.api = i, this.name = e, this.constructable = t, this.config = o, this.isDefault = n, this.isInternal = r, this.defaultPlaceholder = a;\n  }\n  /**\n   * Returns Tool user configuration\n   */\n  get settings() {\n    const e = this.config.config || {};\n    return this.isDefault && !(\"placeholder\" in e) && this.defaultPlaceholder && (e.placeholder = this.defaultPlaceholder), e;\n  }\n  /**\n   * Calls Tool's reset method\n   */\n  reset() {\n    if (M(this.constructable.reset))\n      return this.constructable.reset();\n  }\n  /**\n   * Calls Tool's prepare method\n   */\n  prepare() {\n    if (M(this.constructable.prepare))\n      return this.constructable.prepare({\n        toolName: this.name,\n        config: this.settings\n      });\n  }\n  /**\n   * Returns shortcut for Tool (internal or specified by user)\n   */\n  get shortcut() {\n    const e = this.constructable.shortcut;\n    return this.config.shortcut || e;\n  }\n  /**\n   * Returns Tool's sanitizer configuration\n   */\n  get sanitizeConfig() {\n    return this.constructable.sanitize || {};\n  }\n  /**\n   * Returns true if Tools is inline\n   */\n  isInline() {\n    return this.type === 1;\n  }\n  /**\n   * Returns true if Tools is block\n   */\n  isBlock() {\n    return this.type === 0;\n  }\n  /**\n   * Returns true if Tools is tune\n   */\n  isTune() {\n    return this.type === 2;\n  }\n}\nclass Qo extends y {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.CSS = {\n      inlineToolbar: \"ce-inline-toolbar\",\n      inlineToolbarShowed: \"ce-inline-toolbar--showed\",\n      inlineToolbarLeftOriented: \"ce-inline-toolbar--left-oriented\",\n      inlineToolbarRightOriented: \"ce-inline-toolbar--right-oriented\",\n      inlineToolbarShortcut: \"ce-inline-toolbar__shortcut\",\n      buttonsWrapper: \"ce-inline-toolbar__buttons\",\n      actionsWrapper: \"ce-inline-toolbar__actions\",\n      inlineToolButton: \"ce-inline-tool\",\n      inputField: \"cdx-input\",\n      focusedButton: \"ce-inline-tool--focused\",\n      conversionToggler: \"ce-inline-toolbar__dropdown\",\n      conversionTogglerArrow: \"ce-inline-toolbar__dropdown-arrow\",\n      conversionTogglerHidden: \"ce-inline-toolbar__dropdown--hidden\",\n      conversionTogglerContent: \"ce-inline-toolbar__dropdown-content\",\n      togglerAndButtonsWrapper: \"ce-inline-toolbar__toggler-and-button-wrapper\"\n    }, this.opened = !1, this.toolbarVerticalMargin = te() ? 20 : 6, this.buttonsList = null, this.width = 0, this.flipper = null;\n  }\n  /**\n   * Toggles read-only mode\n   *\n   * @param {boolean} readOnlyEnabled - read-only mode\n   */\n  toggleReadOnly(e) {\n    e ? (this.destroy(), this.Editor.ConversionToolbar.destroy()) : window.requestIdleCallback(() => {\n      this.make();\n    }, { timeout: 2e3 });\n  }\n  /**\n   *  Moving / appearance\n   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   */\n  /**\n   * Shows Inline Toolbar if something is selected\n   *\n   * @param [needToClose] - pass true to close toolbar if it is not allowed.\n   *                                  Avoid to use it just for closing IT, better call .close() clearly.\n   * @param [needToShowConversionToolbar] - pass false to not to show Conversion Toolbar\n   */\n  async tryToShow(e = !1, t = !0) {\n    e && this.close(), this.allowedToShow() && (await this.addToolsFiltered(t), this.move(), this.open(t), this.Editor.Toolbar.close());\n  }\n  /**\n   * Hides Inline Toolbar\n   */\n  close() {\n    this.opened && (this.Editor.ReadOnly.isEnabled || (this.nodes.wrapper.classList.remove(this.CSS.inlineToolbarShowed), Array.from(this.toolsInstances.entries()).forEach(([e, t]) => {\n      const o = this.getToolShortcut(e);\n      o && ae.remove(this.Editor.UI.nodes.redactor, o), M(t.clear) && t.clear();\n    }), this.reset(), this.opened = !1, this.flipper.deactivate(), this.Editor.ConversionToolbar.close()));\n  }\n  /**\n   * Check if node is contained by Inline Toolbar\n   *\n   * @param {Node} node — node to check\n   */\n  containsNode(e) {\n    return this.nodes.wrapper === void 0 ? !1 : this.nodes.wrapper.contains(e);\n  }\n  /**\n   * Removes UI and its components\n   */\n  destroy() {\n    this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes();\n  }\n  /**\n   * Making DOM\n   */\n  make() {\n    this.nodes.wrapper = c.make(\"div\", [\n      this.CSS.inlineToolbar,\n      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []\n    ]), this.nodes.togglerAndButtonsWrapper = c.make(\"div\", this.CSS.togglerAndButtonsWrapper), this.nodes.buttons = c.make(\"div\", this.CSS.buttonsWrapper), this.nodes.actions = c.make(\"div\", this.CSS.actionsWrapper), this.listeners.on(this.nodes.wrapper, \"mousedown\", (e) => {\n      e.target.closest(`.${this.CSS.actionsWrapper}`) || e.preventDefault();\n    }), c.append(this.nodes.wrapper, [this.nodes.togglerAndButtonsWrapper, this.nodes.actions]), c.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper), this.addConversionToggler(), c.append(this.nodes.togglerAndButtonsWrapper, this.nodes.buttons), this.prepareConversionToolbar(), window.requestAnimationFrame(() => {\n      this.recalculateWidth();\n    }), this.enableFlipper();\n  }\n  /**\n   * Shows Inline Toolbar\n   */\n  open() {\n    if (this.opened)\n      return;\n    this.nodes.wrapper.classList.add(this.CSS.inlineToolbarShowed), this.buttonsList = this.nodes.buttons.querySelectorAll(`.${this.CSS.inlineToolButton}`), this.opened = !0;\n    let e = Array.from(this.buttonsList);\n    e.unshift(this.nodes.conversionToggler), e = e.filter((t) => !t.hidden), this.flipper.activate(e);\n  }\n  /**\n   * Move Toolbar to the selected text\n   */\n  move() {\n    const e = b.rect, t = this.Editor.UI.nodes.wrapper.getBoundingClientRect(), o = {\n      x: e.x - t.x,\n      y: e.y + e.height - // + window.scrollY\n      t.top + this.toolbarVerticalMargin\n    };\n    o.x + this.width + t.x > this.Editor.UI.contentRect.right && (o.x = this.Editor.UI.contentRect.right - this.width - t.x), this.nodes.wrapper.style.left = Math.floor(o.x) + \"px\", this.nodes.wrapper.style.top = Math.floor(o.y) + \"px\";\n  }\n  /**\n   * Clear orientation classes and reset position\n   */\n  reset() {\n    this.nodes.wrapper.classList.remove(\n      this.CSS.inlineToolbarLeftOriented,\n      this.CSS.inlineToolbarRightOriented\n    ), this.nodes.wrapper.style.left = \"0\", this.nodes.wrapper.style.top = \"0\";\n  }\n  /**\n   * Need to show Inline Toolbar or not\n   */\n  allowedToShow() {\n    const e = [\"IMG\", \"INPUT\"], t = b.get(), o = b.text;\n    if (!t || !t.anchorNode || t.isCollapsed || o.length < 1)\n      return !1;\n    const i = c.isElement(t.anchorNode) ? t.anchorNode : t.anchorNode.parentElement;\n    if (t && e.includes(i.tagName) || i.closest('[contenteditable=\"true\"]') === null)\n      return !1;\n    const r = this.Editor.BlockManager.getBlock(t.anchorNode);\n    return r ? r.tool.inlineTools.size !== 0 : !1;\n  }\n  /**\n   * Recalculate inline toolbar width\n   */\n  recalculateWidth() {\n    this.width = this.nodes.wrapper.offsetWidth;\n  }\n  /**\n   * Create a toggler for Conversion Dropdown\n   * and prepend it to the buttons list\n   */\n  addConversionToggler() {\n    this.nodes.conversionToggler = c.make(\"div\", this.CSS.conversionToggler), this.nodes.conversionTogglerContent = c.make(\"div\", this.CSS.conversionTogglerContent);\n    const e = c.make(\"div\", this.CSS.conversionTogglerArrow, {\n      innerHTML: kt\n    });\n    this.nodes.conversionToggler.appendChild(this.nodes.conversionTogglerContent), this.nodes.conversionToggler.appendChild(e), this.nodes.togglerAndButtonsWrapper.appendChild(this.nodes.conversionToggler), this.listeners.on(this.nodes.conversionToggler, \"click\", () => {\n      this.Editor.ConversionToolbar.toggle((t) => {\n        !t && this.opened ? this.flipper.activate() : this.opened && this.flipper.deactivate();\n      });\n    }), te() === !1 && ge(this.nodes.conversionToggler, z.ui(K.ui.inlineToolbar.converter, \"Convert to\"), {\n      placement: \"top\",\n      hidingDelay: 100\n    });\n  }\n  /**\n   * Changes Conversion Dropdown content for current block's Tool\n   */\n  async setConversionTogglerContent() {\n    const { BlockManager: e } = this.Editor, { currentBlock: t } = e, o = t.name, i = t.tool.conversionConfig, n = i && i.export;\n    this.nodes.conversionToggler.hidden = !n, this.nodes.conversionToggler.classList.toggle(this.CSS.conversionTogglerHidden, !n);\n    const r = await t.getActiveToolboxEntry() || {};\n    this.nodes.conversionTogglerContent.innerHTML = r.icon || r.title || re(o);\n  }\n  /**\n   * Makes the Conversion Dropdown\n   */\n  prepareConversionToolbar() {\n    const e = this.Editor.ConversionToolbar.make();\n    c.append(this.nodes.wrapper, e);\n  }\n  /**\n   *  Working with Tools\n   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   */\n  /**\n   * Append only allowed Tools\n   *\n   * @param {boolean} needToShowConversionToolbar - pass false to not to show Conversion Toolbar (e.g. for Footnotes-like tools)\n   */\n  async addToolsFiltered(e = !0) {\n    const t = b.get(), o = this.Editor.BlockManager.getBlock(t.anchorNode);\n    this.nodes.buttons.innerHTML = \"\", this.nodes.actions.innerHTML = \"\", this.toolsInstances = /* @__PURE__ */ new Map(), Array.from(o.tool.inlineTools.values()).forEach((i) => {\n      this.addTool(i);\n    }), e && this.Editor.ConversionToolbar.hasTools() ? await this.setConversionTogglerContent() : this.nodes.conversionToggler.hidden = !0, this.recalculateWidth();\n  }\n  /**\n   * Add tool button and activate clicks\n   *\n   * @param {InlineTool} tool - InlineTool object\n   */\n  addTool(e) {\n    const t = e.create(), o = t.render();\n    if (!o) {\n      T(\"Render method must return an instance of Node\", \"warn\", e.name);\n      return;\n    }\n    if (o.dataset.tool = e.name, this.nodes.buttons.appendChild(o), this.toolsInstances.set(e.name, t), M(t.renderActions)) {\n      const a = t.renderActions();\n      this.nodes.actions.appendChild(a);\n    }\n    this.listeners.on(o, \"click\", (a) => {\n      this.toolClicked(t), a.preventDefault();\n    });\n    const i = this.getToolShortcut(e.name);\n    if (i)\n      try {\n        this.enableShortcuts(t, i);\n      } catch {\n      }\n    const n = c.make(\"div\"), r = z.t(\n      K.toolNames,\n      e.title || re(e.name)\n    );\n    n.appendChild(c.text(r)), i && n.appendChild(c.make(\"div\", this.CSS.inlineToolbarShortcut, {\n      textContent: ye(i)\n    })), te() === !1 && ge(o, n, {\n      placement: \"top\",\n      hidingDelay: 100\n    }), t.checkState(b.get());\n  }\n  /**\n   * Get shortcut name for tool\n   *\n   * @param toolName — Tool name\n   */\n  getToolShortcut(e) {\n    const { Tools: t } = this.Editor, o = t.inlineTools.get(e), i = t.internal.inlineTools;\n    return Array.from(i.keys()).includes(e) ? this.inlineTools[e][Et.Shortcut] : o.shortcut;\n  }\n  /**\n   * Enable Tool shortcut with Editor Shortcuts Module\n   *\n   * @param {InlineTool} tool - Tool instance\n   * @param {string} shortcut - shortcut according to the ShortcutData Module format\n   */\n  enableShortcuts(e, t) {\n    ae.add({\n      name: t,\n      handler: (o) => {\n        const { currentBlock: i } = this.Editor.BlockManager;\n        i && i.tool.enabledInlineTools && (o.preventDefault(), this.toolClicked(e));\n      },\n      on: this.Editor.UI.nodes.redactor\n    });\n  }\n  /**\n   * Inline Tool button clicks\n   *\n   * @param {InlineTool} tool - Tool's instance\n   */\n  toolClicked(e) {\n    const t = b.range;\n    e.surround(t), this.checkToolsState(), e.renderActions !== void 0 && this.flipper.deactivate();\n  }\n  /**\n   * Check Tools` state by selection\n   */\n  checkToolsState() {\n    this.toolsInstances.forEach((e) => {\n      e.checkState(b.get());\n    });\n  }\n  /**\n   * Get inline tools tools\n   * Tools that has isInline is true\n   */\n  get inlineTools() {\n    const e = {};\n    return Array.from(this.Editor.Tools.inlineTools.entries()).forEach(([t, o]) => {\n      e[t] = o.create();\n    }), e;\n  }\n  /**\n   * Allow to leaf buttons by arrows / tab\n   * Buttons will be filled on opening\n   */\n  enableFlipper() {\n    this.flipper = new q({\n      focusedItemClass: this.CSS.focusedButton,\n      allowedKeys: [\n        v.ENTER,\n        v.TAB\n      ]\n    });\n  }\n}\nclass ei extends y {\n  /**\n   * All keydowns on Block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  keydown(e) {\n    switch (this.beforeKeydownProcessing(e), e.keyCode) {\n      case v.BACKSPACE:\n        this.backspace(e);\n        break;\n      case v.DELETE:\n        this.delete(e);\n        break;\n      case v.ENTER:\n        this.enter(e);\n        break;\n      case v.DOWN:\n      case v.RIGHT:\n        this.arrowRightAndDown(e);\n        break;\n      case v.UP:\n      case v.LEFT:\n        this.arrowLeftAndUp(e);\n        break;\n      case v.TAB:\n        this.tabPressed(e);\n        break;\n    }\n    e.key === \"/\" && !e.ctrlKey && !e.metaKey && this.slashPressed(), e.code === \"Slash\" && (e.ctrlKey || e.metaKey) && (e.preventDefault(), this.commandSlashPressed());\n  }\n  /**\n   * Fires on keydown before event processing\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  beforeKeydownProcessing(e) {\n    this.needToolbarClosing(e) && lt(e.keyCode) && (this.Editor.Toolbar.close(), this.Editor.ConversionToolbar.close(), e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || this.Editor.BlockSelection.clearSelection(e));\n  }\n  /**\n   * Key up on Block:\n   * - shows Inline Toolbar if something selected\n   * - shows conversion toolbar with 85% of block selection\n   *\n   * @param {KeyboardEvent} event - keyup event\n   */\n  keyup(e) {\n    e.shiftKey || this.Editor.UI.checkEmptiness();\n  }\n  /**\n   * Add drop target styles\n   *\n   * @param {DragEvent} event - drag over event\n   */\n  dragOver(e) {\n    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);\n    t.dropTarget = !0;\n  }\n  /**\n   * Remove drop target style\n   *\n   * @param {DragEvent} event - drag leave event\n   */\n  dragLeave(e) {\n    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);\n    t.dropTarget = !1;\n  }\n  /**\n   * Copying selected blocks\n   * Before putting to the clipboard we sanitize all blocks and then copy to the clipboard\n   *\n   * @param {ClipboardEvent} event - clipboard event\n   */\n  handleCommandC(e) {\n    const { BlockSelection: t } = this.Editor;\n    t.anyBlockSelected && t.copySelectedBlocks(e);\n  }\n  /**\n   * Copy and Delete selected Blocks\n   *\n   * @param {ClipboardEvent} event - clipboard event\n   */\n  handleCommandX(e) {\n    const { BlockSelection: t, BlockManager: o, Caret: i } = this.Editor;\n    t.anyBlockSelected && t.copySelectedBlocks(e).then(() => {\n      const n = o.removeSelectedBlocks(), r = o.insertDefaultBlockAtIndex(n, !0);\n      i.setToBlock(r, i.positions.START), t.clearSelection(e);\n    });\n  }\n  /**\n   * Tab pressed inside a Block.\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  tabPressed(e) {\n    const { InlineToolbar: t, ConversionToolbar: o, Caret: i } = this.Editor;\n    if (o.opened || t.opened)\n      return;\n    (e.shiftKey ? i.navigatePrevious(!0) : i.navigateNext(!0)) && e.preventDefault();\n  }\n  /**\n   * '/' + 'command' keydown inside a Block\n   */\n  commandSlashPressed() {\n    this.Editor.BlockSelection.selectedBlocks.length > 1 || this.activateBlockSettings();\n  }\n  /**\n   * '/' keydown inside a Block\n   */\n  slashPressed() {\n    this.Editor.BlockManager.currentBlock.isEmpty && this.activateToolbox();\n  }\n  /**\n   * ENTER pressed on block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  enter(e) {\n    const { BlockManager: t, UI: o } = this.Editor;\n    if (t.currentBlock.tool.isLineBreaksEnabled || o.someToolbarOpened && o.someFlipperButtonFocused || e.shiftKey)\n      return;\n    let n = this.Editor.BlockManager.currentBlock;\n    this.Editor.Caret.isAtStart && !this.Editor.BlockManager.currentBlock.hasMedia ? this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex) : this.Editor.Caret.isAtEnd ? n = this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex + 1) : n = this.Editor.BlockManager.split(), this.Editor.Caret.setToBlock(n), this.Editor.Toolbar.moveAndOpen(n), e.preventDefault();\n  }\n  /**\n   * Handle backspace keydown on Block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  backspace(e) {\n    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i, previousBlock: n } = t;\n    if (!b.isCollapsed || !o.isAtStart)\n      return;\n    if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.firstInput)) {\n      o.navigatePrevious();\n      return;\n    }\n    if (n === null)\n      return;\n    if (n.isEmpty) {\n      t.removeBlock(n);\n      return;\n    }\n    if (i.isEmpty) {\n      t.removeBlock(i);\n      const l = t.currentBlock;\n      o.setToBlock(l, o.positions.END);\n      return;\n    }\n    ot(i, n) ? this.mergeBlocks(n, i) : o.setToBlock(n, o.positions.END);\n  }\n  /**\n   * Handles delete keydown on Block\n   * Removes char after the caret.\n   * If caret is at the end of the block, merge next block with current\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  delete(e) {\n    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i, nextBlock: n } = t;\n    if (!b.isCollapsed || !o.isAtEnd)\n      return;\n    if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.lastInput)) {\n      o.navigateNext();\n      return;\n    }\n    if (n === null)\n      return;\n    if (n.isEmpty) {\n      t.removeBlock(n);\n      return;\n    }\n    if (i.isEmpty) {\n      t.removeBlock(i), o.setToBlock(n, o.positions.START);\n      return;\n    }\n    ot(i, n) ? this.mergeBlocks(i, n) : o.setToBlock(n, o.positions.START);\n  }\n  /**\n   * Merge passed Blocks\n   *\n   * @param targetBlock - to which Block we want to merge\n   * @param blockToMerge - what Block we want to merge\n   */\n  mergeBlocks(e, t) {\n    const { BlockManager: o, Caret: i, Toolbar: n } = this.Editor;\n    i.createShadow(e.pluginsContent), o.mergeBlocks(e, t).then(() => {\n      window.requestAnimationFrame(() => {\n        i.restoreCaret(e.pluginsContent), e.pluginsContent.normalize(), n.close();\n      });\n    });\n  }\n  /**\n   * Handle right and down keyboard keys\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  arrowRightAndDown(e) {\n    const t = q.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === v.TAB);\n    if (this.Editor.UI.someToolbarOpened && t)\n      return;\n    this.Editor.Toolbar.close();\n    const o = this.Editor.Caret.isAtEnd || this.Editor.BlockSelection.anyBlockSelected;\n    if (e.shiftKey && e.keyCode === v.DOWN && o) {\n      this.Editor.CrossBlockSelection.toggleBlockSelectedState();\n      return;\n    }\n    if (e.keyCode === v.DOWN || e.keyCode === v.RIGHT && !this.isRtl ? this.Editor.Caret.navigateNext() : this.Editor.Caret.navigatePrevious()) {\n      e.preventDefault();\n      return;\n    }\n    xe(() => {\n      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();\n    }, 20)(), this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Handle left and up keyboard keys\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  arrowLeftAndUp(e) {\n    if (this.Editor.UI.someToolbarOpened) {\n      if (q.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === v.TAB))\n        return;\n      this.Editor.UI.closeAllToolbars();\n    }\n    this.Editor.Toolbar.close();\n    const t = this.Editor.Caret.isAtStart || this.Editor.BlockSelection.anyBlockSelected;\n    if (e.shiftKey && e.keyCode === v.UP && t) {\n      this.Editor.CrossBlockSelection.toggleBlockSelectedState(!1);\n      return;\n    }\n    if (e.keyCode === v.UP || e.keyCode === v.LEFT && !this.isRtl ? this.Editor.Caret.navigatePrevious() : this.Editor.Caret.navigateNext()) {\n      e.preventDefault();\n      return;\n    }\n    xe(() => {\n      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();\n    }, 20)(), this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Cases when we need to close Toolbar\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  needToolbarClosing(e) {\n    const t = e.keyCode === v.ENTER && this.Editor.Toolbar.toolbox.opened, o = e.keyCode === v.ENTER && this.Editor.BlockSettings.opened, i = e.keyCode === v.ENTER && this.Editor.InlineToolbar.opened, n = e.keyCode === v.ENTER && this.Editor.ConversionToolbar.opened, r = e.keyCode === v.TAB;\n    return !(e.shiftKey || r || t || o || i || n);\n  }\n  /**\n   * If Toolbox is not open, then just open it and show plus button\n   */\n  activateToolbox() {\n    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open();\n  }\n  /**\n   * Open Toolbar and show BlockSettings before flipping Tools\n   */\n  activateBlockSettings() {\n    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.opened || this.Editor.BlockSettings.open();\n  }\n}\nclass Se {\n  /**\n   * @class\n   * @param {HTMLElement} workingArea — editor`s working node\n   */\n  constructor(e) {\n    this.blocks = [], this.workingArea = e;\n  }\n  /**\n   * Get length of Block instances array\n   *\n   * @returns {number}\n   */\n  get length() {\n    return this.blocks.length;\n  }\n  /**\n   * Get Block instances array\n   *\n   * @returns {Block[]}\n   */\n  get array() {\n    return this.blocks;\n  }\n  /**\n   * Get blocks html elements array\n   *\n   * @returns {HTMLElement[]}\n   */\n  get nodes() {\n    return ct(this.workingArea.children);\n  }\n  /**\n   * Proxy trap to implement array-like setter\n   *\n   * @example\n   * blocks[0] = new Block(...)\n   * @param {Blocks} instance — Blocks instance\n   * @param {PropertyKey} property — block index or any Blocks class property key to set\n   * @param {Block} value — value to set\n   * @returns {boolean}\n   */\n  static set(e, t, o) {\n    return isNaN(Number(t)) ? (Reflect.set(e, t, o), !0) : (e.insert(+t, o), !0);\n  }\n  /**\n   * Proxy trap to implement array-like getter\n   *\n   * @param {Blocks} instance — Blocks instance\n   * @param {PropertyKey} property — Blocks class property key\n   * @returns {Block|*}\n   */\n  static get(e, t) {\n    return isNaN(Number(t)) ? Reflect.get(e, t) : e.get(+t);\n  }\n  /**\n   * Push new Block to the blocks array and append it to working area\n   *\n   * @param {Block} block - Block to add\n   */\n  push(e) {\n    this.blocks.push(e), this.insertToDOM(e);\n  }\n  /**\n   * Swaps blocks with indexes first and second\n   *\n   * @param {number} first - first block index\n   * @param {number} second - second block index\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    const o = this.blocks[t];\n    c.swap(this.blocks[e].holder, o.holder), this.blocks[t] = this.blocks[e], this.blocks[e] = o;\n  }\n  /**\n   * Move a block from one to another index\n   *\n   * @param {number} toIndex - new index of the block\n   * @param {number} fromIndex - block to move\n   */\n  move(e, t) {\n    const o = this.blocks.splice(t, 1)[0], i = e - 1, n = Math.max(0, i), r = this.blocks[n];\n    e > 0 ? this.insertToDOM(o, \"afterend\", r) : this.insertToDOM(o, \"beforebegin\", r), this.blocks.splice(e, 0, o);\n    const a = this.composeBlockEvent(\"move\", {\n      fromIndex: t,\n      toIndex: e\n    });\n    o.call(X.MOVED, a);\n  }\n  /**\n   * Insert new Block at passed index\n   *\n   * @param {number} index — index to insert Block\n   * @param {Block} block — Block to insert\n   * @param {boolean} replace — it true, replace block on given index\n   */\n  insert(e, t, o = !1) {\n    if (!this.length) {\n      this.push(t);\n      return;\n    }\n    e > this.length && (e = this.length), o && (this.blocks[e].holder.remove(), this.blocks[e].call(X.REMOVED));\n    const i = o ? 1 : 0;\n    if (this.blocks.splice(e, i, t), e > 0) {\n      const n = this.blocks[e - 1];\n      this.insertToDOM(t, \"afterend\", n);\n    } else {\n      const n = this.blocks[e + 1];\n      n ? this.insertToDOM(t, \"beforebegin\", n) : this.insertToDOM(t);\n    }\n  }\n  /**\n   * Replaces block under passed index with passed block\n   *\n   * @param index - index of existed block\n   * @param block - new block\n   */\n  replace(e, t) {\n    if (this.blocks[e] === void 0)\n      throw Error(\"Incorrect index\");\n    this.blocks[e].holder.replaceWith(t.holder), this.blocks[e] = t;\n  }\n  /**\n   * Inserts several blocks at once\n   *\n   * @param blocks - blocks to insert\n   * @param index - index to insert blocks at\n   */\n  insertMany(e, t) {\n    const o = new DocumentFragment();\n    for (const i of e)\n      o.appendChild(i.holder);\n    if (this.length > 0) {\n      if (t > 0) {\n        const i = Math.min(t - 1, this.length - 1);\n        this.blocks[i].holder.after(o);\n      } else\n        t === 0 && this.workingArea.prepend(o);\n      this.blocks.splice(t, 0, ...e);\n    } else\n      this.blocks.push(...e), this.workingArea.appendChild(o);\n    e.forEach((i) => i.call(X.RENDERED));\n  }\n  /**\n   * Remove block\n   *\n   * @param {number} index - index of Block to remove\n   */\n  remove(e) {\n    isNaN(e) && (e = this.length - 1), this.blocks[e].holder.remove(), this.blocks[e].call(X.REMOVED), this.blocks.splice(e, 1);\n  }\n  /**\n   * Remove all blocks\n   */\n  removeAll() {\n    this.workingArea.innerHTML = \"\", this.blocks.forEach((e) => e.call(X.REMOVED)), this.blocks.length = 0;\n  }\n  /**\n   * Insert Block after passed target\n   *\n   * @todo decide if this method is necessary\n   * @param {Block} targetBlock — target after which Block should be inserted\n   * @param {Block} newBlock — Block to insert\n   */\n  insertAfter(e, t) {\n    const o = this.blocks.indexOf(e);\n    this.insert(o + 1, t);\n  }\n  /**\n   * Get Block by index\n   *\n   * @param {number} index — Block index\n   * @returns {Block}\n   */\n  get(e) {\n    return this.blocks[e];\n  }\n  /**\n   * Return index of passed Block\n   *\n   * @param {Block} block - Block to find\n   * @returns {number}\n   */\n  indexOf(e) {\n    return this.blocks.indexOf(e);\n  }\n  /**\n   * Insert new Block into DOM\n   *\n   * @param {Block} block - Block to insert\n   * @param {InsertPosition} position — insert position (if set, will use insertAdjacentElement)\n   * @param {Block} target — Block related to position\n   */\n  insertToDOM(e, t, o) {\n    t ? o.holder.insertAdjacentElement(t, e.holder) : this.workingArea.appendChild(e.holder), e.call(X.RENDERED);\n  }\n  /**\n   * Composes Block event with passed type and details\n   *\n   * @param {string} type - event type\n   * @param {object} detail - event detail\n   */\n  composeBlockEvent(e, t) {\n    return new CustomEvent(e, {\n      detail: t\n    });\n  }\n}\nconst nt = \"block-removed\", st = \"block-added\", ti = \"block-moved\", rt = \"block-changed\";\nclass oi {\n  constructor() {\n    this.completed = Promise.resolve();\n  }\n  /**\n   * Add new promise to queue\n   *\n   * @param operation - promise should be added to queue\n   */\n  add(e) {\n    return new Promise((t, o) => {\n      this.completed = this.completed.then(e).then(t).catch(o);\n    });\n  }\n}\nclass ii extends y {\n  constructor() {\n    super(...arguments), this._currentBlockIndex = -1, this._blocks = null;\n  }\n  /**\n   * Returns current Block index\n   *\n   * @returns {number}\n   */\n  get currentBlockIndex() {\n    return this._currentBlockIndex;\n  }\n  /**\n   * Set current Block index and fire Block lifecycle callbacks\n   *\n   * @param {number} newIndex - index of Block to set as current\n   */\n  set currentBlockIndex(e) {\n    this._currentBlockIndex = e;\n  }\n  /**\n   * returns first Block\n   *\n   * @returns {Block}\n   */\n  get firstBlock() {\n    return this._blocks[0];\n  }\n  /**\n   * returns last Block\n   *\n   * @returns {Block}\n   */\n  get lastBlock() {\n    return this._blocks[this._blocks.length - 1];\n  }\n  /**\n   * Get current Block instance\n   *\n   * @returns {Block}\n   */\n  get currentBlock() {\n    return this._blocks[this.currentBlockIndex];\n  }\n  /**\n   * Set passed Block as a current\n   *\n   * @param block - block to set as a current\n   */\n  set currentBlock(e) {\n    this.currentBlockIndex = this.getBlockIndex(e);\n  }\n  /**\n   * Returns next Block instance\n   *\n   * @returns {Block|null}\n   */\n  get nextBlock() {\n    return this.currentBlockIndex === this._blocks.length - 1 ? null : this._blocks[this.currentBlockIndex + 1];\n  }\n  /**\n   * Return first Block with inputs after current Block\n   *\n   * @returns {Block | undefined}\n   */\n  get nextContentfulBlock() {\n    return this.blocks.slice(this.currentBlockIndex + 1).find((t) => !!t.inputs.length);\n  }\n  /**\n   * Return first Block with inputs before current Block\n   *\n   * @returns {Block | undefined}\n   */\n  get previousContentfulBlock() {\n    return this.blocks.slice(0, this.currentBlockIndex).reverse().find((t) => !!t.inputs.length);\n  }\n  /**\n   * Returns previous Block instance\n   *\n   * @returns {Block|null}\n   */\n  get previousBlock() {\n    return this.currentBlockIndex === 0 ? null : this._blocks[this.currentBlockIndex - 1];\n  }\n  /**\n   * Get array of Block instances\n   *\n   * @returns {Block[]} {@link Blocks#array}\n   */\n  get blocks() {\n    return this._blocks.array;\n  }\n  /**\n   * Check if each Block is empty\n   *\n   * @returns {boolean}\n   */\n  get isEditorEmpty() {\n    return this.blocks.every((e) => e.isEmpty);\n  }\n  /**\n   * Should be called after Editor.UI preparation\n   * Define this._blocks property\n   */\n  prepare() {\n    const e = new Se(this.Editor.UI.nodes.redactor);\n    this._blocks = new Proxy(e, {\n      set: Se.set,\n      get: Se.get\n    }), this.listeners.on(\n      document,\n      \"copy\",\n      (t) => this.Editor.BlockEvents.handleCommandC(t)\n    );\n  }\n  /**\n   * Toggle read-only state\n   *\n   * If readOnly is true:\n   *  - Unbind event handlers from created Blocks\n   *\n   * if readOnly is false:\n   *  - Bind event handlers to all existing Blocks\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : this.enableModuleBindings();\n  }\n  /**\n   * Creates Block instance by tool name\n   *\n   * @param {object} options - block creation options\n   * @param {string} options.tool - tools passed in editor config {@link EditorConfig#tools}\n   * @param {string} [options.id] - unique id for this block\n   * @param {BlockToolData} [options.data] - constructor params\n   * @returns {Block}\n   */\n  composeBlock({\n    tool: e,\n    data: t = {},\n    id: o = void 0,\n    tunes: i = {}\n  }) {\n    const n = this.Editor.ReadOnly.isEnabled, r = this.Editor.Tools.blockTools.get(e), a = new R({\n      id: o,\n      data: t,\n      tool: r,\n      api: this.Editor.API,\n      readOnly: n,\n      tunesData: i\n    }, this.eventsDispatcher);\n    return n || window.requestIdleCallback(() => {\n      this.bindBlockEvents(a);\n    }, { timeout: 2e3 }), a;\n  }\n  /**\n   * Insert new block into _blocks\n   *\n   * @param {object} options - insert options\n   * @param {string} [options.id] - block's unique id\n   * @param {string} [options.tool] - plugin name, by default method inserts the default block type\n   * @param {object} [options.data] - plugin data\n   * @param {number} [options.index] - index where to insert new Block\n   * @param {boolean} [options.needToFocus] - flag shows if needed to update current Block index\n   * @param {boolean} [options.replace] - flag shows if block by passed index should be replaced with inserted one\n   * @returns {Block}\n   */\n  insert({\n    id: e = void 0,\n    tool: t = this.config.defaultBlock,\n    data: o = {},\n    index: i,\n    needToFocus: n = !0,\n    replace: r = !1,\n    tunes: a = {}\n  } = {}) {\n    let l = i;\n    l === void 0 && (l = this.currentBlockIndex + (r ? 0 : 1));\n    const d = this.composeBlock({\n      id: e,\n      tool: t,\n      data: o,\n      tunes: a\n    });\n    return r && this.blockDidMutated(nt, this.getBlockByIndex(l), {\n      index: l\n    }), this._blocks.insert(l, d, r), this.blockDidMutated(st, d, {\n      index: l\n    }), n ? this.currentBlockIndex = l : l <= this.currentBlockIndex && this.currentBlockIndex++, d;\n  }\n  /**\n   * Inserts several blocks at once\n   *\n   * @param blocks - blocks to insert\n   * @param index - index where to insert\n   */\n  insertMany(e, t = 0) {\n    this._blocks.insertMany(e, t);\n  }\n  /**\n   * Update Block data.\n   *\n   * Currently we don't have an 'update' method in the Tools API, so we just create a new block with the same id and type\n   * Should not trigger 'block-removed' or 'block-added' events\n   *\n   * @param block - block to update\n   * @param data - new data\n   */\n  async update(e, t) {\n    const o = await e.data, i = this.composeBlock({\n      id: e.id,\n      tool: e.name,\n      data: Object.assign({}, o, t),\n      tunes: e.tunes\n    }), n = this.getBlockIndex(e);\n    return this._blocks.replace(n, i), this.blockDidMutated(rt, i, {\n      index: n\n    }), i;\n  }\n  /**\n   * Replace passed Block with the new one with specified Tool and data\n   *\n   * @param block - block to replace\n   * @param newTool - new Tool name\n   * @param data - new Tool data\n   */\n  replace(e, t, o) {\n    const i = this.getBlockIndex(e);\n    this.insert({\n      tool: t,\n      data: o,\n      index: i,\n      replace: !0\n    });\n  }\n  /**\n   * Insert pasted content. Call onPaste callback after insert.\n   *\n   * @param {string} toolName - name of Tool to insert\n   * @param {PasteEvent} pasteEvent - pasted data\n   * @param {boolean} replace - should replace current block\n   */\n  paste(e, t, o = !1) {\n    const i = this.insert({\n      tool: e,\n      replace: o\n    });\n    try {\n      window.requestIdleCallback(() => {\n        i.call(X.ON_PASTE, t);\n      });\n    } catch (n) {\n      T(`${e}: onPaste callback call is failed`, \"error\", n);\n    }\n    return i;\n  }\n  /**\n   * Insert new default block at passed index\n   *\n   * @param {number} index - index where Block should be inserted\n   * @param {boolean} needToFocus - if true, updates current Block index\n   *\n   * TODO: Remove method and use insert() with index instead (?)\n   * @returns {Block} inserted Block\n   */\n  insertDefaultBlockAtIndex(e, t = !1) {\n    const o = this.composeBlock({ tool: this.config.defaultBlock });\n    return this._blocks[e] = o, this.blockDidMutated(st, o, {\n      index: e\n    }), t ? this.currentBlockIndex = e : e <= this.currentBlockIndex && this.currentBlockIndex++, o;\n  }\n  /**\n   * Always inserts at the end\n   *\n   * @returns {Block}\n   */\n  insertAtEnd() {\n    return this.currentBlockIndex = this.blocks.length - 1, this.insert();\n  }\n  /**\n   * Merge two blocks\n   *\n   * @param {Block} targetBlock - previous block will be append to this block\n   * @param {Block} blockToMerge - block that will be merged with target block\n   * @returns {Promise} - the sequence that can be continued\n   */\n  async mergeBlocks(e, t) {\n    const o = await t.data;\n    W(o) || await e.mergeWith(o), this.removeBlock(t), this.currentBlockIndex = this._blocks.indexOf(e);\n  }\n  /**\n   * Remove passed Block\n   *\n   * @param block - Block to remove\n   * @param addLastBlock - if true, adds new default block at the end. @todo remove this logic and use event-bus instead\n   */\n  removeBlock(e, t = !0) {\n    return new Promise((o) => {\n      const i = this._blocks.indexOf(e);\n      if (!this.validateIndex(i))\n        throw new Error(\"Can't find a Block to remove\");\n      e.destroy(), this._blocks.remove(i), this.blockDidMutated(nt, e, {\n        index: i\n      }), this.currentBlockIndex >= i && this.currentBlockIndex--, this.blocks.length ? i === 0 && (this.currentBlockIndex = 0) : (this.currentBlockIndex = -1, t && this.insert()), o();\n    });\n  }\n  /**\n   * Remove only selected Blocks\n   * and returns first Block index where started removing...\n   *\n   * @returns {number|undefined}\n   */\n  removeSelectedBlocks() {\n    let e;\n    for (let t = this.blocks.length - 1; t >= 0; t--)\n      this.blocks[t].selected && (this.removeBlock(this.blocks[t]), e = t);\n    return e;\n  }\n  /**\n   * Attention!\n   * After removing insert the new default typed Block and focus on it\n   * Removes all blocks\n   */\n  removeAllBlocks() {\n    for (let e = this.blocks.length - 1; e >= 0; e--)\n      this._blocks.remove(e);\n    this.currentBlockIndex = -1, this.insert(), this.currentBlock.firstInput.focus();\n  }\n  /**\n   * Split current Block\n   * 1. Extract content from Caret position to the Block`s end\n   * 2. Insert a new Block below current one with extracted content\n   *\n   * @returns {Block}\n   */\n  split() {\n    const e = this.Editor.Caret.extractFragmentFromCaretPosition(), t = c.make(\"div\");\n    t.appendChild(e);\n    const o = {\n      text: c.isEmpty(t) ? \"\" : t.innerHTML\n    };\n    return this.insert({ data: o });\n  }\n  /**\n   * Returns Block by passed index\n   *\n   * @param {number} index - index to get. -1 to get last\n   * @returns {Block}\n   */\n  getBlockByIndex(e) {\n    return e === -1 && (e = this._blocks.length - 1), this._blocks[e];\n  }\n  /**\n   * Returns an index for passed Block\n   *\n   * @param block - block to find index\n   */\n  getBlockIndex(e) {\n    return this._blocks.indexOf(e);\n  }\n  /**\n   * Returns the Block by passed id\n   *\n   * @param id - id of block to get\n   * @returns {Block}\n   */\n  getBlockById(e) {\n    return this._blocks.array.find((t) => t.id === e);\n  }\n  /**\n   * Get Block instance by html element\n   *\n   * @param {Node} element - html element to get Block by\n   */\n  getBlock(e) {\n    c.isElement(e) || (e = e.parentNode);\n    const t = this._blocks.nodes, o = e.closest(`.${R.CSS.wrapper}`), i = t.indexOf(o);\n    if (i >= 0)\n      return this._blocks[i];\n  }\n  /**\n   * 1) Find first-level Block from passed child Node\n   * 2) Mark it as current\n   *\n   * @param {Node} childNode - look ahead from this node.\n   * @returns {Block | undefined} can return undefined in case when the passed child note is not a part of the current editor instance\n   */\n  setCurrentBlockByChildNode(e) {\n    c.isElement(e) || (e = e.parentNode);\n    const t = e.closest(`.${R.CSS.wrapper}`);\n    if (!t)\n      return;\n    const o = t.closest(`.${this.Editor.UI.CSS.editorWrapper}`);\n    if (o != null && o.isEqualNode(this.Editor.UI.nodes.wrapper))\n      return this.currentBlockIndex = this._blocks.nodes.indexOf(t), this.currentBlock.updateCurrentInput(), this.currentBlock;\n  }\n  /**\n   * Return block which contents passed node\n   *\n   * @param {Node} childNode - node to get Block by\n   * @returns {Block}\n   */\n  getBlockByChildNode(e) {\n    if (!e || !(e instanceof Node))\n      return;\n    c.isElement(e) || (e = e.parentNode);\n    const t = e.closest(`.${R.CSS.wrapper}`);\n    return this.blocks.find((o) => o.holder === t);\n  }\n  /**\n   * Swap Blocks Position\n   *\n   * @param {number} fromIndex - index of first block\n   * @param {number} toIndex - index of second block\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    this._blocks.swap(e, t), this.currentBlockIndex = t;\n  }\n  /**\n   * Move a block to a new index\n   *\n   * @param {number} toIndex - index where to move Block\n   * @param {number} fromIndex - index of Block to move\n   */\n  move(e, t = this.currentBlockIndex) {\n    if (isNaN(e) || isNaN(t)) {\n      T(\"Warning during 'move' call: incorrect indices provided.\", \"warn\");\n      return;\n    }\n    if (!this.validateIndex(e) || !this.validateIndex(t)) {\n      T(\"Warning during 'move' call: indices cannot be lower than 0 or greater than the amount of blocks.\", \"warn\");\n      return;\n    }\n    this._blocks.move(e, t), this.currentBlockIndex = e, this.blockDidMutated(ti, this.currentBlock, {\n      fromIndex: t,\n      toIndex: e\n    });\n  }\n  /**\n   * Converts passed Block to the new Tool\n   * Uses Conversion Config\n   *\n   * @param blockToConvert - Block that should be converted\n   * @param targetToolName - name of the Tool to convert to\n   * @param blockDataOverrides - optional new Block data overrides\n   */\n  async convert(e, t, o) {\n    if (!await e.save())\n      throw new Error(\"Could not convert Block. Failed to extract original Block data.\");\n    const n = this.Editor.Tools.blockTools.get(t);\n    if (!n)\n      throw new Error(`Could not convert Block. Tool «${t}» not found.`);\n    const r = await e.exportDataAsString(), a = V(\n      r,\n      n.sanitizeConfig\n    );\n    let l = to(a, n.conversionConfig);\n    o && (l = Object.assign(l, o)), this.replace(e, n.name, l);\n  }\n  /**\n   * Sets current Block Index -1 which means unknown\n   * and clear highlights\n   */\n  dropPointer() {\n    this.currentBlockIndex = -1;\n  }\n  /**\n   * Clears Editor\n   *\n   * @param {boolean} needToAddDefaultBlock - 1) in internal calls (for example, in api.blocks.render)\n   *                                             we don't need to add an empty default block\n   *                                        2) in api.blocks.clear we should add empty block\n   */\n  async clear(e = !1) {\n    const t = new oi();\n    this.blocks.forEach((o) => {\n      t.add(async () => {\n        await this.removeBlock(o, !1);\n      });\n    }), await t.completed, this.dropPointer(), e && this.insert(), this.Editor.UI.checkEmptiness();\n  }\n  /**\n   * Cleans up all the block tools' resources\n   * This is called when editor is destroyed\n   */\n  async destroy() {\n    await Promise.all(this.blocks.map((e) => e.destroy()));\n  }\n  /**\n   * Bind Block events\n   *\n   * @param {Block} block - Block to which event should be bound\n   */\n  bindBlockEvents(e) {\n    const { BlockEvents: t } = this.Editor;\n    this.readOnlyMutableListeners.on(e.holder, \"keydown\", (o) => {\n      t.keydown(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"keyup\", (o) => {\n      t.keyup(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"dragover\", (o) => {\n      t.dragOver(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"dragleave\", (o) => {\n      t.dragLeave(o);\n    }), e.on(\"didMutated\", (o) => this.blockDidMutated(rt, o, {\n      index: this.getBlockIndex(o)\n    }));\n  }\n  /**\n   * Disable mutable handlers and bindings\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Enables all module handlers and bindings for all Blocks\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(\n      document,\n      \"cut\",\n      (e) => this.Editor.BlockEvents.handleCommandX(e)\n    ), this.blocks.forEach((e) => {\n      this.bindBlockEvents(e);\n    });\n  }\n  /**\n   * Validates that the given index is not lower than 0 or higher than the amount of blocks\n   *\n   * @param {number} index - index of blocks array to validate\n   * @returns {boolean}\n   */\n  validateIndex(e) {\n    return !(e < 0 || e >= this._blocks.length);\n  }\n  /**\n   * Block mutation callback\n   *\n   * @param mutationType - what happened with block\n   * @param block - mutated block\n   * @param detailData - additional data to pass with change event\n   */\n  blockDidMutated(e, t, o) {\n    const i = new CustomEvent(e, {\n      detail: {\n        target: new ee(t),\n        ...o\n      }\n    });\n    return this.eventsDispatcher.emit(pt, {\n      event: i\n    }), t;\n  }\n}\nclass ni extends y {\n  constructor() {\n    super(...arguments), this.anyBlockSelectedCache = null, this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;\n  }\n  /**\n   * Sanitizer Config\n   *\n   * @returns {SanitizerConfig}\n   */\n  get sanitizerConfig() {\n    return {\n      p: {},\n      h1: {},\n      h2: {},\n      h3: {},\n      h4: {},\n      h5: {},\n      h6: {},\n      ol: {},\n      ul: {},\n      li: {},\n      br: !0,\n      img: {\n        src: !0,\n        width: !0,\n        height: !0\n      },\n      a: {\n        href: !0\n      },\n      b: {},\n      i: {},\n      u: {}\n    };\n  }\n  /**\n   * Flag that identifies all Blocks selection\n   *\n   * @returns {boolean}\n   */\n  get allBlocksSelected() {\n    const { BlockManager: e } = this.Editor;\n    return e.blocks.every((t) => t.selected === !0);\n  }\n  /**\n   * Set selected all blocks\n   *\n   * @param {boolean} state - state to set\n   */\n  set allBlocksSelected(e) {\n    const { BlockManager: t } = this.Editor;\n    t.blocks.forEach((o) => {\n      o.selected = e;\n    }), this.clearCache();\n  }\n  /**\n   * Flag that identifies any Block selection\n   *\n   * @returns {boolean}\n   */\n  get anyBlockSelected() {\n    const { BlockManager: e } = this.Editor;\n    return this.anyBlockSelectedCache === null && (this.anyBlockSelectedCache = e.blocks.some((t) => t.selected === !0)), this.anyBlockSelectedCache;\n  }\n  /**\n   * Return selected Blocks array\n   *\n   * @returns {Block[]}\n   */\n  get selectedBlocks() {\n    return this.Editor.BlockManager.blocks.filter((e) => e.selected);\n  }\n  /**\n   * Module Preparation\n   * Registers Shortcuts CMD+A and CMD+C\n   * to select all and copy them\n   */\n  prepare() {\n    this.selection = new b(), ae.add({\n      name: \"CMD+A\",\n      handler: (e) => {\n        const { BlockManager: t, ReadOnly: o } = this.Editor;\n        if (o.isEnabled) {\n          e.preventDefault(), this.selectAllBlocks();\n          return;\n        }\n        t.currentBlock && this.handleCommandA(e);\n      },\n      on: this.Editor.UI.nodes.redactor\n    });\n  }\n  /**\n   * Toggle read-only state\n   *\n   *  - Remove all ranges\n   *  - Unselect all Blocks\n   */\n  toggleReadOnly() {\n    b.get().removeAllRanges(), this.allBlocksSelected = !1;\n  }\n  /**\n   * Remove selection of Block\n   *\n   * @param {number?} index - Block index according to the BlockManager's indexes\n   */\n  unSelectBlockByIndex(e) {\n    const { BlockManager: t } = this.Editor;\n    let o;\n    isNaN(e) ? o = t.currentBlock : o = t.getBlockByIndex(e), o.selected = !1, this.clearCache();\n  }\n  /**\n   * Clear selection from Blocks\n   *\n   * @param {Event} reason - event caused clear of selection\n   * @param {boolean} restoreSelection - if true, restore saved selection\n   */\n  clearSelection(e, t = !1) {\n    const { BlockManager: o, Caret: i, RectangleSelection: n } = this.Editor;\n    this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;\n    const r = e && e instanceof KeyboardEvent, a = r && lt(e.keyCode);\n    if (this.anyBlockSelected && r && a && !b.isSelectionExists) {\n      const l = o.removeSelectedBlocks();\n      o.insertDefaultBlockAtIndex(l, !0), i.setToBlock(o.currentBlock), xe(() => {\n        const d = e.key;\n        i.insertContentAtCaretPosition(d.length > 1 ? \"\" : d);\n      }, 20)();\n    }\n    if (this.Editor.CrossBlockSelection.clear(e), !this.anyBlockSelected || n.isRectActivated()) {\n      this.Editor.RectangleSelection.clearSelection();\n      return;\n    }\n    t && this.selection.restore(), this.allBlocksSelected = !1;\n  }\n  /**\n   * Reduce each Block and copy its content\n   *\n   * @param {ClipboardEvent} e - copy/cut event\n   * @returns {Promise<void>}\n   */\n  copySelectedBlocks(e) {\n    e.preventDefault();\n    const t = c.make(\"div\");\n    this.selectedBlocks.forEach((n) => {\n      const r = V(n.holder.innerHTML, this.sanitizerConfig), a = c.make(\"p\");\n      a.innerHTML = r, t.appendChild(a);\n    });\n    const o = Array.from(t.childNodes).map((n) => n.textContent).join(`\n\n`), i = t.innerHTML;\n    return e.clipboardData.setData(\"text/plain\", o), e.clipboardData.setData(\"text/html\", i), Promise.all(this.selectedBlocks.map((n) => n.save())).then((n) => {\n      try {\n        e.clipboardData.setData(this.Editor.Paste.MIME_TYPE, JSON.stringify(n));\n      } catch {\n      }\n    });\n  }\n  /**\n   * Select Block by its index\n   *\n   * @param {number?} index - Block index according to the BlockManager's indexes\n   */\n  selectBlockByIndex(e) {\n    const { BlockManager: t } = this.Editor, o = t.getBlockByIndex(e);\n    o !== void 0 && this.selectBlock(o);\n  }\n  /**\n   * Select passed Block\n   *\n   * @param {Block} block - Block to select\n   */\n  selectBlock(e) {\n    this.selection.save(), b.get().removeAllRanges(), e.selected = !0, this.clearCache(), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * Remove selection from passed Block\n   *\n   * @param {Block} block - Block to unselect\n   */\n  unselectBlock(e) {\n    e.selected = !1, this.clearCache();\n  }\n  /**\n   * Clear anyBlockSelected cache\n   */\n  clearCache() {\n    this.anyBlockSelectedCache = null;\n  }\n  /**\n   * Module destruction\n   * De-registers Shortcut CMD+A\n   */\n  destroy() {\n    ae.remove(this.Editor.UI.nodes.redactor, \"CMD+A\");\n  }\n  /**\n   * First CMD+A selects all input content by native behaviour,\n   * next CMD+A keypress selects all blocks\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  handleCommandA(e) {\n    if (this.Editor.RectangleSelection.clearSelection(), c.isNativeInput(e.target) && !this.readyToBlockSelection) {\n      this.readyToBlockSelection = !0;\n      return;\n    }\n    const t = this.Editor.BlockManager.getBlock(e.target), o = t.inputs;\n    if (o.length > 1 && !this.readyToBlockSelection) {\n      this.readyToBlockSelection = !0;\n      return;\n    }\n    if (o.length === 1 && !this.needToSelectAll) {\n      this.needToSelectAll = !0;\n      return;\n    }\n    this.needToSelectAll ? (e.preventDefault(), this.selectAllBlocks(), this.needToSelectAll = !1, this.readyToBlockSelection = !1, this.Editor.ConversionToolbar.close()) : this.readyToBlockSelection && (e.preventDefault(), this.selectBlock(t), this.needToSelectAll = !0);\n  }\n  /**\n   * Select All Blocks\n   * Each Block has selected setter that makes Block copyable\n   */\n  selectAllBlocks() {\n    this.selection.save(), b.get().removeAllRanges(), this.allBlocksSelected = !0, this.Editor.InlineToolbar.close();\n  }\n}\nclass we extends y {\n  /**\n   * Allowed caret positions in input\n   *\n   * @static\n   * @returns {{START: string, END: string, DEFAULT: string}}\n   */\n  get positions() {\n    return {\n      START: \"start\",\n      END: \"end\",\n      DEFAULT: \"default\"\n    };\n  }\n  /**\n   * Elements styles that can be useful for Caret Module\n   */\n  static get CSS() {\n    return {\n      shadowCaret: \"cdx-shadow-caret\"\n    };\n  }\n  /**\n   * Get's deepest first node and checks if offset is zero\n   *\n   * @returns {boolean}\n   */\n  get isAtStart() {\n    const { currentBlock: e } = this.Editor.BlockManager;\n    if (!e.focusable)\n      return !0;\n    const t = b.get(), o = c.getDeepestNode(e.currentInput);\n    let i = t.focusNode;\n    if (c.isNativeInput(o))\n      return o.selectionEnd === 0;\n    if (!t.anchorNode)\n      return !1;\n    let n = i.textContent.search(/\\S/);\n    n === -1 && (n = 0);\n    let r = t.focusOffset;\n    return i.nodeType !== Node.TEXT_NODE && i.childNodes.length && (i.childNodes[r] ? (i = i.childNodes[r], r = 0) : (i = i.childNodes[r - 1], r = i.textContent.length)), (c.isLineBreakTag(o) || c.isEmpty(o)) && this.getHigherLevelSiblings(i, \"left\").every((d) => {\n      const u = c.isLineBreakTag(d), h = d.children.length === 1 && c.isLineBreakTag(d.children[0]), f = u || h;\n      return c.isEmpty(d) && !f;\n    }) && r === n ? !0 : o === null || i === o && r <= n;\n  }\n  /**\n   * Get's deepest last node and checks if offset is last node text length\n   *\n   * @returns {boolean}\n   */\n  get isAtEnd() {\n    const { currentBlock: e } = this.Editor.BlockManager;\n    if (!e.focusable)\n      return !0;\n    const t = b.get();\n    let o = t.focusNode;\n    const i = c.getDeepestNode(e.currentInput, !0);\n    if (c.isNativeInput(i))\n      return i.selectionEnd === i.value.length;\n    if (!t.focusNode)\n      return !1;\n    let n = t.focusOffset;\n    if (o.nodeType !== Node.TEXT_NODE && o.childNodes.length && (o.childNodes[n - 1] ? (o = o.childNodes[n - 1], n = o.textContent.length) : (o = o.childNodes[0], n = 0)), c.isLineBreakTag(i) || c.isEmpty(i)) {\n      const a = this.getHigherLevelSiblings(o, \"right\");\n      if (a.every((d, u) => u === a.length - 1 && c.isLineBreakTag(d) || c.isEmpty(d) && !c.isLineBreakTag(d)) && n === o.textContent.length)\n        return !0;\n    }\n    const r = i.textContent.replace(/\\s+$/, \"\");\n    return o === i && n >= r.length;\n  }\n  /**\n   * Method gets Block instance and puts caret to the text node with offset\n   * There two ways that method applies caret position:\n   *   - first found text node: sets at the beginning, but you can pass an offset\n   *   - last found text node: sets at the end of the node. Also, you can customize the behaviour\n   *\n   * @param {Block} block - Block class\n   * @param {string} position - position where to set caret.\n   *                            If default - leave default behaviour and apply offset if it's passed\n   * @param {number} offset - caret offset regarding to the text node\n   */\n  setToBlock(e, t = this.positions.DEFAULT, o = 0) {\n    var d;\n    const { BlockManager: i, BlockSelection: n } = this.Editor;\n    if (n.clearSelection(), !e.focusable) {\n      (d = window.getSelection()) == null || d.removeAllRanges(), n.selectBlock(e), i.currentBlock = e;\n      return;\n    }\n    let r;\n    switch (t) {\n      case this.positions.START:\n        r = e.firstInput;\n        break;\n      case this.positions.END:\n        r = e.lastInput;\n        break;\n      default:\n        r = e.currentInput;\n    }\n    if (!r)\n      return;\n    const a = c.getDeepestNode(r, t === this.positions.END), l = c.getContentLength(a);\n    switch (!0) {\n      case t === this.positions.START:\n        o = 0;\n        break;\n      case t === this.positions.END:\n      case o > l:\n        o = l;\n        break;\n    }\n    this.set(a, o), i.setCurrentBlockByChildNode(e.holder), i.currentBlock.currentInput = r;\n  }\n  /**\n   * Set caret to the current input of current Block.\n   *\n   * @param {HTMLElement} input - input where caret should be set\n   * @param {string} position - position of the caret.\n   *                            If default - leave default behaviour and apply offset if it's passed\n   * @param {number} offset - caret offset regarding to the text node\n   */\n  setToInput(e, t = this.positions.DEFAULT, o = 0) {\n    const { currentBlock: i } = this.Editor.BlockManager, n = c.getDeepestNode(e);\n    switch (t) {\n      case this.positions.START:\n        this.set(n, 0);\n        break;\n      case this.positions.END:\n        this.set(n, c.getContentLength(n));\n        break;\n      default:\n        o && this.set(n, o);\n    }\n    i.currentInput = e;\n  }\n  /**\n   * Creates Document Range and sets caret to the element with offset\n   *\n   * @param {HTMLElement} element - target node.\n   * @param {number} offset - offset\n   */\n  set(e, t = 0) {\n    const { top: i, bottom: n } = b.setCursor(e, t), { innerHeight: r } = window;\n    i < 0 ? window.scrollBy(0, i - 30) : n > r && window.scrollBy(0, n - r + 30);\n  }\n  /**\n   * Set Caret to the last Block\n   * If last block is not empty, append another empty block\n   */\n  setToTheLastBlock() {\n    const e = this.Editor.BlockManager.lastBlock;\n    if (e)\n      if (e.tool.isDefault && e.isEmpty)\n        this.setToBlock(e);\n      else {\n        const t = this.Editor.BlockManager.insertAtEnd();\n        this.setToBlock(t);\n      }\n  }\n  /**\n   * Extract content fragment of current Block from Caret position to the end of the Block\n   */\n  extractFragmentFromCaretPosition() {\n    const e = b.get();\n    if (e.rangeCount) {\n      const t = e.getRangeAt(0), o = this.Editor.BlockManager.currentBlock.currentInput;\n      if (t.deleteContents(), o)\n        if (c.isNativeInput(o)) {\n          const i = o, n = document.createDocumentFragment(), r = i.value.substring(0, i.selectionStart), a = i.value.substring(i.selectionStart);\n          return n.textContent = a, i.value = r, n;\n        } else {\n          const i = t.cloneRange();\n          return i.selectNodeContents(o), i.setStart(t.endContainer, t.endOffset), i.extractContents();\n        }\n    }\n  }\n  /**\n   * Set's caret to the next Block or Tool`s input\n   * Before moving caret, we should check if caret position is at the end of Plugins node\n   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection\n   *\n   * @param {boolean} force - pass true to skip check for caret position\n   */\n  navigateNext(e = !1) {\n    const { BlockManager: t } = this.Editor, { currentBlock: o, nextBlock: i } = t, { nextInput: n } = o, r = this.isAtEnd;\n    let a = i;\n    const l = e || r;\n    if (n && l)\n      return this.setToInput(n, this.positions.START), !0;\n    if (a === null) {\n      if (o.tool.isDefault || !l)\n        return !1;\n      a = t.insertAtEnd();\n    }\n    return l ? (this.setToBlock(a, this.positions.START), !0) : !1;\n  }\n  /**\n   * Set's caret to the previous Tool`s input or Block\n   * Before moving caret, we should check if caret position is start of the Plugins node\n   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection\n   *\n   * @param {boolean} force - pass true to skip check for caret position\n   */\n  navigatePrevious(e = !1) {\n    const { currentBlock: t, previousBlock: o } = this.Editor.BlockManager;\n    if (!t)\n      return !1;\n    const { previousInput: i } = t, n = e || this.isAtStart;\n    return i && n ? (this.setToInput(i, this.positions.END), !0) : o !== null && n ? (this.setToBlock(o, this.positions.END), !0) : !1;\n  }\n  /**\n   * Inserts shadow element after passed element where caret can be placed\n   *\n   * @param {Element} element - element after which shadow caret should be inserted\n   */\n  createShadow(e) {\n    const t = document.createElement(\"span\");\n    t.classList.add(we.CSS.shadowCaret), e.insertAdjacentElement(\"beforeend\", t);\n  }\n  /**\n   * Restores caret position\n   *\n   * @param {HTMLElement} element - element where caret should be restored\n   */\n  restoreCaret(e) {\n    const t = e.querySelector(`.${we.CSS.shadowCaret}`);\n    if (!t)\n      return;\n    new b().expandToTag(t);\n    const i = document.createRange();\n    i.selectNode(t), i.extractContents();\n  }\n  /**\n   * Inserts passed content at caret position\n   *\n   * @param {string} content - content to insert\n   */\n  insertContentAtCaretPosition(e) {\n    const t = document.createDocumentFragment(), o = document.createElement(\"div\"), i = b.get(), n = b.range;\n    o.innerHTML = e, Array.from(o.childNodes).forEach((d) => t.appendChild(d)), t.childNodes.length === 0 && t.appendChild(new Text());\n    const r = t.lastChild;\n    n.deleteContents(), n.insertNode(t);\n    const a = document.createRange(), l = r.nodeType === Node.TEXT_NODE ? r : r.firstChild;\n    l !== null && l.textContent !== null && a.setStart(l, l.textContent.length), i.removeAllRanges(), i.addRange(a);\n  }\n  /**\n   * Get all first-level (first child of [contenteditable]) siblings from passed node\n   * Then you can check it for emptiness\n   *\n   * @example\n   * <div contenteditable>\n   * <p></p>                            |\n   * <p></p>                            | left first-level siblings\n   * <p></p>                            |\n   * <blockquote><a><b>adaddad</b><a><blockquote>       <-- passed node for example <b>\n   * <p></p>                            |\n   * <p></p>                            | right first-level siblings\n   * <p></p>                            |\n   * </div>\n   * @param {HTMLElement} from - element from which siblings should be searched\n   * @param {'left' | 'right'} direction - direction of search\n   * @returns {HTMLElement[]}\n   */\n  getHigherLevelSiblings(e, t) {\n    let o = e;\n    const i = [];\n    for (; o.parentNode && o.parentNode.contentEditable !== \"true\"; )\n      o = o.parentNode;\n    const n = t === \"left\" ? \"previousSibling\" : \"nextSibling\";\n    for (; o[n]; )\n      o = o[n], i.push(o);\n    return i;\n  }\n}\nclass si extends y {\n  constructor() {\n    super(...arguments), this.onMouseUp = () => {\n      this.listeners.off(document, \"mouseover\", this.onMouseOver), this.listeners.off(document, \"mouseup\", this.onMouseUp);\n    }, this.onMouseOver = (e) => {\n      const { BlockManager: t, BlockSelection: o } = this.Editor;\n      if (e.relatedTarget === null && e.target === null)\n        return;\n      const i = t.getBlockByChildNode(e.relatedTarget) || this.lastSelectedBlock, n = t.getBlockByChildNode(e.target);\n      if (!(!i || !n) && n !== i) {\n        if (i === this.firstSelectedBlock) {\n          b.get().removeAllRanges(), i.selected = !0, n.selected = !0, o.clearCache();\n          return;\n        }\n        if (n === this.firstSelectedBlock) {\n          i.selected = !1, n.selected = !1, o.clearCache();\n          return;\n        }\n        this.Editor.InlineToolbar.close(), this.toggleBlocksSelectedState(i, n), this.lastSelectedBlock = n;\n      }\n    };\n  }\n  /**\n   * Module preparation\n   *\n   * @returns {Promise}\n   */\n  async prepare() {\n    this.listeners.on(document, \"mousedown\", (e) => {\n      this.enableCrossBlockSelection(e);\n    });\n  }\n  /**\n   * Sets up listeners\n   *\n   * @param {MouseEvent} event - mouse down event\n   */\n  watchSelection(e) {\n    if (e.button !== Pt.LEFT)\n      return;\n    const { BlockManager: t } = this.Editor;\n    this.firstSelectedBlock = t.getBlock(e.target), this.lastSelectedBlock = this.firstSelectedBlock, this.listeners.on(document, \"mouseover\", this.onMouseOver), this.listeners.on(document, \"mouseup\", this.onMouseUp);\n  }\n  /**\n   * return boolean is cross block selection started\n   */\n  get isCrossBlockSelectionStarted() {\n    return !!this.firstSelectedBlock && !!this.lastSelectedBlock;\n  }\n  /**\n   * Change selection state of the next Block\n   * Used for CBS via Shift + arrow keys\n   *\n   * @param {boolean} next - if true, toggle next block. Previous otherwise\n   */\n  toggleBlockSelectedState(e = !0) {\n    const { BlockManager: t, BlockSelection: o } = this.Editor;\n    this.lastSelectedBlock || (this.lastSelectedBlock = this.firstSelectedBlock = t.currentBlock), this.firstSelectedBlock === this.lastSelectedBlock && (this.firstSelectedBlock.selected = !0, o.clearCache(), b.get().removeAllRanges());\n    const i = t.blocks.indexOf(this.lastSelectedBlock) + (e ? 1 : -1), n = t.blocks[i];\n    n && (this.lastSelectedBlock.selected !== n.selected ? (n.selected = !0, o.clearCache()) : (this.lastSelectedBlock.selected = !1, o.clearCache()), this.lastSelectedBlock = n, this.Editor.InlineToolbar.close(), n.holder.scrollIntoView({\n      block: \"nearest\"\n    }));\n  }\n  /**\n   * Clear saved state\n   *\n   * @param {Event} reason - event caused clear of selection\n   */\n  clear(e) {\n    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor, n = t.blocks.indexOf(this.firstSelectedBlock), r = t.blocks.indexOf(this.lastSelectedBlock);\n    if (o.anyBlockSelected && n > -1 && r > -1 && e && e instanceof KeyboardEvent)\n      switch (e.keyCode) {\n        case v.DOWN:\n        case v.RIGHT:\n          i.setToBlock(t.blocks[Math.max(n, r)], i.positions.END);\n          break;\n        case v.UP:\n        case v.LEFT:\n          i.setToBlock(t.blocks[Math.min(n, r)], i.positions.START);\n          break;\n        default:\n          i.setToBlock(t.blocks[Math.max(n, r)], i.positions.END);\n      }\n    this.firstSelectedBlock = this.lastSelectedBlock = null;\n  }\n  /**\n   * Enables Cross Block Selection\n   *\n   * @param {MouseEvent} event - mouse down event\n   */\n  enableCrossBlockSelection(e) {\n    const { UI: t } = this.Editor;\n    b.isCollapsed || this.Editor.BlockSelection.clearSelection(e), t.nodes.redactor.contains(e.target) ? this.watchSelection(e) : this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Change blocks selection state between passed two blocks.\n   *\n   * @param {Block} firstBlock - first block in range\n   * @param {Block} lastBlock - last block in range\n   */\n  toggleBlocksSelectedState(e, t) {\n    const { BlockManager: o, BlockSelection: i } = this.Editor, n = o.blocks.indexOf(e), r = o.blocks.indexOf(t), a = e.selected !== t.selected;\n    for (let l = Math.min(n, r); l <= Math.max(n, r); l++) {\n      const d = o.blocks[l];\n      d !== this.firstSelectedBlock && d !== (a ? e : t) && (o.blocks[l].selected = !o.blocks[l].selected, i.clearCache());\n    }\n  }\n}\nclass ri extends y {\n  constructor() {\n    super(...arguments), this.isStartedAtEditor = !1;\n  }\n  /**\n   * Toggle read-only state\n   *\n   * if state is true:\n   *  - disable all drag-n-drop event handlers\n   *\n   * if state is false:\n   *  - restore drag-n-drop event handlers\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : this.enableModuleBindings();\n  }\n  /**\n   * Add drag events listeners to editor zone\n   */\n  enableModuleBindings() {\n    const { UI: e } = this.Editor;\n    this.readOnlyMutableListeners.on(e.nodes.holder, \"drop\", async (t) => {\n      await this.processDrop(t);\n    }, !0), this.readOnlyMutableListeners.on(e.nodes.holder, \"dragstart\", () => {\n      this.processDragStart();\n    }), this.readOnlyMutableListeners.on(e.nodes.holder, \"dragover\", (t) => {\n      this.processDragOver(t);\n    }, !0);\n  }\n  /**\n   * Unbind drag-n-drop event handlers\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Handle drop event\n   *\n   * @param {DragEvent} dropEvent - drop event\n   */\n  async processDrop(e) {\n    const {\n      BlockManager: t,\n      Caret: o,\n      Paste: i\n    } = this.Editor;\n    e.preventDefault(), t.blocks.forEach((r) => {\n      r.dropTarget = !1;\n    }), b.isAtEditor && !b.isCollapsed && this.isStartedAtEditor && document.execCommand(\"delete\"), this.isStartedAtEditor = !1;\n    const n = t.setCurrentBlockByChildNode(e.target);\n    if (n)\n      this.Editor.Caret.setToBlock(n, o.positions.END);\n    else {\n      const r = t.setCurrentBlockByChildNode(t.lastBlock.holder);\n      this.Editor.Caret.setToBlock(r, o.positions.END);\n    }\n    await i.processDataTransfer(e.dataTransfer, !0);\n  }\n  /**\n   * Handle drag start event\n   */\n  processDragStart() {\n    b.isAtEditor && !b.isCollapsed && (this.isStartedAtEditor = !0), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * @param {DragEvent} dragEvent - drag event\n   */\n  processDragOver(e) {\n    e.preventDefault();\n  }\n}\nclass ai extends y {\n  /**\n   * Prepare the module\n   *\n   * @param options - options used by the modification observer module\n   * @param options.config - Editor configuration object\n   * @param options.eventsDispatcher - common Editor event bus\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.disabled = !1, this.batchingTimeout = null, this.batchingOnChangeQueue = /* @__PURE__ */ new Map(), this.batchTime = 400, this.mutationObserver = new MutationObserver((o) => {\n      this.redactorChanged(o);\n    }), this.eventsDispatcher.on(pt, (o) => {\n      this.particularBlockChanged(o.event);\n    }), this.eventsDispatcher.on(ft, () => {\n      this.disable();\n    }), this.eventsDispatcher.on(gt, () => {\n      this.enable();\n    });\n  }\n  /**\n   * Enables onChange event\n   */\n  enable() {\n    this.mutationObserver.observe(\n      this.Editor.UI.nodes.redactor,\n      {\n        childList: !0,\n        subtree: !0,\n        characterData: !0,\n        attributes: !0\n      }\n    ), this.disabled = !1;\n  }\n  /**\n   * Disables onChange event\n   */\n  disable() {\n    this.mutationObserver.disconnect(), this.disabled = !0;\n  }\n  /**\n   * Call onChange event passed to Editor.js configuration\n   *\n   * @param event - some of our custom change events\n   */\n  particularBlockChanged(e) {\n    this.disabled || !M(this.config.onChange) || (this.batchingOnChangeQueue.set(`block:${e.detail.target.id}:event:${e.type}`, e), this.batchingTimeout && clearTimeout(this.batchingTimeout), this.batchingTimeout = setTimeout(() => {\n      let t;\n      this.batchingOnChangeQueue.size === 1 ? t = this.batchingOnChangeQueue.values().next().value : t = Array.from(this.batchingOnChangeQueue.values()), this.config.onChange && this.config.onChange(this.Editor.API.methods, t), this.batchingOnChangeQueue.clear();\n    }, this.batchTime));\n  }\n  /**\n   * Fired on every blocks wrapper dom change\n   *\n   * @param mutations - mutations happened\n   */\n  redactorChanged(e) {\n    this.eventsDispatcher.emit(Ae, {\n      mutations: e\n    });\n  }\n}\nconst Ct = class extends y {\n  constructor() {\n    super(...arguments), this.MIME_TYPE = \"application/x-editor-js\", this.toolsTags = {}, this.tagsByTool = {}, this.toolsPatterns = [], this.toolsFiles = {}, this.exceptionList = [], this.processTool = (s) => {\n      try {\n        const e = s.create({}, {}, !1);\n        if (s.pasteConfig === !1) {\n          this.exceptionList.push(s.name);\n          return;\n        }\n        if (!M(e.onPaste))\n          return;\n        this.getTagsConfig(s), this.getFilesConfig(s), this.getPatternsConfig(s);\n      } catch (e) {\n        T(\n          `Paste handling for «${s.name}» Tool hasn't been set up because of the error`,\n          \"warn\",\n          e\n        );\n      }\n    }, this.handlePasteEvent = async (s) => {\n      const { BlockManager: e, Toolbar: t } = this.Editor, o = e.setCurrentBlockByChildNode(s.target);\n      !o || this.isNativeBehaviour(s.target) && !s.clipboardData.types.includes(\"Files\") || o && this.exceptionList.includes(o.name) || (s.preventDefault(), this.processDataTransfer(s.clipboardData), t.close());\n    };\n  }\n  /**\n   * Set onPaste callback and collect tools` paste configurations\n   */\n  async prepare() {\n    this.processTools();\n  }\n  /**\n   * Set read-only state\n   *\n   * @param {boolean} readOnlyEnabled - read only flag value\n   */\n  toggleReadOnly(s) {\n    s ? this.unsetCallback() : this.setCallback();\n  }\n  /**\n   * Handle pasted or dropped data transfer object\n   *\n   * @param {DataTransfer} dataTransfer - pasted or dropped data transfer object\n   * @param {boolean} isDragNDrop - true if data transfer comes from drag'n'drop events\n   */\n  async processDataTransfer(s, e = !1) {\n    const { Tools: t } = this.Editor, o = s.types;\n    if ((o.includes ? o.includes(\"Files\") : o.contains(\"Files\")) && !W(this.toolsFiles)) {\n      await this.processFiles(s.files);\n      return;\n    }\n    const n = s.getData(this.MIME_TYPE), r = s.getData(\"text/plain\");\n    let a = s.getData(\"text/html\");\n    if (n)\n      try {\n        this.insertEditorJSData(JSON.parse(n));\n        return;\n      } catch {\n      }\n    e && r.trim() && a.trim() && (a = \"<p>\" + (a.trim() ? a : r) + \"</p>\");\n    const l = Object.keys(this.toolsTags).reduce((h, f) => (h[f.toLowerCase()] = this.toolsTags[f].sanitizationConfig ?? {}, h), {}), d = Object.assign({}, l, t.getAllInlineToolsSanitizeConfig(), { br: {} }), u = V(a, d);\n    !u.trim() || u.trim() === r || !c.isHTMLString(u) ? await this.processText(r) : await this.processText(u, !0);\n  }\n  /**\n   * Process pasted text and divide them into Blocks\n   *\n   * @param {string} data - text to process. Can be HTML or plain.\n   * @param {boolean} isHTML - if passed string is HTML, this parameter should be true\n   */\n  async processText(s, e = !1) {\n    const { Caret: t, BlockManager: o } = this.Editor, i = e ? this.processHTML(s) : this.processPlain(s);\n    if (!i.length)\n      return;\n    if (i.length === 1) {\n      i[0].isBlock ? this.processSingleBlock(i.pop()) : this.processInlinePaste(i.pop());\n      return;\n    }\n    const r = o.currentBlock && o.currentBlock.tool.isDefault && o.currentBlock.isEmpty;\n    i.map(\n      async (a, l) => this.insertBlock(a, l === 0 && r)\n    ), o.currentBlock && t.setToBlock(o.currentBlock, t.positions.END);\n  }\n  /**\n   * Set onPaste callback handler\n   */\n  setCallback() {\n    this.listeners.on(this.Editor.UI.nodes.holder, \"paste\", this.handlePasteEvent);\n  }\n  /**\n   * Unset onPaste callback handler\n   */\n  unsetCallback() {\n    this.listeners.off(this.Editor.UI.nodes.holder, \"paste\", this.handlePasteEvent);\n  }\n  /**\n   * Get and process tool`s paste configs\n   */\n  processTools() {\n    const s = this.Editor.Tools.blockTools;\n    Array.from(s.values()).forEach(this.processTool);\n  }\n  /**\n   * Get tags name list from either tag name or sanitization config.\n   *\n   * @param {string | object} tagOrSanitizeConfig - tag name or sanitize config object.\n   * @returns {string[]} array of tags.\n   */\n  collectTagNames(s) {\n    return G(s) ? [s] : D(s) ? Object.keys(s) : [];\n  }\n  /**\n   * Get tags to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getTagsConfig(s) {\n    if (s.pasteConfig === !1)\n      return;\n    const e = s.pasteConfig.tags || [], t = [];\n    e.forEach((o) => {\n      const i = this.collectTagNames(o);\n      t.push(...i), i.forEach((n) => {\n        if (Object.prototype.hasOwnProperty.call(this.toolsTags, n)) {\n          T(\n            `Paste handler for «${s.name}» Tool on «${n}» tag is skipped because it is already used by «${this.toolsTags[n].tool.name}» Tool.`,\n            \"warn\"\n          );\n          return;\n        }\n        const r = D(o) ? o[n] : null;\n        this.toolsTags[n.toUpperCase()] = {\n          tool: s,\n          sanitizationConfig: r\n        };\n      });\n    }), this.tagsByTool[s.name] = t.map((o) => o.toUpperCase());\n  }\n  /**\n   * Get files` types and extensions to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getFilesConfig(s) {\n    if (s.pasteConfig === !1)\n      return;\n    const { files: e = {} } = s.pasteConfig;\n    let { extensions: t, mimeTypes: o } = e;\n    !t && !o || (t && !Array.isArray(t) && (T(`«extensions» property of the onDrop config for «${s.name}» Tool should be an array`), t = []), o && !Array.isArray(o) && (T(`«mimeTypes» property of the onDrop config for «${s.name}» Tool should be an array`), o = []), o && (o = o.filter((i) => jt(i) ? !0 : (T(`MIME type value «${i}» for the «${s.name}» Tool is not a valid MIME type`, \"warn\"), !1))), this.toolsFiles[s.name] = {\n      extensions: t || [],\n      mimeTypes: o || []\n    });\n  }\n  /**\n   * Get RegExp patterns to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getPatternsConfig(s) {\n    s.pasteConfig === !1 || !s.pasteConfig.patterns || W(s.pasteConfig.patterns) || Object.entries(s.pasteConfig.patterns).forEach(([e, t]) => {\n      t instanceof RegExp || T(\n        `Pattern ${t} for «${s.name}» Tool is skipped because it should be a Regexp instance.`,\n        \"warn\"\n      ), this.toolsPatterns.push({\n        key: e,\n        pattern: t,\n        tool: s\n      });\n    });\n  }\n  /**\n   * Check if browser behavior suits better\n   *\n   * @param {EventTarget} element - element where content has been pasted\n   * @returns {boolean}\n   */\n  isNativeBehaviour(s) {\n    return c.isNativeInput(s);\n  }\n  /**\n   * Get files from data transfer object and insert related Tools\n   *\n   * @param {FileList} items - pasted or dropped items\n   */\n  async processFiles(s) {\n    const { BlockManager: e } = this.Editor;\n    let t;\n    t = await Promise.all(\n      Array.from(s).map((n) => this.processFile(n))\n    ), t = t.filter((n) => !!n);\n    const i = e.currentBlock.tool.isDefault && e.currentBlock.isEmpty;\n    t.forEach(\n      (n, r) => {\n        e.paste(n.type, n.event, r === 0 && i);\n      }\n    );\n  }\n  /**\n   * Get information about file and find Tool to handle it\n   *\n   * @param {File} file - file to process\n   */\n  async processFile(s) {\n    const e = Ut(s), t = Object.entries(this.toolsFiles).find(([n, { mimeTypes: r, extensions: a }]) => {\n      const [l, d] = s.type.split(\"/\"), u = a.find((f) => f.toLowerCase() === e.toLowerCase()), h = r.find((f) => {\n        const [x, p] = f.split(\"/\");\n        return x === l && (p === d || p === \"*\");\n      });\n      return !!u || !!h;\n    });\n    if (!t)\n      return;\n    const [o] = t;\n    return {\n      event: this.composePasteEvent(\"file\", {\n        file: s\n      }),\n      type: o\n    };\n  }\n  /**\n   * Split HTML string to blocks and return it as array of Block data\n   *\n   * @param {string} innerHTML - html string to process\n   * @returns {PasteData[]}\n   */\n  processHTML(s) {\n    const { Tools: e } = this.Editor, t = c.make(\"DIV\");\n    return t.innerHTML = s, this.getNodes(t).map((i) => {\n      let n, r = e.defaultTool, a = !1;\n      switch (i.nodeType) {\n        case Node.DOCUMENT_FRAGMENT_NODE:\n          n = c.make(\"div\"), n.appendChild(i);\n          break;\n        case Node.ELEMENT_NODE:\n          n = i, a = !0, this.toolsTags[n.tagName] && (r = this.toolsTags[n.tagName].tool);\n          break;\n      }\n      const { tags: l } = r.pasteConfig || { tags: [] }, d = l.reduce((f, x) => (this.collectTagNames(x).forEach((m) => {\n        const L = D(x) ? x[m] : null;\n        f[m.toLowerCase()] = L || {};\n      }), f), {}), u = Object.assign({}, d, r.baseSanitizeConfig);\n      if (n.tagName.toLowerCase() === \"table\") {\n        const f = V(n.outerHTML, u);\n        n = c.make(\"div\", void 0, {\n          innerHTML: f\n        }).firstChild;\n      } else\n        n.innerHTML = V(n.innerHTML, u);\n      const h = this.composePasteEvent(\"tag\", {\n        data: n\n      });\n      return {\n        content: n,\n        isBlock: a,\n        tool: r.name,\n        event: h\n      };\n    }).filter((i) => {\n      const n = c.isEmpty(i.content), r = c.isSingleTag(i.content);\n      return !n || r;\n    });\n  }\n  /**\n   * Split plain text by new line symbols and return it as array of Block data\n   *\n   * @param {string} plain - string to process\n   * @returns {PasteData[]}\n   */\n  processPlain(s) {\n    const { defaultBlock: e } = this.config;\n    if (!s)\n      return [];\n    const t = e;\n    return s.split(/\\r?\\n/).filter((o) => o.trim()).map((o) => {\n      const i = c.make(\"div\");\n      i.textContent = o;\n      const n = this.composePasteEvent(\"tag\", {\n        data: i\n      });\n      return {\n        content: i,\n        tool: t,\n        isBlock: !1,\n        event: n\n      };\n    });\n  }\n  /**\n   * Process paste of single Block tool content\n   *\n   * @param {PasteData} dataToInsert - data of Block to insert\n   */\n  async processSingleBlock(s) {\n    const { Caret: e, BlockManager: t } = this.Editor, { currentBlock: o } = t;\n    if (!o || s.tool !== o.name || !c.containsOnlyInlineElements(s.content.innerHTML)) {\n      this.insertBlock(s, (o == null ? void 0 : o.tool.isDefault) && o.isEmpty);\n      return;\n    }\n    e.insertContentAtCaretPosition(s.content.innerHTML);\n  }\n  /**\n   * Process paste to single Block:\n   * 1. Find patterns` matches\n   * 2. Insert new block if it is not the same type as current one\n   * 3. Just insert text if there is no substitutions\n   *\n   * @param {PasteData} dataToInsert - data of Block to insert\n   */\n  async processInlinePaste(s) {\n    const { BlockManager: e, Caret: t } = this.Editor, { content: o } = s;\n    if (e.currentBlock && e.currentBlock.tool.isDefault && o.textContent.length < Ct.PATTERN_PROCESSING_MAX_LENGTH) {\n      const n = await this.processPattern(o.textContent);\n      if (n) {\n        const r = e.currentBlock && e.currentBlock.tool.isDefault && e.currentBlock.isEmpty, a = e.paste(n.tool, n.event, r);\n        t.setToBlock(a, t.positions.END);\n        return;\n      }\n    }\n    if (e.currentBlock && e.currentBlock.currentInput) {\n      const n = e.currentBlock.tool.baseSanitizeConfig;\n      document.execCommand(\n        \"insertHTML\",\n        !1,\n        V(o.innerHTML, n)\n      );\n    } else\n      this.insertBlock(s);\n  }\n  /**\n   * Get patterns` matches\n   *\n   * @param {string} text - text to process\n   * @returns {Promise<{event: PasteEvent, tool: string}>}\n   */\n  async processPattern(s) {\n    const e = this.toolsPatterns.find((o) => {\n      const i = o.pattern.exec(s);\n      return i ? s === i.shift() : !1;\n    });\n    return e ? {\n      event: this.composePasteEvent(\"pattern\", {\n        key: e.key,\n        data: s\n      }),\n      tool: e.tool.name\n    } : void 0;\n  }\n  /**\n   * Insert pasted Block content to Editor\n   *\n   * @param {PasteData} data - data to insert\n   * @param {boolean} canReplaceCurrentBlock - if true and is current Block is empty, will replace current Block\n   * @returns {void}\n   */\n  insertBlock(s, e = !1) {\n    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i } = t;\n    let n;\n    if (e && i && i.isEmpty) {\n      n = t.paste(s.tool, s.event, !0), o.setToBlock(n, o.positions.END);\n      return;\n    }\n    n = t.paste(s.tool, s.event), o.setToBlock(n, o.positions.END);\n  }\n  /**\n   * Insert data passed as application/x-editor-js JSON\n   *\n   * @param {Array} blocks — Blocks' data to insert\n   * @returns {void}\n   */\n  insertEditorJSData(s) {\n    const { BlockManager: e, Caret: t, Tools: o } = this.Editor;\n    bt(\n      s,\n      (n) => o.blockTools.get(n).sanitizeConfig\n    ).forEach(({ tool: n, data: r }, a) => {\n      let l = !1;\n      a === 0 && (l = e.currentBlock && e.currentBlock.tool.isDefault && e.currentBlock.isEmpty);\n      const d = e.insert({\n        tool: n,\n        data: r,\n        replace: l\n      });\n      t.setToBlock(d, t.positions.END);\n    });\n  }\n  /**\n   * Fetch nodes from Element node\n   *\n   * @param {Node} node - current node\n   * @param {Node[]} nodes - processed nodes\n   * @param {Node} destNode - destination node\n   */\n  processElementNode(s, e, t) {\n    const o = Object.keys(this.toolsTags), i = s, { tool: n } = this.toolsTags[i.tagName] || {}, r = this.tagsByTool[n == null ? void 0 : n.name] || [], a = o.includes(i.tagName), l = c.blockElements.includes(i.tagName.toLowerCase()), d = Array.from(i.children).some(\n      ({ tagName: h }) => o.includes(h) && !r.includes(h)\n    ), u = Array.from(i.children).some(\n      ({ tagName: h }) => c.blockElements.includes(h.toLowerCase())\n    );\n    if (!l && !a && !d)\n      return t.appendChild(i), [...e, t];\n    if (a && !d || l && !u && !d)\n      return [...e, t, i];\n  }\n  /**\n   * Recursively divide HTML string to two types of nodes:\n   * 1. Block element\n   * 2. Document Fragments contained text and markup tags like a, b, i etc.\n   *\n   * @param {Node} wrapper - wrapper of paster HTML content\n   * @returns {Node[]}\n   */\n  getNodes(s) {\n    const e = Array.from(s.childNodes);\n    let t;\n    const o = (i, n) => {\n      if (c.isEmpty(n) && !c.isSingleTag(n))\n        return i;\n      const r = i[i.length - 1];\n      let a = new DocumentFragment();\n      switch (r && c.isFragment(r) && (a = i.pop()), n.nodeType) {\n        case Node.ELEMENT_NODE:\n          if (t = this.processElementNode(n, i, a), t)\n            return t;\n          break;\n        case Node.TEXT_NODE:\n          return a.appendChild(n), [...i, a];\n        default:\n          return [...i, a];\n      }\n      return [...i, ...Array.from(n.childNodes).reduce(o, [])];\n    };\n    return e.reduce(o, []);\n  }\n  /**\n   * Compose paste event with passed type and detail\n   *\n   * @param {string} type - event type\n   * @param {PasteEventDetail} detail - event detail\n   */\n  composePasteEvent(s, e) {\n    return new CustomEvent(s, {\n      detail: e\n    });\n  }\n};\nlet Tt = Ct;\nTt.PATTERN_PROCESSING_MAX_LENGTH = 450;\nclass li extends y {\n  constructor() {\n    super(...arguments), this.toolsDontSupportReadOnly = [], this.readOnlyEnabled = !1;\n  }\n  /**\n   * Returns state of read only mode\n   */\n  get isEnabled() {\n    return this.readOnlyEnabled;\n  }\n  /**\n   * Set initial state\n   */\n  async prepare() {\n    const { Tools: e } = this.Editor, { blockTools: t } = e, o = [];\n    Array.from(t.entries()).forEach(([i, n]) => {\n      n.isReadOnlySupported || o.push(i);\n    }), this.toolsDontSupportReadOnly = o, this.config.readOnly && o.length > 0 && this.throwCriticalError(), this.toggle(this.config.readOnly);\n  }\n  /**\n   * Set read-only mode or toggle current state\n   * Call all Modules `toggleReadOnly` method and re-render Editor\n   *\n   * @param {boolean} state - (optional) read-only state or toggle\n   */\n  async toggle(e = !this.readOnlyEnabled) {\n    e && this.toolsDontSupportReadOnly.length > 0 && this.throwCriticalError();\n    const t = this.readOnlyEnabled;\n    this.readOnlyEnabled = e;\n    for (const i in this.Editor)\n      this.Editor[i].toggleReadOnly && this.Editor[i].toggleReadOnly(e);\n    if (t === e)\n      return this.readOnlyEnabled;\n    const o = await this.Editor.Saver.save();\n    return await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(o.blocks), this.readOnlyEnabled;\n  }\n  /**\n   * Throws an error about tools which don't support read-only mode\n   */\n  throwCriticalError() {\n    throw new ut(\n      `To enable read-only mode all connected tools should support it. Tools ${this.toolsDontSupportReadOnly.join(\", \")} don't support read-only mode.`\n    );\n  }\n}\nclass fe extends y {\n  constructor() {\n    super(...arguments), this.isRectSelectionActivated = !1, this.SCROLL_SPEED = 3, this.HEIGHT_OF_SCROLL_ZONE = 40, this.BOTTOM_SCROLL_ZONE = 1, this.TOP_SCROLL_ZONE = 2, this.MAIN_MOUSE_BUTTON = 0, this.mousedown = !1, this.isScrolling = !1, this.inScrollZone = null, this.startX = 0, this.startY = 0, this.mouseX = 0, this.mouseY = 0, this.stackOfSelected = [], this.listenerIds = [];\n  }\n  /**\n   * CSS classes for the Block\n   *\n   * @returns {{wrapper: string, content: string}}\n   */\n  static get CSS() {\n    return {\n      overlay: \"codex-editor-overlay\",\n      overlayContainer: \"codex-editor-overlay__container\",\n      rect: \"codex-editor-overlay__rectangle\",\n      topScrollZone: \"codex-editor-overlay__scroll-zone--top\",\n      bottomScrollZone: \"codex-editor-overlay__scroll-zone--bottom\"\n    };\n  }\n  /**\n   * Module Preparation\n   * Creating rect and hang handlers\n   */\n  prepare() {\n    this.enableModuleBindings();\n  }\n  /**\n   * Init rect params\n   *\n   * @param {number} pageX - X coord of mouse\n   * @param {number} pageY - Y coord of mouse\n   */\n  startSelection(e, t) {\n    const o = document.elementFromPoint(e - window.pageXOffset, t - window.pageYOffset);\n    o.closest(`.${this.Editor.Toolbar.CSS.toolbar}`) || (this.Editor.BlockSelection.allBlocksSelected = !1, this.clearSelection(), this.stackOfSelected = []);\n    const n = [\n      `.${R.CSS.content}`,\n      `.${this.Editor.Toolbar.CSS.toolbar}`,\n      `.${this.Editor.InlineToolbar.CSS.inlineToolbar}`\n    ], r = o.closest(\".\" + this.Editor.UI.CSS.editorWrapper), a = n.some((l) => !!o.closest(l));\n    !r || a || (this.mousedown = !0, this.startX = e, this.startY = t);\n  }\n  /**\n   * Clear all params to end selection\n   */\n  endSelection() {\n    this.mousedown = !1, this.startX = 0, this.startY = 0, this.overlayRectangle.style.display = \"none\";\n  }\n  /**\n   * is RectSelection Activated\n   */\n  isRectActivated() {\n    return this.isRectSelectionActivated;\n  }\n  /**\n   * Mark that selection is end\n   */\n  clearSelection() {\n    this.isRectSelectionActivated = !1;\n  }\n  /**\n   * Sets Module necessary event handlers\n   */\n  enableModuleBindings() {\n    const { container: e } = this.genHTML();\n    this.listeners.on(e, \"mousedown\", (t) => {\n      this.processMouseDown(t);\n    }, !1), this.listeners.on(document.body, \"mousemove\", Ie((t) => {\n      this.processMouseMove(t);\n    }, 10), {\n      passive: !0\n    }), this.listeners.on(document.body, \"mouseleave\", () => {\n      this.processMouseLeave();\n    }), this.listeners.on(window, \"scroll\", Ie((t) => {\n      this.processScroll(t);\n    }, 10), {\n      passive: !0\n    }), this.listeners.on(document.body, \"mouseup\", () => {\n      this.processMouseUp();\n    }, !1);\n  }\n  /**\n   * Handle mouse down events\n   *\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processMouseDown(e) {\n    if (e.button !== this.MAIN_MOUSE_BUTTON)\n      return;\n    e.target.closest(c.allInputsSelector) !== null || this.startSelection(e.pageX, e.pageY);\n  }\n  /**\n   * Handle mouse move events\n   *\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processMouseMove(e) {\n    this.changingRectangle(e), this.scrollByZones(e.clientY);\n  }\n  /**\n   * Handle mouse leave\n   */\n  processMouseLeave() {\n    this.clearSelection(), this.endSelection();\n  }\n  /**\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processScroll(e) {\n    this.changingRectangle(e);\n  }\n  /**\n   * Handle mouse up\n   */\n  processMouseUp() {\n    this.clearSelection(), this.endSelection();\n  }\n  /**\n   * Scroll If mouse in scroll zone\n   *\n   * @param {number} clientY - Y coord of mouse\n   */\n  scrollByZones(e) {\n    if (this.inScrollZone = null, e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.TOP_SCROLL_ZONE), document.documentElement.clientHeight - e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.BOTTOM_SCROLL_ZONE), !this.inScrollZone) {\n      this.isScrolling = !1;\n      return;\n    }\n    this.isScrolling || (this.scrollVertical(this.inScrollZone === this.TOP_SCROLL_ZONE ? -this.SCROLL_SPEED : this.SCROLL_SPEED), this.isScrolling = !0);\n  }\n  /**\n   * Generates required HTML elements\n   *\n   * @returns {Object<string, Element>}\n   */\n  genHTML() {\n    const { UI: e } = this.Editor, t = e.nodes.holder.querySelector(\".\" + e.CSS.editorWrapper), o = c.make(\"div\", fe.CSS.overlay, {}), i = c.make(\"div\", fe.CSS.overlayContainer, {}), n = c.make(\"div\", fe.CSS.rect, {});\n    return i.appendChild(n), o.appendChild(i), t.appendChild(o), this.overlayRectangle = n, {\n      container: t,\n      overlay: o\n    };\n  }\n  /**\n   * Activates scrolling if blockSelection is active and mouse is in scroll zone\n   *\n   * @param {number} speed - speed of scrolling\n   */\n  scrollVertical(e) {\n    if (!(this.inScrollZone && this.mousedown))\n      return;\n    const t = window.pageYOffset;\n    window.scrollBy(0, e), this.mouseY += window.pageYOffset - t, setTimeout(() => {\n      this.scrollVertical(e);\n    }, 0);\n  }\n  /**\n   * Handles the change in the rectangle and its effect\n   *\n   * @param {MouseEvent} event - mouse event\n   */\n  changingRectangle(e) {\n    if (!this.mousedown)\n      return;\n    e.pageY !== void 0 && (this.mouseX = e.pageX, this.mouseY = e.pageY);\n    const { rightPos: t, leftPos: o, index: i } = this.genInfoForMouseSelection(), n = this.startX > t && this.mouseX > t, r = this.startX < o && this.mouseX < o;\n    this.rectCrossesBlocks = !(n || r), this.isRectSelectionActivated || (this.rectCrossesBlocks = !1, this.isRectSelectionActivated = !0, this.shrinkRectangleToPoint(), this.overlayRectangle.style.display = \"block\"), this.updateRectangleSize(), this.Editor.Toolbar.close(), i !== void 0 && (this.trySelectNextBlock(i), this.inverseSelection(), b.get().removeAllRanges());\n  }\n  /**\n   * Shrink rect to singular point\n   */\n  shrinkRectangleToPoint() {\n    this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`;\n  }\n  /**\n   * Select or unselect all of blocks in array if rect is out or in selectable area\n   */\n  inverseSelection() {\n    const t = this.Editor.BlockManager.getBlockByIndex(this.stackOfSelected[0]).selected;\n    if (this.rectCrossesBlocks && !t)\n      for (const o of this.stackOfSelected)\n        this.Editor.BlockSelection.selectBlockByIndex(o);\n    if (!this.rectCrossesBlocks && t)\n      for (const o of this.stackOfSelected)\n        this.Editor.BlockSelection.unSelectBlockByIndex(o);\n  }\n  /**\n   * Updates size of rectangle\n   */\n  updateRectangleSize() {\n    this.mouseY >= this.startY ? (this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.mouseY - window.pageYOffset}px`) : (this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.top = `${this.mouseY - window.pageYOffset}px`), this.mouseX >= this.startX ? (this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.mouseX - window.pageXOffset}px`) : (this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.left = `${this.mouseX - window.pageXOffset}px`);\n  }\n  /**\n   * Collects information needed to determine the behavior of the rectangle\n   *\n   * @returns {object} index - index next Block, leftPos - start of left border of Block, rightPos - right border\n   */\n  genInfoForMouseSelection() {\n    const t = document.body.offsetWidth / 2, o = this.mouseY - window.pageYOffset, i = document.elementFromPoint(t, o), n = this.Editor.BlockManager.getBlockByChildNode(i);\n    let r;\n    n !== void 0 && (r = this.Editor.BlockManager.blocks.findIndex((h) => h.holder === n.holder));\n    const a = this.Editor.BlockManager.lastBlock.holder.querySelector(\".\" + R.CSS.content), l = Number.parseInt(window.getComputedStyle(a).width, 10) / 2, d = t - l, u = t + l;\n    return {\n      index: r,\n      leftPos: d,\n      rightPos: u\n    };\n  }\n  /**\n   * Select block with index index\n   *\n   * @param index - index of block in redactor\n   */\n  addBlockInSelection(e) {\n    this.rectCrossesBlocks && this.Editor.BlockSelection.selectBlockByIndex(e), this.stackOfSelected.push(e);\n  }\n  /**\n   * Adds a block to the selection and determines which blocks should be selected\n   *\n   * @param {object} index - index of new block in the reactor\n   */\n  trySelectNextBlock(e) {\n    const t = this.stackOfSelected[this.stackOfSelected.length - 1] === e, o = this.stackOfSelected.length, i = 1, n = -1, r = 0;\n    if (t)\n      return;\n    const a = this.stackOfSelected[o - 1] - this.stackOfSelected[o - 2] > 0;\n    let l = r;\n    o > 1 && (l = a ? i : n);\n    const d = e > this.stackOfSelected[o - 1] && l === i, u = e < this.stackOfSelected[o - 1] && l === n, f = !(d || u || l === r);\n    if (!f && (e > this.stackOfSelected[o - 1] || this.stackOfSelected[o - 1] === void 0)) {\n      let m = this.stackOfSelected[o - 1] + 1 || e;\n      for (m; m <= e; m++)\n        this.addBlockInSelection(m);\n      return;\n    }\n    if (!f && e < this.stackOfSelected[o - 1]) {\n      for (let m = this.stackOfSelected[o - 1] - 1; m >= e; m--)\n        this.addBlockInSelection(m);\n      return;\n    }\n    if (!f)\n      return;\n    let x = o - 1, p;\n    for (e > this.stackOfSelected[o - 1] ? p = () => e > this.stackOfSelected[x] : p = () => e < this.stackOfSelected[x]; p(); )\n      this.rectCrossesBlocks && this.Editor.BlockSelection.unSelectBlockByIndex(this.stackOfSelected[x]), this.stackOfSelected.pop(), x--;\n  }\n}\nclass ci extends y {\n  /**\n   * Renders passed blocks as one batch\n   *\n   * @param blocksData - blocks to render\n   */\n  async render(e) {\n    return new Promise((t) => {\n      const { Tools: o, BlockManager: i } = this.Editor;\n      if (e.length === 0)\n        i.insert();\n      else {\n        const n = e.map(({ type: r, data: a, tunes: l, id: d }) => {\n          o.available.has(r) === !1 && (Y(`Tool «${r}» is not found. Check 'tools' property at the Editor.js config.`, \"warn\"), a = this.composeStubDataForTool(r, a, d), r = o.stubTool);\n          let u;\n          try {\n            u = i.composeBlock({\n              id: d,\n              tool: r,\n              data: a,\n              tunes: l\n            });\n          } catch (h) {\n            T(`Block «${r}» skipped because of plugins error`, \"error\", {\n              data: a,\n              error: h\n            }), a = this.composeStubDataForTool(r, a, d), r = o.stubTool, u = i.composeBlock({\n              id: d,\n              tool: r,\n              data: a,\n              tunes: l\n            });\n          }\n          return u;\n        });\n        i.insertMany(n);\n      }\n      window.requestIdleCallback(() => {\n        t();\n      }, { timeout: 2e3 });\n    });\n  }\n  /**\n   * Create data for the Stub Tool that will be used instead of unavailable tool\n   *\n   * @param tool - unavailable tool name to stub\n   * @param data - data of unavailable block\n   * @param [id] - id of unavailable block\n   */\n  composeStubDataForTool(e, t, o) {\n    const { Tools: i } = this.Editor;\n    let n = e;\n    if (i.unavailable.has(e)) {\n      const r = i.unavailable.get(e).toolbox;\n      r !== void 0 && r[0].title !== void 0 && (n = r[0].title);\n    }\n    return {\n      savedData: {\n        id: o,\n        type: e,\n        data: t\n      },\n      title: n\n    };\n  }\n}\nclass di extends y {\n  /**\n   * Composes new chain of Promises to fire them alternatelly\n   *\n   * @returns {OutputData}\n   */\n  async save() {\n    const { BlockManager: e, Tools: t } = this.Editor, o = e.blocks, i = [];\n    try {\n      o.forEach((a) => {\n        i.push(this.getSavedData(a));\n      });\n      const n = await Promise.all(i), r = await bt(n, (a) => t.blockTools.get(a).sanitizeConfig);\n      return this.makeOutput(r);\n    } catch (n) {\n      Y(\"Saving failed due to the Error %o\", \"error\", n);\n    }\n  }\n  /**\n   * Saves and validates\n   *\n   * @param {Block} block - Editor's Tool\n   * @returns {ValidatedData} - Tool's validated data\n   */\n  async getSavedData(e) {\n    const t = await e.save(), o = t && await e.validate(t.data);\n    return {\n      ...t,\n      isValid: o\n    };\n  }\n  /**\n   * Creates output object with saved data, time and version of editor\n   *\n   * @param {ValidatedData} allExtractedData - data extracted from Blocks\n   * @returns {OutputData}\n   */\n  makeOutput(e) {\n    const t = [];\n    return e.forEach(({ id: o, tool: i, data: n, tunes: r, isValid: a }) => {\n      if (!a) {\n        T(`Block «${i}» skipped because saved data is invalid`);\n        return;\n      }\n      if (i === this.Editor.Tools.stubTool) {\n        t.push(n);\n        return;\n      }\n      const l = {\n        id: o,\n        type: i,\n        data: n,\n        ...!W(r) && {\n          tunes: r\n        }\n      };\n      t.push(l);\n    }), {\n      time: +/* @__PURE__ */ new Date(),\n      blocks: t,\n      version: \"2.29.1\"\n    };\n  }\n}\n(function() {\n  try {\n    if (typeof document < \"u\") {\n      var s = document.createElement(\"style\");\n      s.appendChild(document.createTextNode(\".ce-paragraph{line-height:1.6em;outline:none}.ce-paragraph[data-placeholder]:empty:before{content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before{opacity:1}.codex-editor--toolbox-opened .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before,.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:focus:before{opacity:0}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}\")), document.head.appendChild(s);\n    }\n  } catch (e) {\n    console.error(\"vite-plugin-css-injected-by-js\", e);\n  }\n})();\nconst hi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>';\n/**\n * Base Paragraph Block for the Editor.js.\n * Represents a regular text block\n *\n * @author CodeX (team@codex.so)\n * @copyright CodeX 2018\n * @license The MIT License (MIT)\n */\nclass Ke {\n  /**\n   * Default placeholder for Paragraph Tool\n   *\n   * @returns {string}\n   * @class\n   */\n  static get DEFAULT_PLACEHOLDER() {\n    return \"\";\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} params - constructor params\n   * @param {ParagraphData} params.data - previously saved data\n   * @param {ParagraphConfig} params.config - user config for Tool\n   * @param {object} params.api - editor.js api\n   * @param {boolean} readOnly - read only mode flag\n   */\n  constructor({ data: e, config: t, api: o, readOnly: i }) {\n    this.api = o, this.readOnly = i, this._CSS = {\n      block: this.api.styles.block,\n      wrapper: \"ce-paragraph\"\n    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = t.placeholder ? t.placeholder : Ke.DEFAULT_PLACEHOLDER, this._data = {}, this._element = null, this._preserveBlank = t.preserveBlank !== void 0 ? t.preserveBlank : !1, this.data = e;\n  }\n  /**\n   * Check if text content is empty and set empty string to inner html.\n   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements\n   *\n   * @param {KeyboardEvent} e - key up event\n   */\n  onKeyUp(e) {\n    if (e.code !== \"Backspace\" && e.code !== \"Delete\")\n      return;\n    const { textContent: t } = this._element;\n    t === \"\" && (this._element.innerHTML = \"\");\n  }\n  /**\n   * Create Tool's view\n   *\n   * @returns {HTMLElement}\n   * @private\n   */\n  drawView() {\n    const e = document.createElement(\"DIV\");\n    return e.classList.add(this._CSS.wrapper, this._CSS.block), e.contentEditable = !1, e.dataset.placeholder = this.api.i18n.t(this._placeholder), this._data.text && (e.innerHTML = this._data.text), this.readOnly || (e.contentEditable = !0, e.addEventListener(\"keyup\", this.onKeyUp)), e;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement}\n   */\n  render() {\n    return this._element = this.drawView(), this._element;\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {ParagraphData} data\n   * @public\n   */\n  merge(e) {\n    const t = {\n      text: this.data.text + e.text\n    };\n    this.data = t;\n  }\n  /**\n   * Validate Paragraph block data:\n   * - check for emptiness\n   *\n   * @param {ParagraphData} savedData — data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(e) {\n    return !(e.text.trim() === \"\" && !this._preserveBlank);\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view\n   * @returns {ParagraphData} - saved data\n   * @public\n   */\n  save(e) {\n    return {\n      text: e.innerHTML\n    };\n  }\n  /**\n   * On paste callback fired from Editor.\n   *\n   * @param {PasteEvent} event - event with pasted data\n   */\n  onPaste(e) {\n    const t = {\n      text: e.detail.data.innerHTML\n    };\n    this.data = t;\n  }\n  /**\n   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // to convert Paragraph to other block, use 'text' property of saved data\n      import: \"text\"\n      // to covert other block's exported string to Paragraph, fill 'text' property of tool data\n    };\n  }\n  /**\n   * Sanitizer rules\n   */\n  static get sanitize() {\n    return {\n      text: {\n        br: !0\n      }\n    };\n  }\n  /**\n   * Returns true to notify the core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get current Tools`s data\n   *\n   * @returns {ParagraphData} Current data\n   * @private\n   */\n  get data() {\n    if (this._element !== null) {\n      const e = this._element.innerHTML;\n      this._data.text = e;\n    }\n    return this._data;\n  }\n  /**\n   * Store data in plugin:\n   * - at the this._data property\n   * - at the HTML\n   *\n   * @param {ParagraphData} data — data to set\n   * @private\n   */\n  set data(e) {\n    this._data = e || {}, this._element !== null && this.hydrate();\n  }\n  /**\n   * Fill tool's view with data\n   */\n  hydrate() {\n    window.requestAnimationFrame(() => {\n      this._element.innerHTML = this._data.text || \"\";\n    });\n  }\n  /**\n   * Used by Editor paste handling API.\n   * Provides configuration to handle P tags.\n   *\n   * @returns {{tags: string[]}}\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"P\"]\n    };\n  }\n  /**\n   * Icon and title for displaying at the Toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: hi,\n      title: \"Text\"\n    };\n  }\n}\nclass Xe {\n  constructor() {\n    this.commandName = \"bold\", this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--bold\"\n    }, this.nodes = {\n      button: void 0\n    };\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <b> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      b: {}\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = _o, this.nodes.button;\n  }\n  /**\n   * Wrap range with <b> tag\n   */\n  surround() {\n    document.execCommand(this.commandName);\n  }\n  /**\n   * Check selection and set activated state to button if there are <b> tag\n   *\n   * @returns {boolean}\n   */\n  checkState() {\n    const e = document.queryCommandState(this.commandName);\n    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e), e;\n  }\n  /**\n   * Set a shortcut\n   *\n   * @returns {boolean}\n   */\n  get shortcut() {\n    return \"CMD+B\";\n  }\n}\nXe.isInline = !0;\nXe.title = \"Bold\";\nclass Ve {\n  constructor() {\n    this.commandName = \"italic\", this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--italic\"\n    }, this.nodes = {\n      button: null\n    };\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <i> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      i: {}\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Do, this.nodes.button;\n  }\n  /**\n   * Wrap range with <i> tag\n   */\n  surround() {\n    document.execCommand(this.commandName);\n  }\n  /**\n   * Check selection and set activated state to button if there are <i> tag\n   */\n  checkState() {\n    const e = document.queryCommandState(this.commandName);\n    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e), e;\n  }\n  /**\n   * Set a shortcut\n   */\n  get shortcut() {\n    return \"CMD+I\";\n  }\n}\nVe.isInline = !0;\nVe.title = \"Italic\";\nclass qe {\n  /**\n   * @param api - Editor.js API\n   */\n  constructor({ api: e }) {\n    this.commandLink = \"createLink\", this.commandUnlink = \"unlink\", this.ENTER_KEY = 13, this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--link\",\n      buttonUnlink: \"ce-inline-tool--unlink\",\n      input: \"ce-inline-tool-input\",\n      inputShowed: \"ce-inline-tool-input--showed\"\n    }, this.nodes = {\n      button: null,\n      input: null\n    }, this.inputOpened = !1, this.toolbar = e.toolbar, this.inlineToolbar = e.inlineToolbar, this.notifier = e.notifier, this.i18n = e.i18n, this.selection = new b();\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <a> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      a: {\n        href: !0,\n        target: \"_blank\",\n        rel: \"nofollow\"\n      }\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = it, this.nodes.button;\n  }\n  /**\n   * Input for the link\n   */\n  renderActions() {\n    return this.nodes.input = document.createElement(\"input\"), this.nodes.input.placeholder = this.i18n.t(\"Add a link\"), this.nodes.input.classList.add(this.CSS.input), this.nodes.input.addEventListener(\"keydown\", (e) => {\n      e.keyCode === this.ENTER_KEY && this.enterPressed(e);\n    }), this.nodes.input;\n  }\n  /**\n   * Handle clicks on the Inline Toolbar icon\n   *\n   * @param {Range} range - range to wrap with link\n   */\n  surround(e) {\n    if (e) {\n      this.inputOpened ? (this.selection.restore(), this.selection.removeFakeBackground()) : (this.selection.setFakeBackground(), this.selection.save());\n      const t = this.selection.findParentTag(\"A\");\n      if (t) {\n        this.selection.expandToTag(t), this.unlink(), this.closeActions(), this.checkState(), this.toolbar.close();\n        return;\n      }\n    }\n    this.toggleActions();\n  }\n  /**\n   * Check selection and set activated state to button if there are <a> tag\n   */\n  checkState() {\n    const e = this.selection.findParentTag(\"A\");\n    if (e) {\n      this.nodes.button.innerHTML = zo, this.nodes.button.classList.add(this.CSS.buttonUnlink), this.nodes.button.classList.add(this.CSS.buttonActive), this.openActions();\n      const t = e.getAttribute(\"href\");\n      this.nodes.input.value = t !== \"null\" ? t : \"\", this.selection.save();\n    } else\n      this.nodes.button.innerHTML = it, this.nodes.button.classList.remove(this.CSS.buttonUnlink), this.nodes.button.classList.remove(this.CSS.buttonActive);\n    return !!e;\n  }\n  /**\n   * Function called with Inline Toolbar closing\n   */\n  clear() {\n    this.closeActions();\n  }\n  /**\n   * Set a shortcut\n   */\n  get shortcut() {\n    return \"CMD+K\";\n  }\n  /**\n   * Show/close link input\n   */\n  toggleActions() {\n    this.inputOpened ? this.closeActions(!1) : this.openActions(!0);\n  }\n  /**\n   * @param {boolean} needFocus - on link creation we need to focus input. On editing - nope.\n   */\n  openActions(e = !1) {\n    this.nodes.input.classList.add(this.CSS.inputShowed), e && this.nodes.input.focus(), this.inputOpened = !0;\n  }\n  /**\n   * Close input\n   *\n   * @param {boolean} clearSavedSelection — we don't need to clear saved selection\n   *                                        on toggle-clicks on the icon of opened Toolbar\n   */\n  closeActions(e = !0) {\n    if (this.selection.isFakeBackgroundEnabled) {\n      const t = new b();\n      t.save(), this.selection.restore(), this.selection.removeFakeBackground(), t.restore();\n    }\n    this.nodes.input.classList.remove(this.CSS.inputShowed), this.nodes.input.value = \"\", e && this.selection.clearSaved(), this.inputOpened = !1;\n  }\n  /**\n   * Enter pressed on input\n   *\n   * @param {KeyboardEvent} event - enter keydown event\n   */\n  enterPressed(e) {\n    let t = this.nodes.input.value || \"\";\n    if (!t.trim()) {\n      this.selection.restore(), this.unlink(), e.preventDefault(), this.closeActions();\n      return;\n    }\n    if (!this.validateURL(t)) {\n      this.notifier.show({\n        message: \"Pasted link is not valid.\",\n        style: \"error\"\n      }), T(\"Incorrect Link pasted\", \"warn\", t);\n      return;\n    }\n    t = this.prepareLink(t), this.selection.restore(), this.selection.removeFakeBackground(), this.insertLink(t), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation(), this.selection.collapseToEnd(), this.inlineToolbar.close();\n  }\n  /**\n   * Detects if passed string is URL\n   *\n   * @param {string} str - string to validate\n   * @returns {boolean}\n   */\n  validateURL(e) {\n    return !/\\s/.test(e);\n  }\n  /**\n   * Process link before injection\n   * - sanitize\n   * - add protocol for links like 'google.com'\n   *\n   * @param {string} link - raw user input\n   */\n  prepareLink(e) {\n    return e = e.trim(), e = this.addProtocol(e), e;\n  }\n  /**\n   * Add 'http' protocol to the links like 'vc.ru', 'google.com'\n   *\n   * @param {string} link - string to process\n   */\n  addProtocol(e) {\n    if (/^(\\w+):(\\/\\/)?/.test(e))\n      return e;\n    const t = /^\\/[^/\\s]/.test(e), o = e.substring(0, 1) === \"#\", i = /^\\/\\/[^/\\s]/.test(e);\n    return !t && !o && !i && (e = \"http://\" + e), e;\n  }\n  /**\n   * Inserts <a> tag with \"href\"\n   *\n   * @param {string} link - \"href\" value\n   */\n  insertLink(e) {\n    const t = this.selection.findParentTag(\"A\");\n    t && this.selection.expandToTag(t), document.execCommand(this.commandLink, !1, e);\n  }\n  /**\n   * Removes <a> tag\n   */\n  unlink() {\n    document.execCommand(this.commandUnlink);\n  }\n}\nqe.isInline = !0;\nqe.title = \"Link\";\nclass St {\n  /**\n   * @param options - constructor options\n   * @param options.data - stub tool data\n   * @param options.api - Editor.js API\n   */\n  constructor({ data: e, api: t }) {\n    this.CSS = {\n      wrapper: \"ce-stub\",\n      info: \"ce-stub__info\",\n      title: \"ce-stub__title\",\n      subtitle: \"ce-stub__subtitle\"\n    }, this.api = t, this.title = e.title || this.api.i18n.t(\"Error\"), this.subtitle = this.api.i18n.t(\"The block can not be displayed correctly.\"), this.savedData = e.savedData, this.wrapper = this.make();\n  }\n  /**\n   * Returns stub holder\n   *\n   * @returns {HTMLElement}\n   */\n  render() {\n    return this.wrapper;\n  }\n  /**\n   * Return original Tool data\n   *\n   * @returns {BlockToolData}\n   */\n  save() {\n    return this.savedData;\n  }\n  /**\n   * Create Tool html markup\n   *\n   * @returns {HTMLElement}\n   */\n  make() {\n    const e = c.make(\"div\", this.CSS.wrapper), t = Uo, o = c.make(\"div\", this.CSS.info), i = c.make(\"div\", this.CSS.title, {\n      textContent: this.title\n    }), n = c.make(\"div\", this.CSS.subtitle, {\n      textContent: this.subtitle\n    });\n    return e.innerHTML = t, o.appendChild(i), o.appendChild(n), e.appendChild(o), e;\n  }\n}\nSt.isReadOnlySupported = !0;\nclass ui extends Ye {\n  constructor() {\n    super(...arguments), this.type = Be.Inline;\n  }\n  /**\n   * Returns title for Inline Tool if specified by user\n   */\n  get title() {\n    return this.constructable[We.Title];\n  }\n  /**\n   * Constructs new InlineTool instance from constructable\n   */\n  create() {\n    return new this.constructable({\n      api: this.api.getMethodsForTool(this),\n      config: this.settings\n    });\n  }\n}\nclass pi extends Ye {\n  constructor() {\n    super(...arguments), this.type = Be.Tune;\n  }\n  /**\n   * Constructs new BlockTune instance from constructable\n   *\n   * @param data - Tune data\n   * @param block - Block API object\n   */\n  create(e, t) {\n    return new this.constructable({\n      api: this.api.getMethodsForTool(this),\n      config: this.settings,\n      block: t,\n      data: e\n    });\n  }\n}\nclass P extends Map {\n  /**\n   * Returns Block Tools collection\n   */\n  get blockTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isBlock());\n    return new P(e);\n  }\n  /**\n   * Returns Inline Tools collection\n   */\n  get inlineTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isInline());\n    return new P(e);\n  }\n  /**\n   * Returns Block Tunes collection\n   */\n  get blockTunes() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isTune());\n    return new P(e);\n  }\n  /**\n   * Returns internal Tools collection\n   */\n  get internalTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isInternal);\n    return new P(e);\n  }\n  /**\n   * Returns Tools collection provided by user\n   */\n  get externalTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => !t.isInternal);\n    return new P(e);\n  }\n}\nvar fi = Object.defineProperty, gi = Object.getOwnPropertyDescriptor, It = (s, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? gi(e, t) : e, n = s.length - 1, r; n >= 0; n--)\n    (r = s[n]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && fi(e, t, i), i;\n};\nclass Ze extends Ye {\n  constructor() {\n    super(...arguments), this.type = Be.Block, this.inlineTools = new P(), this.tunes = new P();\n  }\n  /**\n   * Creates new Tool instance\n   *\n   * @param data - Tool data\n   * @param block - BlockAPI for current Block\n   * @param readOnly - True if Editor is in read-only mode\n   */\n  create(e, t, o) {\n    return new this.constructable({\n      data: e,\n      block: t,\n      readOnly: o,\n      api: this.api.getMethodsForTool(this),\n      config: this.settings\n    });\n  }\n  /**\n   * Returns true if read-only mode is supported by Tool\n   */\n  get isReadOnlySupported() {\n    return this.constructable[se.IsReadOnlySupported] === !0;\n  }\n  /**\n   * Returns true if Tool supports linebreaks\n   */\n  get isLineBreaksEnabled() {\n    return this.constructable[se.IsEnabledLineBreaks];\n  }\n  /**\n   * Returns Tool toolbox configuration (internal or user-specified).\n   *\n   * Merges internal and user-defined toolbox configs based on the following rules:\n   *\n   * - If both internal and user-defined toolbox configs are arrays their items are merged.\n   * Length of the second one is kept.\n   *\n   * - If both are objects their properties are merged.\n   *\n   * - If one is an object and another is an array than internal config is replaced with user-defined\n   * config. This is made to allow user to override default tool's toolbox representation (single/multiple entries)\n   */\n  get toolbox() {\n    const e = this.constructable[se.Toolbox], t = this.config[ve.Toolbox];\n    if (!W(e) && t !== !1)\n      return t ? Array.isArray(e) ? Array.isArray(t) ? t.map((o, i) => {\n        const n = e[i];\n        return n ? {\n          ...n,\n          ...o\n        } : o;\n      }) : [t] : Array.isArray(t) ? t : [\n        {\n          ...e,\n          ...t\n        }\n      ] : Array.isArray(e) ? e : [e];\n  }\n  /**\n   * Returns Tool conversion configuration\n   */\n  get conversionConfig() {\n    return this.constructable[se.ConversionConfig];\n  }\n  /**\n   * Returns enabled inline tools for Tool\n   */\n  get enabledInlineTools() {\n    return this.config[ve.EnabledInlineTools] || !1;\n  }\n  /**\n   * Returns enabled tunes for Tool\n   */\n  get enabledBlockTunes() {\n    return this.config[ve.EnabledBlockTunes];\n  }\n  /**\n   * Returns Tool paste configuration\n   */\n  get pasteConfig() {\n    return this.constructable[se.PasteConfig] ?? {};\n  }\n  get sanitizeConfig() {\n    const e = super.sanitizeConfig, t = this.baseSanitizeConfig;\n    if (W(e))\n      return t;\n    const o = {};\n    for (const i in e)\n      if (Object.prototype.hasOwnProperty.call(e, i)) {\n        const n = e[i];\n        D(n) ? o[i] = Object.assign({}, t, n) : o[i] = n;\n      }\n    return o;\n  }\n  get baseSanitizeConfig() {\n    const e = {};\n    return Array.from(this.inlineTools.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), Array.from(this.tunes.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), e;\n  }\n}\nIt([\n  le\n], Ze.prototype, \"sanitizeConfig\", 1);\nIt([\n  le\n], Ze.prototype, \"baseSanitizeConfig\", 1);\nclass bi {\n  /**\n   * @class\n   * @param config - tools config\n   * @param editorConfig - EditorJS config\n   * @param api - EditorJS API module\n   */\n  constructor(e, t, o) {\n    this.api = o, this.config = e, this.editorConfig = t;\n  }\n  /**\n   * Returns Tool object based on it's type\n   *\n   * @param name - tool name\n   */\n  get(e) {\n    const { class: t, isInternal: o = !1, ...i } = this.config[e], n = this.getConstructor(t);\n    return new n({\n      name: e,\n      constructable: t,\n      config: i,\n      api: this.api,\n      isDefault: e === this.editorConfig.defaultBlock,\n      defaultPlaceholder: this.editorConfig.placeholder,\n      isInternal: o\n    });\n  }\n  /**\n   * Find appropriate Tool object constructor for Tool constructable\n   *\n   * @param constructable - Tools constructable\n   */\n  getConstructor(e) {\n    switch (!0) {\n      case e[We.IsInline]:\n        return ui;\n      case e[Bt.IsTune]:\n        return pi;\n      default:\n        return Ze;\n    }\n  }\n}\nclass Mt {\n  /**\n   * MoveDownTune constructor\n   *\n   * @param {API} api — Editor's API\n   */\n  constructor({ api: e }) {\n    this.CSS = {\n      animation: \"wobble\"\n    }, this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: kt,\n      title: this.api.i18n.t(\"Move down\"),\n      onActivate: () => this.handleClick(),\n      name: \"move-down\"\n    };\n  }\n  /**\n   * Handle clicks on 'move down' button\n   */\n  handleClick() {\n    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e + 1);\n    if (!t)\n      throw new Error(\"Unable to move Block down since it is already the last\");\n    const o = t.holder, i = o.getBoundingClientRect();\n    let n = Math.abs(window.innerHeight - o.offsetHeight);\n    i.top < window.innerHeight && (n = window.scrollY + o.offsetHeight), window.scrollTo(0, n), this.api.blocks.move(e + 1), this.api.toolbar.toggleBlockSettings(!0);\n  }\n}\nMt.isTune = !0;\nclass Lt {\n  /**\n   * DeleteTune constructor\n   *\n   * @param {API} api - Editor's API\n   */\n  constructor({ api: e }) {\n    this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: No,\n      title: this.api.i18n.t(\"Delete\"),\n      name: \"delete\",\n      confirmation: {\n        title: this.api.i18n.t(\"Click to delete\"),\n        onActivate: () => this.handleClick()\n      }\n    };\n  }\n  /**\n   * Delete block conditions passed\n   */\n  handleClick() {\n    this.api.blocks.delete();\n  }\n}\nLt.isTune = !0;\nclass At {\n  /**\n   * MoveUpTune constructor\n   *\n   * @param {API} api - Editor's API\n   */\n  constructor({ api: e }) {\n    this.CSS = {\n      animation: \"wobble\"\n    }, this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Oo,\n      title: this.api.i18n.t(\"Move up\"),\n      onActivate: () => this.handleClick(),\n      name: \"move-up\"\n    };\n  }\n  /**\n   * Move current block up\n   */\n  handleClick() {\n    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e), o = this.api.blocks.getBlockByIndex(e - 1);\n    if (e === 0 || !t || !o)\n      throw new Error(\"Unable to move Block up since it is already the first\");\n    const i = t.holder, n = o.holder, r = i.getBoundingClientRect(), a = n.getBoundingClientRect();\n    let l;\n    a.top > 0 ? l = Math.abs(r.top) - Math.abs(a.top) : l = Math.abs(r.top) + a.height, window.scrollBy(0, -1 * l), this.api.blocks.move(e - 1), this.api.toolbar.toggleBlockSettings(!0);\n  }\n}\nAt.isTune = !0;\nvar mi = Object.defineProperty, ki = Object.getOwnPropertyDescriptor, vi = (s, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? ki(e, t) : e, n = s.length - 1, r; n >= 0; n--)\n    (r = s[n]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && mi(e, t, i), i;\n};\nclass _t extends y {\n  constructor() {\n    super(...arguments), this.stubTool = \"stub\", this.toolsAvailable = new P(), this.toolsUnavailable = new P();\n  }\n  /**\n   * Returns available Tools\n   */\n  get available() {\n    return this.toolsAvailable;\n  }\n  /**\n   * Returns unavailable Tools\n   */\n  get unavailable() {\n    return this.toolsUnavailable;\n  }\n  /**\n   * Return Tools for the Inline Toolbar\n   */\n  get inlineTools() {\n    return this.available.inlineTools;\n  }\n  /**\n   * Return editor block tools\n   */\n  get blockTools() {\n    return this.available.blockTools;\n  }\n  /**\n   * Return available Block Tunes\n   *\n   * @returns {object} - object of Inline Tool's classes\n   */\n  get blockTunes() {\n    return this.available.blockTunes;\n  }\n  /**\n   * Returns default Tool object\n   */\n  get defaultTool() {\n    return this.blockTools.get(this.config.defaultBlock);\n  }\n  /**\n   * Returns internal tools\n   */\n  get internal() {\n    return this.available.internalTools;\n  }\n  /**\n   * Creates instances via passed or default configuration\n   *\n   * @returns {Promise<void>}\n   */\n  async prepare() {\n    if (this.validateTools(), this.config.tools = Me({}, this.internalTools, this.config.tools), !Object.prototype.hasOwnProperty.call(this.config, \"tools\") || Object.keys(this.config.tools).length === 0)\n      throw Error(\"Can't start without tools\");\n    const e = this.prepareConfig();\n    this.factory = new bi(e, this.config, this.Editor.API);\n    const t = this.getListOfPrepareFunctions(e);\n    if (t.length === 0)\n      return Promise.resolve();\n    await zt(t, (o) => {\n      this.toolPrepareMethodSuccess(o);\n    }, (o) => {\n      this.toolPrepareMethodFallback(o);\n    }), this.prepareBlockTools();\n  }\n  getAllInlineToolsSanitizeConfig() {\n    const e = {};\n    return Array.from(this.inlineTools.values()).forEach((t) => {\n      Object.assign(e, t.sanitizeConfig);\n    }), e;\n  }\n  /**\n   * Calls each Tool reset method to clean up anything set by Tool\n   */\n  destroy() {\n    Object.values(this.available).forEach(async (e) => {\n      M(e.reset) && await e.reset();\n    });\n  }\n  /**\n   * Returns internal tools\n   * Includes Bold, Italic, Link and Paragraph\n   */\n  get internalTools() {\n    return {\n      bold: {\n        class: Xe,\n        isInternal: !0\n      },\n      italic: {\n        class: Ve,\n        isInternal: !0\n      },\n      link: {\n        class: qe,\n        isInternal: !0\n      },\n      paragraph: {\n        class: Ke,\n        inlineToolbar: !0,\n        isInternal: !0\n      },\n      stub: {\n        class: St,\n        isInternal: !0\n      },\n      moveUp: {\n        class: At,\n        isInternal: !0\n      },\n      delete: {\n        class: Lt,\n        isInternal: !0\n      },\n      moveDown: {\n        class: Mt,\n        isInternal: !0\n      }\n    };\n  }\n  /**\n   * Tool prepare method success callback\n   *\n   * @param {object} data - append tool to available list\n   */\n  toolPrepareMethodSuccess(e) {\n    const t = this.factory.get(e.toolName);\n    if (t.isInline()) {\n      const i = [\"render\", \"surround\", \"checkState\"].filter((n) => !t.create()[n]);\n      if (i.length) {\n        T(\n          `Incorrect Inline Tool: ${t.name}. Some of required methods is not implemented %o`,\n          \"warn\",\n          i\n        ), this.toolsUnavailable.set(t.name, t);\n        return;\n      }\n    }\n    this.toolsAvailable.set(t.name, t);\n  }\n  /**\n   * Tool prepare method fail callback\n   *\n   * @param {object} data - append tool to unavailable list\n   */\n  toolPrepareMethodFallback(e) {\n    this.toolsUnavailable.set(e.toolName, this.factory.get(e.toolName));\n  }\n  /**\n   * Binds prepare function of plugins with user or default config\n   *\n   * @returns {Array} list of functions that needs to be fired sequentially\n   * @param config - tools config\n   */\n  getListOfPrepareFunctions(e) {\n    const t = [];\n    return Object.entries(e).forEach(([o, i]) => {\n      t.push({\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        function: M(i.class.prepare) ? i.class.prepare : () => {\n        },\n        data: {\n          toolName: o,\n          config: i.config\n        }\n      });\n    }), t;\n  }\n  /**\n   * Assign enabled Inline Tools and Block Tunes for Block Tool\n   */\n  prepareBlockTools() {\n    Array.from(this.blockTools.values()).forEach((e) => {\n      this.assignInlineToolsToBlockTool(e), this.assignBlockTunesToBlockTool(e);\n    });\n  }\n  /**\n   * Assign enabled Inline Tools for Block Tool\n   *\n   * @param tool - Block Tool\n   */\n  assignInlineToolsToBlockTool(e) {\n    if (this.config.inlineToolbar !== !1) {\n      if (e.enabledInlineTools === !0) {\n        e.inlineTools = new P(\n          Array.isArray(this.config.inlineToolbar) ? this.config.inlineToolbar.map((t) => [t, this.inlineTools.get(t)]) : Array.from(this.inlineTools.entries())\n        );\n        return;\n      }\n      Array.isArray(e.enabledInlineTools) && (e.inlineTools = new P(\n        e.enabledInlineTools.map((t) => [t, this.inlineTools.get(t)])\n      ));\n    }\n  }\n  /**\n   * Assign enabled Block Tunes for Block Tool\n   *\n   * @param tool — Block Tool\n   */\n  assignBlockTunesToBlockTool(e) {\n    if (e.enabledBlockTunes !== !1) {\n      if (Array.isArray(e.enabledBlockTunes)) {\n        const t = new P(\n          e.enabledBlockTunes.map((o) => [o, this.blockTunes.get(o)])\n        );\n        e.tunes = new P([...t, ...this.blockTunes.internalTools]);\n        return;\n      }\n      if (Array.isArray(this.config.tunes)) {\n        const t = new P(\n          this.config.tunes.map((o) => [o, this.blockTunes.get(o)])\n        );\n        e.tunes = new P([...t, ...this.blockTunes.internalTools]);\n        return;\n      }\n      e.tunes = this.blockTunes.internalTools;\n    }\n  }\n  /**\n   * Validate Tools configuration objects and throw Error for user if it is invalid\n   */\n  validateTools() {\n    for (const e in this.config.tools)\n      if (Object.prototype.hasOwnProperty.call(this.config.tools, e)) {\n        if (e in this.internalTools)\n          return;\n        const t = this.config.tools[e];\n        if (!M(t) && !M(t.class))\n          throw Error(\n            `Tool «${e}» must be a constructor function or an object with function in the «class» property`\n          );\n      }\n  }\n  /**\n   * Unify tools config\n   */\n  prepareConfig() {\n    const e = {};\n    for (const t in this.config.tools)\n      D(this.config.tools[t]) ? e[t] = this.config.tools[t] : e[t] = { class: this.config.tools[t] };\n    return e;\n  }\n}\nvi([\n  le\n], _t.prototype, \"getAllInlineToolsSanitizeConfig\", 1);\nconst xi = `:root{--selectionColor: #e1f2ff;--inlineSelectionColor: #d4ecff;--bg-light: #eff2f5;--grayText: #707684;--color-dark: #1D202B;--color-active-icon: #388AE5;--color-gray-border: rgba(201, 201, 204, .48);--content-width: 650px;--narrow-mode-right-padding: 50px;--toolbox-buttons-size: 26px;--toolbox-buttons-size--mobile: 36px;--icon-size: 20px;--icon-size--mobile: 28px;--block-padding-vertical: .4em;--color-line-gray: #EFF0F1 }.codex-editor{position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.codex-editor .hide{display:none}.codex-editor__redactor [contenteditable]:empty:after{content:\"\\\\feff\"}@media (min-width: 651px){.codex-editor--narrow .codex-editor__redactor{margin-right:50px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .codex-editor__redactor{margin-left:50px;margin-right:0}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__actions{right:-5px}}.codex-editor-copyable{position:absolute;height:1px;width:1px;top:-400%;opacity:.001}.codex-editor-overlay{position:fixed;top:0px;left:0px;right:0px;bottom:0px;z-index:999;pointer-events:none;overflow:hidden}.codex-editor-overlay__container{position:relative;pointer-events:auto;z-index:0}.codex-editor-overlay__rectangle{position:absolute;pointer-events:none;background-color:#2eaadc33;border:1px solid transparent}.codex-editor svg{max-height:100%}.codex-editor path{stroke:currentColor}.codex-editor ::-moz-selection{background-color:#d4ecff}.codex-editor ::selection{background-color:#d4ecff}.codex-editor--toolbox-opened [contentEditable=true][data-placeholder]:focus:before{opacity:0!important}.ce-scroll-locked{overflow:hidden}.ce-scroll-locked--hard{overflow:hidden;top:calc(-1 * var(--window-scroll-offset));position:fixed;width:100%}.ce-toolbar{position:absolute;left:0;right:0;top:0;-webkit-transition:opacity .1s ease;transition:opacity .1s ease;will-change:opacity,top;display:none}.ce-toolbar--opened{display:block}.ce-toolbar__content{max-width:650px;margin:0 auto;position:relative}.ce-toolbar__plus{color:#1d202b;cursor:pointer;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-flex-negative:0;flex-shrink:0}@media (max-width: 650px){.ce-toolbar__plus{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__plus:hover{background-color:#eff2f5}}.ce-toolbar__plus--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-toolbar__plus-shortcut{opacity:.6;word-spacing:-2px;margin-top:5px}@media (max-width: 650px){.ce-toolbar__plus{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__plus--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__plus--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__actions{position:absolute;right:100%;opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;padding-right:5px}.ce-toolbar__actions--opened{opacity:1}@media (max-width: 650px){.ce-toolbar__actions{right:auto}}.ce-toolbar__settings-btn{color:#1d202b;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;margin-left:3px;cursor:pointer;user-select:none}@media (max-width: 650px){.ce-toolbar__settings-btn{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__settings-btn:hover{background-color:#eff2f5}}.ce-toolbar__settings-btn--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@media (min-width: 651px){.ce-toolbar__settings-btn{width:24px}}.ce-toolbar__settings-btn--hidden{display:none}@media (max-width: 650px){.ce-toolbar__settings-btn{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__settings-btn--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__settings-btn--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__plus svg,.ce-toolbar__settings-btn svg{width:24px;height:24px}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__plus{left:5px}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbox .ce-popover{right:0;left:auto;left:initial}}.ce-inline-toolbar{--y-offset: 8px;position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;opacity:0;visibility:hidden;-webkit-transition:opacity .25s ease;transition:opacity .25s ease;will-change:opacity,left,top;top:0;left:0;z-index:3}.ce-inline-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-inline-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-inline-toolbar--showed{opacity:1;visibility:visible}.ce-inline-toolbar [hidden]{display:none!important}.ce-inline-toolbar__toggler-and-button-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;padding:0 6px}.ce-inline-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown{display:-webkit-box;display:-ms-flexbox;display:flex;padding:6px;margin:0 6px 0 -6px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-right:1px solid rgba(201,201,204,.48);-webkit-box-sizing:border-box;box-sizing:border-box}@media (hover: hover){.ce-inline-toolbar__dropdown:hover{background:#eff2f5}}.ce-inline-toolbar__dropdown--hidden{display:none}.ce-inline-toolbar__dropdown-content,.ce-inline-toolbar__dropdown-arrow{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown-content svg,.ce-inline-toolbar__dropdown-arrow svg{width:20px;height:20px}.ce-inline-toolbar__shortcut{opacity:.6;word-spacing:-3px;margin-top:3px}.ce-inline-tool{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;border-radius:0;line-height:normal}.ce-inline-tool svg{width:20px;height:20px}@media (max-width: 650px){.ce-inline-tool svg{width:28px;height:28px}}@media (hover: hover){.ce-inline-tool:hover{background-color:#eff2f5}}.ce-inline-tool--active{color:#388ae5}.ce-inline-tool--focused{background:rgba(34,186,255,.08)!important}.ce-inline-tool--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-inline-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-inline-tool--link .icon--unlink,.ce-inline-tool--unlink .icon--link{display:none}.ce-inline-tool--unlink .icon--unlink{display:inline-block;margin-bottom:-1px}.ce-inline-tool-input{outline:none;border:0;border-radius:0 0 4px 4px;margin:0;font-size:13px;padding:10px;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:none;font-weight:500;border-top:1px solid rgba(201,201,204,.48);-webkit-appearance:none;font-family:inherit}@media (max-width: 650px){.ce-inline-tool-input{font-size:15px;font-weight:500}}.ce-inline-tool-input::-webkit-input-placeholder{color:#707684}.ce-inline-tool-input::-moz-placeholder{color:#707684}.ce-inline-tool-input:-ms-input-placeholder{color:#707684}.ce-inline-tool-input::-ms-input-placeholder{color:#707684}.ce-inline-tool-input::placeholder{color:#707684}.ce-inline-tool-input--showed{display:block}.ce-conversion-toolbar{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;opacity:0;visibility:hidden;will-change:transform,opacity;-webkit-transition:opacity .1s ease,-webkit-transform .1s ease;transition:opacity .1s ease,-webkit-transform .1s ease;transition:transform .1s ease,opacity .1s ease;transition:transform .1s ease,opacity .1s ease,-webkit-transform .1s ease;-webkit-transform:translateY(-8px);transform:translateY(-8px);left:-1px;width:190px;margin-top:5px;-webkit-box-sizing:content-box;box-sizing:content-box}.ce-conversion-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-conversion-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-conversion-toolbar--showed{opacity:1;visibility:visible;-webkit-transform:none;transform:none}.ce-conversion-toolbar [hidden]{display:none!important}.ce-conversion-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-conversion-toolbar__label{color:#707684;font-size:11px;font-weight:500;letter-spacing:.33px;padding:10px 10px 5px;text-transform:uppercase}.ce-conversion-tool{display:-webkit-box;display:-ms-flexbox;display:flex;padding:5px 10px;font-size:14px;line-height:20px;font-weight:500;cursor:pointer;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-conversion-tool--hidden{display:none}.ce-conversion-tool--focused{background:rgba(34,186,255,.08)!important}.ce-conversion-tool--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-conversion-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-conversion-tool:hover{background:#eff2f5}.ce-conversion-tool__icon{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;width:26px;height:26px;-webkit-box-shadow:0 0 0 1px rgba(201,201,204,.48);box-shadow:0 0 0 1px #c9c9cc7a;border-radius:5px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;background:#fff;-webkit-box-sizing:content-box;box-sizing:content-box;-ms-flex-negative:0;flex-shrink:0;margin-right:10px}.ce-conversion-tool__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-conversion-tool__icon{width:36px;height:36px;border-radius:8px}.ce-conversion-tool__icon svg{width:28px;height:28px}}.ce-conversion-tool--last{margin-right:0!important}.ce-conversion-tool--active{color:#388ae5!important}.ce-conversion-tool--active{-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-conversion-tool__secondary-label{color:#707684;font-size:12px;margin-left:auto;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;margin-bottom:-2px;opacity:.6}@media (max-width: 650px){.ce-conversion-tool__secondary-label{display:none}}.ce-settings__button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;line-height:32px}.ce-settings__button svg{width:20px;height:20px}@media (max-width: 650px){.ce-settings__button svg{width:28px;height:28px}}@media (hover: hover){.ce-settings__button:hover{background-color:#eff2f5}}.ce-settings__button--active{color:#388ae5}.ce-settings__button--focused{background:rgba(34,186,255,.08)!important}.ce-settings__button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-settings__button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-settings__button:not(:nth-child(3n+3)){margin-right:3px}.ce-settings__button:nth-child(n+4){margin-top:3px}.ce-settings__button--disabled{cursor:not-allowed!important}.ce-settings__button--disabled{opacity:.3}.ce-settings__button--selected{color:#388ae5}@media (min-width: 651px){.codex-editor--narrow .ce-settings .ce-popover{right:0;left:auto;left:initial}}@-webkit-keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-in{0%{opacity:0}to{opacity:1}}.ce-block{-webkit-animation:fade-in .3s ease;animation:fade-in .3s ease;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-animation-fill-mode:initial;animation-fill-mode:initial}.ce-block:first-of-type{margin-top:0}.ce-block--selected .ce-block__content{background:#e1f2ff}.ce-block--selected .ce-block__content [contenteditable]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-block--selected .ce-block__content img,.ce-block--selected .ce-block__content .ce-stub{opacity:.55}.ce-block--stretched .ce-block__content{max-width:none}.ce-block__content{position:relative;max-width:650px;margin:0 auto;-webkit-transition:background-color .15s ease;transition:background-color .15s ease}.ce-block--drop-target .ce-block__content:before{content:\"\";position:absolute;top:100%;left:-20px;margin-top:-1px;height:8px;width:8px;border:solid #388AE5;border-width:1px 1px 0 0;-webkit-transform-origin:right;transform-origin:right;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.ce-block--drop-target .ce-block__content:after{content:\"\";position:absolute;top:100%;height:1px;width:100%;color:#388ae5;background:repeating-linear-gradient(90deg,#388AE5,#388AE5 1px,#fff 1px,#fff 6px)}.ce-block a{cursor:pointer;-webkit-text-decoration:underline;text-decoration:underline}.ce-block b{font-weight:700}.ce-block i{font-style:italic}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}.cdx-block{padding:.4em 0}.cdx-block::-webkit-input-placeholder{line-height:normal!important}.cdx-input{border:1px solid rgba(201,201,204,.48);-webkit-box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);box-shadow:inset 0 1px 2px #232c480f;border-radius:3px;padding:10px 12px;outline:none;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.cdx-input[data-placeholder]:before{position:static!important}.cdx-input[data-placeholder]:before{display:inline-block;width:0;white-space:nowrap;pointer-events:none}.cdx-settings-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;min-width:26px;min-height:26px}.cdx-settings-button svg{width:20px;height:20px}@media (max-width: 650px){.cdx-settings-button svg{width:28px;height:28px}}@media (hover: hover){.cdx-settings-button:hover{background-color:#eff2f5}}.cdx-settings-button--focused{background:rgba(34,186,255,.08)!important}.cdx-settings-button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.cdx-settings-button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.cdx-settings-button--active{color:#388ae5}.cdx-settings-button svg{width:auto;height:auto}@media (max-width: 650px){.cdx-settings-button{width:36px;height:36px;border-radius:8px}}.cdx-loader{position:relative;border:1px solid rgba(201,201,204,.48)}.cdx-loader:before{content:\"\";position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-11px 0 0 -11px;border:2px solid rgba(201,201,204,.48);border-left-color:#388ae5;border-radius:50%;-webkit-animation:cdxRotation 1.2s infinite linear;animation:cdxRotation 1.2s infinite linear}@-webkit-keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.cdx-button{padding:13px;border-radius:3px;border:1px solid rgba(201,201,204,.48);font-size:14.9px;background:#fff;-webkit-box-shadow:0 2px 2px 0 rgba(18,30,57,.04);box-shadow:0 2px 2px #121e390a;color:#707684;text-align:center;cursor:pointer}@media (hover: hover){.cdx-button:hover{background:#FBFCFE;-webkit-box-shadow:0 1px 3px 0 rgba(18,30,57,.08);box-shadow:0 1px 3px #121e3914}}.cdx-button svg{height:20px;margin-right:.2em;margin-top:-2px}.ce-stub{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:12px 18px;margin:10px 0;border-radius:10px;background:#eff2f5;border:1px solid #EFF0F1;color:#707684;font-size:14px}.ce-stub svg{width:20px;height:20px}.ce-stub__info{margin-left:14px}.ce-stub__title{font-weight:500;text-transform:capitalize}.codex-editor.codex-editor--rtl{direction:rtl}.codex-editor.codex-editor--rtl .cdx-list{padding-left:0;padding-right:40px}.codex-editor.codex-editor--rtl .ce-toolbar__plus{right:-26px;left:auto}.codex-editor.codex-editor--rtl .ce-toolbar__actions{right:auto;left:-26px}@media (max-width: 650px){.codex-editor.codex-editor--rtl .ce-toolbar__actions{margin-left:0;margin-right:auto;padding-right:0;padding-left:10px}}.codex-editor.codex-editor--rtl .ce-settings{left:5px;right:auto}.codex-editor.codex-editor--rtl .ce-settings:before{right:auto;left:25px}.codex-editor.codex-editor--rtl .ce-settings__button:not(:nth-child(3n+3)){margin-left:3px;margin-right:0}.codex-editor.codex-editor--rtl .ce-conversion-tool__icon{margin-right:0;margin-left:10px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown{border-right:0px solid transparent;border-left:1px solid rgba(201,201,204,.48);margin:0 -6px 0 6px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:0;margin-right:4px}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__plus{left:0px;right:5px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__actions{left:-5px}}.cdx-search-field{--icon-margin-right: 10px;background:rgba(232,232,235,.49);border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-search-field__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:var(--icon-margin-right)}.cdx-search-field__icon svg{width:20px;height:20px;color:#707684}.cdx-search-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - 26px - var(--icon-margin-right))}.cdx-search-field__input::-webkit-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-moz-placeholder{color:#707684;font-weight:500}.cdx-search-field__input:-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::placeholder{color:#707684;font-weight:500}.ce-popover{--border-radius: 6px;--width: 200px;--max-height: 270px;--padding: 6px;--offset-from-target: 8px;--color-border: #e8e8eb;--color-shadow: rgba(13,20,33,.13);--color-background: white;--color-text-primary: black;--color-text-secondary: #707684;--color-border-icon: rgba(201, 201, 204, .48);--color-border-icon-disabled: #EFF0F1;--color-text-icon-active: #388AE5;--color-background-icon-active: rgba(56, 138, 229, .1);--color-background-item-focus: rgba(34, 186, 255, .08);--color-shadow-item-focus: rgba(7, 161, 227, .08);--color-background-item-hover: #eff2f5;--color-background-item-confirm: #E24A4A;--color-background-item-confirm-hover: #CE4343;min-width:var(--width);width:var(--width);max-height:var(--max-height);border-radius:var(--border-radius);overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:0 3px 15px -3px var(--color-shadow);box-shadow:0 3px 15px -3px var(--color-shadow);position:absolute;left:0;top:calc(100% + var(--offset-from-target));background:var(--color-background);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:4;opacity:0;max-height:0;pointer-events:none;padding:0;border:none}.ce-popover--opened{opacity:1;padding:var(--padding);max-height:var(--max-height);pointer-events:auto;-webkit-animation:panelShowing .1s ease;animation:panelShowing .1s ease;border:1px solid var(--color-border)}@media (max-width: 650px){.ce-popover--opened{-webkit-animation:panelShowingMobile .25s ease;animation:panelShowingMobile .25s ease}}.ce-popover__items{overflow-y:auto;-ms-scroll-chaining:none;overscroll-behavior:contain}@media (max-width: 650px){.ce-popover__overlay{position:fixed;top:0;bottom:0;left:0;right:0;background:#1D202B;z-index:3;opacity:.5;-webkit-transition:opacity .12s ease-in;transition:opacity .12s ease-in;will-change:opacity;visibility:visible}}.ce-popover__overlay--hidden{display:none}.ce-popover--open-top{top:calc(-1 * (var(--offset-from-target) + var(--popover-height)))}@media (max-width: 650px){.ce-popover{--offset: 5px;position:fixed;max-width:none;min-width:calc(100% - var(--offset) * 2);left:var(--offset);right:var(--offset);bottom:calc(var(--offset) + env(safe-area-inset-bottom));top:auto;border-radius:10px}.ce-popover .ce-popover__search{display:none}}.ce-popover__search,.ce-popover__custom-content:not(:empty){margin-bottom:5px}.ce-popover__nothing-found-message{color:#707684;display:none;cursor:default;padding:3px;font-size:14px;line-height:20px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ce-popover__nothing-found-message--displayed{display:block}.ce-popover__custom-content:not(:empty){padding:4px}@media (min-width: 651px){.ce-popover__custom-content:not(:empty){padding:0}}.ce-popover__custom-content--hidden{display:none}.ce-popover-item{--border-radius: 6px;--icon-size: 20px;--icon-size-mobile: 28px;border-radius:var(--border-radius);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:3px;color:var(--color-text-primary);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}@media (max-width: 650px){.ce-popover-item{padding:4px}}.ce-popover-item:not(:last-of-type){margin-bottom:1px}.ce-popover-item__icon{border-radius:5px;width:26px;height:26px;-webkit-box-shadow:0 0 0 1px var(--color-border-icon);box-shadow:0 0 0 1px var(--color-border-icon);background:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:10px}.ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover-item__icon{width:36px;height:36px;border-radius:8px}.ce-popover-item__icon svg{width:var(--icon-size-mobile);height:var(--icon-size-mobile)}}.ce-popover-item__title{font-size:14px;line-height:20px;font-weight:500;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}@media (max-width: 650px){.ce-popover-item__title{font-size:16px}}.ce-popover-item__secondary-title{color:var(--color-text-secondary);font-size:12px;margin-left:auto;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;margin-bottom:-2px;opacity:.6}@media (max-width: 650px){.ce-popover-item__secondary-title{display:none}}.ce-popover-item--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}.ce-popover-item--active .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}.ce-popover-item--disabled{color:var(--color-text-secondary);cursor:default;pointer-events:none}.ce-popover-item--disabled .ce-popover-item__icon{-webkit-box-shadow:0 0 0 1px var(--color-border-icon-disabled);box-shadow:0 0 0 1px var(--color-border-icon-disabled)}.ce-popover-item--focused:not(.ce-popover-item--no-focus){background:var(--color-background-item-focus)!important}.ce-popover-item--focused:not(.ce-popover-item--no-focus){-webkit-box-shadow:inset 0 0 0px 1px var(--color-shadow-item-focus);box-shadow:inset 0 0 0 1px var(--color-shadow-item-focus)}.ce-popover-item--hidden{display:none}@media (hover: hover){.ce-popover-item:hover{cursor:pointer}.ce-popover-item:hover:not(.ce-popover-item--no-hover){background-color:var(--color-background-item-hover)}.ce-popover-item:hover .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}}.ce-popover-item--confirmation{background:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__icon{color:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__title{color:#fff}@media (hover: hover){.ce-popover-item--confirmation:not(.ce-popover-item--no-hover):hover{background:var(--color-background-item-confirm-hover)}}.ce-popover-item--confirmation:not(.ce-popover-item--no-focus).ce-popover-item--focused{background:var(--color-background-item-confirm-hover)!important}.ce-popover-item--confirmation .ce-popover-item__icon,.ce-popover-item--active .ce-popover-item__icon,.ce-popover-item--focused .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}@-webkit-keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.wobble{-webkit-animation-name:wobble;animation-name:wobble;-webkit-animation-duration:.4s;animation-duration:.4s}@-webkit-keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}\n`;\nclass wi extends y {\n  constructor() {\n    super(...arguments), this.isMobile = !1, this.contentRectCache = void 0, this.resizeDebouncer = et(() => {\n      this.windowResize();\n    }, 200);\n  }\n  /**\n   * Editor.js UI CSS class names\n   *\n   * @returns {{editorWrapper: string, editorZone: string}}\n   */\n  get CSS() {\n    return {\n      editorWrapper: \"codex-editor\",\n      editorWrapperNarrow: \"codex-editor--narrow\",\n      editorZone: \"codex-editor__redactor\",\n      editorZoneHidden: \"codex-editor__redactor--hidden\",\n      editorEmpty: \"codex-editor--empty\",\n      editorRtlFix: \"codex-editor--rtl\"\n    };\n  }\n  /**\n   * Return Width of center column of Editor\n   *\n   * @returns {DOMRect}\n   */\n  get contentRect() {\n    if (this.contentRectCache)\n      return this.contentRectCache;\n    const e = this.nodes.wrapper.querySelector(`.${R.CSS.content}`);\n    return e ? (this.contentRectCache = e.getBoundingClientRect(), this.contentRectCache) : {\n      width: 650,\n      left: 0,\n      right: 0\n    };\n  }\n  /**\n   * Making main interface\n   */\n  async prepare() {\n    this.checkIsMobile(), this.make(), this.loadStyles();\n  }\n  /**\n   * Toggle read-only state\n   *\n   * If readOnly is true:\n   *  - removes all listeners from main UI module elements\n   *\n   * if readOnly is false:\n   *  - enables all listeners to UI module elements\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : window.requestIdleCallback(() => {\n      this.enableModuleBindings();\n    }, {\n      timeout: 2e3\n    });\n  }\n  /**\n   * Check if Editor is empty and set CSS class to wrapper\n   */\n  checkEmptiness() {\n    const { BlockManager: e } = this.Editor;\n    this.nodes.wrapper.classList.toggle(this.CSS.editorEmpty, e.isEditorEmpty);\n  }\n  /**\n   * Check if one of Toolbar is opened\n   * Used to prevent global keydowns (for example, Enter) conflicts with Enter-on-toolbar\n   *\n   * @returns {boolean}\n   */\n  get someToolbarOpened() {\n    const { Toolbar: e, BlockSettings: t, InlineToolbar: o, ConversionToolbar: i } = this.Editor;\n    return t.opened || o.opened || i.opened || e.toolbox.opened;\n  }\n  /**\n   * Check for some Flipper-buttons is under focus\n   */\n  get someFlipperButtonFocused() {\n    return this.Editor.Toolbar.toolbox.hasFocus() ? !0 : Object.entries(this.Editor).filter(([e, t]) => t.flipper instanceof q).some(([e, t]) => t.flipper.hasFocus());\n  }\n  /**\n   * Clean editor`s UI\n   */\n  destroy() {\n    this.nodes.holder.innerHTML = \"\";\n  }\n  /**\n   * Close all Editor's toolbars\n   */\n  closeAllToolbars() {\n    const { Toolbar: e, BlockSettings: t, InlineToolbar: o, ConversionToolbar: i } = this.Editor;\n    t.close(), o.close(), i.close(), e.toolbox.close();\n  }\n  /**\n   * Check for mobile mode and cache a result\n   */\n  checkIsMobile() {\n    this.isMobile = window.innerWidth < dt;\n  }\n  /**\n   * Makes Editor.js interface\n   */\n  make() {\n    this.nodes.holder = c.getHolder(this.config.holder), this.nodes.wrapper = c.make(\"div\", [\n      this.CSS.editorWrapper,\n      ...this.isRtl ? [this.CSS.editorRtlFix] : []\n    ]), this.nodes.redactor = c.make(\"div\", this.CSS.editorZone), this.nodes.holder.offsetWidth < this.contentRect.width && this.nodes.wrapper.classList.add(this.CSS.editorWrapperNarrow), this.nodes.redactor.style.paddingBottom = this.config.minHeight + \"px\", this.nodes.wrapper.appendChild(this.nodes.redactor), this.nodes.holder.appendChild(this.nodes.wrapper);\n  }\n  /**\n   * Appends CSS\n   */\n  loadStyles() {\n    const e = \"editor-js-styles\";\n    if (c.get(e))\n      return;\n    const t = c.make(\"style\", null, {\n      id: e,\n      textContent: xi.toString()\n    });\n    this.config.style && !W(this.config.style) && this.config.style.nonce && t.setAttribute(\"nonce\", this.config.style.nonce), c.prepend(document.head, t);\n  }\n  /**\n   * Bind events on the Editor.js interface\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(this.nodes.redactor, \"click\", (o) => {\n      this.redactorClicked(o);\n    }, !1), this.readOnlyMutableListeners.on(this.nodes.redactor, \"mousedown\", (o) => {\n      this.documentTouched(o);\n    }, {\n      capture: !0,\n      passive: !0\n    }), this.readOnlyMutableListeners.on(this.nodes.redactor, \"touchstart\", (o) => {\n      this.documentTouched(o);\n    }, {\n      capture: !0,\n      passive: !0\n    }), this.readOnlyMutableListeners.on(document, \"keydown\", (o) => {\n      this.documentKeydown(o);\n    }, !0), this.readOnlyMutableListeners.on(document, \"mousedown\", (o) => {\n      this.documentClicked(o);\n    }, !0);\n    const t = et(() => {\n      this.selectionChanged();\n    }, 180);\n    this.readOnlyMutableListeners.on(document, \"selectionchange\", t, !0), this.readOnlyMutableListeners.on(window, \"resize\", () => {\n      this.resizeDebouncer();\n    }, {\n      passive: !0\n    }), this.watchBlockHoveredEvents();\n  }\n  /**\n   * Listen redactor mousemove to emit 'block-hovered' event\n   */\n  watchBlockHoveredEvents() {\n    let e;\n    this.readOnlyMutableListeners.on(this.nodes.redactor, \"mousemove\", Ie((t) => {\n      const o = t.target.closest(\".ce-block\");\n      this.Editor.BlockSelection.anyBlockSelected || o && e !== o && (e = o, this.eventsDispatcher.emit(yt, {\n        block: this.Editor.BlockManager.getBlockByChildNode(o)\n      }));\n    }, 20), {\n      passive: !0\n    });\n  }\n  /**\n   * Unbind events on the Editor.js interface\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Resize window handler\n   */\n  windowResize() {\n    this.contentRectCache = null, this.checkIsMobile();\n  }\n  /**\n   * All keydowns on document\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  documentKeydown(e) {\n    switch (e.keyCode) {\n      case v.ENTER:\n        this.enterPressed(e);\n        break;\n      case v.BACKSPACE:\n      case v.DELETE:\n        this.backspacePressed(e);\n        break;\n      case v.ESC:\n        this.escapePressed(e);\n        break;\n      default:\n        this.defaultBehaviour(e);\n        break;\n    }\n  }\n  /**\n   * Ignore all other document's keydown events\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  defaultBehaviour(e) {\n    const { currentBlock: t } = this.Editor.BlockManager, o = e.target.closest(`.${this.CSS.editorWrapper}`), i = e.altKey || e.ctrlKey || e.metaKey || e.shiftKey;\n    if (t !== void 0 && o === null) {\n      this.Editor.BlockEvents.keydown(e);\n      return;\n    }\n    o || t && i || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close());\n  }\n  /**\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  backspacePressed(e) {\n    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor;\n    if (o.anyBlockSelected && !b.isSelectionExists) {\n      const n = t.removeSelectedBlocks(), r = t.insertDefaultBlockAtIndex(n, !0);\n      i.setToBlock(r, i.positions.START), o.clearSelection(e), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation();\n    }\n  }\n  /**\n   * Escape pressed\n   * If some of Toolbar components are opened, then close it otherwise close Toolbar\n   *\n   * @param {Event} event - escape keydown event\n   */\n  escapePressed(e) {\n    this.Editor.BlockSelection.clearSelection(e), this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.toolbox.close(), this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END)) : this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.ConversionToolbar.opened ? this.Editor.ConversionToolbar.close() : this.Editor.InlineToolbar.opened ? this.Editor.InlineToolbar.close() : this.Editor.Toolbar.close();\n  }\n  /**\n   * Enter pressed on document\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  enterPressed(e) {\n    const { BlockManager: t, BlockSelection: o } = this.Editor, i = t.currentBlockIndex >= 0;\n    if (o.anyBlockSelected && !b.isSelectionExists) {\n      o.clearSelection(e), e.preventDefault(), e.stopImmediatePropagation(), e.stopPropagation();\n      return;\n    }\n    if (!this.someToolbarOpened && i && e.target.tagName === \"BODY\") {\n      const n = this.Editor.BlockManager.insert();\n      this.Editor.Caret.setToBlock(n), this.Editor.Toolbar.moveAndOpen(n);\n    }\n    this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * All clicks on document\n   *\n   * @param {MouseEvent} event - Click event\n   */\n  documentClicked(e) {\n    var a, l;\n    if (!e.isTrusted)\n      return;\n    const t = e.target;\n    this.nodes.holder.contains(t) || b.isAtEditor || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close());\n    const i = (a = this.Editor.BlockSettings.nodes.wrapper) == null ? void 0 : a.contains(t), n = (l = this.Editor.Toolbar.nodes.settingsToggler) == null ? void 0 : l.contains(t), r = i || n;\n    if (this.Editor.BlockSettings.opened && !r) {\n      this.Editor.BlockSettings.close();\n      const d = this.Editor.BlockManager.getBlockByChildNode(t);\n      this.Editor.Toolbar.moveAndOpen(d);\n    }\n    this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * First touch on editor\n   * Fired before click\n   *\n   * Used to change current block — we need to do it before 'selectionChange' event.\n   * Also:\n   * - Move and show the Toolbar\n   * - Set a Caret\n   *\n   * @param {MouseEvent | TouchEvent} event - touch or mouse event\n   */\n  documentTouched(e) {\n    let t = e.target;\n    if (t === this.nodes.redactor) {\n      const o = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX, i = e instanceof MouseEvent ? e.clientY : e.touches[0].clientY;\n      t = document.elementFromPoint(o, i);\n    }\n    try {\n      this.Editor.BlockManager.setCurrentBlockByChildNode(t);\n    } catch {\n      this.Editor.RectangleSelection.isRectActivated() || this.Editor.Caret.setToTheLastBlock();\n    }\n    this.Editor.Toolbar.moveAndOpen();\n  }\n  /**\n   * All clicks on the redactor zone\n   *\n   * @param {MouseEvent} event - click event\n   * @description\n   * - By clicks on the Editor's bottom zone:\n   *      - if last Block is empty, set a Caret to this\n   *      - otherwise, add a new empty Block and set a Caret to that\n   */\n  redactorClicked(e) {\n    if (!b.isCollapsed)\n      return;\n    const t = e.target, o = e.metaKey || e.ctrlKey;\n    if (c.isAnchor(t) && o) {\n      e.stopImmediatePropagation(), e.stopPropagation();\n      const i = t.getAttribute(\"href\"), n = Wt(i);\n      Kt(n);\n      return;\n    }\n    this.processBottomZoneClick(e);\n  }\n  /**\n   * Check if user clicks on the Editor's bottom zone:\n   *  - set caret to the last block\n   *  - or add new empty block\n   *\n   * @param event - click event\n   */\n  processBottomZoneClick(e) {\n    const t = this.Editor.BlockManager.getBlockByIndex(-1), o = c.offset(t.holder).bottom, i = e.pageY, { BlockSelection: n } = this.Editor;\n    if (e.target instanceof Element && e.target.isEqualNode(this.nodes.redactor) && /**\n    * If there is cross block selection started, target will be equal to redactor so we need additional check\n    */\n    !n.anyBlockSelected && /**\n    * Prevent caret jumping (to last block) when clicking between blocks\n    */\n    o < i) {\n      e.stopImmediatePropagation(), e.stopPropagation();\n      const { BlockManager: a, Caret: l, Toolbar: d } = this.Editor;\n      (!a.lastBlock.tool.isDefault || !a.lastBlock.isEmpty) && a.insertAtEnd(), l.setToTheLastBlock(), d.moveAndOpen(a.lastBlock);\n    }\n  }\n  /**\n   * Handle selection changes on mobile devices\n   * Uses for showing the Inline Toolbar\n   */\n  selectionChanged() {\n    const { CrossBlockSelection: e, BlockSelection: t } = this.Editor, o = b.anchorElement;\n    if (e.isCrossBlockSelectionStarted && t.anyBlockSelected && b.get().removeAllRanges(), !o) {\n      b.range || this.Editor.InlineToolbar.close();\n      return;\n    }\n    const i = o.closest(`.${R.CSS.content}`) === null;\n    if (i && (this.Editor.InlineToolbar.containsNode(o) || this.Editor.InlineToolbar.close(), !(o.dataset.inlineToolbar === \"true\")))\n      return;\n    this.Editor.BlockManager.currentBlock || this.Editor.BlockManager.setCurrentBlockByChildNode(o);\n    const n = i !== !0;\n    this.Editor.InlineToolbar.tryToShow(!0, n);\n  }\n}\nconst yi = {\n  // API Modules\n  BlocksAPI: oo,\n  CaretAPI: io,\n  EventsAPI: no,\n  I18nAPI: He,\n  API: so,\n  InlineToolbarAPI: ro,\n  ListenersAPI: ao,\n  NotifierAPI: uo,\n  ReadOnlyAPI: po,\n  SanitizerAPI: xo,\n  SaverAPI: wo,\n  SelectionAPI: yo,\n  StylesAPI: Eo,\n  ToolbarAPI: Bo,\n  TooltipAPI: Mo,\n  UiAPI: Lo,\n  // Toolbar Modules\n  BlockSettings: Yo,\n  ConversionToolbar: $,\n  Toolbar: Jo,\n  InlineToolbar: Qo,\n  // Modules\n  BlockEvents: ei,\n  BlockManager: ii,\n  BlockSelection: ni,\n  Caret: we,\n  CrossBlockSelection: si,\n  DragNDrop: ri,\n  ModificationsObserver: ai,\n  Paste: Tt,\n  ReadOnly: li,\n  RectangleSelection: fe,\n  Renderer: ci,\n  Saver: di,\n  Tools: _t,\n  UI: wi\n};\nclass Ei {\n  /**\n   * @param {EditorConfig} config - user configuration\n   */\n  constructor(e) {\n    this.moduleInstances = {}, this.eventsDispatcher = new Ee();\n    let t, o;\n    this.isReady = new Promise((i, n) => {\n      t = i, o = n;\n    }), Promise.resolve().then(async () => {\n      this.configuration = e, this.validate(), this.init(), await this.start(), await this.render();\n      const { BlockManager: i, Caret: n, UI: r, ModificationsObserver: a } = this.moduleInstances;\n      r.checkEmptiness(), a.enable(), this.configuration.autofocus && n.setToBlock(i.blocks[0], n.positions.START), t();\n    }).catch((i) => {\n      T(`Editor.js is not ready because of ${i}`, \"error\"), o(i);\n    });\n  }\n  /**\n   * Setting for configuration\n   *\n   * @param {EditorConfig|string} config - Editor's config to set\n   */\n  set configuration(e) {\n    var o, i;\n    D(e) ? this.config = {\n      ...e\n    } : this.config = {\n      holder: e\n    }, Le(!!this.config.holderId, \"config.holderId\", \"config.holder\"), this.config.holderId && !this.config.holder && (this.config.holder = this.config.holderId, this.config.holderId = null), this.config.holder == null && (this.config.holder = \"editorjs\"), this.config.logLevel || (this.config.logLevel = at.VERBOSE), Ft(this.config.logLevel), Le(!!this.config.initialBlock, \"config.initialBlock\", \"config.defaultBlock\"), this.config.defaultBlock = this.config.defaultBlock || this.config.initialBlock || \"paragraph\", this.config.minHeight = this.config.minHeight !== void 0 ? this.config.minHeight : 300;\n    const t = {\n      type: this.config.defaultBlock,\n      data: {}\n    };\n    this.config.placeholder = this.config.placeholder || !1, this.config.sanitizer = this.config.sanitizer || {\n      p: !0,\n      b: !0,\n      a: !0\n    }, this.config.hideToolbar = this.config.hideToolbar ? this.config.hideToolbar : !1, this.config.tools = this.config.tools || {}, this.config.i18n = this.config.i18n || {}, this.config.data = this.config.data || { blocks: [] }, this.config.onReady = this.config.onReady || (() => {\n    }), this.config.onChange = this.config.onChange || (() => {\n    }), this.config.inlineToolbar = this.config.inlineToolbar !== void 0 ? this.config.inlineToolbar : !0, (W(this.config.data) || !this.config.data.blocks || this.config.data.blocks.length === 0) && (this.config.data = { blocks: [t] }), this.config.readOnly = this.config.readOnly || !1, (o = this.config.i18n) != null && o.messages && z.setDictionary(this.config.i18n.messages), this.config.i18n.direction = ((i = this.config.i18n) == null ? void 0 : i.direction) || \"ltr\";\n  }\n  /**\n   * Returns private property\n   *\n   * @returns {EditorConfig}\n   */\n  get configuration() {\n    return this.config;\n  }\n  /**\n   * Checks for required fields in Editor's config\n   */\n  validate() {\n    const { holderId: e, holder: t } = this.config;\n    if (e && t)\n      throw Error(\"«holderId» and «holder» param can't assign at the same time.\");\n    if (G(t) && !c.get(t))\n      throw Error(`element with ID «${t}» is missing. Pass correct holder's ID.`);\n    if (t && D(t) && !c.isElement(t))\n      throw Error(\"«holder» value must be an Element node\");\n  }\n  /**\n   * Initializes modules:\n   *  - make and save instances\n   *  - configure\n   */\n  init() {\n    this.constructModules(), this.configureModules();\n  }\n  /**\n   * Start Editor!\n   *\n   * Get list of modules that needs to be prepared and return a sequence (Promise)\n   *\n   * @returns {Promise<void>}\n   */\n  async start() {\n    await [\n      \"Tools\",\n      \"UI\",\n      \"BlockManager\",\n      \"Paste\",\n      \"BlockSelection\",\n      \"RectangleSelection\",\n      \"CrossBlockSelection\",\n      \"ReadOnly\"\n    ].reduce(\n      (t, o) => t.then(async () => {\n        try {\n          await this.moduleInstances[o].prepare();\n        } catch (i) {\n          if (i instanceof ut)\n            throw new Error(i.message);\n          T(`Module ${o} was skipped because of %o`, \"warn\", i);\n        }\n      }),\n      Promise.resolve()\n    );\n  }\n  /**\n   * Render initial data\n   */\n  render() {\n    return this.moduleInstances.Renderer.render(this.config.data.blocks);\n  }\n  /**\n   * Make modules instances and save it to the @property this.moduleInstances\n   */\n  constructModules() {\n    Object.entries(yi).forEach(([e, t]) => {\n      try {\n        this.moduleInstances[e] = new t({\n          config: this.configuration,\n          eventsDispatcher: this.eventsDispatcher\n        });\n      } catch (o) {\n        T(\"[constructModules]\", `Module ${e} skipped because`, \"error\", o);\n      }\n    });\n  }\n  /**\n   * Modules instances configuration:\n   *  - pass other modules to the 'state' property\n   *  - ...\n   */\n  configureModules() {\n    for (const e in this.moduleInstances)\n      Object.prototype.hasOwnProperty.call(this.moduleInstances, e) && (this.moduleInstances[e].state = this.getModulesDiff(e));\n  }\n  /**\n   * Return modules without passed name\n   *\n   * @param {string} name - module for witch modules difference should be calculated\n   */\n  getModulesDiff(e) {\n    const t = {};\n    for (const o in this.moduleInstances)\n      o !== e && (t[o] = this.moduleInstances[o]);\n    return t;\n  }\n}\n/**\n * Editor.js\n *\n * @license Apache-2.0\n * @see Editor.js <https://editorjs.io>\n * @author CodeX Team <https://codex.so>\n */\nclass Bi {\n  /** Editor version */\n  static get version() {\n    return \"2.29.1\";\n  }\n  /**\n   * @param {EditorConfig|string|undefined} [configuration] - user configuration\n   */\n  constructor(e) {\n    let t = () => {\n    };\n    D(e) && M(e.onReady) && (t = e.onReady);\n    const o = new Ei(e);\n    this.isReady = o.isReady.then(() => {\n      this.exportAPI(o), t();\n    });\n  }\n  /**\n   * Export external API methods\n   *\n   * @param {Core} editor — Editor's instance\n   */\n  exportAPI(e) {\n    const t = [\"configuration\"], o = () => {\n      Object.values(e.moduleInstances).forEach((n) => {\n        M(n.destroy) && n.destroy(), n.listeners.removeAll();\n      }), Io(), e = null;\n      for (const n in this)\n        Object.prototype.hasOwnProperty.call(this, n) && delete this[n];\n      Object.setPrototypeOf(this, null);\n    };\n    t.forEach((n) => {\n      this[n] = e[n];\n    }), this.destroy = o, Object.setPrototypeOf(this, e.moduleInstances.API.methods), delete this.exportAPI, Object.entries({\n      blocks: {\n        clear: \"clear\",\n        render: \"render\"\n      },\n      caret: {\n        focus: \"focus\"\n      },\n      events: {\n        on: \"on\",\n        off: \"off\",\n        emit: \"emit\"\n      },\n      saver: {\n        save: \"save\"\n      }\n    }).forEach(([n, r]) => {\n      Object.entries(r).forEach(([a, l]) => {\n        this[l] = e.moduleInstances.API.methods[n][a];\n      });\n    });\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2VkaXRvcmpzL2Rpc3QvZWRpdG9yanMubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdDQUFnQztBQUN6QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx1Q0FBdUMsRUFBRSxLQUFLLEVBQUUsY0FBYyxHQUFHLEdBQUcsRUFBRTtBQUN0RTtBQUNBLDBCQUEwQixHQUFHO0FBQzdCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsTUFBTTtBQUNOLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVMsd0NBQXdDLFdBQVc7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFLEVBQUUsNkNBQTZDO0FBQzdEO0FBQ0E7QUFDQSxnQkFBZ0IsRUFBRSxpRkFBaUYsRUFBRTtBQUNyRztBQUNBO0FBQ0E7QUFDQSx5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDLGNBQWMsZ0RBQWdEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtKQUErSixFQUFFO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsMkJBQTJCO0FBQzNCLGFBQWEsU0FBUztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxtQkFBbUI7QUFDM0YsYUFBYSxNQUFNO0FBQ25CLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsYUFBYTtBQUM5RjtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxpQ0FBaUMseUJBQXlCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsaUNBQWlDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCLGlCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVIQUF1SDtBQUNwSTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFxRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNy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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrTEFBa0wsVUFBVTtBQUM1TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9CQUFvQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsUUFBUTtBQUMvRTtBQUNBO0FBQ0EsQ0FBQywrREFBK0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixVQUFVLHlCQUF5QixJQUFJLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFpRTtBQUM3RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxRQUFRO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVkaXRvcmpzLWFwcC8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvZWRpdG9yanMvZGlzdC9lZGl0b3Jqcy5tanM/MjUxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUnQgPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDoge307XG5mdW5jdGlvbiBQZShzKSB7XG4gIHJldHVybiBzICYmIHMuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgXCJkZWZhdWx0XCIpID8gcy5kZWZhdWx0IDogcztcbn1cbmZ1bmN0aW9uIFRlKCkge1xufVxuT2JqZWN0LmFzc2lnbihUZSwge1xuICBkZWZhdWx0OiBUZSxcbiAgcmVnaXN0ZXI6IFRlLFxuICByZXZlcnQ6IGZ1bmN0aW9uKCkge1xuICB9LFxuICBfX2VzTW9kdWxlOiAhMFxufSk7XG5FbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IChFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5vTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBmdW5jdGlvbihzKSB7XG4gIGNvbnN0IGUgPSAodGhpcy5kb2N1bWVudCB8fCB0aGlzLm93bmVyRG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwocyk7XG4gIGxldCB0ID0gZS5sZW5ndGg7XG4gIGZvciAoOyAtLXQgPj0gMCAmJiBlLml0ZW0odCkgIT09IHRoaXM7IClcbiAgICA7XG4gIHJldHVybiB0ID4gLTE7XG59KTtcbkVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QgfHwgKEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QgPSBmdW5jdGlvbihzKSB7XG4gIGxldCBlID0gdGhpcztcbiAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZSkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGRvIHtcbiAgICBpZiAoZS5tYXRjaGVzKHMpKVxuICAgICAgcmV0dXJuIGU7XG4gICAgZSA9IGUucGFyZW50RWxlbWVudCB8fCBlLnBhcmVudE5vZGU7XG4gIH0gd2hpbGUgKGUgIT09IG51bGwpO1xuICByZXR1cm4gbnVsbDtcbn0pO1xuRWxlbWVudC5wcm90b3R5cGUucHJlcGVuZCB8fCAoRWxlbWVudC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKGUpIHtcbiAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgQXJyYXkuaXNBcnJheShlKSB8fCAoZSA9IFtlXSksIGUuZm9yRWFjaCgobykgPT4ge1xuICAgIGNvbnN0IGkgPSBvIGluc3RhbmNlb2YgTm9kZTtcbiAgICB0LmFwcGVuZENoaWxkKGkgPyBvIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobykpO1xuICB9KSwgdGhpcy5pbnNlcnRCZWZvcmUodCwgdGhpcy5maXJzdENoaWxkKTtcbn0pO1xuRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCB8fCAoRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCA9IGZ1bmN0aW9uKHMpIHtcbiAgcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyAhMCA6ICEhcztcbiAgY29uc3QgZSA9IHRoaXMucGFyZW50Tm9kZSwgdCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUsIG51bGwpLCBvID0gcGFyc2VJbnQodC5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLXRvcC13aWR0aFwiKSksIGkgPSBwYXJzZUludCh0LmdldFByb3BlcnR5VmFsdWUoXCJib3JkZXItbGVmdC13aWR0aFwiKSksIG4gPSB0aGlzLm9mZnNldFRvcCAtIGUub2Zmc2V0VG9wIDwgZS5zY3JvbGxUb3AsIHIgPSB0aGlzLm9mZnNldFRvcCAtIGUub2Zmc2V0VG9wICsgdGhpcy5jbGllbnRIZWlnaHQgLSBvID4gZS5zY3JvbGxUb3AgKyBlLmNsaWVudEhlaWdodCwgYSA9IHRoaXMub2Zmc2V0TGVmdCAtIGUub2Zmc2V0TGVmdCA8IGUuc2Nyb2xsTGVmdCwgbCA9IHRoaXMub2Zmc2V0TGVmdCAtIGUub2Zmc2V0TGVmdCArIHRoaXMuY2xpZW50V2lkdGggLSBpID4gZS5zY3JvbGxMZWZ0ICsgZS5jbGllbnRXaWR0aCwgZCA9IG4gJiYgIXI7XG4gIChuIHx8IHIpICYmIHMgJiYgKGUuc2Nyb2xsVG9wID0gdGhpcy5vZmZzZXRUb3AgLSBlLm9mZnNldFRvcCAtIGUuY2xpZW50SGVpZ2h0IC8gMiAtIG8gKyB0aGlzLmNsaWVudEhlaWdodCAvIDIpLCAoYSB8fCBsKSAmJiBzICYmIChlLnNjcm9sbExlZnQgPSB0aGlzLm9mZnNldExlZnQgLSBlLm9mZnNldExlZnQgLSBlLmNsaWVudFdpZHRoIC8gMiAtIGkgKyB0aGlzLmNsaWVudFdpZHRoIC8gMiksIChuIHx8IHIgfHwgYSB8fCBsKSAmJiAhcyAmJiB0aGlzLnNjcm9sbEludG9WaWV3KGQpO1xufSk7XG53aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayA9IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8IGZ1bmN0aW9uKHMpIHtcbiAgY29uc3QgZSA9IERhdGUubm93KCk7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHMoe1xuICAgICAgZGlkVGltZW91dDogITEsXG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIDEpO1xufTtcbndpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgPSB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrIHx8IGZ1bmN0aW9uKHMpIHtcbiAgY2xlYXJUaW1lb3V0KHMpO1xufTtcbmxldCBEdCA9IChzID0gMjEpID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkocykpLnJlZHVjZSgoZSwgdCkgPT4gKHQgJj0gNjMsIHQgPCAzNiA/IGUgKz0gdC50b1N0cmluZygzNikgOiB0IDwgNjIgPyBlICs9ICh0IC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpIDogdCA+IDYyID8gZSArPSBcIi1cIiA6IGUgKz0gXCJfXCIsIGUpLCBcIlwiKTtcbnZhciBhdCA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzLlZFUkJPU0UgPSBcIlZFUkJPU0VcIiwgcy5JTkZPID0gXCJJTkZPXCIsIHMuV0FSTiA9IFwiV0FSTlwiLCBzLkVSUk9SID0gXCJFUlJPUlwiLCBzKSkoYXQgfHwge30pO1xuY29uc3QgdiA9IHtcbiAgQkFDS1NQQUNFOiA4LFxuICBUQUI6IDksXG4gIEVOVEVSOiAxMyxcbiAgU0hJRlQ6IDE2LFxuICBDVFJMOiAxNyxcbiAgQUxUOiAxOCxcbiAgRVNDOiAyNyxcbiAgU1BBQ0U6IDMyLFxuICBMRUZUOiAzNyxcbiAgVVA6IDM4LFxuICBET1dOOiA0MCxcbiAgUklHSFQ6IDM5LFxuICBERUxFVEU6IDQ2LFxuICBNRVRBOiA5MSxcbiAgU0xBU0g6IDE5MVxufSwgUHQgPSB7XG4gIExFRlQ6IDAsXG4gIFdIRUVMOiAxLFxuICBSSUdIVDogMixcbiAgQkFDS1dBUkQ6IDMsXG4gIEZPUldBUkQ6IDRcbn07XG5mdW5jdGlvbiBtZShzLCBlLCB0ID0gXCJsb2dcIiwgbywgaSA9IFwiY29sb3I6IGluaGVyaXRcIikge1xuICBpZiAoIShcImNvbnNvbGVcIiBpbiB3aW5kb3cpIHx8ICF3aW5kb3cuY29uc29sZVt0XSlcbiAgICByZXR1cm47XG4gIGNvbnN0IG4gPSBbXCJpbmZvXCIsIFwibG9nXCIsIFwid2FyblwiLCBcImVycm9yXCJdLmluY2x1ZGVzKHQpLCByID0gW107XG4gIHN3aXRjaCAobWUubG9nTGV2ZWwpIHtcbiAgICBjYXNlIFwiRVJST1JcIjpcbiAgICAgIGlmICh0ICE9PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJXQVJOXCI6XG4gICAgICBpZiAoIVtcImVycm9yXCIsIFwid2FyblwiXS5pbmNsdWRlcyh0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIklORk9cIjpcbiAgICAgIGlmICghbiB8fCBzKVxuICAgICAgICByZXR1cm47XG4gICAgICBicmVhaztcbiAgfVxuICBvICYmIHIucHVzaChvKTtcbiAgY29uc3QgYSA9IFwiRWRpdG9yLmpzIDIuMjkuMVwiLCBsID0gYGxpbmUtaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICBjb2xvcjogIzAwNkZFQTtcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTFweDtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICAgICAgICAgICAgcGFkZGluZzogNHB4IDlweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDMwcHg7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDU2LCAxMzgsIDIyOSwgMC4xNik7XG4gICAgICAgICAgICBtYXJnaW46IDRweCA1cHggNHB4IDA7YDtcbiAgcyAmJiAobiA/IChyLnVuc2hpZnQobCwgaSksIGUgPSBgJWMke2F9JWMgJHtlfWApIDogZSA9IGAoICR7YX0gKSR7ZX1gKTtcbiAgdHJ5IHtcbiAgICBuID8gbyA/IGNvbnNvbGVbdF0oYCR7ZX0gJW9gLCAuLi5yKSA6IGNvbnNvbGVbdF0oZSwgLi4ucikgOiBjb25zb2xlW3RdKGUpO1xuICB9IGNhdGNoIHtcbiAgfVxufVxubWUubG9nTGV2ZWwgPSBcIlZFUkJPU0VcIjtcbmZ1bmN0aW9uIEZ0KHMpIHtcbiAgbWUubG9nTGV2ZWwgPSBzO1xufVxuY29uc3QgVCA9IG1lLmJpbmQod2luZG93LCAhMSksIFkgPSBtZS5iaW5kKHdpbmRvdywgITApO1xuZnVuY3Rpb24gb2Uocykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHMpLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBNKHMpIHtcbiAgcmV0dXJuIG9lKHMpID09PSBcImZ1bmN0aW9uXCIgfHwgb2UocykgPT09IFwiYXN5bmNmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gRChzKSB7XG4gIHJldHVybiBvZShzKSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIEcocykge1xuICByZXR1cm4gb2UocykgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBIdChzKSB7XG4gIHJldHVybiBvZShzKSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBKZShzKSB7XG4gIHJldHVybiBvZShzKSA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIFFlKHMpIHtcbiAgcmV0dXJuIG9lKHMpID09PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gVyhzKSB7XG4gIHJldHVybiBzID8gT2JqZWN0LmtleXMocykubGVuZ3RoID09PSAwICYmIHMuY29uc3RydWN0b3IgPT09IE9iamVjdCA6ICEwO1xufVxuZnVuY3Rpb24gbHQocykge1xuICByZXR1cm4gcyA+IDQ3ICYmIHMgPCA1OCB8fCAvLyBudW1iZXIga2V5c1xuICBzID09PSAzMiB8fCBzID09PSAxMyB8fCAvLyBTcGFjZSBiYXIgJiByZXR1cm4ga2V5KHMpXG4gIHMgPT09IDIyOSB8fCAvLyBwcm9jZXNzaW5nIGtleSBpbnB1dCBmb3IgY2VydGFpbiBsYW5ndWFnZXMg4oCUIENoaW5lc2UsIEphcGFuZXNlLCBldGMuXG4gIHMgPiA2NCAmJiBzIDwgOTEgfHwgLy8gbGV0dGVyIGtleXNcbiAgcyA+IDk1ICYmIHMgPCAxMTIgfHwgLy8gTnVtcGFkIGtleXNcbiAgcyA+IDE4NSAmJiBzIDwgMTkzIHx8IC8vIDs9LC0uL2AgKGluIG9yZGVyKVxuICBzID4gMjE4ICYmIHMgPCAyMjM7XG59XG5hc3luYyBmdW5jdGlvbiB6dChzLCBlID0gKCkgPT4ge1xufSwgdCA9ICgpID0+IHtcbn0pIHtcbiAgYXN5bmMgZnVuY3Rpb24gbyhpLCBuLCByKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGkuZnVuY3Rpb24oaS5kYXRhKSwgYXdhaXQgbihRZShpLmRhdGEpID8ge30gOiBpLmRhdGEpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcihRZShpLmRhdGEpID8ge30gOiBpLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcy5yZWR1Y2UoYXN5bmMgKGksIG4pID0+IChhd2FpdCBpLCBvKG4sIGUsIHQpKSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xufVxuZnVuY3Rpb24gY3Qocykge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocyk7XG59XG5mdW5jdGlvbiB4ZShzLCBlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcywgbyA9IGFyZ3VtZW50cztcbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBzLmFwcGx5KHQsIG8pLCBlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFV0KHMpIHtcbiAgcmV0dXJuIHMubmFtZS5zcGxpdChcIi5cIikucG9wKCk7XG59XG5mdW5jdGlvbiBqdChzKSB7XG4gIHJldHVybiAvXlstXFx3XStcXC8oWy0rXFx3XSt8XFwqKSQvLnRlc3Qocyk7XG59XG5mdW5jdGlvbiBldChzLCBlLCB0KSB7XG4gIGxldCBvO1xuICByZXR1cm4gKC4uLmkpID0+IHtcbiAgICBjb25zdCBuID0gdGhpcywgciA9ICgpID0+IHtcbiAgICAgIG8gPSBudWxsLCB0IHx8IHMuYXBwbHkobiwgaSk7XG4gICAgfSwgYSA9IHQgJiYgIW87XG4gICAgd2luZG93LmNsZWFyVGltZW91dChvKSwgbyA9IHdpbmRvdy5zZXRUaW1lb3V0KHIsIGUpLCBhICYmIHMuYXBwbHkobiwgaSk7XG4gIH07XG59XG5mdW5jdGlvbiBJZShzLCBlLCB0ID0gdm9pZCAwKSB7XG4gIGxldCBvLCBpLCBuLCByID0gbnVsbCwgYSA9IDA7XG4gIHQgfHwgKHQgPSB7fSk7XG4gIGNvbnN0IGwgPSBmdW5jdGlvbigpIHtcbiAgICBhID0gdC5sZWFkaW5nID09PSAhMSA/IDAgOiBEYXRlLm5vdygpLCByID0gbnVsbCwgbiA9IHMuYXBwbHkobywgaSksIHIgfHwgKG8gPSBpID0gbnVsbCk7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkID0gRGF0ZS5ub3coKTtcbiAgICAhYSAmJiB0LmxlYWRpbmcgPT09ICExICYmIChhID0gZCk7XG4gICAgY29uc3QgdSA9IGUgLSAoZCAtIGEpO1xuICAgIHJldHVybiBvID0gdGhpcywgaSA9IGFyZ3VtZW50cywgdSA8PSAwIHx8IHUgPiBlID8gKHIgJiYgKGNsZWFyVGltZW91dChyKSwgciA9IG51bGwpLCBhID0gZCwgbiA9IHMuYXBwbHkobywgaSksIHIgfHwgKG8gPSBpID0gbnVsbCkpIDogIXIgJiYgdC50cmFpbGluZyAhPT0gITEgJiYgKHIgPSBzZXRUaW1lb3V0KGwsIHUpKSwgbjtcbiAgfTtcbn1cbmZ1bmN0aW9uICR0KCkge1xuICBjb25zdCBzID0ge1xuICAgIHdpbjogITEsXG4gICAgbWFjOiAhMSxcbiAgICB4MTE6ICExLFxuICAgIGxpbnV4OiAhMVxuICB9LCBlID0gT2JqZWN0LmtleXMocykuZmluZCgodCkgPT4gd2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0KSAhPT0gLTEpO1xuICByZXR1cm4gZSAmJiAoc1tlXSA9ICEwKSwgcztcbn1cbmZ1bmN0aW9uIHJlKHMpIHtcbiAgcmV0dXJuIHNbMF0udG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBNZShzLCAuLi5lKSB7XG4gIGlmICghZS5sZW5ndGgpXG4gICAgcmV0dXJuIHM7XG4gIGNvbnN0IHQgPSBlLnNoaWZ0KCk7XG4gIGlmIChEKHMpICYmIEQodCkpXG4gICAgZm9yIChjb25zdCBvIGluIHQpXG4gICAgICBEKHRbb10pID8gKHNbb10gfHwgT2JqZWN0LmFzc2lnbihzLCB7IFtvXToge30gfSksIE1lKHNbb10sIHRbb10pKSA6IE9iamVjdC5hc3NpZ24ocywgeyBbb106IHRbb10gfSk7XG4gIHJldHVybiBNZShzLCAuLi5lKTtcbn1cbmZ1bmN0aW9uIHllKHMpIHtcbiAgY29uc3QgZSA9ICR0KCk7XG4gIHJldHVybiBzID0gcy5yZXBsYWNlKC9zaGlmdC9naSwgXCLih6dcIikucmVwbGFjZSgvYmFja3NwYWNlL2dpLCBcIuKMq1wiKS5yZXBsYWNlKC9lbnRlci9naSwgXCLij45cIikucmVwbGFjZSgvdXAvZ2ksIFwi4oaRXCIpLnJlcGxhY2UoL2xlZnQvZ2ksIFwi4oaSXCIpLnJlcGxhY2UoL2Rvd24vZ2ksIFwi4oaTXCIpLnJlcGxhY2UoL3JpZ2h0L2dpLCBcIuKGkFwiKS5yZXBsYWNlKC9lc2NhcGUvZ2ksIFwi4o6LXCIpLnJlcGxhY2UoL2luc2VydC9naSwgXCJJbnNcIikucmVwbGFjZSgvZGVsZXRlL2dpLCBcIuKQoVwiKS5yZXBsYWNlKC9cXCsvZ2ksIFwiICsgXCIpLCBlLm1hYyA/IHMgPSBzLnJlcGxhY2UoL2N0cmx8Y21kL2dpLCBcIuKMmFwiKS5yZXBsYWNlKC9hbHQvZ2ksIFwi4oylXCIpIDogcyA9IHMucmVwbGFjZSgvY21kL2dpLCBcIkN0cmxcIikucmVwbGFjZSgvd2luZG93cy9naSwgXCJXSU5cIiksIHM7XG59XG5mdW5jdGlvbiBXdChzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwocykuaHJlZjtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIHMuc3Vic3RyaW5nKDAsIDIpID09PSBcIi8vXCIgPyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBzIDogd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHM7XG59XG5mdW5jdGlvbiBZdCgpIHtcbiAgcmV0dXJuIER0KDEwKTtcbn1cbmZ1bmN0aW9uIEt0KHMpIHtcbiAgd2luZG93Lm9wZW4ocywgXCJfYmxhbmtcIik7XG59XG5mdW5jdGlvbiBYdChzID0gXCJcIikge1xuICByZXR1cm4gYCR7c30ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlOCkudG9TdHJpbmcoMTYpfWA7XG59XG5mdW5jdGlvbiBMZShzLCBlLCB0KSB7XG4gIGNvbnN0IG8gPSBgwqske2V9wrsgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFBsZWFzZSB1c2UgdGhlIMKrJHt0fcK7IGluc3RlYWQuYDtcbiAgcyAmJiBZKG8sIFwid2FyblwiKTtcbn1cbmZ1bmN0aW9uIGxlKHMsIGUsIHQpIHtcbiAgY29uc3QgbyA9IHQudmFsdWUgPyBcInZhbHVlXCIgOiBcImdldFwiLCBpID0gdFtvXSwgbiA9IGAjJHtlfUNhY2hlYDtcbiAgaWYgKHRbb10gPSBmdW5jdGlvbiguLi5yKSB7XG4gICAgcmV0dXJuIHRoaXNbbl0gPT09IHZvaWQgMCAmJiAodGhpc1tuXSA9IGkuYXBwbHkodGhpcywgLi4ucikpLCB0aGlzW25dO1xuICB9LCBvID09PSBcImdldFwiICYmIHQuc2V0KSB7XG4gICAgY29uc3QgciA9IHQuc2V0O1xuICAgIHQuc2V0ID0gZnVuY3Rpb24oYSkge1xuICAgICAgZGVsZXRlIHNbbl0sIHIuYXBwbHkodGhpcywgYSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmNvbnN0IGR0ID0gNjUwO1xuZnVuY3Rpb24gdGUoKSB7XG4gIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYShgKG1heC13aWR0aDogJHtkdH1weClgKS5tYXRjaGVzO1xufVxuY29uc3QgdHQgPSB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtICYmICgvaVAoYWR8aG9uZXxvZCkvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSkgfHwgd2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gXCJNYWNJbnRlbFwiICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxKTtcbmZ1bmN0aW9uIFZ0KHMsIGUpIHtcbiAgY29uc3QgdCA9IEFycmF5LmlzQXJyYXkocykgfHwgRChzKSwgbyA9IEFycmF5LmlzQXJyYXkoZSkgfHwgRChlKTtcbiAgcmV0dXJuIHQgfHwgbyA/IEpTT04uc3RyaW5naWZ5KHMpID09PSBKU09OLnN0cmluZ2lmeShlKSA6IHMgPT09IGU7XG59XG5jbGFzcyBjIHtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCB0YWcgaGFzIG5vIGNsb3NlZCB0YWdcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnIC0gZWxlbWVudCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1NpbmdsZVRhZyhlKSB7XG4gICAgcmV0dXJuIGUudGFnTmFtZSAmJiBbXG4gICAgICBcIkFSRUFcIixcbiAgICAgIFwiQkFTRVwiLFxuICAgICAgXCJCUlwiLFxuICAgICAgXCJDT0xcIixcbiAgICAgIFwiQ09NTUFORFwiLFxuICAgICAgXCJFTUJFRFwiLFxuICAgICAgXCJIUlwiLFxuICAgICAgXCJJTUdcIixcbiAgICAgIFwiSU5QVVRcIixcbiAgICAgIFwiS0VZR0VOXCIsXG4gICAgICBcIkxJTktcIixcbiAgICAgIFwiTUVUQVwiLFxuICAgICAgXCJQQVJBTVwiLFxuICAgICAgXCJTT1VSQ0VcIixcbiAgICAgIFwiVFJBQ0tcIixcbiAgICAgIFwiV0JSXCJcbiAgICBdLmluY2x1ZGVzKGUudGFnTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGVsZW1lbnQgaXMgQlIgb3IgV0JSXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzTGluZUJyZWFrVGFnKGUpIHtcbiAgICByZXR1cm4gZSAmJiBlLnRhZ05hbWUgJiYgW1xuICAgICAgXCJCUlwiLFxuICAgICAgXCJXQlJcIlxuICAgIF0uaW5jbHVkZXMoZS50YWdOYW1lKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIGZvciBtYWtpbmcgRWxlbWVudHMgd2l0aCBjbGFzcyBuYW1lIGFuZCBhdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFnTmFtZSAtIG5ldyBFbGVtZW50IHRhZyBuYW1lXG4gICAqIEBwYXJhbSAge3N0cmluZ1tdfHN0cmluZ30gW2NsYXNzTmFtZXNdIC0gbGlzdCBvciBuYW1lIG9mIENTUyBjbGFzcyBuYW1lKHMpXG4gICAqIEBwYXJhbSAge29iamVjdH0gW2F0dHJpYnV0ZXNdIC0gYW55IGF0dHJpYnV0ZXNcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgc3RhdGljIG1ha2UoZSwgdCA9IG51bGwsIG8gPSB7fSkge1xuICAgIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpO1xuICAgIEFycmF5LmlzQXJyYXkodCkgPyBpLmNsYXNzTGlzdC5hZGQoLi4udCkgOiB0ICYmIGkuY2xhc3NMaXN0LmFkZCh0KTtcbiAgICBmb3IgKGNvbnN0IG4gaW4gbylcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBuKSAmJiAoaVtuXSA9IG9bbl0pO1xuICAgIHJldHVybiBpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIFRleHQgTm9kZSB3aXRoIHRoZSBwYXNzZWQgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIHRleHQgY29udGVudFxuICAgKiBAcmV0dXJucyB7VGV4dH1cbiAgICovXG4gIHN0YXRpYyB0ZXh0KGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCBvbmUgb3Igc2V2ZXJhbCBlbGVtZW50cyB0byB0aGUgcGFyZW50XG4gICAqXG4gICAqIEBwYXJhbSAge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gcGFyZW50IC0gd2hlcmUgdG8gYXBwZW5kXG4gICAqIEBwYXJhbSAge0VsZW1lbnR8RWxlbWVudFtdfERvY3VtZW50RnJhZ21lbnR8VGV4dHxUZXh0W119IGVsZW1lbnRzIC0gZWxlbWVudCBvciBlbGVtZW50cyBsaXN0XG4gICAqL1xuICBzdGF0aWMgYXBwZW5kKGUsIHQpIHtcbiAgICBBcnJheS5pc0FycmF5KHQpID8gdC5mb3JFYWNoKChvKSA9PiBlLmFwcGVuZENoaWxkKG8pKSA6IGUuYXBwZW5kQ2hpbGQodCk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCBlbGVtZW50IG9yIGEgY291cGxlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhcmVudCBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCAtIHdoZXJlIHRvIGFwcGVuZFxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBlbGVtZW50cyAtIGVsZW1lbnQgb3IgZWxlbWVudHMgbGlzdFxuICAgKi9cbiAgc3RhdGljIHByZXBlbmQoZSwgdCkge1xuICAgIEFycmF5LmlzQXJyYXkodCkgPyAodCA9IHQucmV2ZXJzZSgpLCB0LmZvckVhY2goKG8pID0+IGUucHJlcGVuZChvKSkpIDogZS5wcmVwZW5kKHQpO1xuICB9XG4gIC8qKlxuICAgKiBTd2FwIHR3byBlbGVtZW50cyBpbiBwYXJlbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwxIC0gZnJvbVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbDIgLSB0b1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc3RhdGljIHN3YXAoZSwgdCkge1xuICAgIGNvbnN0IG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBpID0gZS5wYXJlbnROb2RlO1xuICAgIGkuaW5zZXJ0QmVmb3JlKG8sIGUpLCBpLmluc2VydEJlZm9yZShlLCB0KSwgaS5pbnNlcnRCZWZvcmUodCwgbyksIGkucmVtb3ZlQ2hpbGQobyk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdG9yIERlY29yYXRvclxuICAgKlxuICAgKiBSZXR1cm5zIGZpcnN0IG1hdGNoXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBlbGVtZW50IHdlIHNlYXJjaGluZyBpbnNpZGUuIERlZmF1bHQgLSBET00gRG9jdW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gc2VhcmNoaW5nIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIHN0YXRpYyBmaW5kKGUgPSBkb2N1bWVudCwgdCkge1xuICAgIHJldHVybiBlLnF1ZXJ5U2VsZWN0b3IodCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBFbGVtZW50IGJ5IElkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIGlkIHRvIGZpbmRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQoZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0b3IgRGVjb3JhdG9yLlxuICAgKlxuICAgKiBSZXR1cm5zIGFsbCBtYXRjaGVzXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudH0gZWwgLSBlbGVtZW50IHdlIHNlYXJjaGluZyBpbnNpZGUuIERlZmF1bHQgLSBET00gRG9jdW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gc2VhcmNoaW5nIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7Tm9kZUxpc3R9XG4gICAqL1xuICBzdGF0aWMgZmluZEFsbChlID0gZG9jdW1lbnQsIHQpIHtcbiAgICByZXR1cm4gZS5xdWVyeVNlbGVjdG9yQWxsKHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIENTUyBzZWxlY3RvciBmb3IgYWxsIHRleHQgaW5wdXRzXG4gICAqL1xuICBzdGF0aWMgZ2V0IGFsbElucHV0c1NlbGVjdG9yKCkge1xuICAgIHJldHVybiBcIltjb250ZW50ZWRpdGFibGU9dHJ1ZV0sIHRleHRhcmVhLCBpbnB1dDpub3QoW3R5cGVdKSwgXCIgKyBbXCJ0ZXh0XCIsIFwicGFzc3dvcmRcIiwgXCJlbWFpbFwiLCBcIm51bWJlclwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiXS5tYXAoKHQpID0+IGBpbnB1dFt0eXBlPVwiJHt0fVwiXWApLmpvaW4oXCIsIFwiKTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhbGwgY29udGVudGVkaXRhYmxlLCB0ZXh0YXJlYSBhbmQgZWRpdGFibGUgaW5wdXQgZWxlbWVudHMgcGFzc2VkIGhvbGRlciBjb250YWluc1xuICAgKlxuICAgKiBAcGFyYW0gaG9sZGVyIC0gZWxlbWVudCB3aGVyZSB0byBmaW5kIGlucHV0c1xuICAgKi9cbiAgc3RhdGljIGZpbmRBbGxJbnB1dHMoZSkge1xuICAgIHJldHVybiBjdChlLnF1ZXJ5U2VsZWN0b3JBbGwoYy5hbGxJbnB1dHNTZWxlY3RvcikpLnJlZHVjZSgodCwgbykgPT4gYy5pc05hdGl2ZUlucHV0KG8pIHx8IGMuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMobykgPyBbLi4udCwgb10gOiBbLi4udCwgLi4uYy5nZXREZWVwZXN0QmxvY2tFbGVtZW50cyhvKV0sIFtdKTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoIGZvciBkZWVwZXN0IG5vZGUgd2hpY2ggaXMgTGVhZi5cbiAgICogTGVhZiBpcyB0aGUgdmVydGV4IHRoYXQgZG9lc24ndCBoYXZlIGFueSBjaGlsZCBub2Rlc1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHJlY3Vyc2l2ZWx5IGdvZXMgdGhyb3cgdGhlIGFsbCBOb2RlIHVudGlsIGl0IGZpbmRzIHRoZSBMZWFmXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIHJvb3QgTm9kZS4gRnJvbSB0aGlzIHZlcnRleCB3ZSBzdGFydCBEZWVwLWZpcnN0IHNlYXJjaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVwdGgtZmlyc3Rfc2VhcmNofVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdExhc3RdIC0gZmluZCBsYXN0IHRleHQgbm9kZVxuICAgKiBAcmV0dXJucyB7Tm9kZX0gLSBpdCBjYW4gYmUgdGV4dCBOb2RlIG9yIEVsZW1lbnQgTm9kZSwgc28gdGhhdCBjYXJldCB3aWxsIGFibGUgdG8gd29yayB3aXRoIGl0XG4gICAqL1xuICBzdGF0aWMgZ2V0RGVlcGVzdE5vZGUoZSwgdCA9ICExKSB7XG4gICAgY29uc3QgbyA9IHQgPyBcImxhc3RDaGlsZFwiIDogXCJmaXJzdENoaWxkXCIsIGkgPSB0ID8gXCJwcmV2aW91c1NpYmxpbmdcIiA6IFwibmV4dFNpYmxpbmdcIjtcbiAgICBpZiAoZSAmJiBlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBlW29dKSB7XG4gICAgICBsZXQgbiA9IGVbb107XG4gICAgICBpZiAoYy5pc1NpbmdsZVRhZyhuKSAmJiAhYy5pc05hdGl2ZUlucHV0KG4pICYmICFjLmlzTGluZUJyZWFrVGFnKG4pKVxuICAgICAgICBpZiAobltpXSlcbiAgICAgICAgICBuID0gbltpXTtcbiAgICAgICAgZWxzZSBpZiAobi5wYXJlbnROb2RlW2ldKVxuICAgICAgICAgIG4gPSBuLnBhcmVudE5vZGVbaV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gbi5wYXJlbnROb2RlO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVlcGVzdE5vZGUobiwgdCk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBvYmplY3QgaXMgRE9NIG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHsqfSBub2RlIC0gb2JqZWN0IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgc3RhdGljIGlzRWxlbWVudChlKSB7XG4gICAgcmV0dXJuIEplKGUpID8gITEgOiBlICYmIGUubm9kZVR5cGUgJiYgZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIG9iamVjdCBpcyBEb2N1bWVudEZyYWdtZW50IG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5vZGUgLSBvYmplY3QgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBzdGF0aWMgaXNGcmFnbWVudChlKSB7XG4gICAgcmV0dXJuIEplKGUpID8gITEgOiBlICYmIGUubm9kZVR5cGUgJiYgZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgZWxlbWVudCBpcyBjb250ZW50ZWRpdGFibGVcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGh0bWwgZWxlbWVudCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0NvbnRlbnRFZGl0YWJsZShlKSB7XG4gICAgcmV0dXJuIGUuY29udGVudEVkaXRhYmxlID09PSBcInRydWVcIjtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHRhcmdldCBpZiBpdCBpcyBuYXRpdmUgaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgLSBIVE1MIGVsZW1lbnQgb3Igc3RyaW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgc3RhdGljIGlzTmF0aXZlSW5wdXQoZSkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBcIklOUFVUXCIsXG4gICAgICBcIlRFWFRBUkVBXCJcbiAgICBdO1xuICAgIHJldHVybiBlICYmIGUudGFnTmFtZSA/IHQuaW5jbHVkZXMoZS50YWdOYW1lKSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgd2UgY2FuIHNldCBjYXJldFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSB0YXJnZXQgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgY2FuU2V0Q2FyZXQoZSkge1xuICAgIGxldCB0ID0gITA7XG4gICAgaWYgKGMuaXNOYXRpdmVJbnB1dChlKSlcbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICBjYXNlIFwicmFkaW9cIjpcbiAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICBjYXNlIFwic3VibWl0XCI6XG4gICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgIGNhc2UgXCJyZXNldFwiOlxuICAgICAgICAgIHQgPSAhMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICB0ID0gYy5pc0NvbnRlbnRFZGl0YWJsZShlKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIG5vZGUgaWYgaXQgaXMgZW1wdHlcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBjaGVja3Mgc2ltcGxlIE5vZGUgd2l0aG91dCBhbnkgY2hpbGRzIGZvciBlbXB0aW5lc3NcbiAgICogSWYgeW91IGhhdmUgTm9kZSB3aXRoIDIgb3IgbW9yZSBjaGlsZHJlbiBpZCBkZXB0aCwgeW91IGJldHRlciB1c2Uge0BsaW5rIERvbSNpc0VtcHR5fSBtZXRob2RcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gbm9kZSB0byBjaGVja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2lnbm9yZUNoYXJzXSAtIGNoYXIgb3Igc3Vic3RyaW5nIHRvIHRyZWF0IGFzIGVtcHR5XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGl0IGlzIGVtcHR5XG4gICAqL1xuICBzdGF0aWMgaXNOb2RlRW1wdHkoZSwgdCkge1xuICAgIGxldCBvO1xuICAgIHJldHVybiB0aGlzLmlzU2luZ2xlVGFnKGUpICYmICF0aGlzLmlzTGluZUJyZWFrVGFnKGUpID8gITEgOiAodGhpcy5pc0VsZW1lbnQoZSkgJiYgdGhpcy5pc05hdGl2ZUlucHV0KGUpID8gbyA9IGUudmFsdWUgOiBvID0gZS50ZXh0Q29udGVudC5yZXBsYWNlKFwi4oCLXCIsIFwiXCIpLCB0ICYmIChvID0gby5yZXBsYWNlKG5ldyBSZWdFeHAodCwgXCJnXCIpLCBcIlwiKSksIG8udHJpbSgpLmxlbmd0aCA9PT0gMCk7XG4gIH1cbiAgLyoqXG4gICAqIGNoZWNrcyBub2RlIGlmIGl0IGlzIGRvZXNuJ3QgaGF2ZSBhbnkgY2hpbGQgbm9kZXNcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gbm9kZSB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0xlYWYoZSkge1xuICAgIHJldHVybiBlID8gZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBicmVhZHRoLWZpcnN0IHNlYXJjaCAoQkZTKVxuICAgKiB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlYWR0aC1maXJzdF9zZWFyY2h9XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBQdXNoZXMgdG8gc3RhY2sgYWxsIERPTSBsZWFmcyBhbmQgY2hlY2tzIGZvciBlbXB0aW5lc3NcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gbm9kZSB0byBjaGVja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2lnbm9yZUNoYXJzXSAtIGNoYXIgb3Igc3Vic3RyaW5nIHRvIHRyZWF0IGFzIGVtcHR5XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRW1wdHkoZSwgdCkge1xuICAgIGUubm9ybWFsaXplKCk7XG4gICAgY29uc3QgbyA9IFtlXTtcbiAgICBmb3IgKDsgby5sZW5ndGggPiAwOyApXG4gICAgICBpZiAoZSA9IG8uc2hpZnQoKSwgISFlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTGVhZihlKSAmJiAhdGhpcy5pc05vZGVFbXB0eShlLCB0KSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGUuY2hpbGROb2RlcyAmJiBvLnB1c2goLi4uQXJyYXkuZnJvbShlLmNoaWxkTm9kZXMpKTtcbiAgICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHN0cmluZyBjb250YWlucyBodG1sIGVsZW1lbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNIVE1MU3RyaW5nKGUpIHtcbiAgICBjb25zdCB0ID0gYy5tYWtlKFwiZGl2XCIpO1xuICAgIHJldHVybiB0LmlubmVySFRNTCA9IGUsIHQuY2hpbGRFbGVtZW50Q291bnQgPiAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gbGVuZ3RoIG9mIG5vZGVgcyB0ZXh0IGNvbnRlbnRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gbm9kZSB3aXRoIGNvbnRlbnRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXRDb250ZW50TGVuZ3RoKGUpIHtcbiAgICByZXR1cm4gYy5pc05hdGl2ZUlucHV0KGUpID8gZS52YWx1ZS5sZW5ndGggOiBlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IGUubGVuZ3RoIDogZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhcnJheSBvZiBuYW1lcyBvZiBibG9jayBodG1sIGVsZW1lbnRzXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICovXG4gIHN0YXRpYyBnZXQgYmxvY2tFbGVtZW50cygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJhZGRyZXNzXCIsXG4gICAgICBcImFydGljbGVcIixcbiAgICAgIFwiYXNpZGVcIixcbiAgICAgIFwiYmxvY2txdW90ZVwiLFxuICAgICAgXCJjYW52YXNcIixcbiAgICAgIFwiZGl2XCIsXG4gICAgICBcImRsXCIsXG4gICAgICBcImR0XCIsXG4gICAgICBcImZpZWxkc2V0XCIsXG4gICAgICBcImZpZ2NhcHRpb25cIixcbiAgICAgIFwiZmlndXJlXCIsXG4gICAgICBcImZvb3RlclwiLFxuICAgICAgXCJmb3JtXCIsXG4gICAgICBcImgxXCIsXG4gICAgICBcImgyXCIsXG4gICAgICBcImgzXCIsXG4gICAgICBcImg0XCIsXG4gICAgICBcImg1XCIsXG4gICAgICBcImg2XCIsXG4gICAgICBcImhlYWRlclwiLFxuICAgICAgXCJoZ3JvdXBcIixcbiAgICAgIFwiaHJcIixcbiAgICAgIFwibGlcIixcbiAgICAgIFwibWFpblwiLFxuICAgICAgXCJuYXZcIixcbiAgICAgIFwibm9zY3JpcHRcIixcbiAgICAgIFwib2xcIixcbiAgICAgIFwib3V0cHV0XCIsXG4gICAgICBcInBcIixcbiAgICAgIFwicHJlXCIsXG4gICAgICBcInJ1YnlcIixcbiAgICAgIFwic2VjdGlvblwiLFxuICAgICAgXCJ0YWJsZVwiLFxuICAgICAgXCJ0Ym9keVwiLFxuICAgICAgXCJ0aGVhZFwiLFxuICAgICAgXCJ0clwiLFxuICAgICAgXCJ0Zm9vdFwiLFxuICAgICAgXCJ1bFwiLFxuICAgICAgXCJ2aWRlb1wiXG4gICAgXTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcGFzc2VkIGNvbnRlbnQgaW5jbHVkZXMgb25seSBpbmxpbmUgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR9IGRhdGEgLSBlbGVtZW50IG9yIGh0bWwgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKGUpIHtcbiAgICBsZXQgdDtcbiAgICBHKGUpID8gKHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB0LmlubmVySFRNTCA9IGUpIDogdCA9IGU7XG4gICAgY29uc3QgbyA9IChpKSA9PiAhYy5ibG9ja0VsZW1lbnRzLmluY2x1ZGVzKGkudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiBBcnJheS5mcm9tKGkuY2hpbGRyZW4pLmV2ZXJ5KG8pO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHQuY2hpbGRyZW4pLmV2ZXJ5KG8pO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGFuZCByZXR1cm4gYWxsIGJsb2NrIGVsZW1lbnRzIGluIHRoZSBwYXNzZWQgcGFyZW50IChpbmNsdWRpbmcgc3VidHJlZSlcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IC0gcm9vdCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFtdfVxuICAgKi9cbiAgc3RhdGljIGdldERlZXBlc3RCbG9ja0VsZW1lbnRzKGUpIHtcbiAgICByZXR1cm4gYy5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cyhlKSA/IFtlXSA6IEFycmF5LmZyb20oZS5jaGlsZHJlbikucmVkdWNlKCh0LCBvKSA9PiBbLi4udCwgLi4uYy5nZXREZWVwZXN0QmxvY2tFbGVtZW50cyhvKV0sIFtdKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIGZvciBnZXQgaG9sZGVyIGZyb20ge3N0cmluZ30gb3IgcmV0dXJuIEhUTUxFbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgSFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBob2xkZXIncyBpZCBvciBob2xkZXIncyBIVE1MIEVsZW1lbnRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgc3RhdGljIGdldEhvbGRlcihlKSB7XG4gICAgcmV0dXJuIEcoZSkgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKSA6IGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBlbGVtZW50IGlzIGFuY2hvciAoaXMgQSB0YWcpXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNBbmNob3IoZSkge1xuICAgIHJldHVybiBlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJhXCI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBlbGVtZW50J3Mgb2Zmc2V0IHJlbGF0ZWQgdG8gdGhlIGRvY3VtZW50XG4gICAqXG4gICAqIEB0b2RvIGhhbmRsZSBjYXNlIHdoZW4gZWRpdG9yIGluaXRpYWxpemVkIGluIHNjcm9sbGFibGUgcG9wdXBcbiAgICogQHBhcmFtIGVsIC0gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldFxuICAgKi9cbiAgc3RhdGljIG9mZnNldChlKSB7XG4gICAgY29uc3QgdCA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG8gPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsIGkgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCwgbiA9IHQudG9wICsgaSwgciA9IHQubGVmdCArIG87XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogbixcbiAgICAgIGxlZnQ6IHIsXG4gICAgICBib3R0b206IG4gKyB0LmhlaWdodCxcbiAgICAgIHJpZ2h0OiByICsgdC53aWR0aFxuICAgIH07XG4gIH1cbn1cbmNvbnN0IHF0ID0ge1xuICBibG9ja1R1bmVzOiB7XG4gICAgdG9nZ2xlcjoge1xuICAgICAgXCJDbGljayB0byB0dW5lXCI6IFwiXCIsXG4gICAgICBcIm9yIGRyYWcgdG8gbW92ZVwiOiBcIlwiXG4gICAgfVxuICB9LFxuICBpbmxpbmVUb29sYmFyOiB7XG4gICAgY29udmVydGVyOiB7XG4gICAgICBcIkNvbnZlcnQgdG9cIjogXCJcIlxuICAgIH1cbiAgfSxcbiAgdG9vbGJhcjoge1xuICAgIHRvb2xib3g6IHtcbiAgICAgIEFkZDogXCJcIlxuICAgIH1cbiAgfSxcbiAgcG9wb3Zlcjoge1xuICAgIEZpbHRlcjogXCJcIixcbiAgICBcIk5vdGhpbmcgZm91bmRcIjogXCJcIlxuICB9XG59LCBadCA9IHtcbiAgVGV4dDogXCJcIixcbiAgTGluazogXCJcIixcbiAgQm9sZDogXCJcIixcbiAgSXRhbGljOiBcIlwiXG59LCBHdCA9IHtcbiAgbGluazoge1xuICAgIFwiQWRkIGEgbGlua1wiOiBcIlwiXG4gIH0sXG4gIHN0dWI6IHtcbiAgICBcIlRoZSBibG9jayBjYW4gbm90IGJlIGRpc3BsYXllZCBjb3JyZWN0bHkuXCI6IFwiXCJcbiAgfVxufSwgSnQgPSB7XG4gIGRlbGV0ZToge1xuICAgIERlbGV0ZTogXCJcIixcbiAgICBcIkNsaWNrIHRvIGRlbGV0ZVwiOiBcIlwiXG4gIH0sXG4gIG1vdmVVcDoge1xuICAgIFwiTW92ZSB1cFwiOiBcIlwiXG4gIH0sXG4gIG1vdmVEb3duOiB7XG4gICAgXCJNb3ZlIGRvd25cIjogXCJcIlxuICB9XG59LCBodCA9IHtcbiAgdWk6IHF0LFxuICB0b29sTmFtZXM6IFp0LFxuICB0b29sczogR3QsXG4gIGJsb2NrVHVuZXM6IEp0XG59LCBpZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFR5cGUtc2FmZSB0cmFuc2xhdGlvbiBmb3IgaW50ZXJuYWwgVUkgdGV4dHM6XG4gICAqIFBlcmZvcm0gdHJhbnNsYXRpb24gb2YgdGhlIHN0cmluZyBieSBuYW1lc3BhY2UgYW5kIGEga2V5XG4gICAqXG4gICAqIEBleGFtcGxlIEkxOG4udWkoSTE4bkludGVybmFsTlMudWkuYmxvY2tUdW5lcy50b2dnbGVyLCAnQ2xpY2sgdG8gdHVuZScpXG4gICAqIEBwYXJhbSBpbnRlcm5hbE5hbWVzcGFjZSAtIHBhdGggdG8gdHJhbnNsYXRlZCBzdHJpbmcgaW4gZGljdGlvbmFyeVxuICAgKiBAcGFyYW0gZGljdEtleSAtIGRpY3Rpb25hcnkga2V5LiBCZXR0ZXIgdG8gdXNlIGRlZmF1bHQgbG9jYWxlIG9yaWdpbmFsIHRleHRcbiAgICovXG4gIHN0YXRpYyB1aShzLCBlKSB7XG4gICAgcmV0dXJuIGllLl90KHMsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgZm9yIGV4dGVybmFsIHN0cmluZ3MgdGhhdCBpcyBub3QgcHJlc2VudGVkIGluIGRlZmF1bHQgZGljdGlvbmFyeS5cbiAgICogRm9yIGV4YW1wbGUsIGZvciB1c2VyLXNwZWNpZmllZCB0b29sIG5hbWVzXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBwYXRoIHRvIHRyYW5zbGF0ZWQgc3RyaW5nIGluIGRpY3Rpb25hcnlcbiAgICogQHBhcmFtIGRpY3RLZXkgLSBkaWN0aW9uYXJ5IGtleS4gQmV0dGVyIHRvIHVzZSBkZWZhdWx0IGxvY2FsZSBvcmlnaW5hbCB0ZXh0XG4gICAqL1xuICBzdGF0aWMgdChzLCBlKSB7XG4gICAgcmV0dXJuIGllLl90KHMsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGp1c3QgbW9kdWxlIGZvciB1c2luZyBleHRlcm5hbCBkaWN0aW9uYXJ5XG4gICAqXG4gICAqIEBwYXJhbSBkaWN0aW9uYXJ5IC0gbmV3IG1lc3NhZ2VzIGxpc3QgdG8gb3ZlcnJpZGUgZGVmYXVsdFxuICAgKi9cbiAgc3RhdGljIHNldERpY3Rpb25hcnkocykge1xuICAgIGllLmN1cnJlbnREaWN0aW9uYXJ5ID0gcztcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSB0cmFuc2xhdGlvbiBib3RoIGZvciBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgbmFtZXNwYWNlc1xuICAgKiBJZiB0aGVyZSBpcyBubyB0cmFuc2xhdGlvbiBmb3VuZCwgcmV0dXJucyBwYXNzZWQga2V5IGFzIGEgdHJhbnNsYXRlZCBtZXNzYWdlXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBwYXRoIHRvIHRyYW5zbGF0ZWQgc3RyaW5nIGluIGRpY3Rpb25hcnlcbiAgICogQHBhcmFtIGRpY3RLZXkgLSBkaWN0aW9uYXJ5IGtleS4gQmV0dGVyIHRvIHVzZSBkZWZhdWx0IGxvY2FsZSBvcmlnaW5hbCB0ZXh0XG4gICAqL1xuICBzdGF0aWMgX3QocywgZSkge1xuICAgIGNvbnN0IHQgPSBpZS5nZXROYW1lc3BhY2Uocyk7XG4gICAgcmV0dXJuICF0IHx8ICF0W2VdID8gZSA6IHRbZV07XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgbWVzc2FnZXMgc2VjdGlvbiBieSBuYW1lc3BhY2UgcGF0aFxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gcGF0aCB0byBzZWN0aW9uXG4gICAqL1xuICBzdGF0aWMgZ2V0TmFtZXNwYWNlKHMpIHtcbiAgICByZXR1cm4gcy5zcGxpdChcIi5cIikucmVkdWNlKCh0LCBvKSA9PiAhdCB8fCAhT2JqZWN0LmtleXModCkubGVuZ3RoID8ge30gOiB0W29dLCBpZS5jdXJyZW50RGljdGlvbmFyeSk7XG4gIH1cbn07XG5sZXQgeiA9IGllO1xuei5jdXJyZW50RGljdGlvbmFyeSA9IGh0O1xuY2xhc3MgdXQgZXh0ZW5kcyBFcnJvciB7XG59XG5jbGFzcyBFZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSB7fTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIGFueSBldmVudCBvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBzdWJzY3JpYmVyXG4gICAqL1xuICBvbihlLCB0KSB7XG4gICAgZSBpbiB0aGlzLnN1YnNjcmliZXJzIHx8ICh0aGlzLnN1YnNjcmliZXJzW2VdID0gW10pLCB0aGlzLnN1YnNjcmliZXJzW2VdLnB1c2godCk7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBhbnkgZXZlbnQgb24gY2FsbGJhY2suIENhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIG9uY2UgYW5kIGJlIHJlbW92ZWQgZnJvbSBzdWJzY3JpYmVycyBhcnJheSBhZnRlciBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBzdWJzY3JpYmVyXG4gICAqL1xuICBvbmNlKGUsIHQpIHtcbiAgICBlIGluIHRoaXMuc3Vic2NyaWJlcnMgfHwgKHRoaXMuc3Vic2NyaWJlcnNbZV0gPSBbXSk7XG4gICAgY29uc3QgbyA9IChpKSA9PiB7XG4gICAgICBjb25zdCBuID0gdChpKSwgciA9IHRoaXMuc3Vic2NyaWJlcnNbZV0uaW5kZXhPZihvKTtcbiAgICAgIHJldHVybiByICE9PSAtMSAmJiB0aGlzLnN1YnNjcmliZXJzW2VdLnNwbGljZShyLCAxKSwgbjtcbiAgICB9O1xuICAgIHRoaXMuc3Vic2NyaWJlcnNbZV0ucHVzaChvKTtcbiAgfVxuICAvKipcbiAgICogRW1pdCBjYWxsYmFja3Mgd2l0aCBwYXNzZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gZGF0YSAtIHN1YnNjcmliZXJzIGdldCB0aGlzIGRhdGEgd2hlbiB0aGV5IHdlcmUgZmlyZWRcbiAgICovXG4gIGVtaXQoZSwgdCkge1xuICAgIFcodGhpcy5zdWJzY3JpYmVycykgfHwgIXRoaXMuc3Vic2NyaWJlcnNbZV0gfHwgdGhpcy5zdWJzY3JpYmVyc1tlXS5yZWR1Y2UoKG8sIGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBpKG8pO1xuICAgICAgcmV0dXJuIG4gIT09IHZvaWQgMCA/IG4gOiBvO1xuICAgIH0sIHQpO1xuICB9XG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBjYWxsYmFjayBmcm9tIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIG9mZihlLCB0KSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlcnNbZV0gPT09IHZvaWQgMCkge1xuICAgICAgY29uc29sZS53YXJuKGBFdmVudERpc3BhdGNoZXIgLm9mZigpOiB0aGVyZSBpcyBubyBzdWJzY3JpYmVycyBmb3IgZXZlbnQgXCIke2UudG9TdHJpbmcoKX1cIi4gUHJvYmFibHksIC5vZmYoKSBjYWxsZWQgYmVmb3JlIC5vbigpYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgdGhpcy5zdWJzY3JpYmVyc1tlXS5sZW5ndGg7IG8rKylcbiAgICAgIGlmICh0aGlzLnN1YnNjcmliZXJzW2VdW29dID09PSB0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN1YnNjcmliZXJzW2VdW29dO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzdHJveWVyXG4gICAqIGNsZWFycyBzdWJzY3JpYmVycyBsaXN0XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSB7fTtcbiAgfVxufVxuZnVuY3Rpb24gZWUocykge1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywge1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGlkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgIHJldHVybiBzLmlkO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVG9vbCBuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgcmV0dXJuIHMubmFtZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRvb2wgY29uZmlnIHBhc3NlZCBvbiBFZGl0b3IncyBpbml0aWFsaXphdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1Rvb2xDb25maWd9XG4gICAgICovXG4gICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgIHJldHVybiBzLmNvbmZpZztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIC5jZS1ibG9jayBlbGVtZW50LCB0aGF0IHdyYXBzIHBsdWdpbiBjb250ZW50c1xuICAgICAqXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCBob2xkZXIoKSB7XG4gICAgICByZXR1cm4gcy5ob2xkZXI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIEJsb2NrIGNvbnRlbnQgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHMuaXNFbXB0eTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgQmxvY2sgaXMgc2VsZWN0ZWQgd2l0aCBDcm9zcy1CbG9jayBzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgIHJldHVybiBzLnNlbGVjdGVkO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0IEJsb2NrJ3Mgc3RyZXRjaCBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSDigJQgc3RhdGUgdG8gc2V0XG4gICAgICovXG4gICAgc2V0IHN0cmV0Y2hlZCh0KSB7XG4gICAgICBzLnN0cmV0Y2hlZCA9IHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIEJsb2NrIGlzIHN0cmV0Y2hlZFxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHN0cmV0Y2hlZCgpIHtcbiAgICAgIHJldHVybiBzLnN0cmV0Y2hlZDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgQmxvY2sgaGFzIGlucHV0cyB0byBiZSBmb2N1c2VkXG4gICAgICovXG4gICAgZ2V0IGZvY3VzYWJsZSgpIHtcbiAgICAgIHJldHVybiBzLmZvY3VzYWJsZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGwgVG9vbCBtZXRob2Qgd2l0aCBlcnJvcnMgaGFuZGxlciB1bmRlci10aGUtaG9vZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgLSBtZXRob2QgdG8gY2FsbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbSAtIG9iamVjdCB3aXRoIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB7dW5rbm93bn1cbiAgICAgKi9cbiAgICBjYWxsKHQsIG8pIHtcbiAgICAgIHJldHVybiBzLmNhbGwodCwgbyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTYXZlIEJsb2NrIGNvbnRlbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWR8U2F2ZWREYXRhPn1cbiAgICAgKi9cbiAgICBzYXZlKCkge1xuICAgICAgcmV0dXJuIHMuc2F2ZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgQmxvY2sgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIHtCbG9ja1Rvb2xEYXRhfSBkYXRhIC0gZGF0YSB0byB2YWxpZGF0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHZhbGlkYXRlKHQpIHtcbiAgICAgIHJldHVybiBzLnZhbGlkYXRlKHQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRvIHNheSBFZGl0b3IgdGhhdCBCbG9jayB3YXMgY2hhbmdlZC4gVXNlZCB0byBtYW51YWxseSB0cmlnZ2VyIEVkaXRvcidzICdvbkNoYW5nZScgY2FsbGJhY2tcbiAgICAgKiBDYW4gYmUgdXNlZnVsIGZvciBibG9jayBjaGFuZ2VzIGludmlzaWJsZSBmb3IgZWRpdG9yIGNvcmUuXG4gICAgICovXG4gICAgZGlzcGF0Y2hDaGFuZ2UoKSB7XG4gICAgICBzLmRpc3BhdGNoQ2hhbmdlKCk7XG4gICAgfVxuICB9KTtcbn1cbmNsYXNzIEZlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hbGxMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogQXNzaWducyBldmVudCBsaXN0ZW5lciBvbiBlbGVtZW50IGFuZCByZXR1cm5zIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBET00gZWxlbWVudCB0aGF0IG5lZWRzIHRvIGJlIGxpc3RlbmVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBtZXRob2QgdGhhdCB3aWxsIGJlIGZpcmVkIG9uIGV2ZW50XG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gb3B0aW9ucyAtIHVzZUNhcHR1cmUgb3Ige2NhcHR1cmUsIHBhc3NpdmUsIG9uY2V9XG4gICAqL1xuICBvbihlLCB0LCBvLCBpID0gITEpIHtcbiAgICBjb25zdCBuID0gWHQoXCJsXCIpLCByID0ge1xuICAgICAgaWQ6IG4sXG4gICAgICBlbGVtZW50OiBlLFxuICAgICAgZXZlbnRUeXBlOiB0LFxuICAgICAgaGFuZGxlcjogbyxcbiAgICAgIG9wdGlvbnM6IGlcbiAgICB9O1xuICAgIGlmICghdGhpcy5maW5kT25lKGUsIHQsIG8pKVxuICAgICAgcmV0dXJuIHRoaXMuYWxsTGlzdGVuZXJzLnB1c2gociksIGUuYWRkRXZlbnRMaXN0ZW5lcih0LCBvLCBpKSwgbjtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lciBmcm9tIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIERPTSBlbGVtZW50IHRoYXQgd2UgcmVtb3ZpbmcgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIHJlbW92ZSBoYW5kbGVyLCBpZiBlbGVtZW50IGxpc3RlbnMgc2V2ZXJhbCBoYW5kbGVycyBvbiB0aGUgc2FtZSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gb3B0aW9ucyAtIHVzZUNhcHR1cmUgb3Ige2NhcHR1cmUsIHBhc3NpdmUsIG9uY2V9XG4gICAqL1xuICBvZmYoZSwgdCwgbywgaSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmZpbmRBbGwoZSwgdCwgbyk7XG4gICAgbi5mb3JFYWNoKChyLCBhKSA9PiB7XG4gICAgICBjb25zdCBsID0gdGhpcy5hbGxMaXN0ZW5lcnMuaW5kZXhPZihuW2FdKTtcbiAgICAgIGwgPiAtMSAmJiAodGhpcy5hbGxMaXN0ZW5lcnMuc3BsaWNlKGwsIDEpLCByLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihyLmV2ZW50VHlwZSwgci5oYW5kbGVyLCByLm9wdGlvbnMpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBsaXN0ZW5lciBieSBpZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBsaXN0ZW5lciBpZGVudGlmaWVyXG4gICAqL1xuICBvZmZCeUlkKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5maW5kQnlJZChlKTtcbiAgICB0ICYmIHQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHQuZXZlbnRUeXBlLCB0LmhhbmRsZXIsIHQub3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRzIGFuZCByZXR1cm5zIGZpcnN0IGxpc3RlbmVyIGJ5IHBhc3NlZCBwYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIGV2ZW50IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V2ZW50VHlwZV0gLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSAtIGV2ZW50IGhhbmRsZXJcbiAgICogQHJldHVybnMge0xpc3RlbmVyRGF0YXxudWxsfVxuICAgKi9cbiAgZmluZE9uZShlLCB0LCBvKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZmluZEFsbChlLCB0LCBvKTtcbiAgICByZXR1cm4gaS5sZW5ndGggPiAwID8gaVswXSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgc3RvcmVkIGxpc3RlbmVycyBieSBwYXNzZWQgcGFyYW1zXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBldmVudCB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAgICogQHJldHVybnMge0xpc3RlbmVyRGF0YVtdfVxuICAgKi9cbiAgZmluZEFsbChlLCB0LCBvKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbiA9IGUgPyB0aGlzLmZpbmRCeUV2ZW50VGFyZ2V0KGUpIDogW107XG4gICAgcmV0dXJuIGUgJiYgdCAmJiBvID8gaSA9IG4uZmlsdGVyKChyKSA9PiByLmV2ZW50VHlwZSA9PT0gdCAmJiByLmhhbmRsZXIgPT09IG8pIDogZSAmJiB0ID8gaSA9IG4uZmlsdGVyKChyKSA9PiByLmV2ZW50VHlwZSA9PT0gdCkgOiBpID0gbiwgaTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzXG4gICAqL1xuICByZW1vdmVBbGwoKSB7XG4gICAgdGhpcy5hbGxMaXN0ZW5lcnMubWFwKChlKSA9PiB7XG4gICAgICBlLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLmV2ZW50VHlwZSwgZS5oYW5kbGVyLCBlLm9wdGlvbnMpO1xuICAgIH0pLCB0aGlzLmFsbExpc3RlbmVycyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBNb2R1bGUgY2xlYW51cCBvbiBkZXN0cnVjdGlvblxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbCgpO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2ggbWV0aG9kOiBsb29rcyBmb3IgbGlzdGVuZXIgYnkgcGFzc2VkIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIHNlYXJjaGluZyBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtBcnJheX0gbGlzdGVuZXJzIHRoYXQgZm91bmQgb24gZWxlbWVudFxuICAgKi9cbiAgZmluZEJ5RXZlbnRUYXJnZXQoZSkge1xuICAgIHJldHVybiB0aGlzLmFsbExpc3RlbmVycy5maWx0ZXIoKHQpID0+IHtcbiAgICAgIGlmICh0LmVsZW1lbnQgPT09IGUpXG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2ggbWV0aG9kOiBsb29rcyBmb3IgbGlzdGVuZXIgYnkgcGFzc2VkIGV2ZW50IHR5cGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIGV2ZW50IHR5cGVcbiAgICogQHJldHVybnMge0xpc3RlbmVyRGF0YVtdfSBsaXN0ZW5lcnMgdGhhdCBmb3VuZCBvbiBlbGVtZW50XG4gICAqL1xuICBmaW5kQnlUeXBlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxMaXN0ZW5lcnMuZmlsdGVyKCh0KSA9PiB7XG4gICAgICBpZiAodC5ldmVudFR5cGUgPT09IGUpXG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2ggbWV0aG9kOiBsb29rcyBmb3IgbGlzdGVuZXIgYnkgcGFzc2VkIGhhbmRsZXJcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAgICogQHJldHVybnMge0xpc3RlbmVyRGF0YVtdfSBsaXN0ZW5lcnMgdGhhdCBmb3VuZCBvbiBlbGVtZW50XG4gICAqL1xuICBmaW5kQnlIYW5kbGVyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxMaXN0ZW5lcnMuZmlsdGVyKCh0KSA9PiB7XG4gICAgICBpZiAodC5oYW5kbGVyID09PSBlKVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBsaXN0ZW5lciBkYXRhIGZvdW5kIGJ5IGlkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIGxpc3RlbmVyIGlkZW50aWZpZXJcbiAgICogQHJldHVybnMge0xpc3RlbmVyRGF0YX1cbiAgICovXG4gIGZpbmRCeUlkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxMaXN0ZW5lcnMuZmluZCgodCkgPT4gdC5pZCA9PT0gZSk7XG4gIH1cbn1cbmNsYXNzIHkge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTW9kdWxlIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuY29uZmlnIC0gTW9kdWxlIGNvbmZpZ1xuICAgKiBAcGFyYW0gb3B0aW9ucy5ldmVudHNEaXNwYXRjaGVyIC0gQ29tbW9uIGV2ZW50IGJ1c1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGUsIGV2ZW50c0Rpc3BhdGNoZXI6IHQgfSkge1xuICAgIGlmICh0aGlzLm5vZGVzID0ge30sIHRoaXMubGlzdGVuZXJzID0gbmV3IEZlKCksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBBc3NpZ25zIGV2ZW50IGxpc3RlbmVyIG9uIERPTSBlbGVtZW50IGFuZCBwdXNoZXMgaW50byBzcGVjaWFsIGFycmF5IHRoYXQgbWlnaHQgYmUgcmVtb3ZlZFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBET00gRWxlbWVudFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIEV2ZW50IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBFdmVudCBoYW5kbGVyXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IG9wdGlvbnMgLSBMaXN0ZW5pbmcgb3B0aW9uc1xuICAgICAgICovXG4gICAgICBvbjogKG8sIGksIG4sIHIgPSAhMSkgPT4ge1xuICAgICAgICB0aGlzLm11dGFibGVMaXN0ZW5lcklkcy5wdXNoKFxuICAgICAgICAgIHRoaXMubGlzdGVuZXJzLm9uKG8sIGksIG4sIHIpXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhcnMgYWxsIG11dGFibGUgbGlzdGVuZXJzXG4gICAgICAgKi9cbiAgICAgIGNsZWFyQWxsOiAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbyBvZiB0aGlzLm11dGFibGVMaXN0ZW5lcklkcylcbiAgICAgICAgICB0aGlzLmxpc3RlbmVycy5vZmZCeUlkKG8pO1xuICAgICAgICB0aGlzLm11dGFibGVMaXN0ZW5lcklkcyA9IFtdO1xuICAgICAgfVxuICAgIH0sIHRoaXMubXV0YWJsZUxpc3RlbmVySWRzID0gW10sIG5ldy50YXJnZXQgPT09IHkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29uc3RydWN0b3JzIGZvciBhYnN0cmFjdCBjbGFzcyBNb2R1bGUgYXJlIG5vdCBhbGxvd2VkLlwiKTtcbiAgICB0aGlzLmNvbmZpZyA9IGUsIHRoaXMuZXZlbnRzRGlzcGF0Y2hlciA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXRvciBtb2R1bGVzIHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0ge0VkaXRvck1vZHVsZXN9IEVkaXRvciAtIEVkaXRvcidzIE1vZHVsZXNcbiAgICovXG4gIHNldCBzdGF0ZShlKSB7XG4gICAgdGhpcy5FZGl0b3IgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgbWVtb3JpemVkIG5vZGVzXG4gICAqL1xuICByZW1vdmVBbGxOb2RlcygpIHtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgY29uc3QgdCA9IHRoaXMubm9kZXNbZV07XG4gICAgICB0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjdXJyZW50IGRpcmVjdGlvbiBpcyBSVEwgKFJpZ2h0LVRvLUxlZnQpXG4gICAqL1xuICBnZXQgaXNSdGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmkxOG4uZGlyZWN0aW9uID09PSBcInJ0bFwiO1xuICB9XG59XG5jbGFzcyBiIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbnN0YW5jZSA9IG51bGwsIHRoaXMuc2VsZWN0aW9uID0gbnVsbCwgdGhpcy5zYXZlZFNlbGVjdGlvblJhbmdlID0gbnVsbCwgdGhpcy5pc0Zha2VCYWNrZ3JvdW5kRW5hYmxlZCA9ICExLCB0aGlzLmNvbW1hbmRCYWNrZ3JvdW5kID0gXCJiYWNrQ29sb3JcIiwgdGhpcy5jb21tYW5kUmVtb3ZlRm9ybWF0ID0gXCJyZW1vdmVGb3JtYXRcIjtcbiAgfVxuICAvKipcbiAgICogRWRpdG9yIHN0eWxlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7e2VkaXRvcldyYXBwZXI6IHN0cmluZywgZWRpdG9yWm9uZTogc3RyaW5nfX1cbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlZGl0b3JXcmFwcGVyOiBcImNvZGV4LWVkaXRvclwiLFxuICAgICAgZWRpdG9yWm9uZTogXCJjb2RleC1lZGl0b3JfX3JlZGFjdG9yXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlbGVjdGVkIGFuY2hvclxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcnUvZG9jcy9XZWIvQVBJL1NlbGVjdGlvbi9hbmNob3JOb2RlfVxuICAgKlxuICAgKiBAcmV0dXJucyB7Tm9kZXxudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldCBhbmNob3JOb2RlKCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIGUgPyBlLmFuY2hvck5vZGUgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlbGVjdGVkIGFuY2hvciBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGFuY2hvckVsZW1lbnQoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB0ID0gZS5hbmNob3JOb2RlO1xuICAgIHJldHVybiB0ID8gYy5pc0VsZW1lbnQodCkgPyB0IDogdC5wYXJlbnRFbGVtZW50IDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzZWxlY3Rpb24gb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgYW5jaG9yIG5vZGVcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0FQSS9TZWxlY3Rpb24vYW5jaG9yT2Zmc2V0fVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGFuY2hvck9mZnNldCgpIHtcbiAgICBjb25zdCBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiBlID8gZS5hbmNob3JPZmZzZXQgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBJcyBjdXJyZW50IHNlbGVjdGlvbiByYW5nZSBjb2xsYXBzZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNDb2xsYXBzZWQoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gZSA/IGUuaXNDb2xsYXBzZWQgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBjdXJyZW50IHNlbGVjdGlvbiBpZiBpdCBpcyBhdCBFZGl0b3IncyB6b25lXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCBpc0F0RWRpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLmlzU2VsZWN0aW9uQXRFZGl0b3IoYi5nZXQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBzZWxlY3Rpb24gaXMgYXQgRWRpdG9yJ3Mgem9uZVxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gU2VsZWN0aW9uIG9iamVjdCB0byBjaGVja1xuICAgKi9cbiAgc3RhdGljIGlzU2VsZWN0aW9uQXRFZGl0b3IoZSkge1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBsZXQgdCA9IGUuYW5jaG9yTm9kZSB8fCBlLmZvY3VzTm9kZTtcbiAgICB0ICYmIHQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmICh0ID0gdC5wYXJlbnROb2RlKTtcbiAgICBsZXQgbyA9IG51bGw7XG4gICAgcmV0dXJuIHQgJiYgdCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgKG8gPSB0LmNsb3Nlc3QoYC4ke2IuQ1NTLmVkaXRvclpvbmV9YCkpLCBvID8gby5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgOiAhMTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcGFzc2VkIHJhbmdlIGF0IEVkaXRvciB6b25lXG4gICAqXG4gICAqIEBwYXJhbSByYW5nZSAtIHJhbmdlIHRvIGNoZWNrXG4gICAqL1xuICBzdGF0aWMgaXNSYW5nZUF0RWRpdG9yKGUpIHtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHQgPSBlLnN0YXJ0Q29udGFpbmVyO1xuICAgIHQgJiYgdC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgKHQgPSB0LnBhcmVudE5vZGUpO1xuICAgIGxldCBvID0gbnVsbDtcbiAgICByZXR1cm4gdCAmJiB0IGluc3RhbmNlb2YgRWxlbWVudCAmJiAobyA9IHQuY2xvc2VzdChgLiR7Yi5DU1MuZWRpdG9yWm9uZX1gKSksIG8gPyBvLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2RzIHJldHVybiBib29sZWFuIHRoYXQgdHJ1ZSBpZiBzZWxlY3Rpb24gZXhpc3RzIG9uIHRoZSBwYWdlXG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzU2VsZWN0aW9uRXhpc3RzKCkge1xuICAgIHJldHVybiAhIWIuZ2V0KCkuYW5jaG9yTm9kZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGZpcnN0IHJhbmdlXG4gICAqXG4gICAqIEByZXR1cm5zIHtSYW5nZXxudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldCByYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSYW5nZUZyb21TZWxlY3Rpb24odGhpcy5nZXQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcmFuZ2UgZnJvbSBwYXNzZWQgU2VsZWN0aW9uIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gU2VsZWN0aW9uIG9iamVjdCB0byBnZXQgUmFuZ2UgZnJvbVxuICAgKi9cbiAgc3RhdGljIGdldFJhbmdlRnJvbVNlbGVjdGlvbihlKSB7XG4gICAgcmV0dXJuIGUgJiYgZS5yYW5nZUNvdW50ID8gZS5nZXRSYW5nZUF0KDApIDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBzZWxlY3RlZCB0ZXh0XG4gICAqXG4gICAqIEByZXR1cm5zIHtET01SZWN0IHwgQ2xpZW50UmVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgcmVjdCgpIHtcbiAgICBsZXQgZSA9IGRvY3VtZW50LnNlbGVjdGlvbiwgdCwgbyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIGlmIChlICYmIGUudHlwZSAhPT0gXCJDb250cm9sXCIpXG4gICAgICByZXR1cm4gZSA9IGUsIHQgPSBlLmNyZWF0ZVJhbmdlKCksIG8ueCA9IHQuYm91bmRpbmdMZWZ0LCBvLnkgPSB0LmJvdW5kaW5nVG9wLCBvLndpZHRoID0gdC5ib3VuZGluZ1dpZHRoLCBvLmhlaWdodCA9IHQuYm91bmRpbmdIZWlnaHQsIG87XG4gICAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKVxuICAgICAgcmV0dXJuIFQoXCJNZXRob2Qgd2luZG93LmdldFNlbGVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkXCIsIFwid2FyblwiKSwgbztcbiAgICBpZiAoZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgZS5yYW5nZUNvdW50ID09PSBudWxsIHx8IGlzTmFOKGUucmFuZ2VDb3VudCkpXG4gICAgICByZXR1cm4gVChcIk1ldGhvZCBTZWxlY3Rpb25VdGlscy5yYW5nZUNvdW50IGlzIG5vdCBzdXBwb3J0ZWRcIiwgXCJ3YXJuXCIpLCBvO1xuICAgIGlmIChlLnJhbmdlQ291bnQgPT09IDApXG4gICAgICByZXR1cm4gbztcbiAgICBpZiAodCA9IGUuZ2V0UmFuZ2VBdCgwKS5jbG9uZVJhbmdlKCksIHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIChvID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksIG8ueCA9PT0gMCAmJiBvLnkgPT09IDApIHtcbiAgICAgIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIGlmIChpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgICBpLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwi4oCLXCIpKSwgdC5pbnNlcnROb2RlKGkpLCBvID0gaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgbiA9IGkucGFyZW50Tm9kZTtcbiAgICAgICAgbi5yZW1vdmVDaGlsZChpKSwgbi5ub3JtYWxpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc2VsZWN0ZWQgdGV4dCBhcyBTdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gd2luZG93LmdldFNlbGVjdGlvbiA/IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpIDogXCJcIjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aW5kb3cgU2VsZWN0aW9uVXRpbHNcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0FQSS9XaW5kb3cvZ2V0U2VsZWN0aW9ufVxuICAgKlxuICAgKiBAcmV0dXJucyB7U2VsZWN0aW9ufVxuICAgKi9cbiAgc3RhdGljIGdldCgpIHtcbiAgICByZXR1cm4gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgZm9jdXMgdG8gY29udGVudGVkaXRhYmxlIG9yIG5hdGl2ZSBpbnB1dCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gZWxlbWVudCB3aGVyZSB0byBzZXQgZm9jdXNcbiAgICogQHBhcmFtIG9mZnNldCAtIG9mZnNldCBvZiBjdXJzb3JcbiAgICovXG4gIHN0YXRpYyBzZXRDdXJzb3IoZSwgdCA9IDApIHtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSwgaSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gYy5pc05hdGl2ZUlucHV0KGUpID8gYy5jYW5TZXRDYXJldChlKSA/IChlLmZvY3VzKCksIGUuc2VsZWN0aW9uU3RhcnQgPSBlLnNlbGVjdGlvbkVuZCA9IHQsIGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpIDogdm9pZCAwIDogKG8uc2V0U3RhcnQoZSwgdCksIG8uc2V0RW5kKGUsIHQpLCBpLnJlbW92ZUFsbFJhbmdlcygpLCBpLmFkZFJhbmdlKG8pLCBvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgY3VycmVudCByYW5nZSBleGlzdHMgYW5kIGJlbG9uZ3MgdG8gY29udGFpbmVyXG4gICAqXG4gICAqIEBwYXJhbSBjb250YWluZXIgLSB3aGVyZSByYW5nZSBzaG91bGQgYmVcbiAgICovXG4gIHN0YXRpYyBpc1JhbmdlSW5zaWRlQ29udGFpbmVyKGUpIHtcbiAgICBjb25zdCB0ID0gYi5yYW5nZTtcbiAgICByZXR1cm4gdCA9PT0gbnVsbCA/ICExIDogZS5jb250YWlucyh0LnN0YXJ0Q29udGFpbmVyKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBmYWtlIGN1cnNvciB0byB0aGUgY3VycmVudCByYW5nZVxuICAgKi9cbiAgc3RhdGljIGFkZEZha2VDdXJzb3IoKSB7XG4gICAgY29uc3QgZSA9IGIucmFuZ2U7XG4gICAgaWYgKGUgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGMubWFrZShcInNwYW5cIiwgXCJjb2RleC1lZGl0b3JfX2Zha2UtY3Vyc29yXCIpO1xuICAgIHQuZGF0YXNldC5tdXRhdGlvbkZyZWUgPSBcInRydWVcIiwgZS5jb2xsYXBzZSgpLCBlLmluc2VydE5vZGUodCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBlbGVtZW50IGNvbnRhaW5zIGEgZmFrZSBjdXJzb3JcbiAgICpcbiAgICogQHBhcmFtIGVsIC0gd2hlcmUgdG8gY2hlY2tcbiAgICovXG4gIHN0YXRpYyBpc0Zha2VDdXJzb3JJbnNpZGVDb250YWluZXIoZSkge1xuICAgIHJldHVybiBjLmZpbmQoZSwgXCIuY29kZXgtZWRpdG9yX19mYWtlLWN1cnNvclwiKSAhPT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBmYWtlIGN1cnNvciBmcm9tIGEgY29udGFpbmVyXG4gICAqXG4gICAqIEBwYXJhbSBjb250YWluZXIgLSBjb250YWluZXIgdG8gbG9vayBmb3JcbiAgICovXG4gIHN0YXRpYyByZW1vdmVGYWtlQ3Vyc29yKGUgPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgY29uc3QgdCA9IGMuZmluZChlLCBcIi5jb2RleC1lZGl0b3JfX2Zha2UtY3Vyc29yXCIpO1xuICAgIHQgJiYgdC5yZW1vdmUoKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBmYWtlIGJhY2tncm91bmRcbiAgICovXG4gIHJlbW92ZUZha2VCYWNrZ3JvdW5kKCkge1xuICAgIHRoaXMuaXNGYWtlQmFja2dyb3VuZEVuYWJsZWQgJiYgKHRoaXMuaXNGYWtlQmFja2dyb3VuZEVuYWJsZWQgPSAhMSwgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kUmVtb3ZlRm9ybWF0KSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgZmFrZSBiYWNrZ3JvdW5kXG4gICAqL1xuICBzZXRGYWtlQmFja2dyb3VuZCgpIHtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmNvbW1hbmRCYWNrZ3JvdW5kLCAhMSwgXCIjYThkNmZmXCIpLCB0aGlzLmlzRmFrZUJhY2tncm91bmRFbmFibGVkID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIFNhdmUgU2VsZWN0aW9uVXRpbHMncyByYW5nZVxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICB0aGlzLnNhdmVkU2VsZWN0aW9uUmFuZ2UgPSBiLnJhbmdlO1xuICB9XG4gIC8qKlxuICAgKiBSZXN0b3JlIHNhdmVkIFNlbGVjdGlvblV0aWxzJ3MgcmFuZ2VcbiAgICovXG4gIHJlc3RvcmUoKSB7XG4gICAgaWYgKCF0aGlzLnNhdmVkU2VsZWN0aW9uUmFuZ2UpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBlLnJlbW92ZUFsbFJhbmdlcygpLCBlLmFkZFJhbmdlKHRoaXMuc2F2ZWRTZWxlY3Rpb25SYW5nZSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBzYXZlZCBzZWxlY3Rpb25cbiAgICovXG4gIGNsZWFyU2F2ZWQoKSB7XG4gICAgdGhpcy5zYXZlZFNlbGVjdGlvblJhbmdlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ29sbGFwc2UgY3VycmVudCBzZWxlY3Rpb25cbiAgICovXG4gIGNvbGxhcHNlVG9FbmQoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgdCA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgdC5zZWxlY3ROb2RlQ29udGVudHMoZS5mb2N1c05vZGUpLCB0LmNvbGxhcHNlKCExKSwgZS5yZW1vdmVBbGxSYW5nZXMoKSwgZS5hZGRSYW5nZSh0KTtcbiAgfVxuICAvKipcbiAgICogTG9va3MgYWhlYWQgdG8gZmluZCBwYXNzZWQgdGFnIGZyb20gY3VycmVudCBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWdOYW1lICAgICAgIC0gdGFnIHRvIGZvdW5kXG4gICAqIEBwYXJhbSAge3N0cmluZ30gW2NsYXNzTmFtZV0gICAtIHRhZydzIGNsYXNzIG5hbWVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbc2VhcmNoRGVwdGhdIC0gY291bnQgb2YgdGFncyB0aGF0IGNhbiBiZSBpbmNsdWRlZC4gRm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBmaW5kUGFyZW50VGFnKGUsIHQsIG8gPSAxMCkge1xuICAgIGNvbnN0IGkgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgbGV0IG4gPSBudWxsO1xuICAgIHJldHVybiAhaSB8fCAhaS5hbmNob3JOb2RlIHx8ICFpLmZvY3VzTm9kZSA/IG51bGwgOiAoW1xuICAgICAgLyoqIHRoZSBOb2RlIGluIHdoaWNoIHRoZSBzZWxlY3Rpb24gYmVnaW5zICovXG4gICAgICBpLmFuY2hvck5vZGUsXG4gICAgICAvKiogdGhlIE5vZGUgaW4gd2hpY2ggdGhlIHNlbGVjdGlvbiBlbmRzICovXG4gICAgICBpLmZvY3VzTm9kZVxuICAgIF0uZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgbGV0IGwgPSBvO1xuICAgICAgZm9yICg7IGwgPiAwICYmIGEucGFyZW50Tm9kZSAmJiAhKGEudGFnTmFtZSA9PT0gZSAmJiAobiA9IGEsIHQgJiYgYS5jbGFzc0xpc3QgJiYgIWEuY2xhc3NMaXN0LmNvbnRhaW5zKHQpICYmIChuID0gbnVsbCksIG4pKTsgKVxuICAgICAgICBhID0gYS5wYXJlbnROb2RlLCBsLS07XG4gICAgfSksIG4pO1xuICB9XG4gIC8qKlxuICAgKiBFeHBhbmRzIHNlbGVjdGlvbiByYW5nZSB0byB0aGUgcGFzc2VkIHBhcmVudCBub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHdoaWNoIGNvbnRlbnRzIHNob3VsZCBiZSBzZWxlY3RlZFxuICAgKi9cbiAgZXhwYW5kVG9UYWcoZSkge1xuICAgIGNvbnN0IHQgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBvLnNlbGVjdE5vZGVDb250ZW50cyhlKSwgdC5hZGRSYW5nZShvKTtcbiAgfVxufVxuZnVuY3Rpb24gUXQocywgZSkge1xuICBjb25zdCB7IHR5cGU6IHQsIHRhcmdldDogbywgYWRkZWROb2RlczogaSwgcmVtb3ZlZE5vZGVzOiBuIH0gPSBzO1xuICBpZiAobyA9PT0gZSlcbiAgICByZXR1cm4gITA7XG4gIGlmIChbXCJjaGFyYWN0ZXJEYXRhXCIsIFwiYXR0cmlidXRlc1wiXS5pbmNsdWRlcyh0KSkge1xuICAgIGNvbnN0IGwgPSBvLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IG8ucGFyZW50Tm9kZSA6IG87XG4gICAgcmV0dXJuIGUuY29udGFpbnMobCk7XG4gIH1cbiAgY29uc3QgciA9IEFycmF5LmZyb20oaSkuc29tZSgobCkgPT4gZS5jb250YWlucyhsKSksIGEgPSBBcnJheS5mcm9tKG4pLnNvbWUoKGwpID0+IGUuY29udGFpbnMobCkpO1xuICByZXR1cm4gciB8fCBhO1xufVxuY29uc3QgQWUgPSBcInJlZGFjdG9yIGRvbSBjaGFuZ2VkXCIsIHB0ID0gXCJibG9jayBjaGFuZ2VkXCIsIGZ0ID0gXCJmYWtlIGN1cnNvciBpcyBhYm91dCB0byBiZSB0b2dnbGVkXCIsIGd0ID0gXCJmYWtlIGN1cnNvciBoYXZlIGJlZW4gc2V0XCI7XG5mdW5jdGlvbiBvdChzLCBlKSB7XG4gIHJldHVybiBzLm1lcmdlYWJsZSAmJiBzLm5hbWUgPT09IGUubmFtZTtcbn1cbmZ1bmN0aW9uIGVvKHMsIGUpIHtcbiAgY29uc3QgdCA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZXhwb3J0O1xuICByZXR1cm4gTSh0KSA/IHQocykgOiBHKHQpID8gc1t0XSA6ICh0ICE9PSB2b2lkIDAgJiYgVChcIkNvbnZlcnNpb24gwqtleHBvcnTCuyBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uLiBTdHJpbmcgbWVhbnMga2V5IG9mIHNhdmVkIGRhdGEgb2JqZWN0IHRvIGV4cG9ydC4gRnVuY3Rpb24gc2hvdWxkIGV4cG9ydCBwcm9jZXNzZWQgc3RyaW5nIHRvIGV4cG9ydC5cIiksIFwiXCIpO1xufVxuZnVuY3Rpb24gdG8ocywgZSkge1xuICBjb25zdCB0ID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5pbXBvcnQ7XG4gIHJldHVybiBNKHQpID8gdChzKSA6IEcodCkgPyB7XG4gICAgW3RdOiBzXG4gIH0gOiAodCAhPT0gdm9pZCAwICYmIFQoXCJDb252ZXJzaW9uIMKraW1wb3J0wrsgcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZyBvciBmdW5jdGlvbi4gU3RyaW5nIG1lYW5zIGtleSBvZiB0b29sIGRhdGEgdG8gaW1wb3J0LiBGdW5jdGlvbiBhY2NlcHRzIGEgaW1wb3J0ZWQgc3RyaW5nIGFuZCByZXR1cm4gY29tcG9zZWQgdG9vbCBkYXRhLlwiKSwge30pO1xufVxudmFyIFggPSAvKiBAX19QVVJFX18gKi8gKChzKSA9PiAocy5BUFBFTkRfQ0FMTEJBQ0sgPSBcImFwcGVuZENhbGxiYWNrXCIsIHMuUkVOREVSRUQgPSBcInJlbmRlcmVkXCIsIHMuTU9WRUQgPSBcIm1vdmVkXCIsIHMuVVBEQVRFRCA9IFwidXBkYXRlZFwiLCBzLlJFTU9WRUQgPSBcInJlbW92ZWRcIiwgcy5PTl9QQVNURSA9IFwib25QYXN0ZVwiLCBzKSkoWCB8fCB7fSk7XG5jbGFzcyBSIGV4dGVuZHMgRWUge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBibG9jayBjb25zdHJ1Y3RvciBvcHRpb25zXG4gICAqIEBwYXJhbSBbb3B0aW9ucy5pZF0gLSBibG9jaydzIGlkLiBXaWxsIGJlIGdlbmVyYXRlZCBpZiBvbWl0dGVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVG9vbCdzIGluaXRpYWwgZGF0YVxuICAgKiBAcGFyYW0gb3B0aW9ucy50b29sIOKAlCBibG9jaydzIHRvb2xcbiAgICogQHBhcmFtIG9wdGlvbnMuYXBpIC0gRWRpdG9yIEFQSSBtb2R1bGUgZm9yIHBhc3MgaXQgdG8gdGhlIEJsb2NrIFR1bmVzXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlYWRPbmx5IC0gUmVhZC1Pbmx5IGZsYWdcbiAgICogQHBhcmFtIFtldmVudEJ1c10gLSBFZGl0b3IgY29tbW9uIGV2ZW50IGJ1cy4gQWxsb3dzIHRvIHN1YnNjcmliZSBvbiBzb21lIEVkaXRvciBldmVudHMuIENvdWxkIGJlIG9taXR0ZWQgd2hlbiBcInZpcnR1YWxcIiBCbG9jayBpcyBjcmVhdGVkLiBTZWUgQmxvY2tzQVBJQGNvbXBvc2VCbG9ja0RhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgaWQ6IGUgPSBZdCgpLFxuICAgIGRhdGE6IHQsXG4gICAgdG9vbDogbyxcbiAgICBhcGk6IGksXG4gICAgcmVhZE9ubHk6IG4sXG4gICAgdHVuZXNEYXRhOiByXG4gIH0sIGEpIHtcbiAgICBzdXBlcigpLCB0aGlzLmNhY2hlZElucHV0cyA9IFtdLCB0aGlzLnRvb2xSZW5kZXJlZEVsZW1lbnQgPSBudWxsLCB0aGlzLnR1bmVzSW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5kZWZhdWx0VHVuZXNJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnVuYXZhaWxhYmxlVHVuZXNEYXRhID0ge30sIHRoaXMuaW5wdXRJbmRleCA9IDAsIHRoaXMuZWRpdG9yRXZlbnRCdXMgPSBudWxsLCB0aGlzLmhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgICAgdGhpcy5kcm9wSW5wdXRzQ2FjaGUoKSwgdGhpcy51cGRhdGVDdXJyZW50SW5wdXQoKTtcbiAgICB9LCB0aGlzLmRpZE11dGF0ZWQgPSAobCA9IHZvaWQgMCkgPT4ge1xuICAgICAgY29uc3QgZCA9IGwgPT09IHZvaWQgMCwgdSA9IGwgaW5zdGFuY2VvZiBJbnB1dEV2ZW50O1xuICAgICAgIWQgJiYgIXUgJiYgdGhpcy5kZXRlY3RUb29sUm9vdENoYW5nZShsKTtcbiAgICAgIGxldCBoO1xuICAgICAgZCB8fCB1ID8gaCA9ICEwIDogaCA9ICEobC5sZW5ndGggPiAwICYmIGwuZXZlcnkoKHgpID0+IHtcbiAgICAgICAgY29uc3QgeyBhZGRlZE5vZGVzOiBwLCByZW1vdmVkTm9kZXM6IG0sIHRhcmdldDogTCB9ID0geDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAuLi5BcnJheS5mcm9tKHApLFxuICAgICAgICAgIC4uLkFycmF5LmZyb20obSksXG4gICAgICAgICAgTFxuICAgICAgICBdLnNvbWUoKFMpID0+IChjLmlzRWxlbWVudChTKSB8fCAoUyA9IFMucGFyZW50RWxlbWVudCksIFMgJiYgUy5jbG9zZXN0KCdbZGF0YS1tdXRhdGlvbi1mcmVlPVwidHJ1ZVwiXScpICE9PSBudWxsKSk7XG4gICAgICB9KSksIGggJiYgKHRoaXMuZHJvcElucHV0c0NhY2hlKCksIHRoaXMudXBkYXRlQ3VycmVudElucHV0KCksIHRoaXMuY2FsbChcbiAgICAgICAgXCJ1cGRhdGVkXCJcbiAgICAgICAgLyogVVBEQVRFRCAqL1xuICAgICAgKSwgdGhpcy5lbWl0KFwiZGlkTXV0YXRlZFwiLCB0aGlzKSk7XG4gICAgfSwgdGhpcy5uYW1lID0gby5uYW1lLCB0aGlzLmlkID0gZSwgdGhpcy5zZXR0aW5ncyA9IG8uc2V0dGluZ3MsIHRoaXMuY29uZmlnID0gby5zZXR0aW5ncy5jb25maWcgfHwge30sIHRoaXMuYXBpID0gaSwgdGhpcy5lZGl0b3JFdmVudEJ1cyA9IGEgfHwgbnVsbCwgdGhpcy5ibG9ja0FQSSA9IG5ldyBlZSh0aGlzKSwgdGhpcy50b29sID0gbywgdGhpcy50b29sSW5zdGFuY2UgPSBvLmNyZWF0ZSh0LCB0aGlzLmJsb2NrQVBJLCBuKSwgdGhpcy50dW5lcyA9IG8udHVuZXMsIHRoaXMuY29tcG9zZVR1bmVzKHIpLCB0aGlzLmhvbGRlciA9IHRoaXMuY29tcG9zZSgpLCB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLndhdGNoQmxvY2tNdXRhdGlvbnMoKSwgdGhpcy5hZGRJbnB1dEV2ZW50cygpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDU1MgY2xhc3NlcyBmb3IgdGhlIEJsb2NrXG4gICAqXG4gICAqIEByZXR1cm5zIHt7d3JhcHBlcjogc3RyaW5nLCBjb250ZW50OiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyYXBwZXI6IFwiY2UtYmxvY2tcIixcbiAgICAgIHdyYXBwZXJTdHJldGNoZWQ6IFwiY2UtYmxvY2stLXN0cmV0Y2hlZFwiLFxuICAgICAgY29udGVudDogXCJjZS1ibG9ja19fY29udGVudFwiLFxuICAgICAgc2VsZWN0ZWQ6IFwiY2UtYmxvY2stLXNlbGVjdGVkXCIsXG4gICAgICBkcm9wVGFyZ2V0OiBcImNlLWJsb2NrLS1kcm9wLXRhcmdldFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhbmQgcmV0dXJuIGFsbCBlZGl0YWJsZSBlbGVtZW50cyAoY29udGVudGVkaXRhYmxlIGFuZCBuYXRpdmUgaW5wdXRzKSBpbiB0aGUgVG9vbCBIVE1MXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFtdfVxuICAgKi9cbiAgZ2V0IGlucHV0cygpIHtcbiAgICBpZiAodGhpcy5jYWNoZWRJbnB1dHMubGVuZ3RoICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkSW5wdXRzO1xuICAgIGNvbnN0IGUgPSBjLmZpbmRBbGxJbnB1dHModGhpcy5ob2xkZXIpO1xuICAgIHJldHVybiB0aGlzLmlucHV0SW5kZXggPiBlLmxlbmd0aCAtIDEgJiYgKHRoaXMuaW5wdXRJbmRleCA9IGUubGVuZ3RoIC0gMSksIHRoaXMuY2FjaGVkSW5wdXRzID0gZSwgZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGN1cnJlbnQgVG9vbGBzIGlucHV0XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldCBjdXJyZW50SW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzW3RoaXMuaW5wdXRJbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIFNldCBpbnB1dCBpbmRleCB0byB0aGUgcGFzc2VkIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IE5vZGV9IGVsZW1lbnQgLSBIVE1MIEVsZW1lbnQgdG8gc2V0IGFzIGN1cnJlbnQgaW5wdXRcbiAgICovXG4gIHNldCBjdXJyZW50SW5wdXQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmlucHV0cy5maW5kSW5kZXgoKG8pID0+IG8gPT09IGUgfHwgby5jb250YWlucyhlKSk7XG4gICAgdCAhPT0gLTEgJiYgKHRoaXMuaW5wdXRJbmRleCA9IHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgVG9vbGBzIGlucHV0XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldCBmaXJzdElucHV0KCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0c1swXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGZpcnN0IFRvb2xgcyBpbnB1dFxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBnZXQgbGFzdElucHV0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmlucHV0cztcbiAgICByZXR1cm4gZVtlLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gbmV4dCBUb29sYHMgaW5wdXQgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0IG5leHRJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dHNbdGhpcy5pbnB1dEluZGV4ICsgMV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBwcmV2aW91cyBUb29sYHMgaW5wdXQgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0IHByZXZpb3VzSW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzW3RoaXMuaW5wdXRJbmRleCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sncyBKU09OIGRhdGFcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnNhdmUoKS50aGVuKChlKSA9PiBlICYmICFXKGUuZGF0YSkgPyBlLmRhdGEgOiB7fSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdG9vbCdzIHNhbml0aXplciBjb25maWdcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sLnNhbml0aXplQ29uZmlnO1xuICB9XG4gIC8qKlxuICAgKiBpcyBibG9jayBtZXJnZWFibGVcbiAgICogV2UgcGx1Z2luIGhhdmUgbWVyZ2UgZnVuY3Rpb24gdGhlbiB3ZSBjYWxsIGl0IG1lcmdlYWJsZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBtZXJnZWFibGUoKSB7XG4gICAgcmV0dXJuIE0odGhpcy50b29sSW5zdGFuY2UubWVyZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBJZiBCbG9jayBjb250YWlucyBpbnB1dHMsIGl0IGlzIGZvY3VzYWJsZVxuICAgKi9cbiAgZ2V0IGZvY3VzYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dHMubGVuZ3RoICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBibG9jayBmb3IgZW1wdGluZXNzXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgY29uc3QgZSA9IGMuaXNFbXB0eSh0aGlzLnBsdWdpbnNDb250ZW50LCBcIi9cIiksIHQgPSAhdGhpcy5oYXNNZWRpYTtcbiAgICByZXR1cm4gZSAmJiB0O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBibG9jayBoYXMgYSBtZWRpYSBjb250ZW50IHN1Y2ggYXMgaW1hZ2VzLCBpZnJhbWUgYW5kIG90aGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGhhc01lZGlhKCkge1xuICAgIGNvbnN0IGUgPSBbXG4gICAgICBcImltZ1wiLFxuICAgICAgXCJpZnJhbWVcIixcbiAgICAgIFwidmlkZW9cIixcbiAgICAgIFwiYXVkaW9cIixcbiAgICAgIFwic291cmNlXCIsXG4gICAgICBcImlucHV0XCIsXG4gICAgICBcInRleHRhcmVhXCIsXG4gICAgICBcInR3aXR0ZXJ3aWRnZXRcIlxuICAgIF07XG4gICAgcmV0dXJuICEhdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcihlLmpvaW4oXCIsXCIpKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHNlbGVjdGVkIHN0YXRlXG4gICAqIFdlIGRvbid0IG5lZWQgdG8gbWFyayBCbG9jayBhcyBTZWxlY3RlZCB3aGVuIGl0IGlzIGVtcHR5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgLSAndHJ1ZScgdG8gc2VsZWN0LCAnZmFsc2UnIHRvIHJlbW92ZSBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBzZWxlY3RlZChlKSB7XG4gICAgdmFyIGksIG47XG4gICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnRvZ2dsZShSLkNTUy5zZWxlY3RlZCwgZSk7XG4gICAgY29uc3QgdCA9IGUgPT09ICEwICYmIGIuaXNSYW5nZUluc2lkZUNvbnRhaW5lcih0aGlzLmhvbGRlciksIG8gPSBlID09PSAhMSAmJiBiLmlzRmFrZUN1cnNvckluc2lkZUNvbnRhaW5lcih0aGlzLmhvbGRlcik7XG4gICAgKHQgfHwgbykgJiYgKChpID0gdGhpcy5lZGl0b3JFdmVudEJ1cykgPT0gbnVsbCB8fCBpLmVtaXQoZnQsIHsgc3RhdGU6IGUgfSksIHQgPyBiLmFkZEZha2VDdXJzb3IoKSA6IGIucmVtb3ZlRmFrZUN1cnNvcih0aGlzLmhvbGRlciksIChuID0gdGhpcy5lZGl0b3JFdmVudEJ1cykgPT0gbnVsbCB8fCBuLmVtaXQoZ3QsIHsgc3RhdGU6IGUgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRydWUgaWYgaXQgaXMgU2VsZWN0ZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5jb250YWlucyhSLkNTUy5zZWxlY3RlZCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBzdHJldGNoZWQgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSAtICd0cnVlJyB0byBlbmFibGUsICdmYWxzZScgdG8gZGlzYWJsZSBzdHJldGNoZWQgc3RhdGVcbiAgICovXG4gIHNldCBzdHJldGNoZWQoZSkge1xuICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC50b2dnbGUoUi5DU1Mud3JhcHBlclN0cmV0Y2hlZCwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBCbG9jaydzIHN0cmV0Y2hlZCBzdGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBzdHJldGNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5jb250YWlucyhSLkNTUy53cmFwcGVyU3RyZXRjaGVkKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlIGRyb3AgdGFyZ2V0IHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgLSAndHJ1ZScgaWYgYmxvY2sgaXMgZHJvcCB0YXJnZXQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgc2V0IGRyb3BUYXJnZXQoZSkge1xuICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC50b2dnbGUoUi5DU1MuZHJvcFRhcmdldCwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgUGx1Z2lucyBjb250ZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldCBwbHVnaW5zQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sUmVuZGVyZWRFbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBUb29sJ3MgbWV0aG9kXG4gICAqXG4gICAqIE1ldGhvZCBjaGVja3MgdG9vbCBwcm9wZXJ0eSB7TWV0aG9kTmFtZX0uIEZpcmVzIG1ldGhvZCB3aXRoIHBhc3NlcyBwYXJhbXMgSWYgaXQgaXMgaW5zdGFuY2Ugb2YgRnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgLSBtZXRob2QgdG8gY2FsbFxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gbWV0aG9kIGFyZ3VtZW50XG4gICAqL1xuICBjYWxsKGUsIHQpIHtcbiAgICBpZiAoTSh0aGlzLnRvb2xJbnN0YW5jZVtlXSkpIHtcbiAgICAgIGUgPT09IFwiYXBwZW5kQ2FsbGJhY2tcIiAmJiBUKFxuICAgICAgICBcImBhcHBlbmRDYWxsYmFja2AgaG9vayBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVXNlIGByZW5kZXJlZGAgaG9vayBpbnN0ZWFkXCIsXG4gICAgICAgIFwid2FyblwiXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy50b29sSW5zdGFuY2VbZV0uY2FsbCh0aGlzLnRvb2xJbnN0YW5jZSwgdCk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIFQoYEVycm9yIGR1cmluZyAnJHtlfScgY2FsbDogJHtvLm1lc3NhZ2V9YCwgXCJlcnJvclwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgcGx1Z2lucyBtZXJnZSBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja1Rvb2xEYXRhfSBkYXRhIC0gZGF0YSB0byBtZXJnZVxuICAgKi9cbiAgYXN5bmMgbWVyZ2VXaXRoKGUpIHtcbiAgICBhd2FpdCB0aGlzLnRvb2xJbnN0YW5jZS5tZXJnZShlKTtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdHMgZGF0YSBmcm9tIEJsb2NrXG4gICAqIEdyb3VwcyBUb29sJ3Mgc2F2ZSBwcm9jZXNzaW5nIHRpbWVcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGFzeW5jIHNhdmUoKSB7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXMudG9vbEluc3RhbmNlLnNhdmUodGhpcy5wbHVnaW5zQ29udGVudCksIHQgPSB0aGlzLnVuYXZhaWxhYmxlVHVuZXNEYXRhO1xuICAgIFtcbiAgICAgIC4uLnRoaXMudHVuZXNJbnN0YW5jZXMuZW50cmllcygpLFxuICAgICAgLi4udGhpcy5kZWZhdWx0VHVuZXNJbnN0YW5jZXMuZW50cmllcygpXG4gICAgXS5mb3JFYWNoKChbbiwgcl0pID0+IHtcbiAgICAgIGlmIChNKHIuc2F2ZSkpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdFtuXSA9IHIuc2F2ZSgpO1xuICAgICAgICB9IGNhdGNoIChhKSB7XG4gICAgICAgICAgVChgVHVuZSAke3IuY29uc3RydWN0b3IubmFtZX0gc2F2ZSBtZXRob2QgdGhyb3dzIGFuIEVycm9yICVvYCwgXCJ3YXJuXCIsIGEpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBsZXQgaTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUpLnRoZW4oKG4pID0+IChpID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpLCB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHRvb2w6IHRoaXMubmFtZSxcbiAgICAgIGRhdGE6IG4sXG4gICAgICB0dW5lczogdCxcbiAgICAgIHRpbWU6IGkgLSBvXG4gICAgfSkpLmNhdGNoKChuKSA9PiB7XG4gICAgICBUKGBTYXZpbmcgcHJvY2VzcyBmb3IgJHt0aGlzLm5hbWV9IHRvb2wgZmFpbGVkIGR1ZSB0byB0aGUgJHtufWAsIFwibG9nXCIsIFwicmVkXCIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVc2VzIFRvb2wncyB2YWxpZGF0aW9uIG1ldGhvZCB0byBjaGVjayB0aGUgY29ycmVjdG5lc3Mgb2Ygb3V0cHV0IGRhdGFcbiAgICogVG9vbCdzIHZhbGlkYXRpb24gbWV0aG9kIGlzIG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgcmV0dXJucyB0cnVlfGZhbHNlIHdoZXRoZXIgZGF0YSBwYXNzZWQgdGhlIHZhbGlkYXRpb24gb3Igbm90XG4gICAqIEBwYXJhbSB7QmxvY2tUb29sRGF0YX0gZGF0YSAtIGRhdGEgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHZhbGlkXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZShlKSB7XG4gICAgbGV0IHQgPSAhMDtcbiAgICByZXR1cm4gdGhpcy50b29sSW5zdGFuY2UudmFsaWRhdGUgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiAodCA9IGF3YWl0IHRoaXMudG9vbEluc3RhbmNlLnZhbGlkYXRlKGUpKSwgdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBkYXRhIHRvIHJlbmRlciBpbiB0dW5lcyBtZW51LlxuICAgKiBTcGxpdHMgYmxvY2sgdHVuZXMgc2V0dGluZ3MgaW50byAyIGdyb3VwczogcG9wb3ZlciBpdGVtcyBhbmQgY3VzdG9tIGh0bWwuXG4gICAqL1xuICBnZXRUdW5lcygpIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdCA9IFtdLCBvID0gdHlwZW9mIHRoaXMudG9vbEluc3RhbmNlLnJlbmRlclNldHRpbmdzID09IFwiZnVuY3Rpb25cIiA/IHRoaXMudG9vbEluc3RhbmNlLnJlbmRlclNldHRpbmdzKCkgOiBbXSwgaSA9IFtcbiAgICAgIC4uLnRoaXMudHVuZXNJbnN0YW5jZXMudmFsdWVzKCksXG4gICAgICAuLi50aGlzLmRlZmF1bHRUdW5lc0luc3RhbmNlcy52YWx1ZXMoKVxuICAgIF0ubWFwKChuKSA9PiBuLnJlbmRlcigpKTtcbiAgICByZXR1cm4gW28sIGldLmZsYXQoKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBjLmlzRWxlbWVudChuKSA/IGUuYXBwZW5kQ2hpbGQobikgOiBBcnJheS5pc0FycmF5KG4pID8gdC5wdXNoKC4uLm4pIDogdC5wdXNoKG4pO1xuICAgIH0pLCBbdCwgZV07XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBjdXJyZW50IGlucHV0IGluZGV4IHdpdGggc2VsZWN0aW9uIGFuY2hvciBub2RlXG4gICAqL1xuICB1cGRhdGVDdXJyZW50SW5wdXQoKSB7XG4gICAgdGhpcy5jdXJyZW50SW5wdXQgPSBjLmlzTmF0aXZlSW5wdXQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgfHwgIWIuYW5jaG9yTm9kZSA/IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBiLmFuY2hvck5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93cyB0byBzYXkgRWRpdG9yIHRoYXQgQmxvY2sgd2FzIGNoYW5nZWQuIFVzZWQgdG8gbWFudWFsbHkgdHJpZ2dlciBFZGl0b3IncyAnb25DaGFuZ2UnIGNhbGxiYWNrXG4gICAqIENhbiBiZSB1c2VmdWwgZm9yIGJsb2NrIGNoYW5nZXMgaW52aXNpYmxlIGZvciBlZGl0b3IgY29yZS5cbiAgICovXG4gIGRpc3BhdGNoQ2hhbmdlKCkge1xuICAgIHRoaXMuZGlkTXV0YXRlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIFRvb2wgaW5zdGFuY2UgZGVzdHJveSBtZXRob2RcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bndhdGNoQmxvY2tNdXRhdGlvbnMoKSwgdGhpcy5yZW1vdmVJbnB1dEV2ZW50cygpLCBzdXBlci5kZXN0cm95KCksIE0odGhpcy50b29sSW5zdGFuY2UuZGVzdHJveSkgJiYgdGhpcy50b29sSW5zdGFuY2UuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBUb29sIGNvdWxkIHNwZWNpZnkgc2V2ZXJhbCBlbnRyaWVzIHRvIGJlIGRpc3BsYXllZCBhdCB0aGUgVG9vbGJveCAoZm9yIGV4YW1wbGUsIFwiSGVhZGluZyAxXCIsIFwiSGVhZGluZyAyXCIsIFwiSGVhZGluZyAzXCIpXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVudHJ5IHRoYXQgaXMgcmVsYXRlZCB0byB0aGUgQmxvY2sgKGRlcGVuZGVkIG9uIHRoZSBCbG9jayBkYXRhKVxuICAgKi9cbiAgYXN5bmMgZ2V0QWN0aXZlVG9vbGJveEVudHJ5KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnRvb2wudG9vbGJveDtcbiAgICBpZiAoZS5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudG9vbC50b29sYm94WzBdKTtcbiAgICBjb25zdCB0ID0gYXdhaXQgdGhpcy5kYXRhO1xuICAgIHJldHVybiBlLmZpbmQoKGkpID0+IE9iamVjdC5lbnRyaWVzKGkuZGF0YSkuc29tZSgoW24sIHJdKSA9PiB0W25dICYmIFZ0KHRbbl0sIHIpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4cG9ydHMgQmxvY2sgZGF0YSBhcyBzdHJpbmcgdXNpbmcgY29udmVyc2lvbiBjb25maWdcbiAgICovXG4gIGFzeW5jIGV4cG9ydERhdGFBc1N0cmluZygpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5kYXRhO1xuICAgIHJldHVybiBlbyhlLCB0aGlzLnRvb2wuY29udmVyc2lvbkNvbmZpZyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2UgZGVmYXVsdCBCbG9jayB3cmFwcGVycyBhbmQgcHV0IFRvb2xgcyBjb250ZW50IHRoZXJlXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIGNvbXBvc2UoKSB7XG4gICAgY29uc3QgZSA9IGMubWFrZShcImRpdlwiLCBSLkNTUy53cmFwcGVyKSwgdCA9IGMubWFrZShcImRpdlwiLCBSLkNTUy5jb250ZW50KSwgbyA9IHRoaXMudG9vbEluc3RhbmNlLnJlbmRlcigpO1xuICAgIGUuZGF0YXNldC5pZCA9IHRoaXMuaWQsIHRoaXMudG9vbFJlbmRlcmVkRWxlbWVudCA9IG8sIHQuYXBwZW5kQ2hpbGQodGhpcy50b29sUmVuZGVyZWRFbGVtZW50KTtcbiAgICBsZXQgaSA9IHQ7XG4gICAgcmV0dXJuIFsuLi50aGlzLnR1bmVzSW5zdGFuY2VzLnZhbHVlcygpLCAuLi50aGlzLmRlZmF1bHRUdW5lc0luc3RhbmNlcy52YWx1ZXMoKV0uZm9yRWFjaCgobikgPT4ge1xuICAgICAgaWYgKE0obi53cmFwKSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpID0gbi53cmFwKGkpO1xuICAgICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgICAgVChgVHVuZSAke24uY29uc3RydWN0b3IubmFtZX0gd3JhcCBtZXRob2QgdGhyb3dzIGFuIEVycm9yICVvYCwgXCJ3YXJuXCIsIHIpO1xuICAgICAgICB9XG4gICAgfSksIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIEJsb2NrIFR1bmVzXG4gICAqXG4gICAqIEBwYXJhbSB0dW5lc0RhdGEgLSBjdXJyZW50IEJsb2NrIHR1bmVzIGRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbXBvc2VUdW5lcyhlKSB7XG4gICAgQXJyYXkuZnJvbSh0aGlzLnR1bmVzLnZhbHVlcygpKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAodC5pc0ludGVybmFsID8gdGhpcy5kZWZhdWx0VHVuZXNJbnN0YW5jZXMgOiB0aGlzLnR1bmVzSW5zdGFuY2VzKS5zZXQodC5uYW1lLCB0LmNyZWF0ZShlW3QubmFtZV0sIHRoaXMuYmxvY2tBUEkpKTtcbiAgICB9KSwgT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW3QsIG9dKSA9PiB7XG4gICAgICB0aGlzLnR1bmVzSW5zdGFuY2VzLmhhcyh0KSB8fCAodGhpcy51bmF2YWlsYWJsZVR1bmVzRGF0YVt0XSA9IG8pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGZvY3VzIGV2ZW50IGxpc3RlbmVycyB0byBhbGwgaW5wdXRzIGFuZCBjb250ZW50ZWRpdGFibGVcbiAgICovXG4gIGFkZElucHV0RXZlbnRzKCkge1xuICAgIHRoaXMuaW5wdXRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuaGFuZGxlRm9jdXMpLCBjLmlzTmF0aXZlSW5wdXQoZSkgJiYgZS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5kaWRNdXRhdGVkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcmVtb3ZlcyBmb2N1cyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhbGwgaW5wdXRzIGFuZCBjb250ZW50ZWRpdGFibGVcbiAgICovXG4gIHJlbW92ZUlucHV0RXZlbnRzKCkge1xuICAgIHRoaXMuaW5wdXRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuaGFuZGxlRm9jdXMpLCBjLmlzTmF0aXZlSW5wdXQoZSkgJiYgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5kaWRNdXRhdGVkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTGlzdGVuIGNvbW1vbiBlZGl0b3IgRG9tIENoYW5nZWQgZXZlbnQgYW5kIGRldGVjdCBtdXRhdGlvbnMgcmVsYXRlZCB0byB0aGUgIEJsb2NrXG4gICAqL1xuICB3YXRjaEJsb2NrTXV0YXRpb25zKCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMucmVkYWN0b3JEb21DaGFuZ2VkQ2FsbGJhY2sgPSAodCkgPT4ge1xuICAgICAgY29uc3QgeyBtdXRhdGlvbnM6IG8gfSA9IHQ7XG4gICAgICBvLnNvbWUoKG4pID0+IFF0KG4sIHRoaXMudG9vbFJlbmRlcmVkRWxlbWVudCkpICYmIHRoaXMuZGlkTXV0YXRlZChvKTtcbiAgICB9LCAoZSA9IHRoaXMuZWRpdG9yRXZlbnRCdXMpID09IG51bGwgfHwgZS5vbihBZSwgdGhpcy5yZWRhY3RvckRvbUNoYW5nZWRDYWxsYmFjayk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSByZWRhY3RvciBkb20gY2hhbmdlIGV2ZW50IGxpc3RlbmVyXG4gICAqL1xuICB1bndhdGNoQmxvY2tNdXRhdGlvbnMoKSB7XG4gICAgdmFyIGU7XG4gICAgKGUgPSB0aGlzLmVkaXRvckV2ZW50QnVzKSA9PSBudWxsIHx8IGUub2ZmKEFlLCB0aGlzLnJlZGFjdG9yRG9tQ2hhbmdlZENhbGxiYWNrKTtcbiAgfVxuICAvKipcbiAgICogU29tZXRpbWVzIFRvb2wgY2FuIHJlcGxhY2Ugb3duIG1haW4gZWxlbWVudCwgZm9yIGV4YW1wbGUgSDIgLT4gSDQgb3IgVUwgLT4gT0xcbiAgICogV2UgbmVlZCB0byBkZXRlY3Qgc3VjaCBjaGFuZ2VzIGFuZCB1cGRhdGUgYSBsaW5rIHRvIHRvb2xzIG1haW4gZWxlbWVudCB3aXRoIHRoZSBuZXcgb25lXG4gICAqXG4gICAqIEBwYXJhbSBtdXRhdGlvbnMgLSByZWNvcmRzIG9mIGJsb2NrIGNvbnRlbnQgbXV0YXRpb25zXG4gICAqL1xuICBkZXRlY3RUb29sUm9vdENoYW5nZShlKSB7XG4gICAgZS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBpZiAoQXJyYXkuZnJvbSh0LnJlbW92ZWROb2RlcykuaW5jbHVkZXModGhpcy50b29sUmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgICBjb25zdCBpID0gdC5hZGRlZE5vZGVzW3QuYWRkZWROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy50b29sUmVuZGVyZWRFbGVtZW50ID0gaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIGlucHV0cyBjYWNoZWQgdmFsdWVcbiAgICovXG4gIGRyb3BJbnB1dHNDYWNoZSgpIHtcbiAgICB0aGlzLmNhY2hlZElucHV0cyA9IFtdO1xuICB9XG59XG5jbGFzcyBvbyBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmluc2VydCA9IChlID0gdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrLCB0ID0ge30sIG8gPSB7fSwgaSwgbiwgciwgYSkgPT4ge1xuICAgICAgY29uc3QgbCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnQoe1xuICAgICAgICBpZDogYSxcbiAgICAgICAgdG9vbDogZSxcbiAgICAgICAgZGF0YTogdCxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIG5lZWRUb0ZvY3VzOiBuLFxuICAgICAgICByZXBsYWNlOiByXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgZWUobCk7XG4gICAgfSwgdGhpcy5jb21wb3NlQmxvY2tEYXRhID0gYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLmdldChlKTtcbiAgICAgIHJldHVybiBuZXcgUih7XG4gICAgICAgIHRvb2w6IHQsXG4gICAgICAgIGFwaTogdGhpcy5FZGl0b3IuQVBJLFxuICAgICAgICByZWFkT25seTogITAsXG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICB0dW5lc0RhdGE6IHt9XG4gICAgICB9KS5kYXRhO1xuICAgIH0sIHRoaXMudXBkYXRlID0gYXN5bmMgKGUsIHQpID0+IHtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBvIH0gPSB0aGlzLkVkaXRvciwgaSA9IG8uZ2V0QmxvY2tCeUlkKGUpO1xuICAgICAgaWYgKGkgPT09IHZvaWQgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayB3aXRoIGlkIFwiJHtlfVwiIG5vdCBmb3VuZGApO1xuICAgICAgY29uc3QgbiA9IGF3YWl0IG8udXBkYXRlKGksIHQpO1xuICAgICAgcmV0dXJuIG5ldyBlZShuKTtcbiAgICB9LCB0aGlzLmNvbnZlcnQgPSAoZSwgdCwgbykgPT4ge1xuICAgICAgdmFyIGgsIGY7XG4gICAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogaSwgVG9vbHM6IG4gfSA9IHRoaXMuRWRpdG9yLCByID0gaS5nZXRCbG9ja0J5SWQoZSk7XG4gICAgICBpZiAoIXIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgd2l0aCBpZCBcIiR7ZX1cIiBub3QgZm91bmRgKTtcbiAgICAgIGNvbnN0IGEgPSBuLmJsb2NrVG9vbHMuZ2V0KHIubmFtZSksIGwgPSBuLmJsb2NrVG9vbHMuZ2V0KHQpO1xuICAgICAgaWYgKCFsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2NrIFRvb2wgd2l0aCB0eXBlIFwiJHt0fVwiIG5vdCBmb3VuZGApO1xuICAgICAgY29uc3QgZCA9ICgoaCA9IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY29udmVyc2lvbkNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IGguZXhwb3J0KSAhPT0gdm9pZCAwLCB1ID0gKChmID0gbC5jb252ZXJzaW9uQ29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogZi5pbXBvcnQpICE9PSB2b2lkIDA7XG4gICAgICBpZiAoZCAmJiB1KVxuICAgICAgICBpLmNvbnZlcnQociwgdCwgbyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgeCA9IFtcbiAgICAgICAgICBkID8gITEgOiByZShyLm5hbWUpLFxuICAgICAgICAgIHUgPyAhMSA6IHJlKHQpXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgYW5kIFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJzaW9uIGZyb20gXCIke3IubmFtZX1cIiB0byBcIiR7dH1cIiBpcyBub3QgcG9zc2libGUuICR7eH0gdG9vbChzKSBzaG91bGQgcHJvdmlkZSBhIFwiY29udmVyc2lvbkNvbmZpZ1wiYCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pbnNlcnRNYW55ID0gKGUsIHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmxlbmd0aCAtIDEpID0+IHtcbiAgICAgIHRoaXMudmFsaWRhdGVJbmRleCh0KTtcbiAgICAgIGNvbnN0IG8gPSBlLm1hcCgoeyBpZDogaSwgdHlwZTogbiwgZGF0YTogciB9KSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY29tcG9zZUJsb2NrKHtcbiAgICAgICAgaWQ6IGksXG4gICAgICAgIHRvb2w6IG4gfHwgdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrLFxuICAgICAgICBkYXRhOiByXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmluc2VydE1hbnkobywgdCksIG8ubWFwKChpKSA9PiBuZXcgZWUoaSkpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja3N9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xlYXI6ICgpID0+IHRoaXMuY2xlYXIoKSxcbiAgICAgIHJlbmRlcjogKGUpID0+IHRoaXMucmVuZGVyKGUpLFxuICAgICAgcmVuZGVyRnJvbUhUTUw6IChlKSA9PiB0aGlzLnJlbmRlckZyb21IVE1MKGUpLFxuICAgICAgZGVsZXRlOiAoZSkgPT4gdGhpcy5kZWxldGUoZSksXG4gICAgICBzd2FwOiAoZSwgdCkgPT4gdGhpcy5zd2FwKGUsIHQpLFxuICAgICAgbW92ZTogKGUsIHQpID0+IHRoaXMubW92ZShlLCB0KSxcbiAgICAgIGdldEJsb2NrQnlJbmRleDogKGUpID0+IHRoaXMuZ2V0QmxvY2tCeUluZGV4KGUpLFxuICAgICAgZ2V0QnlJZDogKGUpID0+IHRoaXMuZ2V0QnlJZChlKSxcbiAgICAgIGdldEN1cnJlbnRCbG9ja0luZGV4OiAoKSA9PiB0aGlzLmdldEN1cnJlbnRCbG9ja0luZGV4KCksXG4gICAgICBnZXRCbG9ja0luZGV4OiAoZSkgPT4gdGhpcy5nZXRCbG9ja0luZGV4KGUpLFxuICAgICAgZ2V0QmxvY2tzQ291bnQ6ICgpID0+IHRoaXMuZ2V0QmxvY2tzQ291bnQoKSxcbiAgICAgIHN0cmV0Y2hCbG9jazogKGUsIHQgPSAhMCkgPT4gdGhpcy5zdHJldGNoQmxvY2soZSwgdCksXG4gICAgICBpbnNlcnROZXdCbG9jazogKCkgPT4gdGhpcy5pbnNlcnROZXdCbG9jaygpLFxuICAgICAgaW5zZXJ0OiB0aGlzLmluc2VydCxcbiAgICAgIGluc2VydE1hbnk6IHRoaXMuaW5zZXJ0TWFueSxcbiAgICAgIHVwZGF0ZTogdGhpcy51cGRhdGUsXG4gICAgICBjb21wb3NlQmxvY2tEYXRhOiB0aGlzLmNvbXBvc2VCbG9ja0RhdGEsXG4gICAgICBjb252ZXJ0OiB0aGlzLmNvbnZlcnRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrcyBjb3VudFxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QmxvY2tzQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5ibG9ja3MubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgYmxvY2sgaW5kZXhcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldEN1cnJlbnRCbG9ja0luZGV4KCkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIEJsb2NrIGJ5IGlkO1xuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBibG9jayBpZFxuICAgKi9cbiAgZ2V0QmxvY2tJbmRleChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SWQoZSk7XG4gICAgaWYgKCF0KSB7XG4gICAgICBZKFwiVGhlcmUgaXMgbm8gYmxvY2sgd2l0aCBpZCBgXCIgKyBlICsgXCJgXCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0luZGV4KHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrQVBJIG9iamVjdCBieSBCbG9jayBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCB0byBnZXRcbiAgICovXG4gIGdldEJsb2NrQnlJbmRleChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SW5kZXgoZSk7XG4gICAgaWYgKHQgPT09IHZvaWQgMCkge1xuICAgICAgWShcIlRoZXJlIGlzIG5vIGJsb2NrIGF0IGluZGV4IGBcIiArIGUgKyBcImBcIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGVlKHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrQVBJIG9iamVjdCBieSBCbG9jayBpZFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBpZCBvZiBibG9jayB0byBnZXRcbiAgICovXG4gIGdldEJ5SWQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUlkKGUpO1xuICAgIHJldHVybiB0ID09PSB2b2lkIDAgPyAoWShcIlRoZXJlIGlzIG5vIGJsb2NrIHdpdGggaWQgYFwiICsgZSArIFwiYFwiLCBcIndhcm5cIiksIG51bGwpIDogbmV3IGVlKHQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIEJsb2NrIE1hbmFnZXIgbWV0aG9kIHRoYXQgc3dhcCBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCAtIHBvc2l0aW9uIG9mIGZpcnN0IEJsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gcG9zaXRpb24gb2Ygc2Vjb25kIEJsb2NrXG4gICAqIEBkZXByZWNhdGVkIOKAlCB1c2UgJ21vdmUnIGluc3RlYWRcbiAgICovXG4gIHN3YXAoZSwgdCkge1xuICAgIFQoXG4gICAgICBcImBibG9ja3Muc3dhcCgpYCBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFVzZSBgYmxvY2subW92ZSgpYCBtZXRob2QgaW5zdGVhZFwiLFxuICAgICAgXCJpbmZvXCJcbiAgICApLCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuc3dhcChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogTW92ZSBibG9jayBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gaW5kZXggdG8gbW92ZSB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gaW5kZXggdG8gbW92ZSBmcm9tXG4gICAqL1xuICBtb3ZlKGUsIHQpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubW92ZShlLCB0KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tJbmRleCAtIGluZGV4IG9mIEJsb2NrIHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKGUgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SW5kZXgoZSk7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIucmVtb3ZlQmxvY2sodCk7XG4gICAgfSBjYXRjaCAodCkge1xuICAgICAgWSh0LCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5ibG9ja3MubGVuZ3RoID09PSAwICYmIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnQoKSwgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayAmJiB0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2ssIHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5FTkQpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIEVkaXRvcidzIGFyZWFcbiAgICovXG4gIGFzeW5jIGNsZWFyKCkge1xuICAgIGF3YWl0IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jbGVhcighMCksIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogRmlsbHMgRWRpdG9yIHdpdGggQmxvY2tzIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtPdXRwdXREYXRhfSBkYXRhIOKAlCBTYXZlZCBFZGl0b3IgZGF0YVxuICAgKi9cbiAgYXN5bmMgcmVuZGVyKGUpIHtcbiAgICBpZiAoZSA9PT0gdm9pZCAwIHx8IGUuYmxvY2tzID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3QgZGF0YSBwYXNzZWQgdG8gdGhlIHJlbmRlcigpIG1ldGhvZFwiKTtcbiAgICB0aGlzLkVkaXRvci5Nb2RpZmljYXRpb25zT2JzZXJ2ZXIuZGlzYWJsZSgpLCBhd2FpdCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY2xlYXIoKSwgYXdhaXQgdGhpcy5FZGl0b3IuUmVuZGVyZXIucmVuZGVyKGUuYmxvY2tzKSwgdGhpcy5FZGl0b3IuTW9kaWZpY2F0aW9uc09ic2VydmVyLmVuYWJsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGFzc2VkIEhUTUwgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gSFRNTCBzdHJpbmcgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgcmVuZGVyRnJvbUhUTUwoZSkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY2xlYXIoKSwgdGhpcy5FZGl0b3IuUGFzdGUucHJvY2Vzc1RleHQoZSwgITApO1xuICB9XG4gIC8qKlxuICAgKiBTdHJldGNoIEJsb2NrJ3MgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBCbG9jayB0byBzdHJldGNoXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdHVzIC0gdHJ1ZSB0byBlbmFibGUsIGZhbHNlIHRvIGRpc2FibGVcbiAgICogQGRlcHJlY2F0ZWQgVXNlIEJsb2NrQVBJIGludGVyZmFjZSB0byBzdHJldGNoIEJsb2Nrc1xuICAgKi9cbiAgc3RyZXRjaEJsb2NrKGUsIHQgPSAhMCkge1xuICAgIExlKFxuICAgICAgITAsXG4gICAgICBcImJsb2Nrcy5zdHJldGNoQmxvY2soKVwiLFxuICAgICAgXCJCbG9ja0FQSVwiXG4gICAgKTtcbiAgICBjb25zdCBvID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJbmRleChlKTtcbiAgICBvICYmIChvLnN0cmV0Y2hlZCA9IHQpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IEJsb2NrXG4gICAqIEFmdGVyIHNldCBjYXJldCB0byB0aGlzIEJsb2NrXG4gICAqXG4gICAqIEB0b2RvIHJlbW92ZSBpbiAzLjAuMFxuICAgKiBAZGVwcmVjYXRlZCB3aXRoIGluc2VydCgpIG1ldGhvZFxuICAgKi9cbiAgaW5zZXJ0TmV3QmxvY2soKSB7XG4gICAgVChcIk1ldGhvZCBibG9ja3MuaW5zZXJ0TmV3QmxvY2soKSBpcyBkZXByZWNhdGVkIGFuZCBpdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVXNlIGJsb2Nrcy5pbnNlcnQoKSBpbnN0ZWFkLlwiLCBcIndhcm5cIiksIHRoaXMuaW5zZXJ0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlZCBibG9jayBpbmRleCBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIGl0J3MgaW52YWxpZFxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXggLSBpbmRleCB0byB2YWxpZGF0ZVxuICAgKi9cbiAgdmFsaWRhdGVJbmRleChlKSB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwibnVtYmVyXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCBzaG91bGQgYmUgYSBudW1iZXJcIik7XG4gICAgaWYgKGUgPCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwXCIpO1xuICAgIGlmIChlID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwXCIpO1xuICB9XG59XG5jbGFzcyBpbyBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnNldFRvRmlyc3RCbG9jayA9IChlID0gdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkRFRkFVTFQsIHQgPSAwKSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZmlyc3RCbG9jayA/ICh0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5maXJzdEJsb2NrLCBlLCB0KSwgITApIDogITEsIHRoaXMuc2V0VG9MYXN0QmxvY2sgPSAoZSA9IHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5ERUZBVUxULCB0ID0gMCkgPT4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmxhc3RCbG9jayA/ICh0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5sYXN0QmxvY2ssIGUsIHQpLCAhMCkgOiAhMSwgdGhpcy5zZXRUb1ByZXZpb3VzQmxvY2sgPSAoZSA9IHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5ERUZBVUxULCB0ID0gMCkgPT4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLnByZXZpb3VzQmxvY2sgPyAodGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIucHJldmlvdXNCbG9jaywgZSwgdCksICEwKSA6ICExLCB0aGlzLnNldFRvTmV4dEJsb2NrID0gKGUgPSB0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuREVGQVVMVCwgdCA9IDApID0+IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5uZXh0QmxvY2sgPyAodGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubmV4dEJsb2NrLCBlLCB0KSwgITApIDogITEsIHRoaXMuc2V0VG9CbG9jayA9IChlLCB0ID0gdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkRFRkFVTFQsIG8gPSAwKSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzW2VdID8gKHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmJsb2Nrc1tlXSwgdCwgbyksICEwKSA6ICExLCB0aGlzLmZvY3VzID0gKGUgPSAhMSkgPT4gZSA/IHRoaXMuc2V0VG9MYXN0QmxvY2sodGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkVORCkgOiB0aGlzLnNldFRvRmlyc3RCbG9jayh0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuU1RBUlQpO1xuICB9XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7Q2FyZXR9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0VG9GaXJzdEJsb2NrOiB0aGlzLnNldFRvRmlyc3RCbG9jayxcbiAgICAgIHNldFRvTGFzdEJsb2NrOiB0aGlzLnNldFRvTGFzdEJsb2NrLFxuICAgICAgc2V0VG9QcmV2aW91c0Jsb2NrOiB0aGlzLnNldFRvUHJldmlvdXNCbG9jayxcbiAgICAgIHNldFRvTmV4dEJsb2NrOiB0aGlzLnNldFRvTmV4dEJsb2NrLFxuICAgICAgc2V0VG9CbG9jazogdGhpcy5zZXRUb0Jsb2NrLFxuICAgICAgZm9jdXM6IHRoaXMuZm9jdXNcbiAgICB9O1xuICB9XG59XG5jbGFzcyBubyBleHRlbmRzIHkge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge0V2ZW50c31cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbWl0OiAoZSwgdCkgPT4gdGhpcy5lbWl0KGUsIHQpLFxuICAgICAgb2ZmOiAoZSwgdCkgPT4gdGhpcy5vZmYoZSwgdCksXG4gICAgICBvbjogKGUsIHQpID0+IHRoaXMub24oZSwgdClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgb24gRXZlbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBldmVudCBuYW1lIHRvIHN1YnNjcmliZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIG9uKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIub24oZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXQgZXZlbnQgd2l0aCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBldmVudCB0byBlbWl0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZXZlbnQncyBkYXRhXG4gICAqL1xuICBlbWl0KGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIuZW1pdChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBFdmVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gZXZlbnQgdG8gdW5zdWJzY3JpYmVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBldmVudCBoYW5kbGVyXG4gICAqL1xuICBvZmYoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vZmYoZSwgdCk7XG4gIH1cbn1cbmNsYXNzIEhlIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBSZXR1cm4gbmFtZXNwYWNlIHNlY3Rpb24gZm9yIHRvb2wgb3IgYmxvY2sgdHVuZVxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIHRvb2wgb2JqZWN0XG4gICAqL1xuICBzdGF0aWMgZ2V0TmFtZXNwYWNlKGUpIHtcbiAgICByZXR1cm4gZS5pc1R1bmUoKSA/IGBibG9ja1R1bmVzLiR7ZS5uYW1lfWAgOiBgdG9vbHMuJHtlLm5hbWV9YDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIEkxOG4gQVBJIG1ldGhvZHMgd2l0aCBnbG9iYWwgZGljdGlvbmFyeSBhY2Nlc3NcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0OiAoKSA9PiB7XG4gICAgICAgIFkoXCJJMThuLnQoKSBtZXRob2QgY2FuIGJlIGFjY2Vzc2VkIG9ubHkgZnJvbSBUb29sc1wiLCBcIndhcm5cIik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIEkxOG4gQVBJIG1ldGhvZHMgd2l0aCB0b29sIG5hbWVzcGFjZWQgZGljdGlvbmFyeVxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIFRvb2wgb2JqZWN0XG4gICAqL1xuICBnZXRNZXRob2RzRm9yVG9vbChlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICB0aGlzLm1ldGhvZHMsXG4gICAgICB7XG4gICAgICAgIHQ6ICh0KSA9PiB6LnQoSGUuZ2V0TmFtZXNwYWNlKGUpLCB0KVxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIHNvIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBFZGl0b3IuanMgQ29yZSBBUEkgbW9kdWxlc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrczogdGhpcy5FZGl0b3IuQmxvY2tzQVBJLm1ldGhvZHMsXG4gICAgICBjYXJldDogdGhpcy5FZGl0b3IuQ2FyZXRBUEkubWV0aG9kcyxcbiAgICAgIGV2ZW50czogdGhpcy5FZGl0b3IuRXZlbnRzQVBJLm1ldGhvZHMsXG4gICAgICBsaXN0ZW5lcnM6IHRoaXMuRWRpdG9yLkxpc3RlbmVyc0FQSS5tZXRob2RzLFxuICAgICAgbm90aWZpZXI6IHRoaXMuRWRpdG9yLk5vdGlmaWVyQVBJLm1ldGhvZHMsXG4gICAgICBzYW5pdGl6ZXI6IHRoaXMuRWRpdG9yLlNhbml0aXplckFQSS5tZXRob2RzLFxuICAgICAgc2F2ZXI6IHRoaXMuRWRpdG9yLlNhdmVyQVBJLm1ldGhvZHMsXG4gICAgICBzZWxlY3Rpb246IHRoaXMuRWRpdG9yLlNlbGVjdGlvbkFQSS5tZXRob2RzLFxuICAgICAgc3R5bGVzOiB0aGlzLkVkaXRvci5TdHlsZXNBUEkuY2xhc3NlcyxcbiAgICAgIHRvb2xiYXI6IHRoaXMuRWRpdG9yLlRvb2xiYXJBUEkubWV0aG9kcyxcbiAgICAgIGlubGluZVRvb2xiYXI6IHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXJBUEkubWV0aG9kcyxcbiAgICAgIHRvb2x0aXA6IHRoaXMuRWRpdG9yLlRvb2x0aXBBUEkubWV0aG9kcyxcbiAgICAgIGkxOG46IHRoaXMuRWRpdG9yLkkxOG5BUEkubWV0aG9kcyxcbiAgICAgIHJlYWRPbmx5OiB0aGlzLkVkaXRvci5SZWFkT25seUFQSS5tZXRob2RzLFxuICAgICAgdWk6IHRoaXMuRWRpdG9yLlVpQVBJLm1ldGhvZHNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEVkaXRvci5qcyBDb3JlIEFQSSBtZXRob2RzIGZvciBwYXNzZWQgdG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIHRvb2wgb2JqZWN0XG4gICAqL1xuICBnZXRNZXRob2RzRm9yVG9vbChlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICB0aGlzLm1ldGhvZHMsXG4gICAgICB7XG4gICAgICAgIGkxOG46IHRoaXMuRWRpdG9yLkkxOG5BUEkuZ2V0TWV0aG9kc0ZvclRvb2woZSlcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5jbGFzcyBybyBleHRlbmRzIHkge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge0lubGluZVRvb2xiYXJ9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2U6ICgpID0+IHRoaXMuY2xvc2UoKSxcbiAgICAgIG9wZW46ICgpID0+IHRoaXMub3BlbigpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT3BlbiBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgb3BlbigpIHtcbiAgICB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLnRyeVRvU2hvdygpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICB9XG59XG5jbGFzcyBhbyBleHRlbmRzIHkge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge0xpc3RlbmVyc31cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbjogKGUsIHQsIG8sIGkpID0+IHRoaXMub24oZSwgdCwgbywgaSksXG4gICAgICBvZmY6IChlLCB0LCBvLCBpKSA9PiB0aGlzLm9mZihlLCB0LCBvLCBpKSxcbiAgICAgIG9mZkJ5SWQ6IChlKSA9PiB0aGlzLm9mZkJ5SWQoZSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBZHMgYSBET00gZXZlbnQgbGlzdGVuZXIuIFJldHVybiBpdCdzIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBzZXQgaGFuZGxlciB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0geygpID0+IHZvaWR9IGhhbmRsZXIgLSBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ2FwdHVyZSAtIGNhcHR1cmUgZXZlbnQgb3Igbm90XG4gICAqL1xuICBvbihlLCB0LCBvLCBpKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLm9uKGUsIHQsIG8sIGkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lciBmcm9tIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byByZW1vdmUgaGFuZGxlciBmcm9tXG4gICAqIEBwYXJhbSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSBoYW5kbGVyIC0gZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUNhcHR1cmUgLSBjYXB0dXJlIGV2ZW50IG9yIG5vdFxuICAgKi9cbiAgb2ZmKGUsIHQsIG8sIGkpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vZmYoZSwgdCwgbywgaSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVyIGJ5IHRoZSBsaXN0ZW5lciBpZFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBpZCBvZiB0aGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqL1xuICBvZmZCeUlkKGUpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vZmZCeUlkKGUpO1xuICB9XG59XG52YXIgX2UgPSB7fSwgbG8gPSB7XG4gIGdldCBleHBvcnRzKCkge1xuICAgIHJldHVybiBfZTtcbiAgfSxcbiAgc2V0IGV4cG9ydHMocykge1xuICAgIF9lID0gcztcbiAgfVxufTtcbihmdW5jdGlvbihzLCBlKSB7XG4gIChmdW5jdGlvbih0LCBvKSB7XG4gICAgcy5leHBvcnRzID0gbygpO1xuICB9KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgZnVuY3Rpb24gaShuKSB7XG4gICAgICAgIGlmIChvW25dKVxuICAgICAgICAgIHJldHVybiBvW25dLmV4cG9ydHM7XG4gICAgICAgIHZhciByID0gb1tuXSA9IHsgaTogbiwgbDogITEsIGV4cG9ydHM6IHt9IH07XG4gICAgICAgIHJldHVybiB0W25dLmNhbGwoci5leHBvcnRzLCByLCByLmV4cG9ydHMsIGkpLCByLmwgPSAhMCwgci5leHBvcnRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGkubSA9IHQsIGkuYyA9IG8sIGkuZCA9IGZ1bmN0aW9uKG4sIHIsIGEpIHtcbiAgICAgICAgaS5vKG4sIHIpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCByLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGEgfSk7XG4gICAgICB9LCBpLnIgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgICAgIH0sIGkudCA9IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgICAgaWYgKDEgJiByICYmIChuID0gaShuKSksIDggJiByIHx8IDQgJiByICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCIgJiYgbiAmJiBuLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIHZhciBhID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGlmIChpLnIoYSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgdmFsdWU6IG4gfSksIDIgJiByICYmIHR5cGVvZiBuICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgZm9yICh2YXIgbCBpbiBuKVxuICAgICAgICAgICAgaS5kKGEsIGwsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5bZF07XG4gICAgICAgICAgICB9LmJpbmQobnVsbCwgbCkpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sIGkubiA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIHIgPSBuICYmIG4uX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuLmRlZmF1bHQ7XG4gICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGkuZChyLCBcImFcIiwgciksIHI7XG4gICAgICB9LCBpLm8gPSBmdW5jdGlvbihuLCByKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcik7XG4gICAgICB9LCBpLnAgPSBcIi9cIiwgaShpLnMgPSAwKTtcbiAgICB9KFtmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICBpKDEpLCAvKiFcbiAgICAgICAqIENvZGV4IEphdmFTY3JpcHQgTm90aWZpY2F0aW9uIG1vZHVsZVxuICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2NvZGV4LXRlYW0vanMtbm90aWZpZXJcbiAgICAgICAqL1xuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuID0gaSg2KSwgciA9IFwiY2R4LW5vdGlmeS0tYm91bmNlLWluXCIsIGEgPSBudWxsO1xuICAgICAgICByZXR1cm4geyBzaG93OiBmdW5jdGlvbihsKSB7XG4gICAgICAgICAgaWYgKGwubWVzc2FnZSkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgIGEgPSBuLmdldFdyYXBwZXIoKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB2YXIgZCA9IG51bGwsIHUgPSBsLnRpbWUgfHwgOGUzO1xuICAgICAgICAgICAgc3dpdGNoIChsLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNvbmZpcm1cIjpcbiAgICAgICAgICAgICAgICBkID0gbi5jb25maXJtKGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicHJvbXB0XCI6XG4gICAgICAgICAgICAgICAgZCA9IG4ucHJvbXB0KGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGQgPSBuLmFsZXJ0KGwpLCB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfSwgdSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLmFwcGVuZENoaWxkKGQpLCBkLmNsYXNzTGlzdC5hZGQocik7XG4gICAgICAgICAgfVxuICAgICAgICB9IH07XG4gICAgICB9KCk7XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgdmFyIG4gPSBpKDIpO1xuICAgICAgdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiAmJiAobiA9IFtbdC5pLCBuLCBcIlwiXV0pO1xuICAgICAgdmFyIHIgPSB7IGhtcjogITAsIHRyYW5zZm9ybTogdm9pZCAwLCBpbnNlcnRJbnRvOiB2b2lkIDAgfTtcbiAgICAgIGkoNCkobiwgciksIG4ubG9jYWxzICYmICh0LmV4cG9ydHMgPSBuLmxvY2Fscyk7XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgKHQuZXhwb3J0cyA9IGkoMykoITEpKS5wdXNoKFt0LmksIGAuY2R4LW5vdGlmeS0tZXJyb3J7YmFja2dyb3VuZDojZmZmYmZiIWltcG9ydGFudH0uY2R4LW5vdGlmeS0tZXJyb3I6OmJlZm9yZXtiYWNrZ3JvdW5kOiNmYjVkNWQhaW1wb3J0YW50fS5jZHgtbm90aWZ5X19pbnB1dHttYXgtd2lkdGg6MTMwcHg7cGFkZGluZzo1cHggMTBweDtiYWNrZ3JvdW5kOiNmN2Y3Zjc7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czozcHg7Zm9udC1zaXplOjEzcHg7Y29sb3I6IzY1NmI3YztvdXRsaW5lOjB9LmNkeC1ub3RpZnlfX2lucHV0Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojNjU2YjdjfS5jZHgtbm90aWZ5X19pbnB1dDo6cGxhY2Vob2xkZXJ7Y29sb3I6IzY1NmI3Y30uY2R4LW5vdGlmeV9faW5wdXQ6Zm9jdXM6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOnJnYmEoMTAxLDEwNywxMjQsLjMpfS5jZHgtbm90aWZ5X19pbnB1dDpmb2N1czo6cGxhY2Vob2xkZXJ7Y29sb3I6cmdiYSgxMDEsMTA3LDEyNCwuMyl9LmNkeC1ub3RpZnlfX2J1dHRvbntib3JkZXI6bm9uZTtib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6MTNweDtwYWRkaW5nOjVweCAxMHB4O2N1cnNvcjpwb2ludGVyfS5jZHgtbm90aWZ5X19idXR0b246bGFzdC1jaGlsZHttYXJnaW4tbGVmdDoxMHB4fS5jZHgtbm90aWZ5X19idXR0b24tLWNhbmNlbHtiYWNrZ3JvdW5kOiNmMmY1Zjc7Ym94LXNoYWRvdzowIDJweCAxcHggMCByZ2JhKDE2LDE5LDI5LDApO2NvbG9yOiM2NTZiN2N9LmNkeC1ub3RpZnlfX2J1dHRvbi0tY2FuY2VsOmhvdmVye2JhY2tncm91bmQ6I2VlZX0uY2R4LW5vdGlmeV9fYnV0dG9uLS1jb25maXJte2JhY2tncm91bmQ6IzM0Yzk5Mjtib3gtc2hhZG93OjAgMXB4IDFweCAwIHJnYmEoMTgsNDksMzUsLjA1KTtjb2xvcjojZmZmfS5jZHgtbm90aWZ5X19idXR0b24tLWNvbmZpcm06aG92ZXJ7YmFja2dyb3VuZDojMzNiMDgyfS5jZHgtbm90aWZ5X19idG5zLXdyYXBwZXJ7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXgtZmxvdzpyb3cgbm93cmFwO2ZsZXgtZmxvdzpyb3cgbm93cmFwO21hcmdpbi10b3A6NXB4fS5jZHgtbm90aWZ5X19jcm9zc3twb3NpdGlvbjphYnNvbHV0ZTt0b3A6NXB4O3JpZ2h0OjVweDt3aWR0aDoxMHB4O2hlaWdodDoxMHB4O3BhZGRpbmc6NXB4O29wYWNpdHk6LjU0O2N1cnNvcjpwb2ludGVyfS5jZHgtbm90aWZ5X19jcm9zczo6YWZ0ZXIsLmNkeC1ub3RpZnlfX2Nyb3NzOjpiZWZvcmV7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjlweDt0b3A6NXB4O2hlaWdodDoxMnB4O3dpZHRoOjJweDtiYWNrZ3JvdW5kOiM1NzVkNjd9LmNkeC1ub3RpZnlfX2Nyb3NzOjpiZWZvcmV7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfS5jZHgtbm90aWZ5X19jcm9zczo6YWZ0ZXJ7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9LmNkeC1ub3RpZnlfX2Nyb3NzOmhvdmVye29wYWNpdHk6MX0uY2R4LW5vdGlmaWVze3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6Mjtib3R0b206MjBweDtsZWZ0OjIwcHg7Zm9udC1mYW1pbHk6LWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsXCJTZWdvZSBVSVwiLFJvYm90byxPeHlnZW4sVWJ1bnR1LENhbnRhcmVsbCxcIkZpcmEgU2Fuc1wiLFwiRHJvaWQgU2Fuc1wiLFwiSGVsdmV0aWNhIE5ldWVcIixzYW5zLXNlcmlmfS5jZHgtbm90aWZ5e3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjIyMHB4O21hcmdpbi10b3A6MTVweDtwYWRkaW5nOjEzcHggMTZweDtiYWNrZ3JvdW5kOiNmZmY7Ym94LXNoYWRvdzowIDExcHggMTdweCAwIHJnYmEoMjMsMzIsNjEsLjEzKTtib3JkZXItcmFkaXVzOjVweDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoxLjRlbTt3b3JkLXdyYXA6YnJlYWstd29yZH0uY2R4LW5vdGlmeTo6YmVmb3Jle2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jazt0b3A6MDtsZWZ0OjA7d2lkdGg6M3B4O2hlaWdodDpjYWxjKDEwMCUgLSA2cHgpO21hcmdpbjozcHg7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDowIDB9QGtleWZyYW1lcyBib3VuY2VJbnswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlKC4zKX01MCV7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZSgxLjA1KX03MCV7dHJhbnNmb3JtOnNjYWxlKC45KX0xMDAle3RyYW5zZm9ybTpzY2FsZSgxKX19LmNkeC1ub3RpZnktLWJvdW5jZS1pbnthbmltYXRpb24tbmFtZTpib3VuY2VJbjthbmltYXRpb24tZHVyYXRpb246LjZzO2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6MX0uY2R4LW5vdGlmeS0tc3VjY2Vzc3tiYWNrZ3JvdW5kOiNmYWZmZmUhaW1wb3J0YW50fS5jZHgtbm90aWZ5LS1zdWNjZXNzOjpiZWZvcmV7YmFja2dyb3VuZDojNDFmZmIxIWltcG9ydGFudH1gLCBcIlwiXSk7XG4gICAgfSwgZnVuY3Rpb24odCwgbykge1xuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgbiA9IFtdO1xuICAgICAgICByZXR1cm4gbi50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uKGwsIGQpIHtcbiAgICAgICAgICAgICAgdmFyIHUgPSBsWzFdIHx8IFwiXCIsIGggPSBsWzNdO1xuICAgICAgICAgICAgICBpZiAoIWgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgICAgICAgIGlmIChkICYmIHR5cGVvZiBidG9hID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBmID0gKHAgPSBoLCBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHApKSkpICsgXCIgKi9cIiksIHggPSBoLnNvdXJjZXMubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIgKyBoLnNvdXJjZVJvb3QgKyBtICsgXCIgKi9cIjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VdLmNvbmNhdCh4KS5jb25jYXQoW2ZdKS5qb2luKGBcbmApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgICByZXR1cm4gW3VdLmpvaW4oYFxuYCk7XG4gICAgICAgICAgICB9KHIsIGkpO1xuICAgICAgICAgICAgcmV0dXJuIHJbMl0gPyBcIkBtZWRpYSBcIiArIHJbMl0gKyBcIntcIiArIGEgKyBcIn1cIiA6IGE7XG4gICAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgfSwgbi5pID0gZnVuY3Rpb24ociwgYSkge1xuICAgICAgICAgIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgKHIgPSBbW251bGwsIHIsIFwiXCJdXSk7XG4gICAgICAgICAgZm9yICh2YXIgbCA9IHt9LCBkID0gMDsgZCA8IHRoaXMubGVuZ3RoOyBkKyspIHtcbiAgICAgICAgICAgIHZhciB1ID0gdGhpc1tkXVswXTtcbiAgICAgICAgICAgIHR5cGVvZiB1ID09IFwibnVtYmVyXCIgJiYgKGxbdV0gPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoZCA9IDA7IGQgPCByLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgICAgICB2YXIgaCA9IHJbZF07XG4gICAgICAgICAgICB0eXBlb2YgaFswXSA9PSBcIm51bWJlclwiICYmIGxbaFswXV0gfHwgKGEgJiYgIWhbMl0gPyBoWzJdID0gYSA6IGEgJiYgKGhbMl0gPSBcIihcIiArIGhbMl0gKyBcIikgYW5kIChcIiArIGEgKyBcIilcIiksIG4ucHVzaChoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBuO1xuICAgICAgfTtcbiAgICB9LCBmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICB2YXIgbiwgciwgYSA9IHt9LCBsID0gKG4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByID09PSB2b2lkIDAgJiYgKHIgPSBuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCByO1xuICAgICAgfSksIGQgPSBmdW5jdGlvbihrKSB7XG4gICAgICAgIHZhciBnID0ge307XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih3KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHJldHVybiB3KCk7XG4gICAgICAgICAgaWYgKGdbd10gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdmFyIEUgPSBmdW5jdGlvbihJKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKEkpO1xuICAgICAgICAgICAgfS5jYWxsKHRoaXMsIHcpO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBFIGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEUgPSBFLmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICBFID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ1t3XSA9IEU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnW3ddO1xuICAgICAgICB9O1xuICAgICAgfSgpLCB1ID0gbnVsbCwgaCA9IDAsIGYgPSBbXSwgeCA9IGkoNSk7XG4gICAgICBmdW5jdGlvbiBwKGssIGcpIHtcbiAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCBrLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgdmFyIEUgPSBrW3ddLCBJID0gYVtFLmlkXTtcbiAgICAgICAgICBpZiAoSSkge1xuICAgICAgICAgICAgSS5yZWZzKys7XG4gICAgICAgICAgICBmb3IgKHZhciBDID0gMDsgQyA8IEkucGFydHMubGVuZ3RoOyBDKyspXG4gICAgICAgICAgICAgIEkucGFydHNbQ10oRS5wYXJ0c1tDXSk7XG4gICAgICAgICAgICBmb3IgKDsgQyA8IEUucGFydHMubGVuZ3RoOyBDKyspXG4gICAgICAgICAgICAgIEkucGFydHMucHVzaChIKEUucGFydHNbQ10sIGcpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIE8gPSBbXTtcbiAgICAgICAgICAgIGZvciAoQyA9IDA7IEMgPCBFLnBhcnRzLmxlbmd0aDsgQysrKVxuICAgICAgICAgICAgICBPLnB1c2goSChFLnBhcnRzW0NdLCBnKSk7XG4gICAgICAgICAgICBhW0UuaWRdID0geyBpZDogRS5pZCwgcmVmczogMSwgcGFydHM6IE8gfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG0oaywgZykge1xuICAgICAgICBmb3IgKHZhciB3ID0gW10sIEUgPSB7fSwgSSA9IDA7IEkgPCBrLmxlbmd0aDsgSSsrKSB7XG4gICAgICAgICAgdmFyIEMgPSBrW0ldLCBPID0gZy5iYXNlID8gQ1swXSArIGcuYmFzZSA6IENbMF0sIEIgPSB7IGNzczogQ1sxXSwgbWVkaWE6IENbMl0sIHNvdXJjZU1hcDogQ1szXSB9O1xuICAgICAgICAgIEVbT10gPyBFW09dLnBhcnRzLnB1c2goQikgOiB3LnB1c2goRVtPXSA9IHsgaWQ6IE8sIHBhcnRzOiBbQl0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHc7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBMKGssIGcpIHtcbiAgICAgICAgdmFyIHcgPSBkKGsuaW5zZXJ0SW50byk7XG4gICAgICAgIGlmICghdylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgdmFyIEUgPSBmW2YubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChrLmluc2VydEF0ID09PSBcInRvcFwiKVxuICAgICAgICAgIEUgPyBFLm5leHRTaWJsaW5nID8gdy5pbnNlcnRCZWZvcmUoZywgRS5uZXh0U2libGluZykgOiB3LmFwcGVuZENoaWxkKGcpIDogdy5pbnNlcnRCZWZvcmUoZywgdy5maXJzdENoaWxkKSwgZi5wdXNoKGcpO1xuICAgICAgICBlbHNlIGlmIChrLmluc2VydEF0ID09PSBcImJvdHRvbVwiKVxuICAgICAgICAgIHcuYXBwZW5kQ2hpbGQoZyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2Ygay5pbnNlcnRBdCAhPSBcIm9iamVjdFwiIHx8ICFrLmluc2VydEF0LmJlZm9yZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW1N0eWxlIExvYWRlcl1cblxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxuYCk7XG4gICAgICAgICAgdmFyIEkgPSBkKGsuaW5zZXJ0SW50byArIFwiIFwiICsgay5pbnNlcnRBdC5iZWZvcmUpO1xuICAgICAgICAgIHcuaW5zZXJ0QmVmb3JlKGcsIEkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBBKGspIHtcbiAgICAgICAgaWYgKGsucGFyZW50Tm9kZSA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChrKTtcbiAgICAgICAgdmFyIGcgPSBmLmluZGV4T2Yoayk7XG4gICAgICAgIGcgPj0gMCAmJiBmLnNwbGljZShnLCAxKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFMoaykge1xuICAgICAgICB2YXIgZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgcmV0dXJuIGsuYXR0cnMudHlwZSA9PT0gdm9pZCAwICYmIChrLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCIpLCBaKGcsIGsuYXR0cnMpLCBMKGssIGcpLCBnO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gWihrLCBnKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGcpLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgICAgIGsuc2V0QXR0cmlidXRlKHcsIGdbd10pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEgoaywgZykge1xuICAgICAgICB2YXIgdywgRSwgSSwgQztcbiAgICAgICAgaWYgKGcudHJhbnNmb3JtICYmIGsuY3NzKSB7XG4gICAgICAgICAgaWYgKCEoQyA9IGcudHJhbnNmb3JtKGsuY3NzKSkpXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGsuY3NzID0gQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZy5zaW5nbGV0b24pIHtcbiAgICAgICAgICB2YXIgTyA9IGgrKztcbiAgICAgICAgICB3ID0gdSB8fCAodSA9IFMoZykpLCBFID0gY2UuYmluZChudWxsLCB3LCBPLCAhMSksIEkgPSBjZS5iaW5kKG51bGwsIHcsIE8sICEwKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgay5zb3VyY2VNYXAgJiYgdHlwZW9mIFVSTCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgQmxvYiA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGJ0b2EgPT0gXCJmdW5jdGlvblwiID8gKHcgPSBmdW5jdGlvbihCKSB7XG4gICAgICAgICAgICB2YXIgaiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgICAgICAgcmV0dXJuIEIuYXR0cnMudHlwZSA9PT0gdm9pZCAwICYmIChCLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCIpLCBCLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiLCBaKGosIEIuYXR0cnMpLCBMKEIsIGopLCBqO1xuICAgICAgICAgIH0oZyksIEUgPSBmdW5jdGlvbihCLCBqLCBkZSkge1xuICAgICAgICAgICAgdmFyIFEgPSBkZS5jc3MsIENlID0gZGUuc291cmNlTWFwLCBPdCA9IGouY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB2b2lkIDAgJiYgQ2U7XG4gICAgICAgICAgICAoai5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgT3QpICYmIChRID0geChRKSksIENlICYmIChRICs9IGBcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsYCArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KENlKSkpKSArIFwiICovXCIpO1xuICAgICAgICAgICAgdmFyIE50ID0gbmV3IEJsb2IoW1FdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KSwgR2UgPSBCLmhyZWY7XG4gICAgICAgICAgICBCLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKE50KSwgR2UgJiYgVVJMLnJldm9rZU9iamVjdFVSTChHZSk7XG4gICAgICAgICAgfS5iaW5kKG51bGwsIHcsIGcpLCBJID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBBKHcpLCB3LmhyZWYgJiYgVVJMLnJldm9rZU9iamVjdFVSTCh3LmhyZWYpO1xuICAgICAgICAgIH0pIDogKHcgPSBTKGcpLCBFID0gZnVuY3Rpb24oQiwgaikge1xuICAgICAgICAgICAgdmFyIGRlID0gai5jc3MsIFEgPSBqLm1lZGlhO1xuICAgICAgICAgICAgaWYgKFEgJiYgQi5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBRKSwgQi5zdHlsZVNoZWV0KVxuICAgICAgICAgICAgICBCLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGRlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAoOyBCLmZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICAgICAgICBCLnJlbW92ZUNoaWxkKEIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgIEIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LmJpbmQobnVsbCwgdyksIEkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEEodyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBFKGspLCBmdW5jdGlvbihCKSB7XG4gICAgICAgICAgaWYgKEIpIHtcbiAgICAgICAgICAgIGlmIChCLmNzcyA9PT0gay5jc3MgJiYgQi5tZWRpYSA9PT0gay5tZWRpYSAmJiBCLnNvdXJjZU1hcCA9PT0gay5zb3VyY2VNYXApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIEUoayA9IEIpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgSSgpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oaywgZykge1xuICAgICAgICBpZiAodHlwZW9mIERFQlVHIDwgXCJ1XCIgJiYgREVCVUcgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICAgICAgICAoZyA9IGcgfHwge30pLmF0dHJzID0gdHlwZW9mIGcuYXR0cnMgPT0gXCJvYmplY3RcIiA/IGcuYXR0cnMgOiB7fSwgZy5zaW5nbGV0b24gfHwgdHlwZW9mIGcuc2luZ2xldG9uID09IFwiYm9vbGVhblwiIHx8IChnLnNpbmdsZXRvbiA9IGwoKSksIGcuaW5zZXJ0SW50byB8fCAoZy5pbnNlcnRJbnRvID0gXCJoZWFkXCIpLCBnLmluc2VydEF0IHx8IChnLmluc2VydEF0ID0gXCJib3R0b21cIik7XG4gICAgICAgIHZhciB3ID0gbShrLCBnKTtcbiAgICAgICAgcmV0dXJuIHAodywgZyksIGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgICBmb3IgKHZhciBJID0gW10sIEMgPSAwOyBDIDwgdy5sZW5ndGg7IEMrKykge1xuICAgICAgICAgICAgdmFyIE8gPSB3W0NdO1xuICAgICAgICAgICAgKEIgPSBhW08uaWRdKS5yZWZzLS0sIEkucHVzaChCKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChFICYmIHAobShFLCBnKSwgZyksIEMgPSAwOyBDIDwgSS5sZW5ndGg7IEMrKykge1xuICAgICAgICAgICAgdmFyIEI7XG4gICAgICAgICAgICBpZiAoKEIgPSBJW0NdKS5yZWZzID09PSAwKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgQi5wYXJ0cy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBCLnBhcnRzW2pdKCk7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhW0IuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB2YXIgVSwgSiA9IChVID0gW10sIGZ1bmN0aW9uKGssIGcpIHtcbiAgICAgICAgcmV0dXJuIFVba10gPSBnLCBVLmZpbHRlcihCb29sZWFuKS5qb2luKGBcbmApO1xuICAgICAgfSk7XG4gICAgICBmdW5jdGlvbiBjZShrLCBnLCB3LCBFKSB7XG4gICAgICAgIHZhciBJID0gdyA/IFwiXCIgOiBFLmNzcztcbiAgICAgICAgaWYgKGsuc3R5bGVTaGVldClcbiAgICAgICAgICBrLnN0eWxlU2hlZXQuY3NzVGV4dCA9IEooZywgSSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBDID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoSSksIE8gPSBrLmNoaWxkTm9kZXM7XG4gICAgICAgICAgT1tnXSAmJiBrLnJlbW92ZUNoaWxkKE9bZ10pLCBPLmxlbmd0aCA/IGsuaW5zZXJ0QmVmb3JlKEMsIE9bZ10pIDogay5hcHBlbmRDaGlsZChDKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKHQsIG8pIHtcbiAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdmFyIG4gPSB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93LmxvY2F0aW9uO1xuICAgICAgICBpZiAoIW4pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gICAgICAgIGlmICghaSB8fCB0eXBlb2YgaSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB2YXIgciA9IG4ucHJvdG9jb2wgKyBcIi8vXCIgKyBuLmhvc3QsIGEgPSByICsgbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcbiAgICAgICAgcmV0dXJuIGkucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGwsIGQpIHtcbiAgICAgICAgICB2YXIgdSwgaCA9IGQudHJpbSgpLnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihmLCB4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICB9KS5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKGYsIHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiAvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KGgpID8gbCA6ICh1ID0gaC5pbmRleE9mKFwiLy9cIikgPT09IDAgPyBoIDogaC5pbmRleE9mKFwiL1wiKSA9PT0gMCA/IHIgKyBoIDogYSArIGgucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpLCBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KHUpICsgXCIpXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgdmFyIG4sIHIsIGEsIGwsIGQsIHUsIGgsIGYsIHg7XG4gICAgICB0LmV4cG9ydHMgPSAobiA9IFwiY2R4LW5vdGlmaWVzXCIsIHIgPSBcImNkeC1ub3RpZnlcIiwgYSA9IFwiY2R4LW5vdGlmeV9fY3Jvc3NcIiwgbCA9IFwiY2R4LW5vdGlmeV9fYnV0dG9uLS1jb25maXJtXCIsIGQgPSBcImNkeC1ub3RpZnlfX2J1dHRvbi0tY2FuY2VsXCIsIHUgPSBcImNkeC1ub3RpZnlfX2lucHV0XCIsIGggPSBcImNkeC1ub3RpZnlfX2J1dHRvblwiLCBmID0gXCJjZHgtbm90aWZ5X19idG5zLXdyYXBwZXJcIiwgeyBhbGVydDogeCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmFyIG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpLCBMID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKSwgQSA9IHAubWVzc2FnZSwgUyA9IHAuc3R5bGU7XG4gICAgICAgIHJldHVybiBtLmNsYXNzTGlzdC5hZGQociksIFMgJiYgbS5jbGFzc0xpc3QuYWRkKHIgKyBcIi0tXCIgKyBTKSwgbS5pbm5lckhUTUwgPSBBLCBMLmNsYXNzTGlzdC5hZGQoYSksIEwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG0ucmVtb3ZlLmJpbmQobSkpLCBtLmFwcGVuZENoaWxkKEwpLCBtO1xuICAgICAgfSwgY29uZmlybTogZnVuY3Rpb24ocCkge1xuICAgICAgICB2YXIgbSA9IHgocCksIEwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBBID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSwgUyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIFogPSBtLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBhKSwgSCA9IHAuY2FuY2VsSGFuZGxlciwgVSA9IHAub2tIYW5kbGVyO1xuICAgICAgICByZXR1cm4gTC5jbGFzc0xpc3QuYWRkKGYpLCBBLmlubmVySFRNTCA9IHAub2tUZXh0IHx8IFwiQ29uZmlybVwiLCBTLmlubmVySFRNTCA9IHAuY2FuY2VsVGV4dCB8fCBcIkNhbmNlbFwiLCBBLmNsYXNzTGlzdC5hZGQoaCksIFMuY2xhc3NMaXN0LmFkZChoKSwgQS5jbGFzc0xpc3QuYWRkKGwpLCBTLmNsYXNzTGlzdC5hZGQoZCksIEggJiYgdHlwZW9mIEggPT0gXCJmdW5jdGlvblwiICYmIChTLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBIKSwgWi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgSCkpLCBVICYmIHR5cGVvZiBVID09IFwiZnVuY3Rpb25cIiAmJiBBLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBVKSwgQS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgbS5yZW1vdmUuYmluZChtKSksIFMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG0ucmVtb3ZlLmJpbmQobSkpLCBMLmFwcGVuZENoaWxkKEEpLCBMLmFwcGVuZENoaWxkKFMpLCBtLmFwcGVuZENoaWxkKEwpLCBtO1xuICAgICAgfSwgcHJvbXB0OiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHZhciBtID0geChwKSwgTCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIEEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCBTID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLCBaID0gbS5xdWVyeVNlbGVjdG9yKFwiLlwiICsgYSksIEggPSBwLmNhbmNlbEhhbmRsZXIsIFUgPSBwLm9rSGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIEwuY2xhc3NMaXN0LmFkZChmKSwgQS5pbm5lckhUTUwgPSBwLm9rVGV4dCB8fCBcIk9rXCIsIEEuY2xhc3NMaXN0LmFkZChoKSwgQS5jbGFzc0xpc3QuYWRkKGwpLCBTLmNsYXNzTGlzdC5hZGQodSksIHAucGxhY2Vob2xkZXIgJiYgUy5zZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiLCBwLnBsYWNlaG9sZGVyKSwgcC5kZWZhdWx0ICYmIChTLnZhbHVlID0gcC5kZWZhdWx0KSwgcC5pbnB1dFR5cGUgJiYgKFMudHlwZSA9IHAuaW5wdXRUeXBlKSwgSCAmJiB0eXBlb2YgSCA9PSBcImZ1bmN0aW9uXCIgJiYgWi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgSCksIFUgJiYgdHlwZW9mIFUgPT0gXCJmdW5jdGlvblwiICYmIEEuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFUoUy52YWx1ZSk7XG4gICAgICAgIH0pLCBBLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBtLnJlbW92ZS5iaW5kKG0pKSwgTC5hcHBlbmRDaGlsZChTKSwgTC5hcHBlbmRDaGlsZChBKSwgbS5hcHBlbmRDaGlsZChMKSwgbTtcbiAgICAgIH0sIGdldFdyYXBwZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gICAgICAgIHJldHVybiBwLmNsYXNzTGlzdC5hZGQobiksIHA7XG4gICAgICB9IH0pO1xuICAgIH1dKTtcbiAgfSk7XG59KShsbyk7XG5jb25zdCBjbyA9IC8qIEBfX1BVUkVfXyAqLyBQZShfZSk7XG5jbGFzcyBobyB7XG4gIC8qKlxuICAgKiBTaG93IHdlYiBub3RpZmljYXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtOb3RpZmllck9wdGlvbnMgfCBDb25maXJtTm90aWZpZXJPcHRpb25zIHwgUHJvbXB0Tm90aWZpZXJPcHRpb25zfSBvcHRpb25zIC0gbm90aWZpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHNob3coZSkge1xuICAgIGNvLnNob3coZSk7XG4gIH1cbn1cbmNsYXNzIHVvIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbiAtIE1vZHVsZSBDb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmNvbmZpZyAtIEVkaXRvcidzIGNvbmZpZ1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5ldmVudHNEaXNwYXRjaGVyIC0gRWRpdG9yJ3MgZXZlbnQgZGlzcGF0Y2hlclxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGUsIGV2ZW50c0Rpc3BhdGNoZXI6IHQgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZzogZSxcbiAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRcbiAgICB9KSwgdGhpcy5ub3RpZmllciA9IG5ldyBobygpO1xuICB9XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNob3c6IChlKSA9PiB0aGlzLnNob3coZSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTaG93IG5vdGlmaWNhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge05vdGlmaWVyT3B0aW9uc30gb3B0aW9ucyAtIG1lc3NhZ2Ugb3B0aW9uXG4gICAqL1xuICBzaG93KGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub3RpZmllci5zaG93KGUpO1xuICB9XG59XG5jbGFzcyBwbyBleHRlbmRzIHkge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIGNvbnN0IGUgPSAoKSA9PiB0aGlzLmlzRW5hYmxlZDtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlOiAodCkgPT4gdGhpcy50b2dnbGUodCksXG4gICAgICBnZXQgaXNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNldCBvciB0b2dnbGUgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IHN0YXRlIC0gc2V0IG9yIHRvZ2dsZSBzdGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gY3VycmVudCB2YWx1ZVxuICAgKi9cbiAgdG9nZ2xlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuUmVhZE9ubHkudG9nZ2xlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgcmVhZC1vbmx5IHN0YXRlXG4gICAqL1xuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQ7XG4gIH1cbn1cbnZhciBPZSA9IHt9LCBmbyA9IHtcbiAgZ2V0IGV4cG9ydHMoKSB7XG4gICAgcmV0dXJuIE9lO1xuICB9LFxuICBzZXQgZXhwb3J0cyhzKSB7XG4gICAgT2UgPSBzO1xuICB9XG59O1xuKGZ1bmN0aW9uKHMsIGUpIHtcbiAgKGZ1bmN0aW9uKHQsIG8pIHtcbiAgICBzLmV4cG9ydHMgPSBvKCk7XG4gIH0pKFJ0LCBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiB0KGgpIHtcbiAgICAgIHZhciBmID0gaC50YWdzLCB4ID0gT2JqZWN0LmtleXMoZiksIHAgPSB4Lm1hcChmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZlttXTtcbiAgICAgIH0pLmV2ZXJ5KGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IFwib2JqZWN0XCIgfHwgbSA9PT0gXCJib29sZWFuXCIgfHwgbSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb25maWd1cmF0aW9uIHdhcyBpbnZhbGlkXCIpO1xuICAgICAgdGhpcy5jb25maWcgPSBoO1xuICAgIH1cbiAgICB2YXIgbyA9IFtcIlBcIiwgXCJMSVwiLCBcIlREXCIsIFwiVEhcIiwgXCJESVZcIiwgXCJIMVwiLCBcIkgyXCIsIFwiSDNcIiwgXCJINFwiLCBcIkg1XCIsIFwiSDZcIiwgXCJQUkVcIl07XG4gICAgZnVuY3Rpb24gaShoKSB7XG4gICAgICByZXR1cm4gby5pbmRleE9mKGgubm9kZU5hbWUpICE9PSAtMTtcbiAgICB9XG4gICAgdmFyIG4gPSBbXCJBXCIsIFwiQlwiLCBcIlNUUk9OR1wiLCBcIklcIiwgXCJFTVwiLCBcIlNVQlwiLCBcIlNVUFwiLCBcIlVcIiwgXCJTVFJJS0VcIl07XG4gICAgZnVuY3Rpb24gcihoKSB7XG4gICAgICByZXR1cm4gbi5pbmRleE9mKGgubm9kZU5hbWUpICE9PSAtMTtcbiAgICB9XG4gICAgdC5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbihoKSB7XG4gICAgICBjb25zdCBmID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCksIHggPSBmLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICByZXR1cm4geC5pbm5lckhUTUwgPSBoLCB0aGlzLl9zYW5pdGl6ZShmLCB4KSwgeC5pbm5lckhUTUw7XG4gICAgfSwgdC5wcm90b3R5cGUuX3Nhbml0aXplID0gZnVuY3Rpb24oaCwgZikge1xuICAgICAgdmFyIHggPSBhKGgsIGYpLCBwID0geC5maXJzdENoaWxkKCk7XG4gICAgICBpZiAocClcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChwLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSlcbiAgICAgICAgICAgIGlmIChwLmRhdGEudHJpbSgpID09PSBcIlwiICYmIChwLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgaShwLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHx8IHAubmV4dEVsZW1lbnRTaWJsaW5nICYmIGkocC5uZXh0RWxlbWVudFNpYmxpbmcpKSkge1xuICAgICAgICAgICAgICBmLnJlbW92ZUNoaWxkKHApLCB0aGlzLl9zYW5pdGl6ZShoLCBmKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgaWYgKHAubm9kZVR5cGUgPT09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBmLnJlbW92ZUNoaWxkKHApLCB0aGlzLl9zYW5pdGl6ZShoLCBmKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbSA9IHIocCksIEw7XG4gICAgICAgICAgbSAmJiAoTCA9IEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwocC5jaGlsZE5vZGVzLCBpKSk7XG4gICAgICAgICAgdmFyIEEgPSAhIWYucGFyZW50Tm9kZSwgUyA9IGkoZikgJiYgaShwKSAmJiBBLCBaID0gcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBIID0gbCh0aGlzLmNvbmZpZywgWiwgcCksIFUgPSBtICYmIEw7XG4gICAgICAgICAgaWYgKFUgfHwgZChwLCBIKSB8fCAhdGhpcy5jb25maWcua2VlcE5lc3RlZEJsb2NrRWxlbWVudHMgJiYgUykge1xuICAgICAgICAgICAgaWYgKCEocC5ub2RlTmFtZSA9PT0gXCJTQ1JJUFRcIiB8fCBwLm5vZGVOYW1lID09PSBcIlNUWUxFXCIpKVxuICAgICAgICAgICAgICBmb3IgKDsgcC5jaGlsZE5vZGVzLmxlbmd0aCA+IDA7IClcbiAgICAgICAgICAgICAgICBmLmluc2VydEJlZm9yZShwLmNoaWxkTm9kZXNbMF0sIHApO1xuICAgICAgICAgICAgZi5yZW1vdmVDaGlsZChwKSwgdGhpcy5fc2FuaXRpemUoaCwgZik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgSiA9IDA7IEogPCBwLmF0dHJpYnV0ZXMubGVuZ3RoOyBKICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjZSA9IHAuYXR0cmlidXRlc1tKXTtcbiAgICAgICAgICAgIHUoY2UsIEgsIHApICYmIChwLnJlbW92ZUF0dHJpYnV0ZShjZS5uYW1lKSwgSiA9IEogLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2FuaXRpemUoaCwgcCk7XG4gICAgICAgIH0gd2hpbGUgKHAgPSB4Lm5leHRTaWJsaW5nKCkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYShoLCBmKSB7XG4gICAgICByZXR1cm4gaC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgICBmLFxuICAgICAgICBOb2RlRmlsdGVyLlNIT1dfVEVYVCB8IE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQsXG4gICAgICAgIG51bGwsXG4gICAgICAgICExXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsKGgsIGYsIHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgaC50YWdzW2ZdID09IFwiZnVuY3Rpb25cIiA/IGgudGFnc1tmXSh4KSA6IGgudGFnc1tmXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZChoLCBmKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGYgPiBcInVcIiA/ICEwIDogdHlwZW9mIGYgPT0gXCJib29sZWFuXCIgPyAhZiA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1KGgsIGYsIHgpIHtcbiAgICAgIHZhciBwID0gaC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gZiA9PT0gITAgPyAhMSA6IHR5cGVvZiBmW3BdID09IFwiZnVuY3Rpb25cIiA/ICFmW3BdKGgudmFsdWUsIHgpIDogdHlwZW9mIGZbcF0gPiBcInVcIiB8fCBmW3BdID09PSAhMSA/ICEwIDogdHlwZW9mIGZbcF0gPT0gXCJzdHJpbmdcIiA/IGZbcF0gIT09IGgudmFsdWUgOiAhMTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH0pO1xufSkoZm8pO1xuY29uc3QgZ28gPSBPZTtcbmZ1bmN0aW9uIGJ0KHMsIGUpIHtcbiAgcmV0dXJuIHMubWFwKCh0KSA9PiB7XG4gICAgY29uc3QgbyA9IE0oZSkgPyBlKHQudG9vbCkgOiBlO1xuICAgIHJldHVybiBXKG8pIHx8ICh0LmRhdGEgPSB6ZSh0LmRhdGEsIG8pKSwgdDtcbiAgfSk7XG59XG5mdW5jdGlvbiBWKHMsIGUgPSB7fSkge1xuICBjb25zdCB0ID0ge1xuICAgIHRhZ3M6IGVcbiAgfTtcbiAgcmV0dXJuIG5ldyBnbyh0KS5jbGVhbihzKTtcbn1cbmZ1bmN0aW9uIHplKHMsIGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocykgPyBibyhzLCBlKSA6IEQocykgPyBtbyhzLCBlKSA6IEcocykgPyBrbyhzLCBlKSA6IHM7XG59XG5mdW5jdGlvbiBibyhzLCBlKSB7XG4gIHJldHVybiBzLm1hcCgodCkgPT4gemUodCwgZSkpO1xufVxuZnVuY3Rpb24gbW8ocywgZSkge1xuICBjb25zdCB0ID0ge307XG4gIGZvciAoY29uc3QgbyBpbiBzKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgbykpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBpID0gc1tvXSwgbiA9IHZvKGVbb10pID8gZVtvXSA6IGU7XG4gICAgdFtvXSA9IHplKGksIG4pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24ga28ocywgZSkge1xuICByZXR1cm4gRChlKSA/IFYocywgZSkgOiBlID09PSAhMSA/IFYocywge30pIDogcztcbn1cbmZ1bmN0aW9uIHZvKHMpIHtcbiAgcmV0dXJuIEQocykgfHwgSHQocykgfHwgTShzKTtcbn1cbmNsYXNzIHhvIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7U2FuaXRpemVyQ29uZmlnfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsZWFuOiAoZSwgdCkgPT4gdGhpcy5jbGVhbihlLCB0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gc2FuaXRpemluZyBvZiBhIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFpbnRTdHJpbmcgLSB3aGF0IHRvIHNhbml0aXplXG4gICAqIEBwYXJhbSB7U2FuaXRpemVyQ29uZmlnfSBjb25maWcgLSBzYW5pdGl6ZXIgY29uZmlnXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjbGVhbihlLCB0KSB7XG4gICAgcmV0dXJuIFYoZSwgdCk7XG4gIH1cbn1cbmNsYXNzIHdvIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7U2F2ZXJ9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2F2ZTogKCkgPT4gdGhpcy5zYXZlKClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gRWRpdG9yJ3MgZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7T3V0cHV0RGF0YX1cbiAgICovXG4gIHNhdmUoKSB7XG4gICAgY29uc3QgZSA9IFwiRWRpdG9yJ3MgY29udGVudCBjYW4gbm90IGJlIHNhdmVkIGluIHJlYWQtb25seSBtb2RlXCI7XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLlJlYWRPbmx5LmlzRW5hYmxlZCA/IChZKGUsIFwid2FyblwiKSwgUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGUpKSkgOiB0aGlzLkVkaXRvci5TYXZlci5zYXZlKCk7XG4gIH1cbn1cbmNsYXNzIHlvIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7U2VsZWN0aW9uQVBJSW50ZXJmYWNlfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbmRQYXJlbnRUYWc6IChlLCB0KSA9PiB0aGlzLmZpbmRQYXJlbnRUYWcoZSwgdCksXG4gICAgICBleHBhbmRUb1RhZzogKGUpID0+IHRoaXMuZXhwYW5kVG9UYWcoZSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBMb29rcyBhaGVhZCBmcm9tIHNlbGVjdGlvbiBhbmQgZmluZCBwYXNzZWQgdGFnIHdpdGggY2xhc3MgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSAtIHRhZyB0byBmaW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgLSB0YWcncyBjbGFzcyBuYW1lXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxuICAgKi9cbiAgZmluZFBhcmVudFRhZyhlLCB0KSB7XG4gICAgcmV0dXJuIG5ldyBiKCkuZmluZFBhcmVudFRhZyhlLCB0KTtcbiAgfVxuICAvKipcbiAgICogRXhwYW5kIHNlbGVjdGlvbiB0byBwYXNzZWQgdGFnXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgLSB0YWcgdGhhdCBzaG91bGQgY29udGFpbiBzZWxlY3Rpb25cbiAgICovXG4gIGV4cGFuZFRvVGFnKGUpIHtcbiAgICBuZXcgYigpLmV4cGFuZFRvVGFnKGUpO1xuICB9XG59XG5jbGFzcyBFbyBleHRlbmRzIHkge1xuICAvKipcbiAgICogRXhwb3J0ZWQgY2xhc3Nlc1xuICAgKi9cbiAgZ2V0IGNsYXNzZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogQmFzZSBCbG9jayBzdHlsZXNcbiAgICAgICAqL1xuICAgICAgYmxvY2s6IFwiY2R4LWJsb2NrXCIsXG4gICAgICAvKipcbiAgICAgICAqIElubGluZSBUb29scyBzdHlsZXNcbiAgICAgICAqL1xuICAgICAgaW5saW5lVG9vbEJ1dHRvbjogXCJjZS1pbmxpbmUtdG9vbFwiLFxuICAgICAgaW5saW5lVG9vbEJ1dHRvbkFjdGl2ZTogXCJjZS1pbmxpbmUtdG9vbC0tYWN0aXZlXCIsXG4gICAgICAvKipcbiAgICAgICAqIFVJIGVsZW1lbnRzXG4gICAgICAgKi9cbiAgICAgIGlucHV0OiBcImNkeC1pbnB1dFwiLFxuICAgICAgbG9hZGVyOiBcImNkeC1sb2FkZXJcIixcbiAgICAgIGJ1dHRvbjogXCJjZHgtYnV0dG9uXCIsXG4gICAgICAvKipcbiAgICAgICAqIFNldHRpbmdzIHN0eWxlc1xuICAgICAgICovXG4gICAgICBzZXR0aW5nc0J1dHRvbjogXCJjZHgtc2V0dGluZ3MtYnV0dG9uXCIsXG4gICAgICBzZXR0aW5nc0J1dHRvbkFjdGl2ZTogXCJjZHgtc2V0dGluZ3MtYnV0dG9uLS1hY3RpdmVcIlxuICAgIH07XG4gIH1cbn1cbmNsYXNzIEJvIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7VG9vbGJhcn1cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbG9zZTogKCkgPT4gdGhpcy5jbG9zZSgpLFxuICAgICAgb3BlbjogKCkgPT4gdGhpcy5vcGVuKCksXG4gICAgICB0b2dnbGVCbG9ja1NldHRpbmdzOiAoZSkgPT4gdGhpcy50b2dnbGVCbG9ja1NldHRpbmdzKGUpLFxuICAgICAgdG9nZ2xlVG9vbGJveDogKGUpID0+IHRoaXMudG9nZ2xlVG9vbGJveChlKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gdG9vbGJhclxuICAgKi9cbiAgb3BlbigpIHtcbiAgICB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIHRvb2xiYXIgYW5kIGFsbCBpbmNsdWRlZCBlbGVtZW50c1xuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIEJsb2NrIFNldHRpbmcgb2YgdGhlIGN1cnJlbnQgYmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBvcGVuaW5nU3RhdGUg4oCUICBvcGVuaW5nIHN0YXRlIG9mIEJsb2NrIFNldHRpbmdcbiAgICovXG4gIHRvZ2dsZUJsb2NrU2V0dGluZ3MoZSkge1xuICAgIGlmICh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXggPT09IC0xKSB7XG4gICAgICBZKFwiQ291bGQndCB0b2dnbGUgdGhlIFRvb2xiYXIgYmVjYXVzZSB0aGVyZSBpcyBubyBibG9jayBzZWxlY3RlZCBcIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlID8/ICF0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCA/ICh0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKCksIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbigpKSA6IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogT3BlbiB0b29sYm94XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3BlbmluZ1N0YXRlIC0gT3BlbmluZyBzdGF0ZSBvZiB0b29sYm94XG4gICAqL1xuICB0b2dnbGVUb29sYm94KGUpIHtcbiAgICBpZiAodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9ja0luZGV4ID09PSAtMSkge1xuICAgICAgWShcIkNvdWxkJ3QgdG9nZ2xlIHRoZSBUb29sYm94IGJlY2F1c2UgdGhlcmUgaXMgbm8gYmxvY2sgc2VsZWN0ZWQgXCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZSA/PyAhdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94Lm9wZW5lZCA/ICh0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5vcGVuKCkpIDogdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94LmNsb3NlKCk7XG4gIH1cbn1cbnZhciBOZSA9IHt9LCBDbyA9IHtcbiAgZ2V0IGV4cG9ydHMoKSB7XG4gICAgcmV0dXJuIE5lO1xuICB9LFxuICBzZXQgZXhwb3J0cyhzKSB7XG4gICAgTmUgPSBzO1xuICB9XG59O1xuLyohXG4gKiBDb2RlWC5Ub29sdGlwc1xuICogXG4gKiBAdmVyc2lvbiAxLjAuNVxuICogXG4gKiBAbGljZW5jZSBNSVRcbiAqIEBhdXRob3IgQ29kZVggPGh0dHBzOi8vY29kZXguc28+XG4gKiBcbiAqIFxuICovXG4oZnVuY3Rpb24ocywgZSkge1xuICAoZnVuY3Rpb24odCwgbykge1xuICAgIHMuZXhwb3J0cyA9IG8oKTtcbiAgfSkod2luZG93LCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGkobikge1xuICAgICAgICBpZiAob1tuXSlcbiAgICAgICAgICByZXR1cm4gb1tuXS5leHBvcnRzO1xuICAgICAgICB2YXIgciA9IG9bbl0gPSB7IGk6IG4sIGw6ICExLCBleHBvcnRzOiB7fSB9O1xuICAgICAgICByZXR1cm4gdFtuXS5jYWxsKHIuZXhwb3J0cywgciwgci5leHBvcnRzLCBpKSwgci5sID0gITAsIHIuZXhwb3J0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBpLm0gPSB0LCBpLmMgPSBvLCBpLmQgPSBmdW5jdGlvbihuLCByLCBhKSB7XG4gICAgICAgIGkubyhuLCByKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgciwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBhIH0pO1xuICAgICAgfSwgaS5yID0gZnVuY3Rpb24obikge1xuICAgICAgICB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gICAgICB9LCBpLnQgPSBmdW5jdGlvbihuLCByKSB7XG4gICAgICAgIGlmICgxICYgciAmJiAobiA9IGkobikpLCA4ICYgciB8fCA0ICYgciAmJiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiICYmIG4gJiYgbi5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB2YXIgYSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAoaS5yKGEpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiBuIH0pLCAyICYgciAmJiB0eXBlb2YgbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIGZvciAodmFyIGwgaW4gbilcbiAgICAgICAgICAgIGkuZChhLCBsLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuW2RdO1xuICAgICAgICAgICAgfS5iaW5kKG51bGwsIGwpKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LCBpLm4gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciByID0gbiAmJiBuLl9fZXNNb2R1bGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbi5kZWZhdWx0O1xuICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpLmQociwgXCJhXCIsIHIpLCByO1xuICAgICAgfSwgaS5vID0gZnVuY3Rpb24obiwgcikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpO1xuICAgICAgfSwgaS5wID0gXCJcIiwgaShpLnMgPSAwKTtcbiAgICB9KFtmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICB0LmV4cG9ydHMgPSBpKDEpO1xuICAgIH0sIGZ1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIGkucihvKSwgaS5kKG8sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9KTtcbiAgICAgIGNsYXNzIG4ge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzID0geyB3cmFwcGVyOiBudWxsLCBjb250ZW50OiBudWxsIH0sIHRoaXMuc2hvd2VkID0gITEsIHRoaXMub2Zmc2V0VG9wID0gMTAsIHRoaXMub2Zmc2V0TGVmdCA9IDEwLCB0aGlzLm9mZnNldFJpZ2h0ID0gMTAsIHRoaXMuaGlkaW5nRGVsYXkgPSAwLCB0aGlzLmhhbmRsZVdpbmRvd1Njcm9sbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2hvd2VkICYmIHRoaXMuaGlkZSghMCk7XG4gICAgICAgICAgfSwgdGhpcy5sb2FkU3R5bGVzKCksIHRoaXMucHJlcGFyZSgpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmhhbmRsZVdpbmRvd1Njcm9sbCwgeyBwYXNzaXZlOiAhMCB9KTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgQ1NTKCkge1xuICAgICAgICAgIHJldHVybiB7IHRvb2x0aXA6IFwiY3RcIiwgdG9vbHRpcENvbnRlbnQ6IFwiY3RfX2NvbnRlbnRcIiwgdG9vbHRpcFNob3duOiBcImN0LS1zaG93blwiLCBwbGFjZW1lbnQ6IHsgbGVmdDogXCJjdC0tbGVmdFwiLCBib3R0b206IFwiY3QtLWJvdHRvbVwiLCByaWdodDogXCJjdC0tcmlnaHRcIiwgdG9wOiBcImN0LS10b3BcIiB9IH07XG4gICAgICAgIH1cbiAgICAgICAgc2hvdyhhLCBsLCBkKSB7XG4gICAgICAgICAgdGhpcy5ub2Rlcy53cmFwcGVyIHx8IHRoaXMucHJlcGFyZSgpLCB0aGlzLmhpZGluZ1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGlkaW5nVGltZW91dCk7XG4gICAgICAgICAgY29uc3QgdSA9IE9iamVjdC5hc3NpZ24oeyBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsIG1hcmdpblRvcDogMCwgbWFyZ2luTGVmdDogMCwgbWFyZ2luUmlnaHQ6IDAsIG1hcmdpbkJvdHRvbTogMCwgZGVsYXk6IDcwLCBoaWRpbmdEZWxheTogMCB9LCBkKTtcbiAgICAgICAgICBpZiAodS5oaWRpbmdEZWxheSAmJiAodGhpcy5oaWRpbmdEZWxheSA9IHUuaGlkaW5nRGVsYXkpLCB0aGlzLm5vZGVzLmNvbnRlbnQuaW5uZXJIVE1MID0gXCJcIiwgdHlwZW9mIGwgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRoaXMubm9kZXMuY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsKSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShsIGluc3RhbmNlb2YgTm9kZSkpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0NvZGVYIFRvb2x0aXBdIFdyb25nIHR5cGUgb2Ygwqtjb250ZW50wrsgcGFzc2VkLiBJdCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZSBvciBTdHJpbmcuIEJ1dCBcIiArIHR5cGVvZiBsICsgXCIgZ2l2ZW4uXCIpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5jb250ZW50LmFwcGVuZENoaWxkKGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKC4uLk9iamVjdC52YWx1ZXModGhpcy5DU1MucGxhY2VtZW50KSksIHUucGxhY2VtZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgIHRoaXMucGxhY2VUb3AoYSwgdSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgdGhpcy5wbGFjZUxlZnQoYSwgdSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgIHRoaXMucGxhY2VSaWdodChhLCB1KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aGlzLnBsYWNlQm90dG9tKGEsIHUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1ICYmIHUuZGVsYXkgPyB0aGlzLnNob3dpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy50b29sdGlwU2hvd24pLCB0aGlzLnNob3dlZCA9ICEwO1xuICAgICAgICAgIH0sIHUuZGVsYXkpIDogKHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLnRvb2x0aXBTaG93biksIHRoaXMuc2hvd2VkID0gITApO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUoYSA9ICExKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaGlkaW5nRGVsYXkgJiYgIWEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRpbmdUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLmhpZGluZ1RpbWVvdXQpLCB2b2lkICh0aGlzLmhpZGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5oaWRlKCEwKTtcbiAgICAgICAgICAgIH0sIHRoaXMuaGlkaW5nRGVsYXkpKTtcbiAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy50b29sdGlwU2hvd24pLCB0aGlzLnNob3dlZCA9ICExLCB0aGlzLnNob3dpbmdUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLnNob3dpbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBvbkhvdmVyKGEsIGwsIGQpIHtcbiAgICAgICAgICBhLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2hvdyhhLCBsLCBkKTtcbiAgICAgICAgICB9KSwgYS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgIHRoaXMubm9kZXMud3JhcHBlci5yZW1vdmUoKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5oYW5kbGVXaW5kb3dTY3JvbGwpO1xuICAgICAgICB9XG4gICAgICAgIHByZXBhcmUoKSB7XG4gICAgICAgICAgdGhpcy5ub2Rlcy53cmFwcGVyID0gdGhpcy5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnRvb2x0aXApLCB0aGlzLm5vZGVzLmNvbnRlbnQgPSB0aGlzLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MudG9vbHRpcENvbnRlbnQpLCB0aGlzLmFwcGVuZCh0aGlzLm5vZGVzLndyYXBwZXIsIHRoaXMubm9kZXMuY29udGVudCksIHRoaXMuYXBwZW5kKGRvY3VtZW50LmJvZHksIHRoaXMubm9kZXMud3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZFN0eWxlcygpIHtcbiAgICAgICAgICBjb25zdCBhID0gXCJjb2RleC10b29sdGlwcy1zdHlsZVwiO1xuICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCBsID0gaSgyKSwgZCA9IHRoaXMubWFrZShcInN0eWxlXCIsIG51bGwsIHsgdGV4dENvbnRlbnQ6IGwudG9TdHJpbmcoKSwgaWQ6IGEgfSk7XG4gICAgICAgICAgdGhpcy5wcmVwZW5kKGRvY3VtZW50LmhlYWQsIGQpO1xuICAgICAgICB9XG4gICAgICAgIHBsYWNlQm90dG9tKGEsIGwpIHtcbiAgICAgICAgICBjb25zdCBkID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdSA9IGQubGVmdCArIGEuY2xpZW50V2lkdGggLyAyIC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldFdpZHRoIC8gMiwgaCA9IGQuYm90dG9tICsgd2luZG93LnBhZ2VZT2Zmc2V0ICsgdGhpcy5vZmZzZXRUb3AgKyBsLm1hcmdpblRvcDtcbiAgICAgICAgICB0aGlzLmFwcGx5UGxhY2VtZW50KFwiYm90dG9tXCIsIHUsIGgpO1xuICAgICAgICB9XG4gICAgICAgIHBsYWNlVG9wKGEsIGwpIHtcbiAgICAgICAgICBjb25zdCBkID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdSA9IGQubGVmdCArIGEuY2xpZW50V2lkdGggLyAyIC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldFdpZHRoIC8gMiwgaCA9IGQudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0IC0gdGhpcy5ub2Rlcy53cmFwcGVyLmNsaWVudEhlaWdodCAtIHRoaXMub2Zmc2V0VG9wO1xuICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoXCJ0b3BcIiwgdSwgaCk7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VMZWZ0KGEsIGwpIHtcbiAgICAgICAgICBjb25zdCBkID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdSA9IGQubGVmdCAtIHRoaXMubm9kZXMud3JhcHBlci5vZmZzZXRXaWR0aCAtIHRoaXMub2Zmc2V0TGVmdCAtIGwubWFyZ2luTGVmdCwgaCA9IGQudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0ICsgYS5jbGllbnRIZWlnaHQgLyAyIC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldEhlaWdodCAvIDI7XG4gICAgICAgICAgdGhpcy5hcHBseVBsYWNlbWVudChcImxlZnRcIiwgdSwgaCk7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VSaWdodChhLCBsKSB7XG4gICAgICAgICAgY29uc3QgZCA9IGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHUgPSBkLnJpZ2h0ICsgdGhpcy5vZmZzZXRSaWdodCArIGwubWFyZ2luUmlnaHQsIGggPSBkLnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCArIGEuY2xpZW50SGVpZ2h0IC8gMiAtIHRoaXMubm9kZXMud3JhcHBlci5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoXCJyaWdodFwiLCB1LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBhcHBseVBsYWNlbWVudChhLCBsLCBkKSB7XG4gICAgICAgICAgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MucGxhY2VtZW50W2FdKSwgdGhpcy5ub2Rlcy53cmFwcGVyLnN0eWxlLmxlZnQgPSBsICsgXCJweFwiLCB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUudG9wID0gZCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBtYWtlKGEsIGwgPSBudWxsLCBkID0ge30pIHtcbiAgICAgICAgICBjb25zdCB1ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChhKTtcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGwpID8gdS5jbGFzc0xpc3QuYWRkKC4uLmwpIDogbCAmJiB1LmNsYXNzTGlzdC5hZGQobCk7XG4gICAgICAgICAgZm9yIChjb25zdCBoIGluIGQpXG4gICAgICAgICAgICBkLmhhc093blByb3BlcnR5KGgpICYmICh1W2hdID0gZFtoXSk7XG4gICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKGEsIGwpIHtcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGwpID8gbC5mb3JFYWNoKChkKSA9PiBhLmFwcGVuZENoaWxkKGQpKSA6IGEuYXBwZW5kQ2hpbGQobCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJlcGVuZChhLCBsKSB7XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShsKSA/IChsID0gbC5yZXZlcnNlKCkpLmZvckVhY2goKGQpID0+IGEucHJlcGVuZChkKSkgOiBhLnByZXBlbmQobCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbih0LCBvKSB7XG4gICAgICB0LmV4cG9ydHMgPSBgLmN0e3otaW5kZXg6OTk5O29wYWNpdHk6MDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7cG9pbnRlci1ldmVudHM6bm9uZTstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSA1MG1zIGVhc2UtaW4sLXdlYmtpdC10cmFuc2Zvcm0gNzBtcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTt0cmFuc2l0aW9uOm9wYWNpdHkgNTBtcyBlYXNlLWluLC13ZWJraXQtdHJhbnNmb3JtIDcwbXMgY3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7dHJhbnNpdGlvbjpvcGFjaXR5IDUwbXMgZWFzZS1pbix0cmFuc2Zvcm0gNzBtcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTt0cmFuc2l0aW9uOm9wYWNpdHkgNTBtcyBlYXNlLWluLHRyYW5zZm9ybSA3MG1zIGN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpLC13ZWJraXQtdHJhbnNmb3JtIDcwbXMgY3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7d2lsbC1jaGFuZ2U6b3BhY2l0eSx0b3AsbGVmdDstd2Via2l0LWJveC1zaGFkb3c6MCA4cHggMTJweCAwIHJnYmEoMjksMzIsNDMsLjE3KSwwIDRweCA1cHggLTNweCByZ2JhKDUsNiwxMiwuNDkpO2JveC1zaGFkb3c6MCA4cHggMTJweCAwIHJnYmEoMjksMzIsNDMsLjE3KSwwIDRweCA1cHggLTNweCByZ2JhKDUsNiwxMiwuNDkpO2JvcmRlci1yYWRpdXM6OXB4fS5jdCwuY3Q6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MH0uY3Q6YmVmb3Jle2NvbnRlbnQ6XCJcIjtib3R0b206MDtyaWdodDowO2JhY2tncm91bmQtY29sb3I6IzFkMjAyYjt6LWluZGV4Oi0xO2JvcmRlci1yYWRpdXM6NHB4fUBzdXBwb3J0cygtd2Via2l0LW1hc2stYm94LWltYWdlOnVybChcIlwiKSl7LmN0OmJlZm9yZXtib3JkZXItcmFkaXVzOjA7LXdlYmtpdC1tYXNrLWJveC1pbWFnZTp1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiPjxwYXRoIGQ9XCJNMTAuNzEgMGgyLjU4YzMuMDIgMCA0LjY0LjQyIDYuMSAxLjJhOC4xOCA4LjE4IDAgMDEzLjQgMy40QzIzLjYgNi4wNyAyNCA3LjcgMjQgMTAuNzF2Mi41OGMwIDMuMDItLjQyIDQuNjQtMS4yIDYuMWE4LjE4IDguMTggMCAwMS0zLjQgMy40Yy0xLjQ3LjgtMy4xIDEuMjEtNi4xMSAxLjIxSDEwLjdjLTMuMDIgMC00LjY0LS40Mi02LjEtMS4yYTguMTggOC4xOCAwIDAxLTMuNC0zLjRDLjQgMTcuOTMgMCAxNi4zIDAgMTMuMjlWMTAuN2MwLTMuMDIuNDItNC42NCAxLjItNi4xYTguMTggOC4xOCAwIDAxMy40LTMuNEM2LjA3LjQgNy43IDAgMTAuNzEgMHpcIi8+PC9zdmc+JykgNDglIDQxJSAzNy45JSA1My4zJX19QG1lZGlhICgtLW1vYmlsZSl7LmN0e2Rpc3BsYXk6bm9uZX19LmN0X19jb250ZW50e3BhZGRpbmc6NnB4IDEwcHg7Y29sb3I6I2NkZDFlMDtmb250LXNpemU6MTJweDt0ZXh0LWFsaWduOmNlbnRlcjtsZXR0ZXItc3BhY2luZzouMDJlbTtsaW5lLWhlaWdodDoxZW19LmN0OmFmdGVye2NvbnRlbnQ6XCJcIjt3aWR0aDo4cHg7aGVpZ2h0OjhweDtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWNvbG9yOiMxZDIwMmI7ei1pbmRleDotMX0uY3QtLWJvdHRvbXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDVweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoNXB4KX0uY3QtLWJvdHRvbTphZnRlcnt0b3A6LTNweDtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpfS5jdC0tdG9wey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTVweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTVweCl9LmN0LS10b3A6YWZ0ZXJ7dG9wOmF1dG87Ym90dG9tOi0zcHg7bGVmdDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSByb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSByb3RhdGUoLTQ1ZGVnKX0uY3QtLWxlZnR7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNXB4KX0uY3QtLWxlZnQ6YWZ0ZXJ7dG9wOjUwJTtsZWZ0OmF1dG87cmlnaHQ6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUoNDEuNiUsLTUwJSkgcm90YXRlKC00NWRlZyk7dHJhbnNmb3JtOnRyYW5zbGF0ZSg0MS42JSwtNTAlKSByb3RhdGUoLTQ1ZGVnKX0uY3QtLXJpZ2h0ey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoNXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCg1cHgpfS5jdC0tcmlnaHQ6YWZ0ZXJ7dG9wOjUwJTtsZWZ0OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlKC00MS42JSwtNTAlKSByb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm06dHJhbnNsYXRlKC00MS42JSwtNTAlKSByb3RhdGUoLTQ1ZGVnKX0uY3QtLXNob3due29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTpub25lO3RyYW5zZm9ybTpub25lfWA7XG4gICAgfV0pLmRlZmF1bHQ7XG4gIH0pO1xufSkoQ28pO1xuY29uc3QgVG8gPSAvKiBAX19QVVJFX18gKi8gUGUoTmUpO1xubGV0IEYgPSBudWxsO1xuZnVuY3Rpb24gVWUoKSB7XG4gIEYgfHwgKEYgPSBuZXcgVG8oKSk7XG59XG5mdW5jdGlvbiBTbyhzLCBlLCB0KSB7XG4gIFVlKCksIEYgPT0gbnVsbCB8fCBGLnNob3cocywgZSwgdCk7XG59XG5mdW5jdGlvbiBSZShzID0gITEpIHtcbiAgVWUoKSwgRiA9PSBudWxsIHx8IEYuaGlkZShzKTtcbn1cbmZ1bmN0aW9uIGdlKHMsIGUsIHQpIHtcbiAgVWUoKSwgRiA9PSBudWxsIHx8IEYub25Ib3ZlcihzLCBlLCB0KTtcbn1cbmZ1bmN0aW9uIElvKCkge1xuICBGID09IG51bGwgfHwgRi5kZXN0cm95KCksIEYgPSBudWxsO1xufVxuY2xhc3MgTW8gZXh0ZW5kcyB5IHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbiAtIE1vZHVsZSBDb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmNvbmZpZyAtIEVkaXRvcidzIGNvbmZpZ1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5ldmVudHNEaXNwYXRjaGVyIC0gRWRpdG9yJ3MgZXZlbnQgZGlzcGF0Y2hlclxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGUsIGV2ZW50c0Rpc3BhdGNoZXI6IHQgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZzogZSxcbiAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaG93OiAoZSwgdCwgbykgPT4gdGhpcy5zaG93KGUsIHQsIG8pLFxuICAgICAgaGlkZTogKCkgPT4gdGhpcy5oaWRlKCksXG4gICAgICBvbkhvdmVyOiAoZSwgdCwgbykgPT4gdGhpcy5vbkhvdmVyKGUsIHQsIG8pXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIHNob3cgdG9vbHRpcCBvbiBlbGVtZW50IHdpdGggcGFzc2VkIEhUTUwgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCBvbiB3aGljaCB0b29sdGlwIHNob3VsZCBiZSBzaG93blxuICAgKiBAcGFyYW0ge1Rvb2x0aXBDb250ZW50fSBjb250ZW50IC0gdG9vbHRpcCBjb250ZW50XG4gICAqIEBwYXJhbSB7VG9vbHRpcE9wdGlvbnN9IG9wdGlvbnMgLSB0b29sdGlwIG9wdGlvbnNcbiAgICovXG4gIHNob3coZSwgdCwgbykge1xuICAgIFNvKGUsIHQsIG8pO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgaGlkZXMgdG9vbHRpcCBvbiBIVE1MIHBhZ2VcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgUmUoKTtcbiAgfVxuICAvKipcbiAgICogRGVjb3JhdG9yIGZvciBzaG93aW5nIFRvb2x0aXAgYnkgbW91c2VlbnRlci9tb3VzZWxlYXZlXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IG9uIHdoaWNoIHRvb2x0aXAgc2hvdWxkIGJlIHNob3duXG4gICAqIEBwYXJhbSB7VG9vbHRpcENvbnRlbnR9IGNvbnRlbnQgLSB0b29sdGlwIGNvbnRlbnRcbiAgICogQHBhcmFtIHtUb29sdGlwT3B0aW9uc30gb3B0aW9ucyAtIHRvb2x0aXAgb3B0aW9uc1xuICAgKi9cbiAgb25Ib3ZlcihlLCB0LCBvKSB7XG4gICAgZ2UoZSwgdCwgbyk7XG4gIH1cbn1cbmNsYXNzIExvIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kcyAvIGdldHRlcnNcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlczogdGhpcy5lZGl0b3JOb2Rlc1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVyZSBjYW4gYmUgYWRkZWQgc29tZSBVSSBtZXRob2RzLCBsaWtlIHRvZ2dsZVRoaW5Nb2RlKCkgZXRjXG4gICAgICAgKi9cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeHBvcnRlZCBjbGFzc2VzXG4gICAqL1xuICBnZXQgZWRpdG9yTm9kZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogVG9wLWxldmVsIGVkaXRvciBpbnN0YW5jZSB3cmFwcGVyXG4gICAgICAgKi9cbiAgICAgIHdyYXBwZXI6IHRoaXMuRWRpdG9yLlVJLm5vZGVzLndyYXBwZXIsXG4gICAgICAvKipcbiAgICAgICAqIEVsZW1lbnQgdGhhdCBob2xkcyBhbGwgdGhlIEJsb2Nrc1xuICAgICAgICovXG4gICAgICByZWRhY3RvcjogdGhpcy5FZGl0b3IuVUkubm9kZXMucmVkYWN0b3JcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBtdChzLCBlKSB7XG4gIGNvbnN0IHQgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHMpLmZvckVhY2goKFtvLCBpXSkgPT4ge1xuICAgIGlmIChEKGkpKSB7XG4gICAgICBjb25zdCBuID0gZSA/IGAke2V9LiR7b31gIDogbztcbiAgICAgIE9iamVjdC52YWx1ZXMoaSkuZXZlcnkoKGEpID0+IEcoYSkpID8gdFtvXSA9IG4gOiB0W29dID0gbXQoaSwgbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRbb10gPSBpO1xuICB9KSwgdDtcbn1cbmNvbnN0IEsgPSBtdChodCk7XG5mdW5jdGlvbiBBbyhzLCBlKSB7XG4gIGNvbnN0IHQgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHMpLmZvckVhY2goKG8pID0+IHtcbiAgICBjb25zdCBpID0gZVtvXTtcbiAgICBpICE9PSB2b2lkIDAgPyB0W2ldID0gc1tvXSA6IHRbb10gPSBzW29dO1xuICB9KSwgdDtcbn1cbmNvbnN0IF9vID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05IDEyTDkgNy4xQzkgNy4wNDQ3NyA5LjA0NDc3IDcgOS4xIDdIMTAuNEMxMS41IDcgMTQgNy4xIDE0IDkuNUMxNCA5LjUgMTQgMTIgMTEgMTJNOSAxMlYxNi44QzkgMTYuOTEwNSA5LjA4OTU0IDE3IDkuMiAxN0gxMi41QzE0IDE3IDE1IDE2IDE1IDE0LjVDMTUgMTEuNzA0NiAxMSAxMiAxMSAxMk05IDEySDExXCIvPjwvc3ZnPicsIGt0ID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk03IDEwTDExLjg1ODYgMTQuODU4NkMxMS45MzY3IDE0LjkzNjcgMTIuMDYzMyAxNC45MzY3IDEyLjE0MTQgMTQuODU4NkwxNyAxMFwiLz48L3N2Zz4nLCBPbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNyAxNUwxMS44NTg2IDEwLjE0MTRDMTEuOTM2NyAxMC4wNjMzIDEyLjA2MzMgMTAuMDYzMyAxMi4xNDE0IDEwLjE0MTRMMTcgMTVcIi8+PC9zdmc+JywgTm8gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTggOEwxMiAxMk0xMiAxMkwxNiAxNk0xMiAxMkwxNiA4TTEyIDEyTDggMTZcIi8+PC9zdmc+JywgUm8gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI0XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48L3N2Zz4nLCBEbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTMuMzQgMTBDMTIuNDIyMyAxMi43MzM3IDExIDE3IDExIDE3XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNC4yMSA3SDE0LjJcIi8+PC9zdmc+JywgaXQgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTcuNjk5OTggMTIuNkw3LjY3ODk2IDEyLjYyQzYuNTM5OTMgMTMuNzA0OCA2LjUyMDEyIDE1LjUxNTUgNy42MzUxNiAxNi42MjVWMTYuNjI1QzguNzIyOTMgMTcuNzA3MyAxMC40Nzk5IDE3LjcxMDIgMTEuNTcxMiAxNi42MzE0TDEzLjAyNjMgMTUuMTkzQzE0LjA3MDMgMTQuMTYwOSAxNC4yMTQxIDEyLjUyNSAxMy4zNjYyIDExLjMyNjZMMTMuMjIgMTEuMTJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE2LjIyIDExLjEyTDE2LjM1NjQgMTAuOTgwNUMxNy4yODk1IDEwLjAyNjUgMTcuMzQ3OCA4LjUyMDcgMTYuNDkxNCA3LjQ5NzMzVjcuNDk3MzNDMTUuNTY5MSA2LjM5NTA5IDEzLjkyNjkgNi4yNTE0MyAxMi44MjcxIDcuMTc2NzVMMTEuMzkwMSA4LjM4NTg4QzEwLjA5MzUgOS40NzY3NCA5Ljk1NzA2IDExLjQyNDEgMTEuMDg4OCAxMi42ODUyTDExLjEyIDEyLjcyXCIvPjwvc3ZnPicsIFBvID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTkuNDA5OTkgNy4yOTk5OUg5LjRcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNMTQuNiA3LjI5OTk5SDE0LjU5XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTkuMzA5OTkgMTJIOS4zXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTE0LjYgMTJIMTQuNTlcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNOS40MDk5OSAxNi43SDkuNFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMi42XCIgZD1cIk0xNC42IDE2LjdIMTQuNTlcIi8+PC9zdmc+JywgRm8gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEyIDdWMTJNMTIgMTdWMTJNMTcgMTJIMTJNMTIgMTJIN1wiLz48L3N2Zz4nLCBIbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48Y2lyY2xlIGN4PVwiMTAuNVwiIGN5PVwiMTAuNVwiIHI9XCI1LjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxsaW5lIHgxPVwiMTUuNDE0MlwiIHgyPVwiMTlcIiB5MT1cIjE1XCIgeTI9XCIxOC41ODU4XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PC9zdmc+Jywgem8gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE1Ljc3OTUgMTEuNUMxNS43Nzk1IDExLjUgMTYuMDUzIDExLjE5NjIgMTYuNTQ5NyAxMC42NzIyQzE3LjQ0NDIgOS43Mjg1NiAxNy40NzAxIDguMjQ3NSAxNi41NzgxIDcuMzAxNDVWNy4zMDE0NUMxNS42NDgyIDYuMzE1MjIgMTQuMDg3MyA2LjI5MjI3IDEzLjEyODggNy4yNTA3M0wxMS44Nzk2IDguNDk5OTlcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTguMjQ1MTcgMTIuMzg4M0M4LjI0NTE3IDEyLjM4ODMgNy45NzE3MSAxMi42OTIyIDcuNDc1MDQgMTMuMjE2MUM2LjU4MDUxIDE0LjE1OTggNi41NTQ2NyAxNS42NDA4IDcuNDQ2NjYgMTYuNTg2OVYxNi41ODY5QzguMzc2NTMgMTcuNTczMSA5LjkzNzQ0IDE3LjU5NjEgMTAuODk1OSAxNi42Mzc2TDEyLjE0NTIgMTUuMzg4M1wiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTcuNzgwMiAxNS4xMDMyTDE2LjU5NyAxNC45NDIyQzE2LjAxMDkgMTQuODYyNCAxNS40ODQxIDE1LjMwNTkgMTUuNDYyNyAxNS44OTY5TDE1LjQxOTkgMTcuMDgxOFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNi4zOTA2NCA5LjAzMjM4TDcuNTg0MzIgOS4wNjY2OEM4LjE3NTUxIDkuMDgzNjYgOC42NTIyIDguNTg2NjUgOC42MTA1NiA3Ljk5NjY5TDguNTI3MSA2LjgxMzk3XCIvPjxsaW5lIHgxPVwiMTIuMTE0MlwiIHgyPVwiMTEuN1wiIHkxPVwiMTIuMlwiIHkyPVwiMTEuNzg1OFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjwvc3ZnPicsIFVvID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxyZWN0IHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHg9XCI1XCIgeT1cIjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgcng9XCI0XCIvPjxsaW5lIHgxPVwiMTJcIiB4Mj1cIjEyXCIgeTE9XCI5XCIgeTI9XCIxMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMiAxNS4wMlYxNS4wMVwiLz48L3N2Zz4nO1xuY2xhc3MgXyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHBvcG92ZXIgaXRlbSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gcG9wb3ZlciBpdGVtIGNvbnN0cnVjdGlvbiBwYXJhbXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLm5vZGVzID0ge1xuICAgICAgcm9vdDogbnVsbCxcbiAgICAgIGljb246IG51bGxcbiAgICB9LCB0aGlzLmNvbmZpcm1hdGlvblN0YXRlID0gbnVsbCwgdGhpcy5yZW1vdmVTcGVjaWFsRm9jdXNCZWhhdmlvciA9ICgpID0+IHtcbiAgICAgIHRoaXMubm9kZXMucm9vdC5jbGFzc0xpc3QucmVtb3ZlKF8uQ1NTLm5vRm9jdXMpO1xuICAgIH0sIHRoaXMucmVtb3ZlU3BlY2lhbEhvdmVyQmVoYXZpb3IgPSAoKSA9PiB7XG4gICAgICB0aGlzLm5vZGVzLnJvb3QuY2xhc3NMaXN0LnJlbW92ZShfLkNTUy5ub0hvdmVyKTtcbiAgICB9LCB0aGlzLm9uRXJyb3JBbmltYXRpb25FbmQgPSAoKSA9PiB7XG4gICAgICB0aGlzLm5vZGVzLmljb24uY2xhc3NMaXN0LnJlbW92ZShfLkNTUy53b2JibGVBbmltYXRpb24pLCB0aGlzLm5vZGVzLmljb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCB0aGlzLm9uRXJyb3JBbmltYXRpb25FbmQpO1xuICAgIH0sIHRoaXMucGFyYW1zID0gZSwgdGhpcy5ub2Rlcy5yb290ID0gdGhpcy5tYWtlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGl0ZW0gaXMgZGlzYWJsZWQgYW5kIGhlbmNlIG5vdCBjbGlja2FibGVcbiAgICovXG4gIGdldCBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtcy5pc0Rpc2FibGVkO1xuICB9XG4gIC8qKlxuICAgKiBFeHBvc2VzIHBvcG92ZXIgaXRlbSB0b2dnbGUgcGFyYW1ldGVyXG4gICAqL1xuICBnZXQgdG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtcy50b2dnbGU7XG4gIH1cbiAgLyoqXG4gICAqIEl0ZW0gdGl0bGVcbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMudGl0bGU7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgcG9wb3ZlciBzaG91bGQgY2xvc2Ugb25jZSBpdGVtIGlzIGFjdGl2YXRlZFxuICAgKi9cbiAgZ2V0IGNsb3NlT25BY3RpdmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMuY2xvc2VPbkFjdGl2YXRlO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGNvbmZpcm1hdGlvbiBzdGF0ZSBpcyBlbmFibGVkIGZvciBwb3BvdmVyIGl0ZW1cbiAgICovXG4gIGdldCBpc0NvbmZpcm1hdGlvblN0YXRlRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maXJtYXRpb25TdGF0ZSAhPT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBpdGVtIGlzIGZvY3VzZWQgaW4ga2V5Ym9hcmQgbmF2aWdhdGlvbiBwcm9jZXNzXG4gICAqL1xuICBnZXQgaXNGb2N1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKF8uQ1NTLmZvY3VzZWQpO1xuICB9XG4gIC8qKlxuICAgKiBQb3BvdmVyIGl0ZW0gQ1NTIGNsYXNzZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb250YWluZXI6IFwiY2UtcG9wb3Zlci1pdGVtXCIsXG4gICAgICB0aXRsZTogXCJjZS1wb3BvdmVyLWl0ZW1fX3RpdGxlXCIsXG4gICAgICBzZWNvbmRhcnlUaXRsZTogXCJjZS1wb3BvdmVyLWl0ZW1fX3NlY29uZGFyeS10aXRsZVwiLFxuICAgICAgaWNvbjogXCJjZS1wb3BvdmVyLWl0ZW1fX2ljb25cIixcbiAgICAgIGFjdGl2ZTogXCJjZS1wb3BvdmVyLWl0ZW0tLWFjdGl2ZVwiLFxuICAgICAgZGlzYWJsZWQ6IFwiY2UtcG9wb3Zlci1pdGVtLS1kaXNhYmxlZFwiLFxuICAgICAgZm9jdXNlZDogXCJjZS1wb3BvdmVyLWl0ZW0tLWZvY3VzZWRcIixcbiAgICAgIGhpZGRlbjogXCJjZS1wb3BvdmVyLWl0ZW0tLWhpZGRlblwiLFxuICAgICAgY29uZmlybWF0aW9uU3RhdGU6IFwiY2UtcG9wb3Zlci1pdGVtLS1jb25maXJtYXRpb25cIixcbiAgICAgIG5vSG92ZXI6IFwiY2UtcG9wb3Zlci1pdGVtLS1uby1ob3ZlclwiLFxuICAgICAgbm9Gb2N1czogXCJjZS1wb3BvdmVyLWl0ZW0tLW5vLWZvY3VzXCIsXG4gICAgICB3b2JibGVBbmltYXRpb246IFwid29iYmxlXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHBvcG92ZXIgaXRlbSByb290IGVsZW1lbnRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucm9vdDtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIG9uIHBvcG92ZXIgaXRlbSBjbGlja1xuICAgKi9cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMuaXNDb25maXJtYXRpb25TdGF0ZUVuYWJsZWQpIHtcbiAgICAgIHRoaXMuYWN0aXZhdGVPckVuYWJsZUNvbmZpcm1hdGlvbk1vZGUodGhpcy5jb25maXJtYXRpb25TdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWN0aXZhdGVPckVuYWJsZUNvbmZpcm1hdGlvbk1vZGUodGhpcy5wYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIGl0ZW0gYWN0aXZlIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBpc0FjdGl2ZSAtIHRydWUgaWYgaXRlbSBzaG91bGQgc3RyaWN0bHkgc2hvdWxkIGJlY29tZSBhY3RpdmVcbiAgICovXG4gIHRvZ2dsZUFjdGl2ZShlKSB7XG4gICAgdGhpcy5ub2Rlcy5yb290LmNsYXNzTGlzdC50b2dnbGUoXy5DU1MuYWN0aXZlLCBlKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyBpdGVtIGhpZGRlbiBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gaXNIaWRkZW4gLSB0cnVlIGlmIGl0ZW0gc2hvdWxkIGJlIGhpZGRlblxuICAgKi9cbiAgdG9nZ2xlSGlkZGVuKGUpIHtcbiAgICB0aGlzLm5vZGVzLnJvb3QuY2xhc3NMaXN0LnRvZ2dsZShfLkNTUy5oaWRkZW4sIGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgcG9wb3ZlciBpdGVtIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZVxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pc0NvbmZpcm1hdGlvblN0YXRlRW5hYmxlZCAmJiB0aGlzLmRpc2FibGVDb25maXJtYXRpb25Nb2RlKCk7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCBjYWxsZWQgb25jZSBpdGVtIGJlY29tZXMgZm9jdXNlZCBkdXJpbmcga2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgKi9cbiAgb25Gb2N1cygpIHtcbiAgICB0aGlzLmRpc2FibGVTcGVjaWFsSG92ZXJBbmRGb2N1c0JlaGF2aW9yKCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgSFRNTCBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gcG9wb3ZlciBpdGVtIHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gaXRlbSBjb25zdHJ1Y3Rpb24gcGFyYW1zXG4gICAqL1xuICBtYWtlKGUpIHtcbiAgICBjb25zdCB0ID0gYy5tYWtlKFwiZGl2XCIsIF8uQ1NTLmNvbnRhaW5lcik7XG4gICAgcmV0dXJuIGUubmFtZSAmJiAodC5kYXRhc2V0Lml0ZW1OYW1lID0gZS5uYW1lKSwgdGhpcy5ub2Rlcy5pY29uID0gYy5tYWtlKFwiZGl2XCIsIF8uQ1NTLmljb24sIHtcbiAgICAgIGlubmVySFRNTDogZS5pY29uIHx8IFJvXG4gICAgfSksIHQuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5pY29uKSwgdC5hcHBlbmRDaGlsZChjLm1ha2UoXCJkaXZcIiwgXy5DU1MudGl0bGUsIHtcbiAgICAgIGlubmVySFRNTDogZS50aXRsZSB8fCBcIlwiXG4gICAgfSkpLCBlLnNlY29uZGFyeUxhYmVsICYmIHQuYXBwZW5kQ2hpbGQoYy5tYWtlKFwiZGl2XCIsIF8uQ1NTLnNlY29uZGFyeVRpdGxlLCB7XG4gICAgICB0ZXh0Q29udGVudDogZS5zZWNvbmRhcnlMYWJlbFxuICAgIH0pKSwgZS5pc0FjdGl2ZSAmJiB0LmNsYXNzTGlzdC5hZGQoXy5DU1MuYWN0aXZlKSwgZS5pc0Rpc2FibGVkICYmIHQuY2xhc3NMaXN0LmFkZChfLkNTUy5kaXNhYmxlZCksIHQ7XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBjb25maXJtYXRpb24gbW9kZSBmb3IgdGhlIGl0ZW0uXG4gICAqXG4gICAqIEBwYXJhbSBuZXdTdGF0ZSAtIG5ldyBwb3BvdmVyIGl0ZW0gcGFyYW1zIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWRcbiAgICovXG4gIGVuYWJsZUNvbmZpcm1hdGlvbk1vZGUoZSkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICAuLi50aGlzLnBhcmFtcyxcbiAgICAgIC4uLmUsXG4gICAgICBjb25maXJtYXRpb246IGUuY29uZmlybWF0aW9uXG4gICAgfSwgbyA9IHRoaXMubWFrZSh0KTtcbiAgICB0aGlzLm5vZGVzLnJvb3QuaW5uZXJIVE1MID0gby5pbm5lckhUTUwsIHRoaXMubm9kZXMucm9vdC5jbGFzc0xpc3QuYWRkKF8uQ1NTLmNvbmZpcm1hdGlvblN0YXRlKSwgdGhpcy5jb25maXJtYXRpb25TdGF0ZSA9IGUsIHRoaXMuZW5hYmxlU3BlY2lhbEhvdmVyQW5kRm9jdXNCZWhhdmlvcigpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGl0ZW0gdG8gaXRzIG9yaWdpbmFsIHN0YXRlXG4gICAqL1xuICBkaXNhYmxlQ29uZmlybWF0aW9uTW9kZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5tYWtlKHRoaXMucGFyYW1zKTtcbiAgICB0aGlzLm5vZGVzLnJvb3QuaW5uZXJIVE1MID0gZS5pbm5lckhUTUwsIHRoaXMubm9kZXMucm9vdC5jbGFzc0xpc3QucmVtb3ZlKF8uQ1NTLmNvbmZpcm1hdGlvblN0YXRlKSwgdGhpcy5jb25maXJtYXRpb25TdGF0ZSA9IG51bGwsIHRoaXMuZGlzYWJsZVNwZWNpYWxIb3ZlckFuZEZvY3VzQmVoYXZpb3IoKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBzcGVjaWFsIGZvY3VzIGFuZCBob3ZlciBiZWhhdmlvciBmb3IgaXRlbSBpbiBjb25maXJtYXRpb24gc3RhdGUuXG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnQgaXRlbSBmcm9tIGJlaW5nIGhpZ2hsaWdodGVkIGFzIGhvdmVyZWQvZm9jdXNlZCBqdXN0IGFmdGVyIGNsaWNrLlxuICAgKi9cbiAgZW5hYmxlU3BlY2lhbEhvdmVyQW5kRm9jdXNCZWhhdmlvcigpIHtcbiAgICB0aGlzLm5vZGVzLnJvb3QuY2xhc3NMaXN0LmFkZChfLkNTUy5ub0hvdmVyKSwgdGhpcy5ub2Rlcy5yb290LmNsYXNzTGlzdC5hZGQoXy5DU1Mubm9Gb2N1cyksIHRoaXMubm9kZXMucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLnJlbW92ZVNwZWNpYWxIb3ZlckJlaGF2aW9yLCB7IG9uY2U6ICEwIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyBzcGVjaWFsIGZvY3VzIGFuZCBob3ZlciBiZWhhdmlvclxuICAgKi9cbiAgZGlzYWJsZVNwZWNpYWxIb3ZlckFuZEZvY3VzQmVoYXZpb3IoKSB7XG4gICAgdGhpcy5yZW1vdmVTcGVjaWFsRm9jdXNCZWhhdmlvcigpLCB0aGlzLnJlbW92ZVNwZWNpYWxIb3ZlckJlaGF2aW9yKCksIHRoaXMubm9kZXMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLnJlbW92ZVNwZWNpYWxIb3ZlckJlaGF2aW9yKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgaXRlbSdzIG9uQWN0aXZhdGUgY2FsbGJhY2sgaWYgdGhlIGl0ZW0gaGFzIG5vIGNvbmZpcm1hdGlvbiBjb25maWd1cmVkXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB0byBhY3RpdmF0ZSBvciBicmluZyB0byBjb25maXJtYXRpb24gbW9kZVxuICAgKi9cbiAgYWN0aXZhdGVPckVuYWJsZUNvbmZpcm1hdGlvbk1vZGUoZSkge1xuICAgIGlmIChlLmNvbmZpcm1hdGlvbiA9PT0gdm9pZCAwKVxuICAgICAgdHJ5IHtcbiAgICAgICAgZS5vbkFjdGl2YXRlKGUpLCB0aGlzLmRpc2FibGVDb25maXJtYXRpb25Nb2RlKCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhpcy5hbmltYXRlRXJyb3IoKTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICB0aGlzLmVuYWJsZUNvbmZpcm1hdGlvbk1vZGUoZS5jb25maXJtYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBBbmltYXRlcyBpdGVtIHdoaWNoIHN5bWJvbGl6ZXMgdGhhdCBlcnJvciBvY2N1cmVkIHdoaWxlIGV4ZWN1dGluZyAnb25BY3RpdmF0ZSgpJyBjYWxsYmFja1xuICAgKi9cbiAgYW5pbWF0ZUVycm9yKCkge1xuICAgIHRoaXMubm9kZXMuaWNvbi5jbGFzc0xpc3QuY29udGFpbnMoXy5DU1Mud29iYmxlQW5pbWF0aW9uKSB8fCAodGhpcy5ub2Rlcy5pY29uLmNsYXNzTGlzdC5hZGQoXy5DU1Mud29iYmxlQW5pbWF0aW9uKSwgdGhpcy5ub2Rlcy5pY29uLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgdGhpcy5vbkVycm9yQW5pbWF0aW9uRW5kKSk7XG4gIH1cbn1cbmNvbnN0IGhlID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfSBub2RlTGlzdCDigJQgdGhlIGxpc3Qgb2YgaXRlcmFibGUgSFRNTC1pdGVtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9jdXNlZENzc0NsYXNzIC0gdXNlci1wcm92aWRlZCBDU1MtY2xhc3MgdGhhdCB3aWxsIGJlIHNldCBpbiBmbGlwcGluZyBwcm9jZXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzLCBlKSB7XG4gICAgdGhpcy5jdXJzb3IgPSAtMSwgdGhpcy5pdGVtcyA9IFtdLCB0aGlzLml0ZW1zID0gcyB8fCBbXSwgdGhpcy5mb2N1c2VkQ3NzQ2xhc3MgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEZvY3VzZWQgYnV0dG9uIE5vZGVcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRJdGVtKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnNvciA9PT0gLTEgPyBudWxsIDogdGhpcy5pdGVtc1t0aGlzLmN1cnNvcl07XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgY3Vyc29yIHRvIHNwZWNpZmllZCBwb3NpdGlvblxuICAgKlxuICAgKiBAcGFyYW0gY3Vyc29yUG9zaXRpb24gLSBuZXcgY3Vyc29yIHBvc2l0aW9uXG4gICAqL1xuICBzZXRDdXJzb3Iocykge1xuICAgIHMgPCB0aGlzLml0ZW1zLmxlbmd0aCAmJiBzID49IC0xICYmICh0aGlzLmRyb3BDdXJzb3IoKSwgdGhpcy5jdXJzb3IgPSBzLCB0aGlzLml0ZW1zW3RoaXMuY3Vyc29yXS5jbGFzc0xpc3QuYWRkKHRoaXMuZm9jdXNlZENzc0NsYXNzKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgaXRlbXMuIENhbiBiZSB1c2VkIHdoZW4gaXRlcmFibGUgaXRlbXMgY2hhbmdlZCBkeW5hbWljYWxseVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W119IG5vZGVMaXN0IC0gbm9kZXMgdG8gaXRlcmF0ZVxuICAgKi9cbiAgc2V0SXRlbXMocykge1xuICAgIHRoaXMuaXRlbXMgPSBzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGN1cnNvciBuZXh0IHRvIHRoZSBjdXJyZW50XG4gICAqL1xuICBuZXh0KCkge1xuICAgIHRoaXMuY3Vyc29yID0gdGhpcy5sZWFmTm9kZXNBbmRSZXR1cm5JbmRleChoZS5kaXJlY3Rpb25zLlJJR0hUKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBjdXJzb3IgYmVmb3JlIGN1cnJlbnRcbiAgICovXG4gIHByZXZpb3VzKCkge1xuICAgIHRoaXMuY3Vyc29yID0gdGhpcy5sZWFmTm9kZXNBbmRSZXR1cm5JbmRleChoZS5kaXJlY3Rpb25zLkxFRlQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGN1cnNvciB0byB0aGUgZGVmYXVsdCBwb3NpdGlvbiBhbmQgcmVtb3ZlcyBDU1MtY2xhc3MgZnJvbSBwcmV2aW91c2x5IGZvY3VzZWQgaXRlbVxuICAgKi9cbiAgZHJvcEN1cnNvcigpIHtcbiAgICB0aGlzLmN1cnNvciAhPT0gLTEgJiYgKHRoaXMuaXRlbXNbdGhpcy5jdXJzb3JdLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5mb2N1c2VkQ3NzQ2xhc3MpLCB0aGlzLmN1cnNvciA9IC0xKTtcbiAgfVxuICAvKipcbiAgICogTGVhZnMgbm9kZXMgaW5zaWRlIHRoZSB0YXJnZXQgbGlzdCBmcm9tIGFjdGl2ZSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gLSBsZWFmIGRpcmVjdGlvbi4gQ2FuIGJlICdsZWZ0JyBvciAncmlnaHQnXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IGluZGV4IG9mIGZvY3VzZWQgbm9kZVxuICAgKi9cbiAgbGVhZk5vZGVzQW5kUmV0dXJuSW5kZXgocykge1xuICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmN1cnNvcjtcbiAgICBsZXQgZSA9IHRoaXMuY3Vyc29yO1xuICAgIHJldHVybiBlID09PSAtMSA/IGUgPSBzID09PSBoZS5kaXJlY3Rpb25zLlJJR0hUID8gLTEgOiAwIDogdGhpcy5pdGVtc1tlXS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZm9jdXNlZENzc0NsYXNzKSwgcyA9PT0gaGUuZGlyZWN0aW9ucy5SSUdIVCA/IGUgPSAoZSArIDEpICUgdGhpcy5pdGVtcy5sZW5ndGggOiBlID0gKHRoaXMuaXRlbXMubGVuZ3RoICsgZSAtIDEpICUgdGhpcy5pdGVtcy5sZW5ndGgsIGMuY2FuU2V0Q2FyZXQodGhpcy5pdGVtc1tlXSkgJiYgeGUoKCkgPT4gYi5zZXRDdXJzb3IodGhpcy5pdGVtc1tlXSksIDUwKSgpLCB0aGlzLml0ZW1zW2VdLmNsYXNzTGlzdC5hZGQodGhpcy5mb2N1c2VkQ3NzQ2xhc3MpLCBlO1xuICB9XG59O1xubGV0IG5lID0gaGU7XG5uZS5kaXJlY3Rpb25zID0ge1xuICBSSUdIVDogXCJyaWdodFwiLFxuICBMRUZUOiBcImxlZnRcIlxufTtcbmNsYXNzIHEge1xuICAvKipcbiAgICogQHBhcmFtIHtGbGlwcGVyT3B0aW9uc30gb3B0aW9ucyAtIGRpZmZlcmVudCBjb25zdHJ1Y3Rpbmcgc2V0dGluZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLml0ZXJhdG9yID0gbnVsbCwgdGhpcy5hY3RpdmF0ZWQgPSAhMSwgdGhpcy5mbGlwQ2FsbGJhY2tzID0gW10sIHRoaXMub25LZXlEb3duID0gKHQpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzRXZlbnRSZWFkeUZvckhhbmRsaW5nKHQpKVxuICAgICAgICBzd2l0Y2ggKHEudXNlZEtleXMuaW5jbHVkZXModC5rZXlDb2RlKSAmJiB0LnByZXZlbnREZWZhdWx0KCksIHQua2V5Q29kZSkge1xuICAgICAgICAgIGNhc2Ugdi5UQUI6XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRhYlByZXNzKHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB2LkxFRlQ6XG4gICAgICAgICAgY2FzZSB2LlVQOlxuICAgICAgICAgICAgdGhpcy5mbGlwTGVmdCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB2LlJJR0hUOlxuICAgICAgICAgIGNhc2Ugdi5ET1dOOlxuICAgICAgICAgICAgdGhpcy5mbGlwUmlnaHQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2Ugdi5FTlRFUjpcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRW50ZXJQcmVzcyh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSwgdGhpcy5pdGVyYXRvciA9IG5ldyBuZShlLml0ZW1zLCBlLmZvY3VzZWRJdGVtQ2xhc3MpLCB0aGlzLmFjdGl2YXRlQ2FsbGJhY2sgPSBlLmFjdGl2YXRlQ2FsbGJhY2ssIHRoaXMuYWxsb3dlZEtleXMgPSBlLmFsbG93ZWRLZXlzIHx8IHEudXNlZEtleXM7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgZmxpcHBlciBpcyBjdXJyZW50bHkgYWN0aXZhdGVkXG4gICAqL1xuICBnZXQgaXNBY3RpdmF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVkO1xuICB9XG4gIC8qKlxuICAgKiBBcnJheSBvZiBrZXlzIChjb2RlcykgdGhhdCBpcyBoYW5kbGVkIGJ5IEZsaXBwZXJcbiAgICogVXNlZCB0bzpcbiAgICogIC0gcHJldmVudERlZmF1bHQgb25seSBmb3IgdGhpcyBrZXlzLCBub3QgYWxsIGtleWRvd25zIChAc2VlIGNvbnN0cnVjdG9yKVxuICAgKiAgLSB0byBza2lwIGV4dGVybmFsIGJlaGF2aW91cnMgb25seSBmb3IgdGhlc2Uga2V5cywgd2hlbiBmaWxsZXIgaXMgYWN0aXZhdGVkIChAc2VlIEJsb2NrRXZlbnRzQGFycm93UmlnaHRBbmREb3duKVxuICAgKi9cbiAgc3RhdGljIGdldCB1c2VkS2V5cygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgdi5UQUIsXG4gICAgICB2LkxFRlQsXG4gICAgICB2LlJJR0hULFxuICAgICAgdi5FTlRFUixcbiAgICAgIHYuVVAsXG4gICAgICB2LkRPV05cbiAgICBdO1xuICB9XG4gIC8qKlxuICAgKiBBY3RpdmUgdGFiL2Fycm93cyBoYW5kbGluZyBieSBmbGlwcGVyXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtcyAtIFNvbWUgbW9kdWxlcyAobGlrZSwgSW5saW5lVG9vbGJhciwgQmxvY2tTZXR0aW5ncykgbWlnaHQgcmVmcmVzaCBidXR0b25zIGR5bmFtaWNhbGx5XG4gICAqIEBwYXJhbSBjdXJzb3JQb3NpdGlvbiAtIGluZGV4IG9mIHRoZSBpdGVtIHRoYXQgc2hvdWxkIGJlIGZvY3VzZWQgb25jZSBmbGlwcGVyIGlzIGFjdGl2YXRlZFxuICAgKi9cbiAgYWN0aXZhdGUoZSwgdCkge1xuICAgIHRoaXMuYWN0aXZhdGVkID0gITAsIGUgJiYgdGhpcy5pdGVyYXRvci5zZXRJdGVtcyhlKSwgdCAhPT0gdm9pZCAwICYmIHRoaXMuaXRlcmF0b3Iuc2V0Q3Vyc29yKHQpLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uS2V5RG93biwgITApO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlIHRhYi9hcnJvd3MgaGFuZGxpbmcgYnkgZmxpcHBlclxuICAgKi9cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFjdGl2YXRlZCA9ICExLCB0aGlzLmRyb3BDdXJzb3IoKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbktleURvd24pO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1cyBmaXJzdCBpdGVtXG4gICAqL1xuICBmb2N1c0ZpcnN0KCkge1xuICAgIHRoaXMuZHJvcEN1cnNvcigpLCB0aGlzLmZsaXBSaWdodCgpO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1c2VzIHByZXZpb3VzIGZsaXBwZXIgaXRlcmF0b3IgaXRlbVxuICAgKi9cbiAgZmxpcExlZnQoKSB7XG4gICAgdGhpcy5pdGVyYXRvci5wcmV2aW91cygpLCB0aGlzLmZsaXBDYWxsYmFjaygpO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1c2VzIG5leHQgZmxpcHBlciBpdGVyYXRvciBpdGVtXG4gICAqL1xuICBmbGlwUmlnaHQoKSB7XG4gICAgdGhpcy5pdGVyYXRvci5uZXh0KCksIHRoaXMuZmxpcENhbGxiYWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHNvbWUgYnV0dG9uIGlzIGZvY3VzZWRcbiAgICovXG4gIGhhc0ZvY3VzKCkge1xuICAgIHJldHVybiAhIXRoaXMuaXRlcmF0b3IuY3VycmVudEl0ZW07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyZXMgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQgb24gZWFjaCBuYXZpZ2F0aW9uIGFjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gY2IgLSBmdW5jdGlvbiB0byBleGVjdXRlXG4gICAqL1xuICBvbkZsaXAoZSkge1xuICAgIHRoaXMuZmxpcENhbGxiYWNrcy5wdXNoKGUpO1xuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyZXMgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBvbiBlYWNoIG5hdmlnYXRpb24gYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBjYiAtIGZ1bmN0aW9uIHRvIHN0b3AgZXhlY3V0aW5nXG4gICAqL1xuICByZW1vdmVPbkZsaXAoZSkge1xuICAgIHRoaXMuZmxpcENhbGxiYWNrcyA9IHRoaXMuZmxpcENhbGxiYWNrcy5maWx0ZXIoKHQpID0+IHQgIT09IGUpO1xuICB9XG4gIC8qKlxuICAgKiBEcm9wcyBmbGlwcGVyJ3MgaXRlcmF0b3IgY3Vyc29yXG4gICAqXG4gICAqIEBzZWUgRG9tSXRlcmF0b3IjZHJvcEN1cnNvclxuICAgKi9cbiAgZHJvcEN1cnNvcigpIHtcbiAgICB0aGlzLml0ZXJhdG9yLmRyb3BDdXJzb3IoKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBmaXJlZCBiZWZvcmUgaGFuZGxpbmcgZmxpcHBlciBrZXljb2Rlc1xuICAgKiBUaGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gZGVmaW5lcyBpZiBpdCBpcyBuZWVkIHRvIGJlIGhhbmRsZWQgb3Igbm90XG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duIGtleWJvYXJkIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNFdmVudFJlYWR5Rm9ySGFuZGxpbmcoZSkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2YXRlZCAmJiB0aGlzLmFsbG93ZWRLZXlzLmluY2x1ZGVzKGUua2V5Q29kZSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gZmxpcHBlciBpcyBhY3RpdmF0ZWQgdGFiIHByZXNzIHdpbGwgbGVhZiB0aGUgaXRlbXNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIHRhYiBrZXlkb3duIGV2ZW50XG4gICAqL1xuICBoYW5kbGVUYWJQcmVzcyhlKSB7XG4gICAgc3dpdGNoIChlLnNoaWZ0S2V5ID8gbmUuZGlyZWN0aW9ucy5MRUZUIDogbmUuZGlyZWN0aW9ucy5SSUdIVCkge1xuICAgICAgY2FzZSBuZS5kaXJlY3Rpb25zLlJJR0hUOlxuICAgICAgICB0aGlzLmZsaXBSaWdodCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbmUuZGlyZWN0aW9ucy5MRUZUOlxuICAgICAgICB0aGlzLmZsaXBMZWZ0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW50ZXIgcHJlc3Mgd2lsbCBjbGljayBjdXJyZW50IGl0ZW0gaWYgZmxpcHBlciBpcyBhY3RpdmF0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGVudGVyIGtleWRvd24gZXZlbnRcbiAgICovXG4gIGhhbmRsZUVudGVyUHJlc3MoZSkge1xuICAgIHRoaXMuYWN0aXZhdGVkICYmICh0aGlzLml0ZXJhdG9yLmN1cnJlbnRJdGVtICYmIChlLnN0b3BQcm9wYWdhdGlvbigpLCBlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuaXRlcmF0b3IuY3VycmVudEl0ZW0uY2xpY2soKSksIE0odGhpcy5hY3RpdmF0ZUNhbGxiYWNrKSAmJiB0aGlzLmFjdGl2YXRlQ2FsbGJhY2sodGhpcy5pdGVyYXRvci5jdXJyZW50SXRlbSkpO1xuICB9XG4gIC8qKlxuICAgKiBGaXJlZCBhZnRlciBmbGlwcGluZyBpbiBhbnkgZGlyZWN0aW9uXG4gICAqL1xuICBmbGlwQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5pdGVyYXRvci5jdXJyZW50SXRlbSAmJiB0aGlzLml0ZXJhdG9yLmN1cnJlbnRJdGVtLnNjcm9sbEludG9WaWV3SWZOZWVkZWQoKSwgdGhpcy5mbGlwQ2FsbGJhY2tzLmZvckVhY2goKGUpID0+IGUoKSk7XG4gIH1cbn1cbmNsYXNzIHBlIHtcbiAgLyoqXG4gICAqIFN0eWxlc1xuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyYXBwZXI6IFwiY2R4LXNlYXJjaC1maWVsZFwiLFxuICAgICAgaWNvbjogXCJjZHgtc2VhcmNoLWZpZWxkX19pY29uXCIsXG4gICAgICBpbnB1dDogXCJjZHgtc2VhcmNoLWZpZWxkX19pbnB1dFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBhdmFpbGFibGUgY29uZmlnXG4gICAqIEBwYXJhbSBvcHRpb25zLml0ZW1zIC0gc2VhcmNoYWJsZSBpdGVtcyBsaXN0XG4gICAqIEBwYXJhbSBvcHRpb25zLm9uU2VhcmNoIC0gc2VhcmNoIGNhbGxiYWNrXG4gICAqIEBwYXJhbSBvcHRpb25zLnBsYWNlaG9sZGVyIC0gaW5wdXQgcGxhY2Vob2xkZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgaXRlbXM6IGUsIG9uU2VhcmNoOiB0LCBwbGFjZWhvbGRlcjogbyB9KSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgRmUoKSwgdGhpcy5pdGVtcyA9IGUsIHRoaXMub25TZWFyY2ggPSB0LCB0aGlzLnJlbmRlcihvKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzZWFyY2ggZmllbGQgZWxlbWVudFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGZvY3VzIHRvIHRoZSBpbnB1dFxuICAgKi9cbiAgZm9jdXMoKSB7XG4gICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgc2VhcmNoIHF1ZXJ5IGFuZCByZXN1bHRzXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmlucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5zZWFyY2hRdWVyeSA9IFwiXCIsIHRoaXMub25TZWFyY2goXCJcIiwgdGhpcy5mb3VuZEl0ZW1zKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIG1lbW9yeVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5yZW1vdmVBbGwoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgc2VhcmNoIGZpZWxkXG4gICAqXG4gICAqIEBwYXJhbSBwbGFjZWhvbGRlciAtIGlucHV0IHBsYWNlaG9sZGVyXG4gICAqL1xuICByZW5kZXIoZSkge1xuICAgIHRoaXMud3JhcHBlciA9IGMubWFrZShcImRpdlwiLCBwZS5DU1Mud3JhcHBlcik7XG4gICAgY29uc3QgdCA9IGMubWFrZShcImRpdlwiLCBwZS5DU1MuaWNvbiwge1xuICAgICAgaW5uZXJIVE1MOiBIb1xuICAgIH0pO1xuICAgIHRoaXMuaW5wdXQgPSBjLm1ha2UoXCJpbnB1dFwiLCBwZS5DU1MuaW5wdXQsIHtcbiAgICAgIHBsYWNlaG9sZGVyOiBlLFxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHByZXZlbnQgZm9jdXNpbmcgb24gdGhlIGlucHV0IGJ5IFRhYiBrZXlcbiAgICAgICAqIChQb3BvdmVyIGluIHRoZSBUb29sYmFyIGxheXMgYmVsb3cgdGhlIGJsb2NrcyxcbiAgICAgICAqIHNvIFRhYiBpbiB0aGUgbGFzdCBibG9jayB3aWxsIGZvY3VzIHRoaXMgaGlkZGVuIGlucHV0IGlmIHRoaXMgcHJvcGVydHkgaXMgbm90IHNldClcbiAgICAgICAqL1xuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSksIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0KSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuaW5wdXQpLCB0aGlzLmxpc3RlbmVycy5vbih0aGlzLmlucHV0LCBcImlucHV0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuc2VhcmNoUXVlcnkgPSB0aGlzLmlucHV0LnZhbHVlLCB0aGlzLm9uU2VhcmNoKHRoaXMuc2VhcmNoUXVlcnksIHRoaXMuZm91bmRJdGVtcyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCBvZiBmb3VuZCBpdGVtcyBmb3IgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5XG4gICAqL1xuICBnZXQgZm91bmRJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoKGUpID0+IHRoaXMuY2hlY2tJdGVtKGUpKTtcbiAgfVxuICAvKipcbiAgICogQ29udGFpbnMgbG9naWMgZm9yIGNoZWNraW5nIHdoZXRoZXIgcGFzc2VkIGl0ZW0gY29uZm9ybXMgdGhlIHNlYXJjaCBxdWVyeVxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gdG8gYmUgY2hlY2tlZFxuICAgKi9cbiAgY2hlY2tJdGVtKGUpIHtcbiAgICB2YXIgaTtcbiAgICBjb25zdCB0ID0gKChpID0gZS50aXRsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGkudG9Mb3dlckNhc2UoKSkgfHwgXCJcIiwgbyA9IHRoaXMuc2VhcmNoUXVlcnkudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gdC5pbmNsdWRlcyhvKTtcbiAgfVxufVxuY29uc3QgdWUgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBMb2NrcyBib2R5IGVsZW1lbnQgc2Nyb2xsXG4gICAqL1xuICBsb2NrKCkge1xuICAgIHR0ID8gdGhpcy5sb2NrSGFyZCgpIDogZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKHVlLkNTUy5zY3JvbGxMb2NrZWQpO1xuICB9XG4gIC8qKlxuICAgKiBVbmxvY2tzIGJvZHkgZWxlbWVudCBzY3JvbGxcbiAgICovXG4gIHVubG9jaygpIHtcbiAgICB0dCA/IHRoaXMudW5sb2NrSGFyZCgpIDogZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKHVlLkNTUy5zY3JvbGxMb2NrZWQpO1xuICB9XG4gIC8qKlxuICAgKiBMb2NrcyBzY3JvbGwgaW4gYSBoYXJkIHdheSAodmlhIHNldHRpbmcgZml4ZWQgcG9zaXRpb24gdG8gYm9keSBlbGVtZW50KVxuICAgKi9cbiAgbG9ja0hhcmQoKSB7XG4gICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IHdpbmRvdy5wYWdlWU9mZnNldCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgXCItLXdpbmRvdy1zY3JvbGwtb2Zmc2V0XCIsXG4gICAgICBgJHt0aGlzLnNjcm9sbFBvc2l0aW9ufXB4YFxuICAgICksIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCh1ZS5DU1Muc2Nyb2xsTG9ja2VkSGFyZCk7XG4gIH1cbiAgLyoqXG4gICAqIFVubG9ja3MgaGFyZCBzY3JvbGwgbG9ja1xuICAgKi9cbiAgdW5sb2NrSGFyZCgpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUodWUuQ1NTLnNjcm9sbExvY2tlZEhhcmQpLCB0aGlzLnNjcm9sbFBvc2l0aW9uICE9PSBudWxsICYmIHdpbmRvdy5zY3JvbGxUbygwLCB0aGlzLnNjcm9sbFBvc2l0aW9uKSwgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gIH1cbn07XG5sZXQgdnQgPSB1ZTtcbnZ0LkNTUyA9IHtcbiAgc2Nyb2xsTG9ja2VkOiBcImNlLXNjcm9sbC1sb2NrZWRcIixcbiAgc2Nyb2xsTG9ja2VkSGFyZDogXCJjZS1zY3JvbGwtbG9ja2VkLS1oYXJkXCJcbn07XG52YXIgam8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHksICRvID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwgV28gPSAocywgZSwgdCwgbykgPT4ge1xuICBmb3IgKHZhciBpID0gbyA+IDEgPyB2b2lkIDAgOiBvID8gJG8oZSwgdCkgOiBlLCBuID0gcy5sZW5ndGggLSAxLCByOyBuID49IDA7IG4tLSlcbiAgICAociA9IHNbbl0pICYmIChpID0gKG8gPyByKGUsIHQsIGkpIDogcihpKSkgfHwgaSk7XG4gIHJldHVybiBvICYmIGkgJiYgam8oZSwgdCwgaSksIGk7XG59LCBiZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzLkNsb3NlID0gXCJjbG9zZVwiLCBzKSkoYmUgfHwge30pO1xuY29uc3QgTiA9IGNsYXNzIGV4dGVuZHMgRWUge1xuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIHBvcG92ZXIgY29uc3RydWN0aW9uIHBhcmFtc1xuICAgKi9cbiAgY29uc3RydWN0b3Iocykge1xuICAgIHN1cGVyKCksIHRoaXMuc2NvcGVFbGVtZW50ID0gZG9jdW1lbnQuYm9keSwgdGhpcy5saXN0ZW5lcnMgPSBuZXcgRmUoKSwgdGhpcy5zY3JvbGxMb2NrZXIgPSBuZXcgdnQoKSwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIHdyYXBwZXI6IG51bGwsXG4gICAgICBwb3BvdmVyOiBudWxsLFxuICAgICAgbm90aGluZ0ZvdW5kTWVzc2FnZTogbnVsbCxcbiAgICAgIGN1c3RvbUNvbnRlbnQ6IG51bGwsXG4gICAgICBpdGVtczogbnVsbCxcbiAgICAgIG92ZXJsYXk6IG51bGxcbiAgICB9LCB0aGlzLm1lc3NhZ2VzID0ge1xuICAgICAgbm90aGluZ0ZvdW5kOiBcIk5vdGhpbmcgZm91bmRcIixcbiAgICAgIHNlYXJjaDogXCJTZWFyY2hcIlxuICAgIH0sIHRoaXMub25GbGlwID0gKCkgPT4ge1xuICAgICAgdGhpcy5pdGVtcy5maW5kKCh0KSA9PiB0LmlzRm9jdXNlZCkub25Gb2N1cygpO1xuICAgIH0sIHRoaXMuaXRlbXMgPSBzLml0ZW1zLm1hcCgoZSkgPT4gbmV3IF8oZSkpLCBzLnNjb3BlRWxlbWVudCAhPT0gdm9pZCAwICYmICh0aGlzLnNjb3BlRWxlbWVudCA9IHMuc2NvcGVFbGVtZW50KSwgcy5tZXNzYWdlcyAmJiAodGhpcy5tZXNzYWdlcyA9IHtcbiAgICAgIC4uLnRoaXMubWVzc2FnZXMsXG4gICAgICAuLi5zLm1lc3NhZ2VzXG4gICAgfSksIHMuY3VzdG9tQ29udGVudEZsaXBwYWJsZUl0ZW1zICYmICh0aGlzLmN1c3RvbUNvbnRlbnRGbGlwcGFibGVJdGVtcyA9IHMuY3VzdG9tQ29udGVudEZsaXBwYWJsZUl0ZW1zKSwgdGhpcy5tYWtlKCksIHMuY3VzdG9tQ29udGVudCAmJiB0aGlzLmFkZEN1c3RvbUNvbnRlbnQocy5jdXN0b21Db250ZW50KSwgcy5zZWFyY2hhYmxlICYmIHRoaXMuYWRkU2VhcmNoKCksIHRoaXMuaW5pdGlhbGl6ZUZsaXBwZXIoKTtcbiAgfVxuICAvKipcbiAgICogUG9wb3ZlciBDU1MgY2xhc3Nlc1xuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcG92ZXI6IFwiY2UtcG9wb3ZlclwiLFxuICAgICAgcG9wb3Zlck9wZW5Ub3A6IFwiY2UtcG9wb3Zlci0tb3Blbi10b3BcIixcbiAgICAgIHBvcG92ZXJPcGVuZWQ6IFwiY2UtcG9wb3Zlci0tb3BlbmVkXCIsXG4gICAgICBzZWFyY2g6IFwiY2UtcG9wb3Zlcl9fc2VhcmNoXCIsXG4gICAgICBub3RoaW5nRm91bmRNZXNzYWdlOiBcImNlLXBvcG92ZXJfX25vdGhpbmctZm91bmQtbWVzc2FnZVwiLFxuICAgICAgbm90aGluZ0ZvdW5kTWVzc2FnZURpc3BsYXllZDogXCJjZS1wb3BvdmVyX19ub3RoaW5nLWZvdW5kLW1lc3NhZ2UtLWRpc3BsYXllZFwiLFxuICAgICAgY3VzdG9tQ29udGVudDogXCJjZS1wb3BvdmVyX19jdXN0b20tY29udGVudFwiLFxuICAgICAgY3VzdG9tQ29udGVudEhpZGRlbjogXCJjZS1wb3BvdmVyX19jdXN0b20tY29udGVudC0taGlkZGVuXCIsXG4gICAgICBpdGVtczogXCJjZS1wb3BvdmVyX19pdGVtc1wiLFxuICAgICAgb3ZlcmxheTogXCJjZS1wb3BvdmVyX19vdmVybGF5XCIsXG4gICAgICBvdmVybGF5SGlkZGVuOiBcImNlLXBvcG92ZXJfX292ZXJsYXktLWhpZGRlblwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBIVE1MIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGUgcG9wb3ZlclxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgc29tZSBpdGVtIGluc2lkZSBwb3BvdmVyIGlzIGZvY3VzZWRcbiAgICovXG4gIGhhc0ZvY3VzKCkge1xuICAgIHJldHVybiB0aGlzLmZsaXBwZXIuaGFzRm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogT3BlbiBwb3BvdmVyXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMuc2hvdWxkT3BlbkJvdHRvbSB8fCAodGhpcy5ub2Rlcy5wb3BvdmVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1wb3BvdmVyLWhlaWdodFwiLCB0aGlzLmhlaWdodCArIFwicHhcIiksIHRoaXMubm9kZXMucG9wb3Zlci5jbGFzc0xpc3QuYWRkKE4uQ1NTLnBvcG92ZXJPcGVuVG9wKSksIHRoaXMubm9kZXMub3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKE4uQ1NTLm92ZXJsYXlIaWRkZW4pLCB0aGlzLm5vZGVzLnBvcG92ZXIuY2xhc3NMaXN0LmFkZChOLkNTUy5wb3BvdmVyT3BlbmVkKSwgdGhpcy5mbGlwcGVyLmFjdGl2YXRlKHRoaXMuZmxpcHBhYmxlRWxlbWVudHMpLCB0aGlzLnNlYXJjaCAhPT0gdm9pZCAwICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB2YXIgcztcbiAgICAgIChzID0gdGhpcy5zZWFyY2gpID09IG51bGwgfHwgcy5mb2N1cygpO1xuICAgIH0pLCB0ZSgpICYmIHRoaXMuc2Nyb2xsTG9ja2VyLmxvY2soKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHBvcG92ZXJcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5ub2Rlcy5wb3BvdmVyLmNsYXNzTGlzdC5yZW1vdmUoTi5DU1MucG9wb3Zlck9wZW5lZCksIHRoaXMubm9kZXMucG9wb3Zlci5jbGFzc0xpc3QucmVtb3ZlKE4uQ1NTLnBvcG92ZXJPcGVuVG9wKSwgdGhpcy5ub2Rlcy5vdmVybGF5LmNsYXNzTGlzdC5hZGQoTi5DU1Mub3ZlcmxheUhpZGRlbiksIHRoaXMuZmxpcHBlci5kZWFjdGl2YXRlKCksIHRoaXMuaXRlbXMuZm9yRWFjaCgocykgPT4gcy5yZXNldCgpKSwgdGhpcy5zZWFyY2ggIT09IHZvaWQgMCAmJiB0aGlzLnNlYXJjaC5jbGVhcigpLCB0ZSgpICYmIHRoaXMuc2Nyb2xsTG9ja2VyLnVubG9jaygpLCB0aGlzLmVtaXQoXG4gICAgICBcImNsb3NlXCJcbiAgICAgIC8qIENsb3NlICovXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIG1lbW9yeVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmZsaXBwZXIuZGVhY3RpdmF0ZSgpLCB0aGlzLmxpc3RlbmVycy5yZW1vdmVBbGwoKSwgdGUoKSAmJiB0aGlzLnNjcm9sbExvY2tlci51bmxvY2soKTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cyBIVE1MIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byBwb3BvdmVyXG4gICAqL1xuICBtYWtlKCkge1xuICAgIHRoaXMubm9kZXMucG9wb3ZlciA9IGMubWFrZShcImRpdlwiLCBbTi5DU1MucG9wb3Zlcl0pLCB0aGlzLm5vZGVzLm5vdGhpbmdGb3VuZE1lc3NhZ2UgPSBjLm1ha2UoXCJkaXZcIiwgW04uQ1NTLm5vdGhpbmdGb3VuZE1lc3NhZ2VdLCB7XG4gICAgICB0ZXh0Q29udGVudDogdGhpcy5tZXNzYWdlcy5ub3RoaW5nRm91bmRcbiAgICB9KSwgdGhpcy5ub2Rlcy5wb3BvdmVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMubm90aGluZ0ZvdW5kTWVzc2FnZSksIHRoaXMubm9kZXMuaXRlbXMgPSBjLm1ha2UoXCJkaXZcIiwgW04uQ1NTLml0ZW1zXSksIHRoaXMuaXRlbXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgdGhpcy5ub2Rlcy5pdGVtcy5hcHBlbmRDaGlsZChzLmdldEVsZW1lbnQoKSk7XG4gICAgfSksIHRoaXMubm9kZXMucG9wb3Zlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLml0ZW1zKSwgdGhpcy5saXN0ZW5lcnMub24odGhpcy5ub2Rlcy5wb3BvdmVyLCBcImNsaWNrXCIsIChzKSA9PiB7XG4gICAgICBjb25zdCBlID0gdGhpcy5nZXRUYXJnZXRJdGVtKHMpO1xuICAgICAgZSAhPT0gdm9pZCAwICYmIHRoaXMuaGFuZGxlSXRlbUNsaWNrKGUpO1xuICAgIH0pLCB0aGlzLm5vZGVzLndyYXBwZXIgPSBjLm1ha2UoXCJkaXZcIiksIHRoaXMubm9kZXMub3ZlcmxheSA9IGMubWFrZShcImRpdlwiLCBbTi5DU1Mub3ZlcmxheSwgTi5DU1Mub3ZlcmxheUhpZGRlbl0pLCB0aGlzLmxpc3RlbmVycy5vbih0aGlzLm5vZGVzLm92ZXJsYXksIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSksIHRoaXMubm9kZXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLm92ZXJsYXkpLCB0aGlzLm5vZGVzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5wb3BvdmVyKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBzZWFyY2ggdG8gdGhlIHBvcG92ZXJcbiAgICovXG4gIGFkZFNlYXJjaCgpIHtcbiAgICB0aGlzLnNlYXJjaCA9IG5ldyBwZSh7XG4gICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLm1lc3NhZ2VzLnNlYXJjaCxcbiAgICAgIG9uU2VhcmNoOiAoZSwgdCkgPT4ge1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgICBjb25zdCBuID0gIXQuaW5jbHVkZXMoaSk7XG4gICAgICAgICAgaS50b2dnbGVIaWRkZW4obik7XG4gICAgICAgIH0pLCB0aGlzLnRvZ2dsZU5vdGhpbmdGb3VuZE1lc3NhZ2UodC5sZW5ndGggPT09IDApLCB0aGlzLnRvZ2dsZUN1c3RvbUNvbnRlbnQoZSAhPT0gXCJcIik7XG4gICAgICAgIGNvbnN0IG8gPSBlID09PSBcIlwiID8gdGhpcy5mbGlwcGFibGVFbGVtZW50cyA6IHQubWFwKChpKSA9PiBpLmdldEVsZW1lbnQoKSk7XG4gICAgICAgIHRoaXMuZmxpcHBlci5pc0FjdGl2YXRlZCAmJiAodGhpcy5mbGlwcGVyLmRlYWN0aXZhdGUoKSwgdGhpcy5mbGlwcGVyLmFjdGl2YXRlKG8pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzID0gdGhpcy5zZWFyY2guZ2V0RWxlbWVudCgpO1xuICAgIHMuY2xhc3NMaXN0LmFkZChOLkNTUy5zZWFyY2gpLCB0aGlzLm5vZGVzLnBvcG92ZXIuaW5zZXJ0QmVmb3JlKHMsIHRoaXMubm9kZXMucG9wb3Zlci5maXJzdENoaWxkKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBjdXN0b20gaHRtbCBjb250ZW50IHRvIHRoZSBwb3BvdmVyXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZW50IC0gaHRtbCBjb250ZW50IHRvIGFwcGVuZFxuICAgKi9cbiAgYWRkQ3VzdG9tQ29udGVudChzKSB7XG4gICAgdGhpcy5ub2Rlcy5jdXN0b21Db250ZW50ID0gcywgdGhpcy5ub2Rlcy5jdXN0b21Db250ZW50LmNsYXNzTGlzdC5hZGQoTi5DU1MuY3VzdG9tQ29udGVudCksIHRoaXMubm9kZXMucG9wb3Zlci5pbnNlcnRCZWZvcmUocywgdGhpcy5ub2Rlcy5wb3BvdmVyLmZpcnN0Q2hpbGQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcG9wb3ZlciBpdGVtIHRoYXQgaXMgdGhlIHRhcmdldCBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IHRvIHJldHJpZXZlIHBvcG92ZXIgaXRlbSBmcm9tXG4gICAqL1xuICBnZXRUYXJnZXRJdGVtKHMpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maW5kKChlKSA9PiBzLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGUuZ2V0RWxlbWVudCgpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgaXRlbSBjbGlja3NcbiAgICpcbiAgICogQHBhcmFtIGl0ZW0gLSBpdGVtIHRvIGhhbmRsZSBjbGljayBvZlxuICAgKi9cbiAgaGFuZGxlSXRlbUNsaWNrKHMpIHtcbiAgICBzLmlzRGlzYWJsZWQgfHwgKHRoaXMuaXRlbXMuZmlsdGVyKChlKSA9PiBlICE9PSBzKS5mb3JFYWNoKChlKSA9PiBlLnJlc2V0KCkpLCBzLmhhbmRsZUNsaWNrKCksIHRoaXMudG9nZ2xlSXRlbUFjdGl2ZW5lc3NJZk5lZWRlZChzKSwgcy5jbG9zZU9uQWN0aXZhdGUgJiYgdGhpcy5oaWRlKCkpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIEZsaXBwZXIgaW5zdGFuY2Ugd2hpY2ggYWxsb3dzIHRvIG5hdmlnYXRlIGJldHdlZW4gcG9wb3ZlciBpdGVtcyB2aWEga2V5Ym9hcmRcbiAgICovXG4gIGluaXRpYWxpemVGbGlwcGVyKCkge1xuICAgIHRoaXMuZmxpcHBlciA9IG5ldyBxKHtcbiAgICAgIGl0ZW1zOiB0aGlzLmZsaXBwYWJsZUVsZW1lbnRzLFxuICAgICAgZm9jdXNlZEl0ZW1DbGFzczogXy5DU1MuZm9jdXNlZCxcbiAgICAgIGFsbG93ZWRLZXlzOiBbXG4gICAgICAgIHYuVEFCLFxuICAgICAgICB2LlVQLFxuICAgICAgICB2LkRPV04sXG4gICAgICAgIHYuRU5URVJcbiAgICAgIF1cbiAgICB9KSwgdGhpcy5mbGlwcGVyLm9uRmxpcCh0aGlzLm9uRmxpcCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCBvZiBlbGVtZW50cyBhdmFpbGFibGUgZm9yIGtleWJvYXJkIG5hdmlnYXRpb24uXG4gICAqIENvbnRhaW5zIGJvdGggdXN1YWwgcG9wb3ZlciBpdGVtcyBlbGVtZW50cyBhbmQgY3VzdG9tIGh0bWwgY29udGVudC5cbiAgICovXG4gIGdldCBmbGlwcGFibGVFbGVtZW50cygpIHtcbiAgICBjb25zdCBzID0gdGhpcy5pdGVtcy5tYXAoKHQpID0+IHQuZ2V0RWxlbWVudCgpKTtcbiAgICByZXR1cm4gKHRoaXMuY3VzdG9tQ29udGVudEZsaXBwYWJsZUl0ZW1zIHx8IFtdKS5jb25jYXQocyk7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICBsZXQgcyA9IDA7XG4gICAgaWYgKHRoaXMubm9kZXMucG9wb3ZlciA9PT0gbnVsbClcbiAgICAgIHJldHVybiBzO1xuICAgIGNvbnN0IGUgPSB0aGlzLm5vZGVzLnBvcG92ZXIuY2xvbmVOb2RlKCEwKTtcbiAgICByZXR1cm4gZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgZS5zdHlsZS50b3AgPSBcIi0xMDAwcHhcIiwgZS5jbGFzc0xpc3QuYWRkKE4uQ1NTLnBvcG92ZXJPcGVuZWQpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGUpLCBzID0gZS5vZmZzZXRIZWlnaHQsIGUucmVtb3ZlKCksIHM7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwb3BvdmVyIHNob3VsZCBiZSBvcGVuZWQgYm90dG9tLlxuICAgKiBJdCBzaG91bGQgaGFwcGVuIHdoZW4gdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGJlbG93IG9yIG5vdCBlbm91Z2ggc3BhY2UgYWJvdmVcbiAgICovXG4gIGdldCBzaG91bGRPcGVuQm90dG9tKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLm5vZGVzLnBvcG92ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGUgPSB0aGlzLnNjb3BlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdCA9IHRoaXMuaGVpZ2h0LCBvID0gcy50b3AgKyB0LCBpID0gcy50b3AgLSB0LCBuID0gTWF0aC5taW4od2luZG93LmlubmVySGVpZ2h0LCBlLmJvdHRvbSk7XG4gICAgcmV0dXJuIGkgPCBlLnRvcCB8fCBvIDw9IG47XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgbm90aGluZyBmb3VuZCBtZXNzYWdlIHZpc2liaWxpdHlcbiAgICpcbiAgICogQHBhcmFtIGlzRGlzcGxheWVkIC0gdHJ1ZSBpZiB0aGUgbWVzc2FnZSBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAqL1xuICB0b2dnbGVOb3RoaW5nRm91bmRNZXNzYWdlKHMpIHtcbiAgICB0aGlzLm5vZGVzLm5vdGhpbmdGb3VuZE1lc3NhZ2UuY2xhc3NMaXN0LnRvZ2dsZShOLkNTUy5ub3RoaW5nRm91bmRNZXNzYWdlRGlzcGxheWVkLCBzKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyBjdXN0b20gY29udGVudCB2aXNpYmlsaXR5XG4gICAqXG4gICAqIEBwYXJhbSBpc0Rpc3BsYXllZCAtIHRydWUgaWYgY3VzdG9tIGNvbnRlbnQgc2hvdWxkIGJlIGRpc3BsYXllZFxuICAgKi9cbiAgdG9nZ2xlQ3VzdG9tQ29udGVudChzKSB7XG4gICAgdmFyIGU7XG4gICAgKGUgPSB0aGlzLm5vZGVzLmN1c3RvbUNvbnRlbnQpID09IG51bGwgfHwgZS5jbGFzc0xpc3QudG9nZ2xlKE4uQ1NTLmN1c3RvbUNvbnRlbnRIaWRkZW4sIHMpO1xuICB9XG4gIC8qKlxuICAgKiAtIFRvZ2dsZXMgaXRlbSBhY3RpdmUgc3RhdGUsIGlmIGNsaWNrZWQgcG9wb3ZlciBpdGVtIGhhcyBwcm9wZXJ0eSAndG9nZ2xlJyBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogLSBQZXJmb3JtcyByYWRpb2J1dHRvbi1saWtlIGJlaGF2aW9yIGlmIHRoZSBpdGVtIGhhcyBwcm9wZXJ0eSAndG9nZ2xlJyBzZXQgdG8gc3RyaW5nIGtleS5cbiAgICogKEFsbCB0aGUgb3RoZXIgaXRlbXMgd2l0aCB0aGUgc2FtZSBrZXkgZ2V0IGluYWN0aXZlLCBhbmQgdGhlIGl0ZW0gZ2V0cyBhY3RpdmUpXG4gICAqXG4gICAqIEBwYXJhbSBjbGlja2VkSXRlbSAtIHBvcG92ZXIgaXRlbSB0aGF0IHdhcyBjbGlja2VkXG4gICAqL1xuICB0b2dnbGVJdGVtQWN0aXZlbmVzc0lmTmVlZGVkKHMpIHtcbiAgICBpZiAocy50b2dnbGUgPT09ICEwICYmIHMudG9nZ2xlQWN0aXZlKCksIHR5cGVvZiBzLnRvZ2dsZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5pdGVtcy5maWx0ZXIoKHQpID0+IHQudG9nZ2xlID09PSBzLnRvZ2dsZSk7XG4gICAgICBpZiAoZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcy50b2dnbGVBY3RpdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIHQudG9nZ2xlQWN0aXZlKHQgPT09IHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xubGV0IGplID0gTjtcbldvKFtcbiAgbGVcbl0sIGplLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgMSk7XG5jbGFzcyBZbyBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLm9wZW5lZCA9ICExLCB0aGlzLnNlbGVjdGlvbiA9IG5ldyBiKCksIHRoaXMub25Qb3BvdmVyQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlIEV2ZW50c1xuICAgKlxuICAgKiBAcmV0dXJucyB7e29wZW5lZDogc3RyaW5nLCBjbG9zZWQ6IHN0cmluZ319XG4gICAqL1xuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuZWQ6IFwiYmxvY2stc2V0dGluZ3Mtb3BlbmVkXCIsXG4gICAgICBjbG9zZWQ6IFwiYmxvY2stc2V0dGluZ3MtY2xvc2VkXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBCbG9jayBTZXR0aW5ncyBDU1NcbiAgICovXG4gIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldHRpbmdzOiBcImNlLXNldHRpbmdzXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIGlubmVyIHBvcG92ZXIncyBmbGlwcGVyIGluc3RhbmNlXG4gICAqXG4gICAqIEB0b2RvIHJlbW92ZSBvbmNlIEJsb2NrU2V0dGluZ3MgYmVjb21lcyBzdGFuZGFsb25lIG5vbi1tb2R1bGUgY2xhc3NcbiAgICovXG4gIGdldCBmbGlwcGVyKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiAoZSA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZmxpcHBlcjtcbiAgfVxuICAvKipcbiAgICogUGFuZWwgd2l0aCBibG9jayBzZXR0aW5ncyB3aXRoIDIgc2VjdGlvbnM6XG4gICAqICAtIFRvb2wncyBTZXR0aW5nc1xuICAgKiAgLSBEZWZhdWx0IFNldHRpbmdzIFtNb3ZlLCBSZW1vdmUsIGV0Y11cbiAgICovXG4gIG1ha2UoKSB7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyID0gYy5tYWtlKFwiZGl2XCIsIFt0aGlzLkNTUy5zZXR0aW5nc10pO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyBtb2R1bGVcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxOb2RlcygpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIEJsb2NrIFNldHRpbmdzIHBhbmVcbiAgICpcbiAgICogQHBhcmFtIHRhcmdldEJsb2NrIC0gbmVhciB3aGljaCBCbG9jayB3ZSBzaG91bGQgb3BlbiBCbG9ja1NldHRpbmdzXG4gICAqL1xuICBvcGVuKGUgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrKSB7XG4gICAgdGhpcy5vcGVuZWQgPSAhMCwgdGhpcy5zZWxlY3Rpb24uc2F2ZSgpLCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5zZWxlY3RCbG9jayhlKSwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJDYWNoZSgpO1xuICAgIGNvbnN0IFt0LCBvXSA9IGUuZ2V0VHVuZXMoKTtcbiAgICB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIuZW1pdCh0aGlzLmV2ZW50cy5vcGVuZWQpLCB0aGlzLnBvcG92ZXIgPSBuZXcgamUoe1xuICAgICAgc2VhcmNoYWJsZTogITAsXG4gICAgICBpdGVtczogdC5tYXAoKGkpID0+IHRoaXMucmVzb2x2ZVR1bmVBbGlhc2VzKGkpKSxcbiAgICAgIGN1c3RvbUNvbnRlbnQ6IG8sXG4gICAgICBjdXN0b21Db250ZW50RmxpcHBhYmxlSXRlbXM6IHRoaXMuZ2V0Q29udHJvbHMobyksXG4gICAgICBzY29wZUVsZW1lbnQ6IHRoaXMuRWRpdG9yLkFQSS5tZXRob2RzLnVpLm5vZGVzLnJlZGFjdG9yLFxuICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgbm90aGluZ0ZvdW5kOiB6LnVpKEsudWkucG9wb3ZlciwgXCJOb3RoaW5nIGZvdW5kXCIpLFxuICAgICAgICBzZWFyY2g6IHoudWkoSy51aS5wb3BvdmVyLCBcIkZpbHRlclwiKVxuICAgICAgfVxuICAgIH0pLCB0aGlzLnBvcG92ZXIub24oYmUuQ2xvc2UsIHRoaXMub25Qb3BvdmVyQ2xvc2UpLCB0aGlzLm5vZGVzLndyYXBwZXIuYXBwZW5kKHRoaXMucG9wb3Zlci5nZXRFbGVtZW50KCkpLCB0aGlzLnBvcG92ZXIuc2hvdygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHJvb3QgYmxvY2sgc2V0dGluZ3MgZWxlbWVudFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBCbG9jayBTZXR0aW5ncyBwYW5lXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLm9wZW5lZCAmJiAodGhpcy5vcGVuZWQgPSAhMSwgYi5pc0F0RWRpdG9yIHx8IHRoaXMuc2VsZWN0aW9uLnJlc3RvcmUoKSwgdGhpcy5zZWxlY3Rpb24uY2xlYXJTYXZlZCgpLCAhdGhpcy5FZGl0b3IuQ3Jvc3NCbG9ja1NlbGVjdGlvbi5pc0Nyb3NzQmxvY2tTZWxlY3Rpb25TdGFydGVkICYmIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24udW5zZWxlY3RCbG9jayh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrKSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyLmVtaXQodGhpcy5ldmVudHMuY2xvc2VkKSwgdGhpcy5wb3BvdmVyICYmICh0aGlzLnBvcG92ZXIub2ZmKGJlLkNsb3NlLCB0aGlzLm9uUG9wb3ZlckNsb3NlKSwgdGhpcy5wb3BvdmVyLmRlc3Ryb3koKSwgdGhpcy5wb3BvdmVyLmdldEVsZW1lbnQoKS5yZW1vdmUoKSwgdGhpcy5wb3BvdmVyID0gbnVsbCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgYnV0dG9ucyBhbmQgaW5wdXRzIGluc2lkZSBzcGVjaWZpZWQgY29udGFpbmVyXG4gICAqXG4gICAqIEBwYXJhbSBjb250YWluZXIgLSBjb250YWluZXIgdG8gcXVlcnkgY29udHJvbHMgaW5zaWRlIG9mXG4gICAqL1xuICBnZXRDb250cm9scyhlKSB7XG4gICAgY29uc3QgeyBTdHlsZXNBUEk6IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gZS5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgYC4ke3QuY2xhc3Nlcy5zZXR0aW5nc0J1dHRvbn0sICR7Yy5hbGxJbnB1dHNTZWxlY3Rvcn1gXG4gICAgKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZXMgYWxpYXNlcyBpbiB0dW5lcyBtZW51IGl0ZW1zXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB3aXRoIHJlc29sdmVkIGFsaWFzZXNcbiAgICovXG4gIHJlc29sdmVUdW5lQWxpYXNlcyhlKSB7XG4gICAgY29uc3QgdCA9IEFvKGUsIHsgbGFiZWw6IFwidGl0bGVcIiB9KTtcbiAgICByZXR1cm4gZS5jb25maXJtYXRpb24gJiYgKHQuY29uZmlybWF0aW9uID0gdGhpcy5yZXNvbHZlVHVuZUFsaWFzZXMoZS5jb25maXJtYXRpb24pKSwgdDtcbiAgfVxufVxuY2xhc3MgJCBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLm9wZW5lZCA9ICExLCB0aGlzLnRvb2xzID0gW10sIHRoaXMuZmxpcHBlciA9IG51bGwsIHRoaXMudG9nZ2xpbmdDYWxsYmFjayA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENTUyBnZXR0ZXJcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb252ZXJzaW9uVG9vbGJhcldyYXBwZXI6IFwiY2UtY29udmVyc2lvbi10b29sYmFyXCIsXG4gICAgICBjb252ZXJzaW9uVG9vbGJhclNob3dlZDogXCJjZS1jb252ZXJzaW9uLXRvb2xiYXItLXNob3dlZFwiLFxuICAgICAgY29udmVyc2lvblRvb2xiYXJUb29sczogXCJjZS1jb252ZXJzaW9uLXRvb2xiYXJfX3Rvb2xzXCIsXG4gICAgICBjb252ZXJzaW9uVG9vbGJhckxhYmVsOiBcImNlLWNvbnZlcnNpb24tdG9vbGJhcl9fbGFiZWxcIixcbiAgICAgIGNvbnZlcnNpb25Ub29sOiBcImNlLWNvbnZlcnNpb24tdG9vbFwiLFxuICAgICAgY29udmVyc2lvblRvb2xIaWRkZW46IFwiY2UtY29udmVyc2lvbi10b29sLS1oaWRkZW5cIixcbiAgICAgIGNvbnZlcnNpb25Ub29sSWNvbjogXCJjZS1jb252ZXJzaW9uLXRvb2xfX2ljb25cIixcbiAgICAgIGNvbnZlcnNpb25Ub29sU2Vjb25kYXJ5TGFiZWw6IFwiY2UtY29udmVyc2lvbi10b29sX19zZWNvbmRhcnktbGFiZWxcIixcbiAgICAgIGNvbnZlcnNpb25Ub29sRm9jdXNlZDogXCJjZS1jb252ZXJzaW9uLXRvb2wtLWZvY3VzZWRcIixcbiAgICAgIGNvbnZlcnNpb25Ub29sQWN0aXZlOiBcImNlLWNvbnZlcnNpb24tdG9vbC0tYWN0aXZlXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgVUkgb2YgQ29udmVyc2lvbiBUb29sYmFyXG4gICAqL1xuICBtYWtlKCkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlciA9IGMubWFrZShcImRpdlwiLCBbXG4gICAgICAkLkNTUy5jb252ZXJzaW9uVG9vbGJhcldyYXBwZXIsXG4gICAgICAuLi50aGlzLmlzUnRsID8gW3RoaXMuRWRpdG9yLlVJLkNTUy5lZGl0b3JSdGxGaXhdIDogW11cbiAgICBdKSwgdGhpcy5ub2Rlcy50b29scyA9IGMubWFrZShcImRpdlwiLCAkLkNTUy5jb252ZXJzaW9uVG9vbGJhclRvb2xzKTtcbiAgICBjb25zdCBlID0gYy5tYWtlKFwiZGl2XCIsICQuQ1NTLmNvbnZlcnNpb25Ub29sYmFyTGFiZWwsIHtcbiAgICAgIHRleHRDb250ZW50OiB6LnVpKEsudWkuaW5saW5lVG9vbGJhci5jb252ZXJ0ZXIsIFwiQ29udmVydCB0b1wiKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmFkZFRvb2xzKCksIHRoaXMuZW5hYmxlRmxpcHBlcigpLCBjLmFwcGVuZCh0aGlzLm5vZGVzLndyYXBwZXIsIGUpLCBjLmFwcGVuZCh0aGlzLm5vZGVzLndyYXBwZXIsIHRoaXMubm9kZXMudG9vbHMpLCB0aGlzLm5vZGVzLndyYXBwZXI7XG4gIH1cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIGZsaXBwZXIgYW5kIHJlbW92ZXMgYWxsIG5vZGVzXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZmxpcHBlciAmJiAodGhpcy5mbGlwcGVyLmRlYWN0aXZhdGUoKSwgdGhpcy5mbGlwcGVyID0gbnVsbCksIHRoaXMucmVtb3ZlQWxsTm9kZXMoKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlIGNvbnZlcnNpb24gZHJvcGRvd24gdmlzaWJpbGl0eVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdG9nZ2xpbmdDYWxsYmFja10g4oCUIGNhbGxiYWNrIHRoYXQgd2lsbCBhY2NlcHQgb3BlbmluZyBzdGF0ZVxuICAgKi9cbiAgdG9nZ2xlKGUpIHtcbiAgICB0aGlzLm9wZW5lZCA/IHRoaXMuY2xvc2UoKSA6IHRoaXMub3BlbigpLCBNKGUpICYmICh0aGlzLnRvZ2dsaW5nQ2FsbGJhY2sgPSBlKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgQ29udmVyc2lvbiBUb29sYmFyXG4gICAqL1xuICBvcGVuKCkge1xuICAgIHRoaXMuZmlsdGVyVG9vbHMoKSwgdGhpcy5vcGVuZWQgPSAhMCwgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQoJC5DU1MuY29udmVyc2lvblRvb2xiYXJTaG93ZWQpLCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuZmxpcHBlci5hY3RpdmF0ZSh0aGlzLnRvb2xzLm1hcCgoZSkgPT4gZS5idXR0b24pLmZpbHRlcigoZSkgPT4gIWUuY2xhc3NMaXN0LmNvbnRhaW5zKCQuQ1NTLmNvbnZlcnNpb25Ub29sSGlkZGVuKSkpLCB0aGlzLmZsaXBwZXIuZm9jdXNGaXJzdCgpLCBNKHRoaXMudG9nZ2xpbmdDYWxsYmFjaykgJiYgdGhpcy50b2dnbGluZ0NhbGxiYWNrKCEwKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIENvbnZlcnNpb24gVG9vbGJhclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5mbGlwcGVyLmRlYWN0aXZhdGUoKSwgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJC5DU1MuY29udmVyc2lvblRvb2xiYXJTaG93ZWQpLCBNKHRoaXMudG9nZ2xpbmdDYWxsYmFjaykgJiYgdGhpcy50b2dnbGluZ0NhbGxiYWNrKCExKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGl0IGhhcyBtb3JlIHRoYW4gb25lIHRvb2wgYXZhaWxhYmxlIGZvciBjb252ZXJ0IGluXG4gICAqL1xuICBoYXNUb29scygpIHtcbiAgICByZXR1cm4gdGhpcy50b29scy5sZW5ndGggPT09IDEgPyB0aGlzLnRvb2xzWzBdLm5hbWUgIT09IHRoaXMuY29uZmlnLmRlZmF1bHRCbG9jayA6ICEwO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyBvbmUgQmxvY2sgd2l0aCBhbm90aGVyXG4gICAqIEZvciB0aGF0IFRvb2xzIG11c3QgcHJvdmlkZSBpbXBvcnQvZXhwb3J0IG1ldGhvZHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxhY2luZ1Rvb2xOYW1lIC0gbmFtZSBvZiBUb29sIHdoaWNoIHJlcGxhY2VzIGN1cnJlbnRcbiAgICogQHBhcmFtIGJsb2NrRGF0YU92ZXJyaWRlcyAtIElmIHRoaXMgY29udmVyc2lvbiBmaXJlZCBieSB0aGUgb25lIG9mIG11bHRpcGxlIFRvb2xib3ggaXRlbXMsIGV4dGVuZCBjb252ZXJ0ZWQgZGF0YSB3aXRoIHRoaXMgaXRlbSdzIFwiZGF0YVwiIG92ZXJyaWRlc1xuICAgKi9cbiAgYXN5bmMgcmVwbGFjZVdpdGhCbG9jayhlLCB0KSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IG8sIEJsb2NrU2VsZWN0aW9uOiBpLCBJbmxpbmVUb29sYmFyOiBuLCBDYXJldDogciB9ID0gdGhpcy5FZGl0b3I7XG4gICAgby5jb252ZXJ0KHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2ssIGUsIHQpLCBpLmNsZWFyU2VsZWN0aW9uKCksIHRoaXMuY2xvc2UoKSwgbi5jbG9zZSgpLCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHIuc2V0VG9CbG9jayh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLCByLnBvc2l0aW9ucy5FTkQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJdGVyYXRlcyBleGlzdGluZyBUb29scyBhbmQgaW5zZXJ0cyB0byB0aGUgQ29udmVyc2lvblRvb2xiYXJcbiAgICogaWYgdG9vbHMgaGF2ZSBhYmlsaXR5IHRvIGltcG9ydFxuICAgKi9cbiAgYWRkVG9vbHMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHM7XG4gICAgQXJyYXkuZnJvbShlLmVudHJpZXMoKSkuZm9yRWFjaCgoW3QsIG9dKSA9PiB7XG4gICAgICB2YXIgbjtcbiAgICAgIGNvbnN0IGkgPSBvLmNvbnZlcnNpb25Db25maWc7XG4gICAgICAhaSB8fCAhaS5pbXBvcnQgfHwgKG4gPSBvLnRvb2xib3gpID09IG51bGwgfHwgbi5mb3JFYWNoKFxuICAgICAgICAocikgPT4gdGhpcy5hZGRUb29sSWZWYWxpZCh0LCByKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBhIHRvb2wgdG8gdGhlIENvbnZlcnNpb25Ub29sYmFyIGlmIHRoZSB0b29sJ3MgdG9vbGJveCBjb25maWcgaXMgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSB0b29sJ3MgbmFtZVxuICAgKiBAcGFyYW0gdG9vbGJveFNldHRpbmdzIC0gdG9vbCdzIHNpbmdsZSB0b29sYm94IHNldHRpbmdcbiAgICovXG4gIGFkZFRvb2xJZlZhbGlkKGUsIHQpIHtcbiAgICBXKHQpIHx8ICF0Lmljb24gfHwgdGhpcy5hZGRUb29sKGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgdG9vbCB0byB0aGUgQ29udmVyc2lvbiBUb29sYmFyXG4gICAqXG4gICAqIEBwYXJhbSB0b29sTmFtZSAtIG5hbWUgb2YgVG9vbCB0byBhZGRcbiAgICogQHBhcmFtIHRvb2xib3hJdGVtIC0gdG9vbCdzIHRvb2xib3ggaXRlbSBkYXRhXG4gICAqL1xuICBhZGRUb29sKGUsIHQpIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCBvID0gYy5tYWtlKFwiZGl2XCIsIFskLkNTUy5jb252ZXJzaW9uVG9vbF0pLCBpID0gYy5tYWtlKFwiZGl2XCIsIFskLkNTUy5jb252ZXJzaW9uVG9vbEljb25dKTtcbiAgICBvLmRhdGFzZXQudG9vbCA9IGUsIGkuaW5uZXJIVE1MID0gdC5pY29uLCBjLmFwcGVuZChvLCBpKSwgYy5hcHBlbmQobywgYy50ZXh0KHoudChLLnRvb2xOYW1lcywgdC50aXRsZSB8fCByZShlKSkpKTtcbiAgICBjb25zdCBuID0gKHIgPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLmdldChlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuc2hvcnRjdXQ7XG4gICAgaWYgKG4pIHtcbiAgICAgIGNvbnN0IGEgPSBjLm1ha2UoXCJzcGFuXCIsICQuQ1NTLmNvbnZlcnNpb25Ub29sU2Vjb25kYXJ5TGFiZWwsIHtcbiAgICAgICAgaW5uZXJUZXh0OiB5ZShuKVxuICAgICAgfSk7XG4gICAgICBjLmFwcGVuZChvLCBhKTtcbiAgICB9XG4gICAgYy5hcHBlbmQodGhpcy5ub2Rlcy50b29scywgbyksIHRoaXMudG9vbHMucHVzaCh7XG4gICAgICBuYW1lOiBlLFxuICAgICAgYnV0dG9uOiBvLFxuICAgICAgdG9vbGJveEl0ZW06IHRcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24obywgXCJjbGlja1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLnJlcGxhY2VXaXRoQmxvY2soZSwgdC5kYXRhKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGlkZSBjdXJyZW50IFRvb2wgYW5kIHNob3cgb3RoZXJzXG4gICAqL1xuICBhc3luYyBmaWx0ZXJUb29scygpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogZSB9ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLCB0ID0gYXdhaXQgZS5nZXRBY3RpdmVUb29sYm94RW50cnkoKTtcbiAgICBmdW5jdGlvbiBvKGksIG4pIHtcbiAgICAgIHJldHVybiBpLmljb24gPT09IG4uaWNvbiAmJiBpLnRpdGxlID09PSBuLnRpdGxlO1xuICAgIH1cbiAgICB0aGlzLnRvb2xzLmZvckVhY2goKGkpID0+IHtcbiAgICAgIGxldCBuID0gITE7XG4gICAgICBpZiAodCkge1xuICAgICAgICBjb25zdCByID0gbyh0LCBpLnRvb2xib3hJdGVtKTtcbiAgICAgICAgbiA9IGkuYnV0dG9uLmRhdGFzZXQudG9vbCA9PT0gZS5uYW1lICYmIHI7XG4gICAgICB9XG4gICAgICBpLmJ1dHRvbi5oaWRkZW4gPSBuLCBpLmJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKCQuQ1NTLmNvbnZlcnNpb25Ub29sSGlkZGVuLCBuKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJlcGFyZSBGbGlwcGVyIHRvIGJlIGFibGUgdG8gbGVhZiB0b29scyBieSBhcnJvd3MvdGFiXG4gICAqL1xuICBlbmFibGVGbGlwcGVyKCkge1xuICAgIHRoaXMuZmxpcHBlciA9IG5ldyBxKHtcbiAgICAgIGZvY3VzZWRJdGVtQ2xhc3M6ICQuQ1NTLmNvbnZlcnNpb25Ub29sRm9jdXNlZFxuICAgIH0pO1xuICB9XG59XG52YXIgRGUgPSB7fSwgS28gPSB7XG4gIGdldCBleHBvcnRzKCkge1xuICAgIHJldHVybiBEZTtcbiAgfSxcbiAgc2V0IGV4cG9ydHMocykge1xuICAgIERlID0gcztcbiAgfVxufTtcbi8qIVxuICogTGlicmFyeSBmb3IgaGFuZGxpbmcga2V5Ym9hcmQgc2hvcnRjdXRzXG4gKiBAY29weXJpZ2h0IENvZGVYIChodHRwczovL2NvZGV4LnNvKVxuICogQGxpY2Vuc2UgTUlUXG4gKiBAYXV0aG9yIENvZGVYIChodHRwczovL2NvZGV4LnNvKVxuICogQHZlcnNpb24gMS4yLjBcbiAqL1xuKGZ1bmN0aW9uKHMsIGUpIHtcbiAgKGZ1bmN0aW9uKHQsIG8pIHtcbiAgICBzLmV4cG9ydHMgPSBvKCk7XG4gIH0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBvID0ge307XG4gICAgICBmdW5jdGlvbiBpKG4pIHtcbiAgICAgICAgaWYgKG9bbl0pXG4gICAgICAgICAgcmV0dXJuIG9bbl0uZXhwb3J0cztcbiAgICAgICAgdmFyIHIgPSBvW25dID0geyBpOiBuLCBsOiAhMSwgZXhwb3J0czoge30gfTtcbiAgICAgICAgcmV0dXJuIHRbbl0uY2FsbChyLmV4cG9ydHMsIHIsIHIuZXhwb3J0cywgaSksIHIubCA9ICEwLCByLmV4cG9ydHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gaS5tID0gdCwgaS5jID0gbywgaS5kID0gZnVuY3Rpb24obiwgciwgYSkge1xuICAgICAgICBpLm8obiwgcikgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHIsIHsgZW51bWVyYWJsZTogITAsIGdldDogYSB9KTtcbiAgICAgIH0sIGkuciA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgICAgfSwgaS50ID0gZnVuY3Rpb24obiwgcikge1xuICAgICAgICBpZiAoMSAmIHIgJiYgKG4gPSBpKG4pKSwgOCAmIHIgfHwgNCAmIHIgJiYgdHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiBuICYmIG4uX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgdmFyIGEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKGkucihhKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6ICEwLCB2YWx1ZTogbiB9KSwgMiAmIHIgJiYgdHlwZW9mIG4gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICBmb3IgKHZhciBsIGluIG4pXG4gICAgICAgICAgICBpLmQoYSwgbCwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbltkXTtcbiAgICAgICAgICAgIH0uYmluZChudWxsLCBsKSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSwgaS5uID0gZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgciA9IG4gJiYgbi5fX2VzTW9kdWxlID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG4uZGVmYXVsdDtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaS5kKHIsIFwiYVwiLCByKSwgcjtcbiAgICAgIH0sIGkubyA9IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKTtcbiAgICAgIH0sIGkucCA9IFwiXCIsIGkoaS5zID0gMCk7XG4gICAgfShbZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgZnVuY3Rpb24gbihsLCBkKSB7XG4gICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgZC5sZW5ndGg7IHUrKykge1xuICAgICAgICAgIHZhciBoID0gZFt1XTtcbiAgICAgICAgICBoLmVudW1lcmFibGUgPSBoLmVudW1lcmFibGUgfHwgITEsIGguY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBoICYmIChoLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobCwgaC5rZXksIGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByKGwsIGQsIHUpIHtcbiAgICAgICAgcmV0dXJuIGQgJiYgbihsLnByb3RvdHlwZSwgZCksIHUgJiYgbihsLCB1KSwgbDtcbiAgICAgIH1cbiAgICAgIGkucihvKTtcbiAgICAgIHZhciBhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGwoZCkge1xuICAgICAgICAgIHZhciB1ID0gdGhpcztcbiAgICAgICAgICAoZnVuY3Rpb24oaCwgZikge1xuICAgICAgICAgICAgaWYgKCEoaCBpbnN0YW5jZW9mIGYpKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgIH0pKHRoaXMsIGwpLCB0aGlzLmNvbW1hbmRzID0ge30sIHRoaXMua2V5cyA9IHt9LCB0aGlzLm5hbWUgPSBkLm5hbWUsIHRoaXMucGFyc2VTaG9ydGN1dE5hbWUoZC5uYW1lKSwgdGhpcy5lbGVtZW50ID0gZC5vbiwgdGhpcy5jYWxsYmFjayA9IGQuY2FsbGJhY2ssIHRoaXMuZXhlY3V0ZVNob3J0Y3V0ID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgdS5leGVjdXRlKGgpO1xuICAgICAgICAgIH0sIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmV4ZWN1dGVTaG9ydGN1dCwgITEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByKGwsIG51bGwsIFt7IGtleTogXCJzdXBwb3J0ZWRDb21tYW5kc1wiLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7IFNISUZUOiBbXCJTSElGVFwiXSwgQ01EOiBbXCJDTURcIiwgXCJDT05UUk9MXCIsIFwiQ09NTUFORFwiLCBcIldJTkRPV1NcIiwgXCJDVFJMXCJdLCBBTFQ6IFtcIkFMVFwiLCBcIk9QVElPTlwiXSB9O1xuICAgICAgICB9IH0sIHsga2V5OiBcImtleUNvZGVzXCIsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHsgMDogNDgsIDE6IDQ5LCAyOiA1MCwgMzogNTEsIDQ6IDUyLCA1OiA1MywgNjogNTQsIDc6IDU1LCA4OiA1NiwgOTogNTcsIEE6IDY1LCBCOiA2NiwgQzogNjcsIEQ6IDY4LCBFOiA2OSwgRjogNzAsIEc6IDcxLCBIOiA3MiwgSTogNzMsIEo6IDc0LCBLOiA3NSwgTDogNzYsIE06IDc3LCBOOiA3OCwgTzogNzksIFA6IDgwLCBROiA4MSwgUjogODIsIFM6IDgzLCBUOiA4NCwgVTogODUsIFY6IDg2LCBXOiA4NywgWDogODgsIFk6IDg5LCBaOiA5MCwgQkFDS1NQQUNFOiA4LCBFTlRFUjogMTMsIEVTQ0FQRTogMjcsIExFRlQ6IDM3LCBVUDogMzgsIFJJR0hUOiAzOSwgRE9XTjogNDAsIElOU0VSVDogNDUsIERFTEVURTogNDYsIFwiLlwiOiAxOTAgfTtcbiAgICAgICAgfSB9XSksIHIobCwgW3sga2V5OiBcInBhcnNlU2hvcnRjdXROYW1lXCIsIHZhbHVlOiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgZCA9IGQuc3BsaXQoXCIrXCIpO1xuICAgICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgZC5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgZFt1XSA9IGRbdV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBoID0gITE7XG4gICAgICAgICAgICBmb3IgKHZhciBmIGluIGwuc3VwcG9ydGVkQ29tbWFuZHMpXG4gICAgICAgICAgICAgIGlmIChsLnN1cHBvcnRlZENvbW1hbmRzW2ZdLmluY2x1ZGVzKGRbdV0pKSB7XG4gICAgICAgICAgICAgICAgaCA9IHRoaXMuY29tbWFuZHNbZl0gPSAhMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaCB8fCAodGhpcy5rZXlzW2RbdV1dID0gITApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciB4IGluIGwuc3VwcG9ydGVkQ29tbWFuZHMpXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzW3hdIHx8ICh0aGlzLmNvbW1hbmRzW3hdID0gITEpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImV4ZWN1dGVcIiwgdmFsdWU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICB2YXIgdSwgaCA9IHsgQ01EOiBkLmN0cmxLZXkgfHwgZC5tZXRhS2V5LCBTSElGVDogZC5zaGlmdEtleSwgQUxUOiBkLmFsdEtleSB9LCBmID0gITA7XG4gICAgICAgICAgZm9yICh1IGluIHRoaXMuY29tbWFuZHMpXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzW3VdICE9PSBoW3VdICYmIChmID0gITEpO1xuICAgICAgICAgIHZhciB4LCBwID0gITA7XG4gICAgICAgICAgZm9yICh4IGluIHRoaXMua2V5cylcbiAgICAgICAgICAgIHAgPSBwICYmIGQua2V5Q29kZSA9PT0gbC5rZXlDb2Rlc1t4XTtcbiAgICAgICAgICBmICYmIHAgJiYgdGhpcy5jYWxsYmFjayhkKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyZW1vdmVcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmV4ZWN1dGVTaG9ydGN1dCk7XG4gICAgICAgIH0gfV0pLCBsO1xuICAgICAgfSgpO1xuICAgICAgby5kZWZhdWx0ID0gYTtcbiAgICB9XSkuZGVmYXVsdDtcbiAgfSk7XG59KShLbyk7XG5jb25zdCBYbyA9IC8qIEBfX1BVUkVfXyAqLyBQZShEZSk7XG5jbGFzcyBWbyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVnaXN0ZXJlZFNob3J0Y3V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHNob3J0Y3V0XG4gICAqXG4gICAqIEBwYXJhbSBzaG9ydGN1dCAtIHNob3J0Y3V0IG9wdGlvbnNcbiAgICovXG4gIGFkZChlKSB7XG4gICAgaWYgKHRoaXMuZmluZFNob3J0Y3V0KGUub24sIGUubmFtZSkpXG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYFNob3J0Y3V0ICR7ZS5uYW1lfSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yICR7ZS5vbn0uIFBsZWFzZSByZW1vdmUgaXQgYmVmb3JlIGFkZCBhIG5ldyBoYW5kbGVyLmBcbiAgICAgICk7XG4gICAgY29uc3QgbyA9IG5ldyBYbyh7XG4gICAgICBuYW1lOiBlLm5hbWUsXG4gICAgICBvbjogZS5vbixcbiAgICAgIGNhbGxiYWNrOiBlLmhhbmRsZXJcbiAgICB9KSwgaSA9IHRoaXMucmVnaXN0ZXJlZFNob3J0Y3V0cy5nZXQoZS5vbikgfHwgW107XG4gICAgdGhpcy5yZWdpc3RlcmVkU2hvcnRjdXRzLnNldChlLm9uLCBbLi4uaSwgb10pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgc2hvcnRjdXRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBFbGVtZW50IHNob3J0Y3V0IGlzIHNldCBmb3JcbiAgICogQHBhcmFtIG5hbWUgLSBzaG9ydGN1dCBuYW1lXG4gICAqL1xuICByZW1vdmUoZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0aGlzLmZpbmRTaG9ydGN1dChlLCB0KTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm47XG4gICAgby5yZW1vdmUoKTtcbiAgICBjb25zdCBpID0gdGhpcy5yZWdpc3RlcmVkU2hvcnRjdXRzLmdldChlKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRTaG9ydGN1dHMuc2V0KGUsIGkuZmlsdGVyKChuKSA9PiBuICE9PSBvKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBTaG9ydGN1dCBpbnN0YW5jZSBpZiBleGlzdFxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIEVsZW1lbnQgc2hvcmN1dCBpcyBzZXQgZm9yXG4gICAqIEBwYXJhbSBzaG9ydGN1dCAtIHNob3J0Y3V0IG5hbWVcbiAgICogQHJldHVybnMge251bWJlcn0gaW5kZXggLSBzaG9ydGN1dCBpbmRleCBpZiBleGlzdFxuICAgKi9cbiAgZmluZFNob3J0Y3V0KGUsIHQpIHtcbiAgICByZXR1cm4gKHRoaXMucmVnaXN0ZXJlZFNob3J0Y3V0cy5nZXQoZSkgfHwgW10pLmZpbmQoKHsgbmFtZTogaSB9KSA9PiBpID09PSB0KTtcbiAgfVxufVxuY29uc3QgYWUgPSBuZXcgVm8oKTtcbnZhciBxbyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgWm8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCB4dCA9IChzLCBlLCB0LCBvKSA9PiB7XG4gIGZvciAodmFyIGkgPSBvID4gMSA/IHZvaWQgMCA6IG8gPyBabyhlLCB0KSA6IGUsIG4gPSBzLmxlbmd0aCAtIDEsIHI7IG4gPj0gMDsgbi0tKVxuICAgIChyID0gc1tuXSkgJiYgKGkgPSAobyA/IHIoZSwgdCwgaSkgOiByKGkpKSB8fCBpKTtcbiAgcmV0dXJuIG8gJiYgaSAmJiBxbyhlLCB0LCBpKSwgaTtcbn0sIGtlID0gLyogQF9fUFVSRV9fICovICgocykgPT4gKHMuT3BlbmVkID0gXCJ0b29sYm94LW9wZW5lZFwiLCBzLkNsb3NlZCA9IFwidG9vbGJveC1jbG9zZWRcIiwgcy5CbG9ja0FkZGVkID0gXCJ0b29sYm94LWJsb2NrLWFkZGVkXCIsIHMpKShrZSB8fCB7fSk7XG5jb25zdCB3dCA9IGNsYXNzIGV4dGVuZHMgRWUge1xuICAvKipcbiAgICogVG9vbGJveCBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGF2YWlsYWJsZSBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLmFwaSAtIEVkaXRvciBBUEkgbWV0aG9kc1xuICAgKiBAcGFyYW0gb3B0aW9ucy50b29scyAtIFRvb2xzIGF2YWlsYWJsZSB0byBjaGVjayB3aGV0aGVyIHNvbWUgb2YgdGhlbSBzaG91bGQgYmUgZGlzcGxheWVkIGF0IHRoZSBUb29sYm94IG9yIG5vdFxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGk6IHMsIHRvb2xzOiBlLCBpMThuTGFiZWxzOiB0IH0pIHtcbiAgICBzdXBlcigpLCB0aGlzLm9wZW5lZCA9ICExLCB0aGlzLm5vZGVzID0ge1xuICAgICAgdG9vbGJveDogbnVsbFxuICAgIH0sIHRoaXMub25Qb3BvdmVyQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9wZW5lZCA9ICExLCB0aGlzLmVtaXQoXG4gICAgICAgIFwidG9vbGJveC1jbG9zZWRcIlxuICAgICAgICAvKiBDbG9zZWQgKi9cbiAgICAgICk7XG4gICAgfSwgdGhpcy5hcGkgPSBzLCB0aGlzLnRvb2xzID0gZSwgdGhpcy5pMThuTGFiZWxzID0gdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUcnVlIGlmIFRvb2xib3ggaXMgRW1wdHkgYW5kIG5vdGhpbmcgdG8gc2hvd1xuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xzVG9CZURpc3BsYXllZC5sZW5ndGggPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIENTUyBzdHlsZXNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbGJveDogXCJjZS10b29sYm94XCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyB0aGUgVG9vbGJveFxuICAgKi9cbiAgbWFrZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3BvdmVyID0gbmV3IGplKHtcbiAgICAgIHNjb3BlRWxlbWVudDogdGhpcy5hcGkudWkubm9kZXMucmVkYWN0b3IsXG4gICAgICBzZWFyY2hhYmxlOiAhMCxcbiAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIG5vdGhpbmdGb3VuZDogdGhpcy5pMThuTGFiZWxzLm5vdGhpbmdGb3VuZCxcbiAgICAgICAgc2VhcmNoOiB0aGlzLmkxOG5MYWJlbHMuZmlsdGVyXG4gICAgICB9LFxuICAgICAgaXRlbXM6IHRoaXMudG9vbGJveEl0ZW1zVG9CZURpc3BsYXllZFxuICAgIH0pLCB0aGlzLnBvcG92ZXIub24oYmUuQ2xvc2UsIHRoaXMub25Qb3BvdmVyQ2xvc2UpLCB0aGlzLmVuYWJsZVNob3J0Y3V0cygpLCB0aGlzLm5vZGVzLnRvb2xib3ggPSB0aGlzLnBvcG92ZXIuZ2V0RWxlbWVudCgpLCB0aGlzLm5vZGVzLnRvb2xib3guY2xhc3NMaXN0LmFkZCh3dC5DU1MudG9vbGJveCksIHRoaXMubm9kZXMudG9vbGJveDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBUb29sYm94IGhhcyB0aGUgRmxpcHBlciBhY3RpdmF0ZWQgYW5kIHRoZSBGbGlwcGVyIGhhcyBzZWxlY3RlZCBidXR0b25cbiAgICovXG4gIGhhc0ZvY3VzKCkge1xuICAgIHZhciBzO1xuICAgIHJldHVybiAocyA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IHMuaGFzRm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSBNb2R1bGVcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIHM7XG4gICAgc3VwZXIuZGVzdHJveSgpLCB0aGlzLm5vZGVzICYmIHRoaXMubm9kZXMudG9vbGJveCAmJiAodGhpcy5ub2Rlcy50b29sYm94LnJlbW92ZSgpLCB0aGlzLm5vZGVzLnRvb2xib3ggPSBudWxsKSwgdGhpcy5yZW1vdmVBbGxTaG9ydGN1dHMoKSwgKHMgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgfHwgcy5vZmYoYmUuQ2xvc2UsIHRoaXMub25Qb3BvdmVyQ2xvc2UpO1xuICB9XG4gIC8qKlxuICAgKiBUb29sYm94IFRvb2wncyBidXR0b24gY2xpY2sgaGFuZGxlclxuICAgKlxuICAgKiBAcGFyYW0gdG9vbE5hbWUgLSB0b29sIHR5cGUgdG8gYmUgYWN0aXZhdGVkXG4gICAqIEBwYXJhbSBibG9ja0RhdGFPdmVycmlkZXMgLSBCbG9jayBkYXRhIHByZWRlZmluZWQgYnkgdGhlIGFjdGl2YXRlZCBUb29sYm94IGl0ZW1cbiAgICovXG4gIHRvb2xCdXR0b25BY3RpdmF0ZWQocywgZSkge1xuICAgIHRoaXMuaW5zZXJ0TmV3QmxvY2socywgZSk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gVG9vbGJveCB3aXRoIFRvb2xzXG4gICAqL1xuICBvcGVuKCkge1xuICAgIHZhciBzO1xuICAgIHRoaXMuaXNFbXB0eSB8fCAoKHMgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgfHwgcy5zaG93KCksIHRoaXMub3BlbmVkID0gITAsIHRoaXMuZW1pdChcbiAgICAgIFwidG9vbGJveC1vcGVuZWRcIlxuICAgICAgLyogT3BlbmVkICovXG4gICAgKSk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIFRvb2xib3hcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHZhciBzO1xuICAgIChzID0gdGhpcy5wb3BvdmVyKSA9PSBudWxsIHx8IHMuaGlkZSgpLCB0aGlzLm9wZW5lZCA9ICExLCB0aGlzLmVtaXQoXG4gICAgICBcInRvb2xib3gtY2xvc2VkXCJcbiAgICAgIC8qIENsb3NlZCAqL1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIFRvb2xib3hcbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLm9wZW5lZCA/IHRoaXMuY2xvc2UoKSA6IHRoaXMub3BlbigpO1xuICB9XG4gIGdldCB0b29sc1RvQmVEaXNwbGF5ZWQoKSB7XG4gICAgY29uc3QgcyA9IFtdO1xuICAgIHJldHVybiB0aGlzLnRvb2xzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUudG9vbGJveCAmJiBzLnB1c2goZSk7XG4gICAgfSksIHM7XG4gIH1cbiAgZ2V0IHRvb2xib3hJdGVtc1RvQmVEaXNwbGF5ZWQoKSB7XG4gICAgY29uc3QgcyA9IChlLCB0KSA9PiAoe1xuICAgICAgaWNvbjogZS5pY29uLFxuICAgICAgdGl0bGU6IHoudChLLnRvb2xOYW1lcywgZS50aXRsZSB8fCByZSh0Lm5hbWUpKSxcbiAgICAgIG5hbWU6IHQubmFtZSxcbiAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy50b29sQnV0dG9uQWN0aXZhdGVkKHQubmFtZSwgZS5kYXRhKTtcbiAgICAgIH0sXG4gICAgICBzZWNvbmRhcnlMYWJlbDogdC5zaG9ydGN1dCA/IHllKHQuc2hvcnRjdXQpIDogXCJcIlxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnRvb2xzVG9CZURpc3BsYXllZC5yZWR1Y2UoKGUsIHQpID0+IChBcnJheS5pc0FycmF5KHQudG9vbGJveCkgPyB0LnRvb2xib3guZm9yRWFjaCgobykgPT4ge1xuICAgICAgZS5wdXNoKHMobywgdCkpO1xuICAgIH0pIDogdC50b29sYm94ICE9PSB2b2lkIDAgJiYgZS5wdXNoKHModC50b29sYm94LCB0KSksIGUpLCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIEl0ZXJhdGUgYWxsIHRvb2xzIGFuZCBlbmFibGUgdGhlaXJzIHNob3J0Y3V0cyBpZiBzcGVjaWZpZWRcbiAgICovXG4gIGVuYWJsZVNob3J0Y3V0cygpIHtcbiAgICB0aGlzLnRvb2xzVG9CZURpc3BsYXllZC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBjb25zdCBlID0gcy5zaG9ydGN1dDtcbiAgICAgIGUgJiYgdGhpcy5lbmFibGVTaG9ydGN1dEZvclRvb2wocy5uYW1lLCBlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIHNob3J0Y3V0IEJsb2NrIFRvb2wgaW1wbGVtZW50ZWQgc2hvcnRjdXRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvb2xOYW1lIC0gVG9vbCBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydGN1dCAtIHNob3J0Y3V0IGFjY29yZGluZyB0byB0aGUgU2hvcnRjdXREYXRhIE1vZHVsZSBmb3JtYXRcbiAgICovXG4gIGVuYWJsZVNob3J0Y3V0Rm9yVG9vbChzLCBlKSB7XG4gICAgYWUuYWRkKHtcbiAgICAgIG5hbWU6IGUsXG4gICAgICBvbjogdGhpcy5hcGkudWkubm9kZXMucmVkYWN0b3IsXG4gICAgICBoYW5kbGVyOiAodCkgPT4ge1xuICAgICAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLmFwaS5ibG9ja3MuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSwgaSA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRCbG9ja0J5SW5kZXgobyk7XG4gICAgICAgIGlmIChpKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmFwaS5ibG9ja3MuY29udmVydChpLmlkLCBzKSwgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYXBpLmNhcmV0LnNldFRvQmxvY2sobywgXCJlbmRcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zZXJ0TmV3QmxvY2socyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGFkZGVkIHNob3J0Y3V0c1xuICAgKiBGaXJlZCB3aGVuIHRoZSBSZWFkLU9ubHkgbW9kZSBpcyBhY3RpdmF0ZWRcbiAgICovXG4gIHJlbW92ZUFsbFNob3J0Y3V0cygpIHtcbiAgICB0aGlzLnRvb2xzVG9CZURpc3BsYXllZC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBjb25zdCBlID0gcy5zaG9ydGN1dDtcbiAgICAgIGUgJiYgYWUucmVtb3ZlKHRoaXMuYXBpLnVpLm5vZGVzLnJlZGFjdG9yLCBlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgYmxvY2tcbiAgICogQ2FuIGJlIGNhbGxlZCB3aGVuIGJ1dHRvbiBjbGlja2VkIG9uIFRvb2xib3ggb3IgYnkgU2hvcnRjdXREYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b29sTmFtZSAtIFRvb2wgbmFtZVxuICAgKiBAcGFyYW0gYmxvY2tEYXRhT3ZlcnJpZGVzIC0gcHJlZGVmaW5lZCBCbG9jayBkYXRhXG4gICAqL1xuICBhc3luYyBpbnNlcnROZXdCbG9jayhzLCBlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRDdXJyZW50QmxvY2tJbmRleCgpLCBvID0gdGhpcy5hcGkuYmxvY2tzLmdldEJsb2NrQnlJbmRleCh0KTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IG8uaXNFbXB0eSA/IHQgOiB0ICsgMTtcbiAgICBsZXQgbjtcbiAgICBpZiAoZSkge1xuICAgICAgY29uc3QgYSA9IGF3YWl0IHRoaXMuYXBpLmJsb2Nrcy5jb21wb3NlQmxvY2tEYXRhKHMpO1xuICAgICAgbiA9IE9iamVjdC5hc3NpZ24oYSwgZSk7XG4gICAgfVxuICAgIGNvbnN0IHIgPSB0aGlzLmFwaS5ibG9ja3MuaW5zZXJ0KFxuICAgICAgcyxcbiAgICAgIG4sXG4gICAgICB2b2lkIDAsXG4gICAgICBpLFxuICAgICAgdm9pZCAwLFxuICAgICAgby5pc0VtcHR5XG4gICAgKTtcbiAgICByLmNhbGwoWC5BUFBFTkRfQ0FMTEJBQ0spLCB0aGlzLmFwaS5jYXJldC5zZXRUb0Jsb2NrKGkpLCB0aGlzLmVtaXQoXCJ0b29sYm94LWJsb2NrLWFkZGVkXCIsIHtcbiAgICAgIGJsb2NrOiByXG4gICAgfSksIHRoaXMuYXBpLnRvb2xiYXIuY2xvc2UoKTtcbiAgfVxufTtcbmxldCAkZSA9IHd0O1xueHQoW1xuICBsZVxuXSwgJGUucHJvdG90eXBlLCBcInRvb2xzVG9CZURpc3BsYXllZFwiLCAxKTtcbnh0KFtcbiAgbGVcbl0sICRlLnByb3RvdHlwZSwgXCJ0b29sYm94SXRlbXNUb0JlRGlzcGxheWVkXCIsIDEpO1xuY29uc3QgeXQgPSBcImJsb2NrIGhvdmVyZWRcIjtcbmFzeW5jIGZ1bmN0aW9uIEdvKHMsIGUpIHtcbiAgY29uc3QgdCA9IG5hdmlnYXRvci5rZXlib2FyZDtcbiAgcmV0dXJuIHQgJiYgKGF3YWl0IHQuZ2V0TGF5b3V0TWFwKCkpLmdldChzKSB8fCBlO1xufVxuY2xhc3MgSm8gZXh0ZW5kcyB5IHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbiAtIE1vZHVsZSBDb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmNvbmZpZyAtIEVkaXRvcidzIGNvbmZpZ1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5ldmVudHNEaXNwYXRjaGVyIC0gRWRpdG9yJ3MgZXZlbnQgZGlzcGF0Y2hlclxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGUsIGV2ZW50c0Rpc3BhdGNoZXI6IHQgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZzogZSxcbiAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRcbiAgICB9KSwgdGhpcy50b29sYm94SW5zdGFuY2UgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDU1Mgc3R5bGVzXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sYmFyOiBcImNlLXRvb2xiYXJcIixcbiAgICAgIGNvbnRlbnQ6IFwiY2UtdG9vbGJhcl9fY29udGVudFwiLFxuICAgICAgYWN0aW9uczogXCJjZS10b29sYmFyX19hY3Rpb25zXCIsXG4gICAgICBhY3Rpb25zT3BlbmVkOiBcImNlLXRvb2xiYXJfX2FjdGlvbnMtLW9wZW5lZFwiLFxuICAgICAgdG9vbGJhck9wZW5lZDogXCJjZS10b29sYmFyLS1vcGVuZWRcIixcbiAgICAgIG9wZW5lZFRvb2xib3hIb2xkZXJNb2RpZmllcjogXCJjb2RleC1lZGl0b3ItLXRvb2xib3gtb3BlbmVkXCIsXG4gICAgICBwbHVzQnV0dG9uOiBcImNlLXRvb2xiYXJfX3BsdXNcIixcbiAgICAgIHBsdXNCdXR0b25TaG9ydGN1dDogXCJjZS10b29sYmFyX19wbHVzLXNob3J0Y3V0XCIsXG4gICAgICBzZXR0aW5nc1RvZ2dsZXI6IFwiY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRuXCIsXG4gICAgICBzZXR0aW5nc1RvZ2dsZXJIaWRkZW46IFwiY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRuLS1oaWRkZW5cIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFRvb2xiYXIgb3BlbmluZyBzdGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBvcGVuZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuY29udGFpbnModGhpcy5DU1MudG9vbGJhck9wZW5lZCk7XG4gIH1cbiAgLyoqXG4gICAqIFB1YmxpYyBpbnRlcmZhY2UgZm9yIGFjY2Vzc2luZyB0aGUgVG9vbGJveFxuICAgKi9cbiAgZ2V0IHRvb2xib3goKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW5lZDogKGUgPSB0aGlzLnRvb2xib3hJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGUub3BlbmVkLFxuICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgICh0ID0gdGhpcy50b29sYm94SW5zdGFuY2UpID09IG51bGwgfHwgdC5jbG9zZSgpO1xuICAgICAgfSxcbiAgICAgIG9wZW46ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMudG9vbGJveEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgVChcInRvb2xib3gub3BlbigpIGNhbGxlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24gaXMgZmluaXNoZWRcIiwgXCJ3YXJuXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrID0gdGhpcy5ob3ZlcmVkQmxvY2ssIHRoaXMudG9vbGJveEluc3RhbmNlLm9wZW4oKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGU6ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMudG9vbGJveEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgVChcInRvb2xib3gudG9nZ2xlKCkgY2FsbGVkIGJlZm9yZSBpbml0aWFsaXphdGlvbiBpcyBmaW5pc2hlZFwiLCBcIndhcm5cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9vbGJveEluc3RhbmNlLnRvZ2dsZSgpO1xuICAgICAgfSxcbiAgICAgIGhhc0ZvY3VzOiAoKSA9PiB7XG4gICAgICAgIHZhciB0O1xuICAgICAgICByZXR1cm4gKHQgPSB0aGlzLnRvb2xib3hJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaGFzRm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBCbG9jayBhY3Rpb25zIGFwcGVhcmFuY2UgbWFuaXB1bGF0aW9uc1xuICAgKi9cbiAgZ2V0IGJsb2NrQWN0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGlkZTogKCkgPT4ge1xuICAgICAgICB0aGlzLm5vZGVzLmFjdGlvbnMuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5hY3Rpb25zT3BlbmVkKTtcbiAgICAgIH0sXG4gICAgICBzaG93OiAoKSA9PiB7XG4gICAgICAgIHRoaXMubm9kZXMuYWN0aW9ucy5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmFjdGlvbnNPcGVuZWQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCBCbG9jayBUdW5lcyB0b2dnbGVyXG4gICAqL1xuICBnZXQgYmxvY2tUdW5lc1RvZ2dsZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpZGU6ICgpID0+IHRoaXMubm9kZXMuc2V0dGluZ3NUb2dnbGVyLmNsYXNzTGlzdC5hZGQodGhpcy5DU1Muc2V0dGluZ3NUb2dnbGVySGlkZGVuKSxcbiAgICAgIHNob3c6ICgpID0+IHRoaXMubm9kZXMuc2V0dGluZ3NUb2dnbGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1Muc2V0dGluZ3NUb2dnbGVySGlkZGVuKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgcmVhZC1vbmx5IG1vZGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSByZWFkLW9ubHkgbW9kZVxuICAgKi9cbiAgdG9nZ2xlUmVhZE9ubHkoZSkge1xuICAgIGUgPyAodGhpcy5kZXN0cm95KCksIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuZGVzdHJveSgpLCB0aGlzLmRpc2FibGVNb2R1bGVCaW5kaW5ncygpKSA6IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMuZHJhd1VJKCksIHRoaXMuZW5hYmxlTW9kdWxlQmluZGluZ3MoKTtcbiAgICB9LCB7IHRpbWVvdXQ6IDJlMyB9KTtcbiAgfVxuICAvKipcbiAgICogTW92ZSBUb29sYmFyIHRvIHRoZSBwYXNzZWQgKG9yIGN1cnJlbnQpIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSBibG9jayAtIGJsb2NrIHRvIG1vdmUgVG9vbGJhciBuZWFyIGl0XG4gICAqL1xuICBtb3ZlQW5kT3BlbihlID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jaykge1xuICAgIGlmICh0aGlzLnRvb2xib3hJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgVChcIkNhbid0IG9wZW4gVG9vbGJhciBzaW5jZSBFZGl0b3IgaW5pdGlhbGl6YXRpb24gaXMgbm90IGZpbmlzaGVkIHlldFwiLCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRvb2xib3hJbnN0YW5jZS5vcGVuZWQgJiYgdGhpcy50b29sYm94SW5zdGFuY2UuY2xvc2UoKSwgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5jbG9zZSgpLCAhZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmhvdmVyZWRCbG9jayA9IGU7XG4gICAgY29uc3QgdCA9IGUuaG9sZGVyLCB7IGlzTW9iaWxlOiBvIH0gPSB0aGlzLkVkaXRvci5VSSwgaSA9IGUucGx1Z2luc0NvbnRlbnQsIG4gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpKSwgciA9IHBhcnNlSW50KG4ucGFkZGluZ1RvcCwgMTApLCBhID0gdC5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IGw7XG4gICAgbyA/IGwgPSB0Lm9mZnNldFRvcCArIGEgOiBsID0gdC5vZmZzZXRUb3AgKyByLCB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUudG9wID0gYCR7TWF0aC5mbG9vcihsKX1weGAsIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5ibG9ja3MubGVuZ3RoID09PSAxICYmIGUuaXNFbXB0eSA/IHRoaXMuYmxvY2tUdW5lc1RvZ2dsZXIuaGlkZSgpIDogdGhpcy5ibG9ja1R1bmVzVG9nZ2xlci5zaG93KCksIHRoaXMub3BlbigpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgVG9vbGJhclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdmFyIGUsIHQ7XG4gICAgdGhpcy5FZGl0b3IuUmVhZE9ubHkuaXNFbmFibGVkIHx8ICgoZSA9IHRoaXMubm9kZXMud3JhcHBlcikgPT0gbnVsbCB8fCBlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1MudG9vbGJhck9wZW5lZCksIHRoaXMuYmxvY2tBY3Rpb25zLmhpZGUoKSwgKHQgPSB0aGlzLnRvb2xib3hJbnN0YW5jZSkgPT0gbnVsbCB8fCB0LmNsb3NlKCksIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuY2xvc2UoKSwgdGhpcy5yZXNldCgpKTtcbiAgfVxuICAvKipcbiAgICogUmVzZXQgdGhlIFRvb2xiYXIgcG9zaXRpb24gdG8gcHJldmVudCBET00gaGVpZ2h0IGdyb3d0aCwgZm9yIGV4YW1wbGUgYWZ0ZXIgYmxvY2tzIGRlbGV0aW9uXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUudG9wID0gXCJ1bnNldFwiO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIFRvb2xiYXIgd2l0aCBQbHVzIEJ1dHRvbiBhbmQgQWN0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhCbG9ja0FjdGlvbnMgLSBieSBkZWZhdWx0LCBUb29sYmFyIG9wZW5zIHdpdGggQmxvY2sgQWN0aW9ucy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBmbGFnIGFsbG93cyB0byBvcGVuIFRvb2xiYXIgd2l0aG91dCBBY3Rpb25zLlxuICAgKi9cbiAgb3BlbihlID0gITApIHtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy50b29sYmFyT3BlbmVkKSwgZSA/IHRoaXMuYmxvY2tBY3Rpb25zLnNob3coKSA6IHRoaXMuYmxvY2tBY3Rpb25zLmhpZGUoKTtcbiAgfVxuICAvKipcbiAgICogRHJhd3MgVG9vbGJhciBlbGVtZW50c1xuICAgKi9cbiAgYXN5bmMgbWFrZSgpIHtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIgPSBjLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MudG9vbGJhciksIFtcImNvbnRlbnRcIiwgXCJhY3Rpb25zXCJdLmZvckVhY2goKG4pID0+IHtcbiAgICAgIHRoaXMubm9kZXNbbl0gPSBjLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1Nbbl0pO1xuICAgIH0pLCBjLmFwcGVuZCh0aGlzLm5vZGVzLndyYXBwZXIsIHRoaXMubm9kZXMuY29udGVudCksIGMuYXBwZW5kKHRoaXMubm9kZXMuY29udGVudCwgdGhpcy5ub2Rlcy5hY3Rpb25zKSwgdGhpcy5ub2Rlcy5wbHVzQnV0dG9uID0gYy5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnBsdXNCdXR0b24sIHtcbiAgICAgIGlubmVySFRNTDogRm9cbiAgICB9KSwgYy5hcHBlbmQodGhpcy5ub2Rlcy5hY3Rpb25zLCB0aGlzLm5vZGVzLnBsdXNCdXR0b24pLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnBsdXNCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgUmUoITApLCB0aGlzLnBsdXNCdXR0b25DbGlja2VkKCk7XG4gICAgfSwgITEpO1xuICAgIGNvbnN0IGUgPSBjLm1ha2UoXCJkaXZcIik7XG4gICAgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh6LnVpKEsudWkudG9vbGJhci50b29sYm94LCBcIkFkZFwiKSkpLCBlLmFwcGVuZENoaWxkKGMubWFrZShcImRpdlwiLCB0aGlzLkNTUy5wbHVzQnV0dG9uU2hvcnRjdXQsIHtcbiAgICAgIHRleHRDb250ZW50OiBcIi9cIlxuICAgIH0pKSwgZ2UodGhpcy5ub2Rlcy5wbHVzQnV0dG9uLCBlLCB7XG4gICAgICBoaWRpbmdEZWxheTogNDAwXG4gICAgfSksIHRoaXMubm9kZXMuc2V0dGluZ3NUb2dnbGVyID0gYy5tYWtlKFwic3BhblwiLCB0aGlzLkNTUy5zZXR0aW5nc1RvZ2dsZXIsIHtcbiAgICAgIGlubmVySFRNTDogUG9cbiAgICB9KSwgYy5hcHBlbmQodGhpcy5ub2Rlcy5hY3Rpb25zLCB0aGlzLm5vZGVzLnNldHRpbmdzVG9nZ2xlcik7XG4gICAgY29uc3QgdCA9IGMubWFrZShcImRpdlwiKSwgbyA9IGMudGV4dCh6LnVpKEsudWkuYmxvY2tUdW5lcy50b2dnbGVyLCBcIkNsaWNrIHRvIHR1bmVcIikpLCBpID0gYXdhaXQgR28oXCJTbGFzaFwiLCBcIi9cIik7XG4gICAgdC5hcHBlbmRDaGlsZChvKSwgdC5hcHBlbmRDaGlsZChjLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MucGx1c0J1dHRvblNob3J0Y3V0LCB7XG4gICAgICB0ZXh0Q29udGVudDogeWUoYENNRCArICR7aX1gKVxuICAgIH0pKSwgZ2UodGhpcy5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIsIHQsIHtcbiAgICAgIGhpZGluZ0RlbGF5OiA0MDBcbiAgICB9KSwgYy5hcHBlbmQodGhpcy5ub2Rlcy5hY3Rpb25zLCB0aGlzLm1ha2VUb29sYm94KCkpLCBjLmFwcGVuZCh0aGlzLm5vZGVzLmFjdGlvbnMsIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuZ2V0RWxlbWVudCgpKSwgYy5hcHBlbmQodGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlciwgdGhpcy5ub2Rlcy53cmFwcGVyKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgVG9vbGJveCBpbnN0YW5jZSBhbmQgcmV0dXJuIGl0J3MgcmVuZGVyZWQgZWxlbWVudFxuICAgKi9cbiAgbWFrZVRvb2xib3goKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbGJveEluc3RhbmNlID0gbmV3ICRlKHtcbiAgICAgIGFwaTogdGhpcy5FZGl0b3IuQVBJLm1ldGhvZHMsXG4gICAgICB0b29sczogdGhpcy5FZGl0b3IuVG9vbHMuYmxvY2tUb29scyxcbiAgICAgIGkxOG5MYWJlbHM6IHtcbiAgICAgICAgZmlsdGVyOiB6LnVpKEsudWkucG9wb3ZlciwgXCJGaWx0ZXJcIiksXG4gICAgICAgIG5vdGhpbmdGb3VuZDogei51aShLLnVpLnBvcG92ZXIsIFwiTm90aGluZyBmb3VuZFwiKVxuICAgICAgfVxuICAgIH0pLCB0aGlzLnRvb2xib3hJbnN0YW5jZS5vbihrZS5PcGVuZWQsICgpID0+IHtcbiAgICAgIHRoaXMuRWRpdG9yLlVJLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5vcGVuZWRUb29sYm94SG9sZGVyTW9kaWZpZXIpO1xuICAgIH0pLCB0aGlzLnRvb2xib3hJbnN0YW5jZS5vbihrZS5DbG9zZWQsICgpID0+IHtcbiAgICAgIHRoaXMuRWRpdG9yLlVJLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5vcGVuZWRUb29sYm94SG9sZGVyTW9kaWZpZXIpO1xuICAgIH0pLCB0aGlzLnRvb2xib3hJbnN0YW5jZS5vbihrZS5CbG9ja0FkZGVkLCAoeyBibG9jazogZSB9KSA9PiB7XG4gICAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQ2FyZXQ6IG8gfSA9IHRoaXMuRWRpdG9yLCBpID0gdC5nZXRCbG9ja0J5SWQoZS5pZCk7XG4gICAgICBpLmlucHV0cy5sZW5ndGggPT09IDAgJiYgKGkgPT09IHQubGFzdEJsb2NrID8gKHQuaW5zZXJ0QXRFbmQoKSwgby5zZXRUb0Jsb2NrKHQubGFzdEJsb2NrKSkgOiBvLnNldFRvQmxvY2sodC5uZXh0QmxvY2spKTtcbiAgICB9KSwgdGhpcy50b29sYm94SW5zdGFuY2UubWFrZSgpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciBQbHVzIEJ1dHRvblxuICAgKi9cbiAgcGx1c0J1dHRvbkNsaWNrZWQoKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayA9IHRoaXMuaG92ZXJlZEJsb2NrLCAoZSA9IHRoaXMudG9vbGJveEluc3RhbmNlKSA9PSBudWxsIHx8IGUudG9nZ2xlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBiaW5kaW5nc1xuICAgKi9cbiAgZW5hYmxlTW9kdWxlQmluZGluZ3MoKSB7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24odGhpcy5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIsIFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCksIHRoaXMuc2V0dGluZ3NUb2dnbGVyQ2xpY2tlZCgpLCAodCA9IHRoaXMudG9vbGJveEluc3RhbmNlKSAhPSBudWxsICYmIHQub3BlbmVkICYmIHRoaXMudG9vbGJveEluc3RhbmNlLmNsb3NlKCksIFJlKCEwKTtcbiAgICB9LCAhMCksIHRlKCkgfHwgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9uKHl0LCAoZSkgPT4ge1xuICAgICAgdmFyIHQ7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCB8fCAodCA9IHRoaXMudG9vbGJveEluc3RhbmNlKSAhPSBudWxsICYmIHQub3BlbmVkIHx8IHRoaXMubW92ZUFuZE9wZW4oZS5ibG9jayk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGUgYmluZGluZ3NcbiAgICovXG4gIGRpc2FibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5jbGVhckFsbCgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGlja3Mgb24gdGhlIEJsb2NrIFNldHRpbmdzIHRvZ2dsZXJcbiAgICovXG4gIHNldHRpbmdzVG9nZ2xlckNsaWNrZWQoKSB7XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayA9IHRoaXMuaG92ZXJlZEJsb2NrLCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCA/IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuY2xvc2UoKSA6IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3Blbih0aGlzLmhvdmVyZWRCbG9jayk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIFRvb2xiYXIgVUlcbiAgICpcbiAgICogVG9vbGJhciBjb250YWlucyBCbG9ja1NldHRpbmdzIGFuZCBUb29sYm94LlxuICAgKiBUaGF0J3Mgd2h5IGF0IGZpcnN0IHdlIGRyYXcgaXRzIGNvbXBvbmVudHMgYW5kIHRoZW4gVG9vbGJhciBpdHNlbGZcbiAgICpcbiAgICogU3RlcHM6XG4gICAqICAtIE1ha2UgVG9vbGJhciBkZXBlbmRlbnQgY29tcG9uZW50cyBsaWtlIEJsb2NrU2V0dGluZ3MsIFRvb2xib3ggYW5kIHNvIG9uXG4gICAqICAtIE1ha2UgaXRzZWxmIGFuZCBhcHBlbmQgZGVwZW5kZW50IG5vZGVzIHRvIGl0c2VsZlxuICAgKlxuICAgKi9cbiAgZHJhd1VJKCkge1xuICAgIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MubWFrZSgpLCB0aGlzLm1ha2UoKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgY3JlYXRlZCBhbmQgc2F2ZWQgSFRNTEVsZW1lbnRzXG4gICAqIEl0IGlzIHVzZWQgaW4gUmVhZC1Pbmx5IG1vZGVcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxOb2RlcygpLCB0aGlzLnRvb2xib3hJbnN0YW5jZSAmJiB0aGlzLnRvb2xib3hJbnN0YW5jZS5kZXN0cm95KCk7XG4gIH1cbn1cbnZhciBCZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzW3MuQmxvY2sgPSAwXSA9IFwiQmxvY2tcIiwgc1tzLklubGluZSA9IDFdID0gXCJJbmxpbmVcIiwgc1tzLlR1bmUgPSAyXSA9IFwiVHVuZVwiLCBzKSkoQmUgfHwge30pLCB2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzLlNob3J0Y3V0ID0gXCJzaG9ydGN1dFwiLCBzLlRvb2xib3ggPSBcInRvb2xib3hcIiwgcy5FbmFibGVkSW5saW5lVG9vbHMgPSBcImlubGluZVRvb2xiYXJcIiwgcy5FbmFibGVkQmxvY2tUdW5lcyA9IFwidHVuZXNcIiwgcy5Db25maWcgPSBcImNvbmZpZ1wiLCBzKSkodmUgfHwge30pLCBFdCA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzLlNob3J0Y3V0ID0gXCJzaG9ydGN1dFwiLCBzLlNhbml0aXplQ29uZmlnID0gXCJzYW5pdGl6ZVwiLCBzKSkoRXQgfHwge30pLCBzZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzLklzRW5hYmxlZExpbmVCcmVha3MgPSBcImVuYWJsZUxpbmVCcmVha3NcIiwgcy5Ub29sYm94ID0gXCJ0b29sYm94XCIsIHMuQ29udmVyc2lvbkNvbmZpZyA9IFwiY29udmVyc2lvbkNvbmZpZ1wiLCBzLklzUmVhZE9ubHlTdXBwb3J0ZWQgPSBcImlzUmVhZE9ubHlTdXBwb3J0ZWRcIiwgcy5QYXN0ZUNvbmZpZyA9IFwicGFzdGVDb25maWdcIiwgcykpKHNlIHx8IHt9KSwgV2UgPSAvKiBAX19QVVJFX18gKi8gKChzKSA9PiAocy5Jc0lubGluZSA9IFwiaXNJbmxpbmVcIiwgcy5UaXRsZSA9IFwidGl0bGVcIiwgcykpKFdlIHx8IHt9KSwgQnQgPSAvKiBAX19QVVJFX18gKi8gKChzKSA9PiAocy5Jc1R1bmUgPSBcImlzVHVuZVwiLCBzKSkoQnQgfHwge30pO1xuY2xhc3MgWWUge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3JPcHRpb25zfSBvcHRpb25zIC0gQ29uc3RydWN0b3Igb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IGUsXG4gICAgY29uc3RydWN0YWJsZTogdCxcbiAgICBjb25maWc6IG8sXG4gICAgYXBpOiBpLFxuICAgIGlzRGVmYXVsdDogbixcbiAgICBpc0ludGVybmFsOiByID0gITEsXG4gICAgZGVmYXVsdFBsYWNlaG9sZGVyOiBhXG4gIH0pIHtcbiAgICB0aGlzLmFwaSA9IGksIHRoaXMubmFtZSA9IGUsIHRoaXMuY29uc3RydWN0YWJsZSA9IHQsIHRoaXMuY29uZmlnID0gbywgdGhpcy5pc0RlZmF1bHQgPSBuLCB0aGlzLmlzSW50ZXJuYWwgPSByLCB0aGlzLmRlZmF1bHRQbGFjZWhvbGRlciA9IGE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCB1c2VyIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldCBzZXR0aW5ncygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jb25maWcuY29uZmlnIHx8IHt9O1xuICAgIHJldHVybiB0aGlzLmlzRGVmYXVsdCAmJiAhKFwicGxhY2Vob2xkZXJcIiBpbiBlKSAmJiB0aGlzLmRlZmF1bHRQbGFjZWhvbGRlciAmJiAoZS5wbGFjZWhvbGRlciA9IHRoaXMuZGVmYXVsdFBsYWNlaG9sZGVyKSwgZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgVG9vbCdzIHJlc2V0IG1ldGhvZFxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgaWYgKE0odGhpcy5jb25zdHJ1Y3RhYmxlLnJlc2V0KSlcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGUucmVzZXQoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgVG9vbCdzIHByZXBhcmUgbWV0aG9kXG4gICAqL1xuICBwcmVwYXJlKCkge1xuICAgIGlmIChNKHRoaXMuY29uc3RydWN0YWJsZS5wcmVwYXJlKSlcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGUucHJlcGFyZSh7XG4gICAgICAgIHRvb2xOYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIGNvbmZpZzogdGhpcy5zZXR0aW5nc1xuICAgICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc2hvcnRjdXQgZm9yIFRvb2wgKGludGVybmFsIG9yIHNwZWNpZmllZCBieSB1c2VyKVxuICAgKi9cbiAgZ2V0IHNob3J0Y3V0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbnN0cnVjdGFibGUuc2hvcnRjdXQ7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnNob3J0Y3V0IHx8IGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCdzIHNhbml0aXplciBjb25maWd1cmF0aW9uXG4gICAqL1xuICBnZXQgc2FuaXRpemVDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZS5zYW5pdGl6ZSB8fCB7fTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIFRvb2xzIGlzIGlubGluZVxuICAgKi9cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gMTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIFRvb2xzIGlzIGJsb2NrXG4gICAqL1xuICBpc0Jsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBUb29scyBpcyB0dW5lXG4gICAqL1xuICBpc1R1bmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gMjtcbiAgfVxufVxuY2xhc3MgUW8gZXh0ZW5kcyB5IHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbiAtIE1vZHVsZSBDb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmNvbmZpZyAtIEVkaXRvcidzIGNvbmZpZ1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5ldmVudHNEaXNwYXRjaGVyIC0gRWRpdG9yJ3MgZXZlbnQgZGlzcGF0Y2hlclxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGUsIGV2ZW50c0Rpc3BhdGNoZXI6IHQgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZzogZSxcbiAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRcbiAgICB9KSwgdGhpcy5DU1MgPSB7XG4gICAgICBpbmxpbmVUb29sYmFyOiBcImNlLWlubGluZS10b29sYmFyXCIsXG4gICAgICBpbmxpbmVUb29sYmFyU2hvd2VkOiBcImNlLWlubGluZS10b29sYmFyLS1zaG93ZWRcIixcbiAgICAgIGlubGluZVRvb2xiYXJMZWZ0T3JpZW50ZWQ6IFwiY2UtaW5saW5lLXRvb2xiYXItLWxlZnQtb3JpZW50ZWRcIixcbiAgICAgIGlubGluZVRvb2xiYXJSaWdodE9yaWVudGVkOiBcImNlLWlubGluZS10b29sYmFyLS1yaWdodC1vcmllbnRlZFwiLFxuICAgICAgaW5saW5lVG9vbGJhclNob3J0Y3V0OiBcImNlLWlubGluZS10b29sYmFyX19zaG9ydGN1dFwiLFxuICAgICAgYnV0dG9uc1dyYXBwZXI6IFwiY2UtaW5saW5lLXRvb2xiYXJfX2J1dHRvbnNcIixcbiAgICAgIGFjdGlvbnNXcmFwcGVyOiBcImNlLWlubGluZS10b29sYmFyX19hY3Rpb25zXCIsXG4gICAgICBpbmxpbmVUb29sQnV0dG9uOiBcImNlLWlubGluZS10b29sXCIsXG4gICAgICBpbnB1dEZpZWxkOiBcImNkeC1pbnB1dFwiLFxuICAgICAgZm9jdXNlZEJ1dHRvbjogXCJjZS1pbmxpbmUtdG9vbC0tZm9jdXNlZFwiLFxuICAgICAgY29udmVyc2lvblRvZ2dsZXI6IFwiY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duXCIsXG4gICAgICBjb252ZXJzaW9uVG9nZ2xlckFycm93OiBcImNlLWlubGluZS10b29sYmFyX19kcm9wZG93bi1hcnJvd1wiLFxuICAgICAgY29udmVyc2lvblRvZ2dsZXJIaWRkZW46IFwiY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duLS1oaWRkZW5cIixcbiAgICAgIGNvbnZlcnNpb25Ub2dnbGVyQ29udGVudDogXCJjZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24tY29udGVudFwiLFxuICAgICAgdG9nZ2xlckFuZEJ1dHRvbnNXcmFwcGVyOiBcImNlLWlubGluZS10b29sYmFyX190b2dnbGVyLWFuZC1idXR0b24td3JhcHBlclwiXG4gICAgfSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy50b29sYmFyVmVydGljYWxNYXJnaW4gPSB0ZSgpID8gMjAgOiA2LCB0aGlzLmJ1dHRvbnNMaXN0ID0gbnVsbCwgdGhpcy53aWR0aCA9IDAsIHRoaXMuZmxpcHBlciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgcmVhZC1vbmx5IG1vZGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSByZWFkLW9ubHkgbW9kZVxuICAgKi9cbiAgdG9nZ2xlUmVhZE9ubHkoZSkge1xuICAgIGUgPyAodGhpcy5kZXN0cm95KCksIHRoaXMuRWRpdG9yLkNvbnZlcnNpb25Ub29sYmFyLmRlc3Ryb3koKSkgOiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLm1ha2UoKTtcbiAgICB9LCB7IHRpbWVvdXQ6IDJlMyB9KTtcbiAgfVxuICAvKipcbiAgICogIE1vdmluZyAvIGFwcGVhcmFuY2VcbiAgICogIH5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5cbiAgICovXG4gIC8qKlxuICAgKiBTaG93cyBJbmxpbmUgVG9vbGJhciBpZiBzb21ldGhpbmcgaXMgc2VsZWN0ZWRcbiAgICpcbiAgICogQHBhcmFtIFtuZWVkVG9DbG9zZV0gLSBwYXNzIHRydWUgdG8gY2xvc2UgdG9vbGJhciBpZiBpdCBpcyBub3QgYWxsb3dlZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXZvaWQgdG8gdXNlIGl0IGp1c3QgZm9yIGNsb3NpbmcgSVQsIGJldHRlciBjYWxsIC5jbG9zZSgpIGNsZWFybHkuXG4gICAqIEBwYXJhbSBbbmVlZFRvU2hvd0NvbnZlcnNpb25Ub29sYmFyXSAtIHBhc3MgZmFsc2UgdG8gbm90IHRvIHNob3cgQ29udmVyc2lvbiBUb29sYmFyXG4gICAqL1xuICBhc3luYyB0cnlUb1Nob3coZSA9ICExLCB0ID0gITApIHtcbiAgICBlICYmIHRoaXMuY2xvc2UoKSwgdGhpcy5hbGxvd2VkVG9TaG93KCkgJiYgKGF3YWl0IHRoaXMuYWRkVG9vbHNGaWx0ZXJlZCh0KSwgdGhpcy5tb3ZlKCksIHRoaXMub3Blbih0KSwgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpKTtcbiAgfVxuICAvKipcbiAgICogSGlkZXMgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMub3BlbmVkICYmICh0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQgfHwgKHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLmlubGluZVRvb2xiYXJTaG93ZWQpLCBBcnJheS5mcm9tKHRoaXMudG9vbHNJbnN0YW5jZXMuZW50cmllcygpKS5mb3JFYWNoKChbZSwgdF0pID0+IHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLmdldFRvb2xTaG9ydGN1dChlKTtcbiAgICAgIG8gJiYgYWUucmVtb3ZlKHRoaXMuRWRpdG9yLlVJLm5vZGVzLnJlZGFjdG9yLCBvKSwgTSh0LmNsZWFyKSAmJiB0LmNsZWFyKCk7XG4gICAgfSksIHRoaXMucmVzZXQoKSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5mbGlwcGVyLmRlYWN0aXZhdGUoKSwgdGhpcy5FZGl0b3IuQ29udmVyc2lvblRvb2xiYXIuY2xvc2UoKSkpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBub2RlIGlzIGNvbnRhaW5lZCBieSBJbmxpbmUgVG9vbGJhclxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUg4oCUIG5vZGUgdG8gY2hlY2tcbiAgICovXG4gIGNvbnRhaW5zTm9kZShlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMud3JhcHBlciA9PT0gdm9pZCAwID8gITEgOiB0aGlzLm5vZGVzLndyYXBwZXIuY29udGFpbnMoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgVUkgYW5kIGl0cyBjb21wb25lbnRzXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZmxpcHBlciAmJiAodGhpcy5mbGlwcGVyLmRlYWN0aXZhdGUoKSwgdGhpcy5mbGlwcGVyID0gbnVsbCksIHRoaXMucmVtb3ZlQWxsTm9kZXMoKTtcbiAgfVxuICAvKipcbiAgICogTWFraW5nIERPTVxuICAgKi9cbiAgbWFrZSgpIHtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIgPSBjLm1ha2UoXCJkaXZcIiwgW1xuICAgICAgdGhpcy5DU1MuaW5saW5lVG9vbGJhcixcbiAgICAgIC4uLnRoaXMuaXNSdGwgPyBbdGhpcy5FZGl0b3IuVUkuQ1NTLmVkaXRvclJ0bEZpeF0gOiBbXVxuICAgIF0pLCB0aGlzLm5vZGVzLnRvZ2dsZXJBbmRCdXR0b25zV3JhcHBlciA9IGMubWFrZShcImRpdlwiLCB0aGlzLkNTUy50b2dnbGVyQW5kQnV0dG9uc1dyYXBwZXIpLCB0aGlzLm5vZGVzLmJ1dHRvbnMgPSBjLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MuYnV0dG9uc1dyYXBwZXIpLCB0aGlzLm5vZGVzLmFjdGlvbnMgPSBjLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MuYWN0aW9uc1dyYXBwZXIpLCB0aGlzLmxpc3RlbmVycy5vbih0aGlzLm5vZGVzLndyYXBwZXIsIFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICBlLnRhcmdldC5jbG9zZXN0KGAuJHt0aGlzLkNTUy5hY3Rpb25zV3JhcHBlcn1gKSB8fCBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSksIGMuYXBwZW5kKHRoaXMubm9kZXMud3JhcHBlciwgW3RoaXMubm9kZXMudG9nZ2xlckFuZEJ1dHRvbnNXcmFwcGVyLCB0aGlzLm5vZGVzLmFjdGlvbnNdKSwgYy5hcHBlbmQodGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlciwgdGhpcy5ub2Rlcy53cmFwcGVyKSwgdGhpcy5hZGRDb252ZXJzaW9uVG9nZ2xlcigpLCBjLmFwcGVuZCh0aGlzLm5vZGVzLnRvZ2dsZXJBbmRCdXR0b25zV3JhcHBlciwgdGhpcy5ub2Rlcy5idXR0b25zKSwgdGhpcy5wcmVwYXJlQ29udmVyc2lvblRvb2xiYXIoKSwgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlV2lkdGgoKTtcbiAgICB9KSwgdGhpcy5lbmFibGVGbGlwcGVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIElubGluZSBUb29sYmFyXG4gICAqL1xuICBvcGVuKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5pbmxpbmVUb29sYmFyU2hvd2VkKSwgdGhpcy5idXR0b25zTGlzdCA9IHRoaXMubm9kZXMuYnV0dG9ucy5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0aGlzLkNTUy5pbmxpbmVUb29sQnV0dG9ufWApLCB0aGlzLm9wZW5lZCA9ICEwO1xuICAgIGxldCBlID0gQXJyYXkuZnJvbSh0aGlzLmJ1dHRvbnNMaXN0KTtcbiAgICBlLnVuc2hpZnQodGhpcy5ub2Rlcy5jb252ZXJzaW9uVG9nZ2xlciksIGUgPSBlLmZpbHRlcigodCkgPT4gIXQuaGlkZGVuKSwgdGhpcy5mbGlwcGVyLmFjdGl2YXRlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIFRvb2xiYXIgdG8gdGhlIHNlbGVjdGVkIHRleHRcbiAgICovXG4gIG1vdmUoKSB7XG4gICAgY29uc3QgZSA9IGIucmVjdCwgdCA9IHRoaXMuRWRpdG9yLlVJLm5vZGVzLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG8gPSB7XG4gICAgICB4OiBlLnggLSB0LngsXG4gICAgICB5OiBlLnkgKyBlLmhlaWdodCAtIC8vICsgd2luZG93LnNjcm9sbFlcbiAgICAgIHQudG9wICsgdGhpcy50b29sYmFyVmVydGljYWxNYXJnaW5cbiAgICB9O1xuICAgIG8ueCArIHRoaXMud2lkdGggKyB0LnggPiB0aGlzLkVkaXRvci5VSS5jb250ZW50UmVjdC5yaWdodCAmJiAoby54ID0gdGhpcy5FZGl0b3IuVUkuY29udGVudFJlY3QucmlnaHQgLSB0aGlzLndpZHRoIC0gdC54KSwgdGhpcy5ub2Rlcy53cmFwcGVyLnN0eWxlLmxlZnQgPSBNYXRoLmZsb29yKG8ueCkgKyBcInB4XCIsIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBNYXRoLmZsb29yKG8ueSkgKyBcInB4XCI7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIG9yaWVudGF0aW9uIGNsYXNzZXMgYW5kIHJlc2V0IHBvc2l0aW9uXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgIHRoaXMuQ1NTLmlubGluZVRvb2xiYXJMZWZ0T3JpZW50ZWQsXG4gICAgICB0aGlzLkNTUy5pbmxpbmVUb29sYmFyUmlnaHRPcmllbnRlZFxuICAgICksIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gXCIwXCIsIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBcIjBcIjtcbiAgfVxuICAvKipcbiAgICogTmVlZCB0byBzaG93IElubGluZSBUb29sYmFyIG9yIG5vdFxuICAgKi9cbiAgYWxsb3dlZFRvU2hvdygpIHtcbiAgICBjb25zdCBlID0gW1wiSU1HXCIsIFwiSU5QVVRcIl0sIHQgPSBiLmdldCgpLCBvID0gYi50ZXh0O1xuICAgIGlmICghdCB8fCAhdC5hbmNob3JOb2RlIHx8IHQuaXNDb2xsYXBzZWQgfHwgby5sZW5ndGggPCAxKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGkgPSBjLmlzRWxlbWVudCh0LmFuY2hvck5vZGUpID8gdC5hbmNob3JOb2RlIDogdC5hbmNob3JOb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKHQgJiYgZS5pbmNsdWRlcyhpLnRhZ05hbWUpIHx8IGkuY2xvc2VzdCgnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nKSA9PT0gbnVsbClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCByID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrKHQuYW5jaG9yTm9kZSk7XG4gICAgcmV0dXJuIHIgPyByLnRvb2wuaW5saW5lVG9vbHMuc2l6ZSAhPT0gMCA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBSZWNhbGN1bGF0ZSBpbmxpbmUgdG9vbGJhciB3aWR0aFxuICAgKi9cbiAgcmVjYWxjdWxhdGVXaWR0aCgpIHtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldFdpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0b2dnbGVyIGZvciBDb252ZXJzaW9uIERyb3Bkb3duXG4gICAqIGFuZCBwcmVwZW5kIGl0IHRvIHRoZSBidXR0b25zIGxpc3RcbiAgICovXG4gIGFkZENvbnZlcnNpb25Ub2dnbGVyKCkge1xuICAgIHRoaXMubm9kZXMuY29udmVyc2lvblRvZ2dsZXIgPSBjLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MuY29udmVyc2lvblRvZ2dsZXIpLCB0aGlzLm5vZGVzLmNvbnZlcnNpb25Ub2dnbGVyQ29udGVudCA9IGMubWFrZShcImRpdlwiLCB0aGlzLkNTUy5jb252ZXJzaW9uVG9nZ2xlckNvbnRlbnQpO1xuICAgIGNvbnN0IGUgPSBjLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MuY29udmVyc2lvblRvZ2dsZXJBcnJvdywge1xuICAgICAgaW5uZXJIVE1MOiBrdFxuICAgIH0pO1xuICAgIHRoaXMubm9kZXMuY29udmVyc2lvblRvZ2dsZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5jb252ZXJzaW9uVG9nZ2xlckNvbnRlbnQpLCB0aGlzLm5vZGVzLmNvbnZlcnNpb25Ub2dnbGVyLmFwcGVuZENoaWxkKGUpLCB0aGlzLm5vZGVzLnRvZ2dsZXJBbmRCdXR0b25zV3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLmNvbnZlcnNpb25Ub2dnbGVyKSwgdGhpcy5saXN0ZW5lcnMub24odGhpcy5ub2Rlcy5jb252ZXJzaW9uVG9nZ2xlciwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLkVkaXRvci5Db252ZXJzaW9uVG9vbGJhci50b2dnbGUoKHQpID0+IHtcbiAgICAgICAgIXQgJiYgdGhpcy5vcGVuZWQgPyB0aGlzLmZsaXBwZXIuYWN0aXZhdGUoKSA6IHRoaXMub3BlbmVkICYmIHRoaXMuZmxpcHBlci5kZWFjdGl2YXRlKCk7XG4gICAgICB9KTtcbiAgICB9KSwgdGUoKSA9PT0gITEgJiYgZ2UodGhpcy5ub2Rlcy5jb252ZXJzaW9uVG9nZ2xlciwgei51aShLLnVpLmlubGluZVRvb2xiYXIuY29udmVydGVyLCBcIkNvbnZlcnQgdG9cIiksIHtcbiAgICAgIHBsYWNlbWVudDogXCJ0b3BcIixcbiAgICAgIGhpZGluZ0RlbGF5OiAxMDBcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBDb252ZXJzaW9uIERyb3Bkb3duIGNvbnRlbnQgZm9yIGN1cnJlbnQgYmxvY2sncyBUb29sXG4gICAqL1xuICBhc3luYyBzZXRDb252ZXJzaW9uVG9nZ2xlckNvbnRlbnQoKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGUgfSA9IHRoaXMuRWRpdG9yLCB7IGN1cnJlbnRCbG9jazogdCB9ID0gZSwgbyA9IHQubmFtZSwgaSA9IHQudG9vbC5jb252ZXJzaW9uQ29uZmlnLCBuID0gaSAmJiBpLmV4cG9ydDtcbiAgICB0aGlzLm5vZGVzLmNvbnZlcnNpb25Ub2dnbGVyLmhpZGRlbiA9ICFuLCB0aGlzLm5vZGVzLmNvbnZlcnNpb25Ub2dnbGVyLmNsYXNzTGlzdC50b2dnbGUodGhpcy5DU1MuY29udmVyc2lvblRvZ2dsZXJIaWRkZW4sICFuKTtcbiAgICBjb25zdCByID0gYXdhaXQgdC5nZXRBY3RpdmVUb29sYm94RW50cnkoKSB8fCB7fTtcbiAgICB0aGlzLm5vZGVzLmNvbnZlcnNpb25Ub2dnbGVyQ29udGVudC5pbm5lckhUTUwgPSByLmljb24gfHwgci50aXRsZSB8fCByZShvKTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgdGhlIENvbnZlcnNpb24gRHJvcGRvd25cbiAgICovXG4gIHByZXBhcmVDb252ZXJzaW9uVG9vbGJhcigpIHtcbiAgICBjb25zdCBlID0gdGhpcy5FZGl0b3IuQ29udmVyc2lvblRvb2xiYXIubWFrZSgpO1xuICAgIGMuYXBwZW5kKHRoaXMubm9kZXMud3JhcHBlciwgZSk7XG4gIH1cbiAgLyoqXG4gICAqICBXb3JraW5nIHdpdGggVG9vbHNcbiAgICogIH5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5cbiAgICovXG4gIC8qKlxuICAgKiBBcHBlbmQgb25seSBhbGxvd2VkIFRvb2xzXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVlZFRvU2hvd0NvbnZlcnNpb25Ub29sYmFyIC0gcGFzcyBmYWxzZSB0byBub3QgdG8gc2hvdyBDb252ZXJzaW9uIFRvb2xiYXIgKGUuZy4gZm9yIEZvb3Rub3Rlcy1saWtlIHRvb2xzKVxuICAgKi9cbiAgYXN5bmMgYWRkVG9vbHNGaWx0ZXJlZChlID0gITApIHtcbiAgICBjb25zdCB0ID0gYi5nZXQoKSwgbyA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9jayh0LmFuY2hvck5vZGUpO1xuICAgIHRoaXMubm9kZXMuYnV0dG9ucy5pbm5lckhUTUwgPSBcIlwiLCB0aGlzLm5vZGVzLmFjdGlvbnMuaW5uZXJIVE1MID0gXCJcIiwgdGhpcy50b29sc0luc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIEFycmF5LmZyb20oby50b29sLmlubGluZVRvb2xzLnZhbHVlcygpKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICB0aGlzLmFkZFRvb2woaSk7XG4gICAgfSksIGUgJiYgdGhpcy5FZGl0b3IuQ29udmVyc2lvblRvb2xiYXIuaGFzVG9vbHMoKSA/IGF3YWl0IHRoaXMuc2V0Q29udmVyc2lvblRvZ2dsZXJDb250ZW50KCkgOiB0aGlzLm5vZGVzLmNvbnZlcnNpb25Ub2dnbGVyLmhpZGRlbiA9ICEwLCB0aGlzLnJlY2FsY3VsYXRlV2lkdGgoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIHRvb2wgYnV0dG9uIGFuZCBhY3RpdmF0ZSBjbGlja3NcbiAgICpcbiAgICogQHBhcmFtIHtJbmxpbmVUb29sfSB0b29sIC0gSW5saW5lVG9vbCBvYmplY3RcbiAgICovXG4gIGFkZFRvb2woZSkge1xuICAgIGNvbnN0IHQgPSBlLmNyZWF0ZSgpLCBvID0gdC5yZW5kZXIoKTtcbiAgICBpZiAoIW8pIHtcbiAgICAgIFQoXCJSZW5kZXIgbWV0aG9kIG11c3QgcmV0dXJuIGFuIGluc3RhbmNlIG9mIE5vZGVcIiwgXCJ3YXJuXCIsIGUubmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvLmRhdGFzZXQudG9vbCA9IGUubmFtZSwgdGhpcy5ub2Rlcy5idXR0b25zLmFwcGVuZENoaWxkKG8pLCB0aGlzLnRvb2xzSW5zdGFuY2VzLnNldChlLm5hbWUsIHQpLCBNKHQucmVuZGVyQWN0aW9ucykpIHtcbiAgICAgIGNvbnN0IGEgPSB0LnJlbmRlckFjdGlvbnMoKTtcbiAgICAgIHRoaXMubm9kZXMuYWN0aW9ucy5hcHBlbmRDaGlsZChhKTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnMub24obywgXCJjbGlja1wiLCAoYSkgPT4ge1xuICAgICAgdGhpcy50b29sQ2xpY2tlZCh0KSwgYS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldFRvb2xTaG9ydGN1dChlLm5hbWUpO1xuICAgIGlmIChpKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5lbmFibGVTaG9ydGN1dHModCwgaSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICBjb25zdCBuID0gYy5tYWtlKFwiZGl2XCIpLCByID0gei50KFxuICAgICAgSy50b29sTmFtZXMsXG4gICAgICBlLnRpdGxlIHx8IHJlKGUubmFtZSlcbiAgICApO1xuICAgIG4uYXBwZW5kQ2hpbGQoYy50ZXh0KHIpKSwgaSAmJiBuLmFwcGVuZENoaWxkKGMubWFrZShcImRpdlwiLCB0aGlzLkNTUy5pbmxpbmVUb29sYmFyU2hvcnRjdXQsIHtcbiAgICAgIHRleHRDb250ZW50OiB5ZShpKVxuICAgIH0pKSwgdGUoKSA9PT0gITEgJiYgZ2Uobywgbiwge1xuICAgICAgcGxhY2VtZW50OiBcInRvcFwiLFxuICAgICAgaGlkaW5nRGVsYXk6IDEwMFxuICAgIH0pLCB0LmNoZWNrU3RhdGUoYi5nZXQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzaG9ydGN1dCBuYW1lIGZvciB0b29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sTmFtZSDigJQgVG9vbCBuYW1lXG4gICAqL1xuICBnZXRUb29sU2hvcnRjdXQoZSkge1xuICAgIGNvbnN0IHsgVG9vbHM6IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gdC5pbmxpbmVUb29scy5nZXQoZSksIGkgPSB0LmludGVybmFsLmlubGluZVRvb2xzO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGkua2V5cygpKS5pbmNsdWRlcyhlKSA/IHRoaXMuaW5saW5lVG9vbHNbZV1bRXQuU2hvcnRjdXRdIDogby5zaG9ydGN1dDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIFRvb2wgc2hvcnRjdXQgd2l0aCBFZGl0b3IgU2hvcnRjdXRzIE1vZHVsZVxuICAgKlxuICAgKiBAcGFyYW0ge0lubGluZVRvb2x9IHRvb2wgLSBUb29sIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydGN1dCAtIHNob3J0Y3V0IGFjY29yZGluZyB0byB0aGUgU2hvcnRjdXREYXRhIE1vZHVsZSBmb3JtYXRcbiAgICovXG4gIGVuYWJsZVNob3J0Y3V0cyhlLCB0KSB7XG4gICAgYWUuYWRkKHtcbiAgICAgIG5hbWU6IHQsXG4gICAgICBoYW5kbGVyOiAobykgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogaSB9ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyO1xuICAgICAgICBpICYmIGkudG9vbC5lbmFibGVkSW5saW5lVG9vbHMgJiYgKG8ucHJldmVudERlZmF1bHQoKSwgdGhpcy50b29sQ2xpY2tlZChlKSk7XG4gICAgICB9LFxuICAgICAgb246IHRoaXMuRWRpdG9yLlVJLm5vZGVzLnJlZGFjdG9yXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIElubGluZSBUb29sIGJ1dHRvbiBjbGlja3NcbiAgICpcbiAgICogQHBhcmFtIHtJbmxpbmVUb29sfSB0b29sIC0gVG9vbCdzIGluc3RhbmNlXG4gICAqL1xuICB0b29sQ2xpY2tlZChlKSB7XG4gICAgY29uc3QgdCA9IGIucmFuZ2U7XG4gICAgZS5zdXJyb3VuZCh0KSwgdGhpcy5jaGVja1Rvb2xzU3RhdGUoKSwgZS5yZW5kZXJBY3Rpb25zICE9PSB2b2lkIDAgJiYgdGhpcy5mbGlwcGVyLmRlYWN0aXZhdGUoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgVG9vbHNgIHN0YXRlIGJ5IHNlbGVjdGlvblxuICAgKi9cbiAgY2hlY2tUb29sc1N0YXRlKCkge1xuICAgIHRoaXMudG9vbHNJbnN0YW5jZXMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5jaGVja1N0YXRlKGIuZ2V0KCkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5saW5lIHRvb2xzIHRvb2xzXG4gICAqIFRvb2xzIHRoYXQgaGFzIGlzSW5saW5lIGlzIHRydWVcbiAgICovXG4gIGdldCBpbmxpbmVUb29scygpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5FZGl0b3IuVG9vbHMuaW5saW5lVG9vbHMuZW50cmllcygpKS5mb3JFYWNoKChbdCwgb10pID0+IHtcbiAgICAgIGVbdF0gPSBvLmNyZWF0ZSgpO1xuICAgIH0pLCBlO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvdyB0byBsZWFmIGJ1dHRvbnMgYnkgYXJyb3dzIC8gdGFiXG4gICAqIEJ1dHRvbnMgd2lsbCBiZSBmaWxsZWQgb24gb3BlbmluZ1xuICAgKi9cbiAgZW5hYmxlRmxpcHBlcigpIHtcbiAgICB0aGlzLmZsaXBwZXIgPSBuZXcgcSh7XG4gICAgICBmb2N1c2VkSXRlbUNsYXNzOiB0aGlzLkNTUy5mb2N1c2VkQnV0dG9uLFxuICAgICAgYWxsb3dlZEtleXM6IFtcbiAgICAgICAgdi5FTlRFUixcbiAgICAgICAgdi5UQUJcbiAgICAgIF1cbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgZWkgZXh0ZW5kcyB5IHtcbiAgLyoqXG4gICAqIEFsbCBrZXlkb3ducyBvbiBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAga2V5ZG93bihlKSB7XG4gICAgc3dpdGNoICh0aGlzLmJlZm9yZUtleWRvd25Qcm9jZXNzaW5nKGUpLCBlLmtleUNvZGUpIHtcbiAgICAgIGNhc2Ugdi5CQUNLU1BBQ0U6XG4gICAgICAgIHRoaXMuYmFja3NwYWNlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugdi5ERUxFVEU6XG4gICAgICAgIHRoaXMuZGVsZXRlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugdi5FTlRFUjpcbiAgICAgICAgdGhpcy5lbnRlcihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHYuRE9XTjpcbiAgICAgIGNhc2Ugdi5SSUdIVDpcbiAgICAgICAgdGhpcy5hcnJvd1JpZ2h0QW5kRG93bihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHYuVVA6XG4gICAgICBjYXNlIHYuTEVGVDpcbiAgICAgICAgdGhpcy5hcnJvd0xlZnRBbmRVcChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHYuVEFCOlxuICAgICAgICB0aGlzLnRhYlByZXNzZWQoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlLmtleSA9PT0gXCIvXCIgJiYgIWUuY3RybEtleSAmJiAhZS5tZXRhS2V5ICYmIHRoaXMuc2xhc2hQcmVzc2VkKCksIGUuY29kZSA9PT0gXCJTbGFzaFwiICYmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAmJiAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmNvbW1hbmRTbGFzaFByZXNzZWQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpcmVzIG9uIGtleWRvd24gYmVmb3JlIGV2ZW50IHByb2Nlc3NpbmdcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGJlZm9yZUtleWRvd25Qcm9jZXNzaW5nKGUpIHtcbiAgICB0aGlzLm5lZWRUb29sYmFyQ2xvc2luZyhlKSAmJiBsdChlLmtleUNvZGUpICYmICh0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCksIHRoaXMuRWRpdG9yLkNvbnZlcnNpb25Ub29sYmFyLmNsb3NlKCksIGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5hbHRLZXkgfHwgZS5zaGlmdEtleSB8fCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKSk7XG4gIH1cbiAgLyoqXG4gICAqIEtleSB1cCBvbiBCbG9jazpcbiAgICogLSBzaG93cyBJbmxpbmUgVG9vbGJhciBpZiBzb21ldGhpbmcgc2VsZWN0ZWRcbiAgICogLSBzaG93cyBjb252ZXJzaW9uIHRvb2xiYXIgd2l0aCA4NSUgb2YgYmxvY2sgc2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXl1cCBldmVudFxuICAgKi9cbiAga2V5dXAoZSkge1xuICAgIGUuc2hpZnRLZXkgfHwgdGhpcy5FZGl0b3IuVUkuY2hlY2tFbXB0aW5lc3MoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGRyb3AgdGFyZ2V0IHN0eWxlc1xuICAgKlxuICAgKiBAcGFyYW0ge0RyYWdFdmVudH0gZXZlbnQgLSBkcmFnIG92ZXIgZXZlbnRcbiAgICovXG4gIGRyYWdPdmVyKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlDaGlsZE5vZGUoZS50YXJnZXQpO1xuICAgIHQuZHJvcFRhcmdldCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgZHJvcCB0YXJnZXQgc3R5bGVcbiAgICpcbiAgICogQHBhcmFtIHtEcmFnRXZlbnR9IGV2ZW50IC0gZHJhZyBsZWF2ZSBldmVudFxuICAgKi9cbiAgZHJhZ0xlYXZlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlDaGlsZE5vZGUoZS50YXJnZXQpO1xuICAgIHQuZHJvcFRhcmdldCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBDb3B5aW5nIHNlbGVjdGVkIGJsb2Nrc1xuICAgKiBCZWZvcmUgcHV0dGluZyB0byB0aGUgY2xpcGJvYXJkIHdlIHNhbml0aXplIGFsbCBibG9ja3MgYW5kIHRoZW4gY29weSB0byB0aGUgY2xpcGJvYXJkXG4gICAqXG4gICAqIEBwYXJhbSB7Q2xpcGJvYXJkRXZlbnR9IGV2ZW50IC0gY2xpcGJvYXJkIGV2ZW50XG4gICAqL1xuICBoYW5kbGVDb21tYW5kQyhlKSB7XG4gICAgY29uc3QgeyBCbG9ja1NlbGVjdGlvbjogdCB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdC5hbnlCbG9ja1NlbGVjdGVkICYmIHQuY29weVNlbGVjdGVkQmxvY2tzKGUpO1xuICB9XG4gIC8qKlxuICAgKiBDb3B5IGFuZCBEZWxldGUgc2VsZWN0ZWQgQmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7Q2xpcGJvYXJkRXZlbnR9IGV2ZW50IC0gY2xpcGJvYXJkIGV2ZW50XG4gICAqL1xuICBoYW5kbGVDb21tYW5kWChlKSB7XG4gICAgY29uc3QgeyBCbG9ja1NlbGVjdGlvbjogdCwgQmxvY2tNYW5hZ2VyOiBvLCBDYXJldDogaSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdC5hbnlCbG9ja1NlbGVjdGVkICYmIHQuY29weVNlbGVjdGVkQmxvY2tzKGUpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgbiA9IG8ucmVtb3ZlU2VsZWN0ZWRCbG9ja3MoKSwgciA9IG8uaW5zZXJ0RGVmYXVsdEJsb2NrQXRJbmRleChuLCAhMCk7XG4gICAgICBpLnNldFRvQmxvY2sociwgaS5wb3NpdGlvbnMuU1RBUlQpLCB0LmNsZWFyU2VsZWN0aW9uKGUpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUYWIgcHJlc3NlZCBpbnNpZGUgYSBCbG9jay5cbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIHRhYlByZXNzZWQoZSkge1xuICAgIGNvbnN0IHsgSW5saW5lVG9vbGJhcjogdCwgQ29udmVyc2lvblRvb2xiYXI6IG8sIENhcmV0OiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBpZiAoby5vcGVuZWQgfHwgdC5vcGVuZWQpXG4gICAgICByZXR1cm47XG4gICAgKGUuc2hpZnRLZXkgPyBpLm5hdmlnYXRlUHJldmlvdXMoITApIDogaS5uYXZpZ2F0ZU5leHQoITApKSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgLyoqXG4gICAqICcvJyArICdjb21tYW5kJyBrZXlkb3duIGluc2lkZSBhIEJsb2NrXG4gICAqL1xuICBjb21tYW5kU2xhc2hQcmVzc2VkKCkge1xuICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnNlbGVjdGVkQmxvY2tzLmxlbmd0aCA+IDEgfHwgdGhpcy5hY3RpdmF0ZUJsb2NrU2V0dGluZ3MoKTtcbiAgfVxuICAvKipcbiAgICogJy8nIGtleWRvd24gaW5zaWRlIGEgQmxvY2tcbiAgICovXG4gIHNsYXNoUHJlc3NlZCgpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLmlzRW1wdHkgJiYgdGhpcy5hY3RpdmF0ZVRvb2xib3goKTtcbiAgfVxuICAvKipcbiAgICogRU5URVIgcHJlc3NlZCBvbiBibG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAgZW50ZXIoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBVSTogbyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgaWYgKHQuY3VycmVudEJsb2NrLnRvb2wuaXNMaW5lQnJlYWtzRW5hYmxlZCB8fCBvLnNvbWVUb29sYmFyT3BlbmVkICYmIG8uc29tZUZsaXBwZXJCdXR0b25Gb2N1c2VkIHx8IGUuc2hpZnRLZXkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IG4gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrO1xuICAgIHRoaXMuRWRpdG9yLkNhcmV0LmlzQXRTdGFydCAmJiAhdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jay5oYXNNZWRpYSA/IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2tJbmRleCkgOiB0aGlzLkVkaXRvci5DYXJldC5pc0F0RW5kID8gbiA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2tJbmRleCArIDEpIDogbiA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5zcGxpdCgpLCB0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKG4pLCB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKG4pLCBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBiYWNrc3BhY2Uga2V5ZG93biBvbiBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAgYmFja3NwYWNlKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQ2FyZXQ6IG8gfSA9IHRoaXMuRWRpdG9yLCB7IGN1cnJlbnRCbG9jazogaSwgcHJldmlvdXNCbG9jazogbiB9ID0gdDtcbiAgICBpZiAoIWIuaXNDb2xsYXBzZWQgfHwgIW8uaXNBdFN0YXJ0KVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSwgIShpLmN1cnJlbnRJbnB1dCA9PT0gaS5maXJzdElucHV0KSkge1xuICAgICAgby5uYXZpZ2F0ZVByZXZpb3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChuLmlzRW1wdHkpIHtcbiAgICAgIHQucmVtb3ZlQmxvY2sobik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpLmlzRW1wdHkpIHtcbiAgICAgIHQucmVtb3ZlQmxvY2soaSk7XG4gICAgICBjb25zdCBsID0gdC5jdXJyZW50QmxvY2s7XG4gICAgICBvLnNldFRvQmxvY2sobCwgby5wb3NpdGlvbnMuRU5EKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3QoaSwgbikgPyB0aGlzLm1lcmdlQmxvY2tzKG4sIGkpIDogby5zZXRUb0Jsb2NrKG4sIG8ucG9zaXRpb25zLkVORCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgZGVsZXRlIGtleWRvd24gb24gQmxvY2tcbiAgICogUmVtb3ZlcyBjaGFyIGFmdGVyIHRoZSBjYXJldC5cbiAgICogSWYgY2FyZXQgaXMgYXQgdGhlIGVuZCBvZiB0aGUgYmxvY2ssIG1lcmdlIG5leHQgYmxvY2sgd2l0aCBjdXJyZW50XG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBkZWxldGUoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBDYXJldDogbyB9ID0gdGhpcy5FZGl0b3IsIHsgY3VycmVudEJsb2NrOiBpLCBuZXh0QmxvY2s6IG4gfSA9IHQ7XG4gICAgaWYgKCFiLmlzQ29sbGFwc2VkIHx8ICFvLmlzQXRFbmQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpLCAhKGkuY3VycmVudElucHV0ID09PSBpLmxhc3RJbnB1dCkpIHtcbiAgICAgIG8ubmF2aWdhdGVOZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChuLmlzRW1wdHkpIHtcbiAgICAgIHQucmVtb3ZlQmxvY2sobik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpLmlzRW1wdHkpIHtcbiAgICAgIHQucmVtb3ZlQmxvY2soaSksIG8uc2V0VG9CbG9jayhuLCBvLnBvc2l0aW9ucy5TVEFSVCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG90KGksIG4pID8gdGhpcy5tZXJnZUJsb2NrcyhpLCBuKSA6IG8uc2V0VG9CbG9jayhuLCBvLnBvc2l0aW9ucy5TVEFSVCk7XG4gIH1cbiAgLyoqXG4gICAqIE1lcmdlIHBhc3NlZCBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHRhcmdldEJsb2NrIC0gdG8gd2hpY2ggQmxvY2sgd2Ugd2FudCB0byBtZXJnZVxuICAgKiBAcGFyYW0gYmxvY2tUb01lcmdlIC0gd2hhdCBCbG9jayB3ZSB3YW50IHRvIG1lcmdlXG4gICAqL1xuICBtZXJnZUJsb2NrcyhlLCB0KSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IG8sIENhcmV0OiBpLCBUb29sYmFyOiBuIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBpLmNyZWF0ZVNoYWRvdyhlLnBsdWdpbnNDb250ZW50KSwgby5tZXJnZUJsb2NrcyhlLCB0KS50aGVuKCgpID0+IHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBpLnJlc3RvcmVDYXJldChlLnBsdWdpbnNDb250ZW50KSwgZS5wbHVnaW5zQ29udGVudC5ub3JtYWxpemUoKSwgbi5jbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSByaWdodCBhbmQgZG93biBrZXlib2FyZCBrZXlzXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgYXJyb3dSaWdodEFuZERvd24oZSkge1xuICAgIGNvbnN0IHQgPSBxLnVzZWRLZXlzLmluY2x1ZGVzKGUua2V5Q29kZSkgJiYgKCFlLnNoaWZ0S2V5IHx8IGUua2V5Q29kZSA9PT0gdi5UQUIpO1xuICAgIGlmICh0aGlzLkVkaXRvci5VSS5zb21lVG9vbGJhck9wZW5lZCAmJiB0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKTtcbiAgICBjb25zdCBvID0gdGhpcy5FZGl0b3IuQ2FyZXQuaXNBdEVuZCB8fCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5hbnlCbG9ja1NlbGVjdGVkO1xuICAgIGlmIChlLnNoaWZ0S2V5ICYmIGUua2V5Q29kZSA9PT0gdi5ET1dOICYmIG8pIHtcbiAgICAgIHRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24udG9nZ2xlQmxvY2tTZWxlY3RlZFN0YXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLmtleUNvZGUgPT09IHYuRE9XTiB8fCBlLmtleUNvZGUgPT09IHYuUklHSFQgJiYgIXRoaXMuaXNSdGwgPyB0aGlzLkVkaXRvci5DYXJldC5uYXZpZ2F0ZU5leHQoKSA6IHRoaXMuRWRpdG9yLkNhcmV0Lm5hdmlnYXRlUHJldmlvdXMoKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB4ZSgoKSA9PiB7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrICYmIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sudXBkYXRlQ3VycmVudElucHV0KCk7XG4gICAgfSwgMjApKCksIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbGVmdCBhbmQgdXAga2V5Ym9hcmQga2V5c1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5Ym9hcmQgZXZlbnRcbiAgICovXG4gIGFycm93TGVmdEFuZFVwKGUpIHtcbiAgICBpZiAodGhpcy5FZGl0b3IuVUkuc29tZVRvb2xiYXJPcGVuZWQpIHtcbiAgICAgIGlmIChxLnVzZWRLZXlzLmluY2x1ZGVzKGUua2V5Q29kZSkgJiYgKCFlLnNoaWZ0S2V5IHx8IGUua2V5Q29kZSA9PT0gdi5UQUIpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLkVkaXRvci5VSS5jbG9zZUFsbFRvb2xiYXJzKCk7XG4gICAgfVxuICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQ2FyZXQuaXNBdFN0YXJ0IHx8IHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmFueUJsb2NrU2VsZWN0ZWQ7XG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSB2LlVQICYmIHQpIHtcbiAgICAgIHRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24udG9nZ2xlQmxvY2tTZWxlY3RlZFN0YXRlKCExKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gdi5VUCB8fCBlLmtleUNvZGUgPT09IHYuTEVGVCAmJiAhdGhpcy5pc1J0bCA/IHRoaXMuRWRpdG9yLkNhcmV0Lm5hdmlnYXRlUHJldmlvdXMoKSA6IHRoaXMuRWRpdG9yLkNhcmV0Lm5hdmlnYXRlTmV4dCgpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHhlKCgpID0+IHtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgJiYgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jay51cGRhdGVDdXJyZW50SW5wdXQoKTtcbiAgICB9LCAyMCkoKSwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSk7XG4gIH1cbiAgLyoqXG4gICAqIENhc2VzIHdoZW4gd2UgbmVlZCB0byBjbG9zZSBUb29sYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgbmVlZFRvb2xiYXJDbG9zaW5nKGUpIHtcbiAgICBjb25zdCB0ID0gZS5rZXlDb2RlID09PSB2LkVOVEVSICYmIHRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5vcGVuZWQsIG8gPSBlLmtleUNvZGUgPT09IHYuRU5URVIgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQsIGkgPSBlLmtleUNvZGUgPT09IHYuRU5URVIgJiYgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5vcGVuZWQsIG4gPSBlLmtleUNvZGUgPT09IHYuRU5URVIgJiYgdGhpcy5FZGl0b3IuQ29udmVyc2lvblRvb2xiYXIub3BlbmVkLCByID0gZS5rZXlDb2RlID09PSB2LlRBQjtcbiAgICByZXR1cm4gIShlLnNoaWZ0S2V5IHx8IHIgfHwgdCB8fCBvIHx8IGkgfHwgbik7XG4gIH1cbiAgLyoqXG4gICAqIElmIFRvb2xib3ggaXMgbm90IG9wZW4sIHRoZW4ganVzdCBvcGVuIGl0IGFuZCBzaG93IHBsdXMgYnV0dG9uXG4gICAqL1xuICBhY3RpdmF0ZVRvb2xib3goKSB7XG4gICAgdGhpcy5FZGl0b3IuVG9vbGJhci5vcGVuZWQgfHwgdGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbigpLCB0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3gub3BlbigpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIFRvb2xiYXIgYW5kIHNob3cgQmxvY2tTZXR0aW5ncyBiZWZvcmUgZmxpcHBpbmcgVG9vbHNcbiAgICovXG4gIGFjdGl2YXRlQmxvY2tTZXR0aW5ncygpIHtcbiAgICB0aGlzLkVkaXRvci5Ub29sYmFyLm9wZW5lZCB8fCB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKCksIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkIHx8IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbigpO1xuICB9XG59XG5jbGFzcyBTZSB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gd29ya2luZ0FyZWEg4oCUIGVkaXRvcmBzIHdvcmtpbmcgbm9kZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuYmxvY2tzID0gW10sIHRoaXMud29ya2luZ0FyZWEgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgbGVuZ3RoIG9mIEJsb2NrIGluc3RhbmNlcyBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sgaW5zdGFuY2VzIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja1tdfVxuICAgKi9cbiAgZ2V0IGFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmJsb2NrcztcbiAgfVxuICAvKipcbiAgICogR2V0IGJsb2NrcyBodG1sIGVsZW1lbnRzIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFtdfVxuICAgKi9cbiAgZ2V0IG5vZGVzKCkge1xuICAgIHJldHVybiBjdCh0aGlzLndvcmtpbmdBcmVhLmNoaWxkcmVuKTtcbiAgfVxuICAvKipcbiAgICogUHJveHkgdHJhcCB0byBpbXBsZW1lbnQgYXJyYXktbGlrZSBzZXR0ZXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYmxvY2tzWzBdID0gbmV3IEJsb2NrKC4uLilcbiAgICogQHBhcmFtIHtCbG9ja3N9IGluc3RhbmNlIOKAlCBCbG9ja3MgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0gcHJvcGVydHkg4oCUIGJsb2NrIGluZGV4IG9yIGFueSBCbG9ja3MgY2xhc3MgcHJvcGVydHkga2V5IHRvIHNldFxuICAgKiBAcGFyYW0ge0Jsb2NrfSB2YWx1ZSDigJQgdmFsdWUgdG8gc2V0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIHNldChlLCB0LCBvKSB7XG4gICAgcmV0dXJuIGlzTmFOKE51bWJlcih0KSkgPyAoUmVmbGVjdC5zZXQoZSwgdCwgbyksICEwKSA6IChlLmluc2VydCgrdCwgbyksICEwKTtcbiAgfVxuICAvKipcbiAgICogUHJveHkgdHJhcCB0byBpbXBsZW1lbnQgYXJyYXktbGlrZSBnZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja3N9IGluc3RhbmNlIOKAlCBCbG9ja3MgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0gcHJvcGVydHkg4oCUIEJsb2NrcyBjbGFzcyBwcm9wZXJ0eSBrZXlcbiAgICogQHJldHVybnMge0Jsb2NrfCp9XG4gICAqL1xuICBzdGF0aWMgZ2V0KGUsIHQpIHtcbiAgICByZXR1cm4gaXNOYU4oTnVtYmVyKHQpKSA/IFJlZmxlY3QuZ2V0KGUsIHQpIDogZS5nZXQoK3QpO1xuICB9XG4gIC8qKlxuICAgKiBQdXNoIG5ldyBCbG9jayB0byB0aGUgYmxvY2tzIGFycmF5IGFuZCBhcHBlbmQgaXQgdG8gd29ya2luZyBhcmVhXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgdG8gYWRkXG4gICAqL1xuICBwdXNoKGUpIHtcbiAgICB0aGlzLmJsb2Nrcy5wdXNoKGUpLCB0aGlzLmluc2VydFRvRE9NKGUpO1xuICB9XG4gIC8qKlxuICAgKiBTd2FwcyBibG9ja3Mgd2l0aCBpbmRleGVzIGZpcnN0IGFuZCBzZWNvbmRcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZpcnN0IC0gZmlyc3QgYmxvY2sgaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZCAtIHNlY29uZCBibG9jayBpbmRleFxuICAgKiBAZGVwcmVjYXRlZCDigJQgdXNlICdtb3ZlJyBpbnN0ZWFkXG4gICAqL1xuICBzd2FwKGUsIHQpIHtcbiAgICBjb25zdCBvID0gdGhpcy5ibG9ja3NbdF07XG4gICAgYy5zd2FwKHRoaXMuYmxvY2tzW2VdLmhvbGRlciwgby5ob2xkZXIpLCB0aGlzLmJsb2Nrc1t0XSA9IHRoaXMuYmxvY2tzW2VdLCB0aGlzLmJsb2Nrc1tlXSA9IG87XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgYSBibG9jayBmcm9tIG9uZSB0byBhbm90aGVyIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gbmV3IGluZGV4IG9mIHRoZSBibG9ja1xuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gYmxvY2sgdG8gbW92ZVxuICAgKi9cbiAgbW92ZShlLCB0KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuYmxvY2tzLnNwbGljZSh0LCAxKVswXSwgaSA9IGUgLSAxLCBuID0gTWF0aC5tYXgoMCwgaSksIHIgPSB0aGlzLmJsb2Nrc1tuXTtcbiAgICBlID4gMCA/IHRoaXMuaW5zZXJ0VG9ET00obywgXCJhZnRlcmVuZFwiLCByKSA6IHRoaXMuaW5zZXJ0VG9ET00obywgXCJiZWZvcmViZWdpblwiLCByKSwgdGhpcy5ibG9ja3Muc3BsaWNlKGUsIDAsIG8pO1xuICAgIGNvbnN0IGEgPSB0aGlzLmNvbXBvc2VCbG9ja0V2ZW50KFwibW92ZVwiLCB7XG4gICAgICBmcm9tSW5kZXg6IHQsXG4gICAgICB0b0luZGV4OiBlXG4gICAgfSk7XG4gICAgby5jYWxsKFguTU9WRUQsIGEpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IEJsb2NrIGF0IHBhc3NlZCBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXgg4oCUIGluZGV4IHRvIGluc2VydCBCbG9ja1xuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayDigJQgQmxvY2sgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZSDigJQgaXQgdHJ1ZSwgcmVwbGFjZSBibG9jayBvbiBnaXZlbiBpbmRleFxuICAgKi9cbiAgaW5zZXJ0KGUsIHQsIG8gPSAhMSkge1xuICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucHVzaCh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZSA+IHRoaXMubGVuZ3RoICYmIChlID0gdGhpcy5sZW5ndGgpLCBvICYmICh0aGlzLmJsb2Nrc1tlXS5ob2xkZXIucmVtb3ZlKCksIHRoaXMuYmxvY2tzW2VdLmNhbGwoWC5SRU1PVkVEKSk7XG4gICAgY29uc3QgaSA9IG8gPyAxIDogMDtcbiAgICBpZiAodGhpcy5ibG9ja3Muc3BsaWNlKGUsIGksIHQpLCBlID4gMCkge1xuICAgICAgY29uc3QgbiA9IHRoaXMuYmxvY2tzW2UgLSAxXTtcbiAgICAgIHRoaXMuaW5zZXJ0VG9ET00odCwgXCJhZnRlcmVuZFwiLCBuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbiA9IHRoaXMuYmxvY2tzW2UgKyAxXTtcbiAgICAgIG4gPyB0aGlzLmluc2VydFRvRE9NKHQsIFwiYmVmb3JlYmVnaW5cIiwgbikgOiB0aGlzLmluc2VydFRvRE9NKHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgYmxvY2sgdW5kZXIgcGFzc2VkIGluZGV4IHdpdGggcGFzc2VkIGJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCAtIGluZGV4IG9mIGV4aXN0ZWQgYmxvY2tcbiAgICogQHBhcmFtIGJsb2NrIC0gbmV3IGJsb2NrXG4gICAqL1xuICByZXBsYWNlKGUsIHQpIHtcbiAgICBpZiAodGhpcy5ibG9ja3NbZV0gPT09IHZvaWQgMClcbiAgICAgIHRocm93IEVycm9yKFwiSW5jb3JyZWN0IGluZGV4XCIpO1xuICAgIHRoaXMuYmxvY2tzW2VdLmhvbGRlci5yZXBsYWNlV2l0aCh0LmhvbGRlciksIHRoaXMuYmxvY2tzW2VdID0gdDtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBzZXZlcmFsIGJsb2NrcyBhdCBvbmNlXG4gICAqXG4gICAqIEBwYXJhbSBibG9ja3MgLSBibG9ja3MgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSBpbmRleCAtIGluZGV4IHRvIGluc2VydCBibG9ja3MgYXRcbiAgICovXG4gIGluc2VydE1hbnkoZSwgdCkge1xuICAgIGNvbnN0IG8gPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGZvciAoY29uc3QgaSBvZiBlKVxuICAgICAgby5hcHBlbmRDaGlsZChpLmhvbGRlcik7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGkgPSBNYXRoLm1pbih0IC0gMSwgdGhpcy5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5ibG9ja3NbaV0uaG9sZGVyLmFmdGVyKG8pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHQgPT09IDAgJiYgdGhpcy53b3JraW5nQXJlYS5wcmVwZW5kKG8pO1xuICAgICAgdGhpcy5ibG9ja3Muc3BsaWNlKHQsIDAsIC4uLmUpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5ibG9ja3MucHVzaCguLi5lKSwgdGhpcy53b3JraW5nQXJlYS5hcHBlbmRDaGlsZChvKTtcbiAgICBlLmZvckVhY2goKGkpID0+IGkuY2FsbChYLlJFTkRFUkVEKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBibG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBCbG9jayB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZShlKSB7XG4gICAgaXNOYU4oZSkgJiYgKGUgPSB0aGlzLmxlbmd0aCAtIDEpLCB0aGlzLmJsb2Nrc1tlXS5ob2xkZXIucmVtb3ZlKCksIHRoaXMuYmxvY2tzW2VdLmNhbGwoWC5SRU1PVkVEKSwgdGhpcy5ibG9ja3Muc3BsaWNlKGUsIDEpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGJsb2Nrc1xuICAgKi9cbiAgcmVtb3ZlQWxsKCkge1xuICAgIHRoaXMud29ya2luZ0FyZWEuaW5uZXJIVE1MID0gXCJcIiwgdGhpcy5ibG9ja3MuZm9yRWFjaCgoZSkgPT4gZS5jYWxsKFguUkVNT1ZFRCkpLCB0aGlzLmJsb2Nrcy5sZW5ndGggPSAwO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgQmxvY2sgYWZ0ZXIgcGFzc2VkIHRhcmdldFxuICAgKlxuICAgKiBAdG9kbyBkZWNpZGUgaWYgdGhpcyBtZXRob2QgaXMgbmVjZXNzYXJ5XG4gICAqIEBwYXJhbSB7QmxvY2t9IHRhcmdldEJsb2NrIOKAlCB0YXJnZXQgYWZ0ZXIgd2hpY2ggQmxvY2sgc2hvdWxkIGJlIGluc2VydGVkXG4gICAqIEBwYXJhbSB7QmxvY2t9IG5ld0Jsb2NrIOKAlCBCbG9jayB0byBpbnNlcnRcbiAgICovXG4gIGluc2VydEFmdGVyKGUsIHQpIHtcbiAgICBjb25zdCBvID0gdGhpcy5ibG9ja3MuaW5kZXhPZihlKTtcbiAgICB0aGlzLmluc2VydChvICsgMSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBCbG9jayBieSBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXgg4oCUIEJsb2NrIGluZGV4XG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldChlKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzW2VdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gaW5kZXggb2YgcGFzc2VkIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgdG8gZmluZFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgaW5kZXhPZihlKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzLmluZGV4T2YoZSk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBuZXcgQmxvY2sgaW50byBET01cbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtJbnNlcnRQb3NpdGlvbn0gcG9zaXRpb24g4oCUIGluc2VydCBwb3NpdGlvbiAoaWYgc2V0LCB3aWxsIHVzZSBpbnNlcnRBZGphY2VudEVsZW1lbnQpXG4gICAqIEBwYXJhbSB7QmxvY2t9IHRhcmdldCDigJQgQmxvY2sgcmVsYXRlZCB0byBwb3NpdGlvblxuICAgKi9cbiAgaW5zZXJ0VG9ET00oZSwgdCwgbykge1xuICAgIHQgPyBvLmhvbGRlci5pbnNlcnRBZGphY2VudEVsZW1lbnQodCwgZS5ob2xkZXIpIDogdGhpcy53b3JraW5nQXJlYS5hcHBlbmRDaGlsZChlLmhvbGRlciksIGUuY2FsbChYLlJFTkRFUkVEKTtcbiAgfVxuICAvKipcbiAgICogQ29tcG9zZXMgQmxvY2sgZXZlbnQgd2l0aCBwYXNzZWQgdHlwZSBhbmQgZGV0YWlsc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGRldGFpbCAtIGV2ZW50IGRldGFpbFxuICAgKi9cbiAgY29tcG9zZUJsb2NrRXZlbnQoZSwgdCkge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZSwge1xuICAgICAgZGV0YWlsOiB0XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IG50ID0gXCJibG9jay1yZW1vdmVkXCIsIHN0ID0gXCJibG9jay1hZGRlZFwiLCB0aSA9IFwiYmxvY2stbW92ZWRcIiwgcnQgPSBcImJsb2NrLWNoYW5nZWRcIjtcbmNsYXNzIG9pIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb21wbGV0ZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIG5ldyBwcm9taXNlIHRvIHF1ZXVlXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gLSBwcm9taXNlIHNob3VsZCBiZSBhZGRlZCB0byBxdWV1ZVxuICAgKi9cbiAgYWRkKGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHQsIG8pID0+IHtcbiAgICAgIHRoaXMuY29tcGxldGVkID0gdGhpcy5jb21wbGV0ZWQudGhlbihlKS50aGVuKHQpLmNhdGNoKG8pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBpaSBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLl9jdXJyZW50QmxvY2tJbmRleCA9IC0xLCB0aGlzLl9ibG9ja3MgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgQmxvY2sgaW5kZXhcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBjdXJyZW50QmxvY2tJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJsb2NrSW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBjdXJyZW50IEJsb2NrIGluZGV4IGFuZCBmaXJlIEJsb2NrIGxpZmVjeWNsZSBjYWxsYmFja3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0luZGV4IC0gaW5kZXggb2YgQmxvY2sgdG8gc2V0IGFzIGN1cnJlbnRcbiAgICovXG4gIHNldCBjdXJyZW50QmxvY2tJbmRleChlKSB7XG4gICAgdGhpcy5fY3VycmVudEJsb2NrSW5kZXggPSBlO1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIGZpcnN0IEJsb2NrXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldCBmaXJzdEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3NbMF07XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgbGFzdCBCbG9ja1xuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBnZXQgbGFzdEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3NbdGhpcy5fYmxvY2tzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBCbG9jayBpbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBnZXQgY3VycmVudEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3NbdGhpcy5jdXJyZW50QmxvY2tJbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIFNldCBwYXNzZWQgQmxvY2sgYXMgYSBjdXJyZW50XG4gICAqXG4gICAqIEBwYXJhbSBibG9jayAtIGJsb2NrIHRvIHNldCBhcyBhIGN1cnJlbnRcbiAgICovXG4gIHNldCBjdXJyZW50QmxvY2soZSkge1xuICAgIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSB0aGlzLmdldEJsb2NrSW5kZXgoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbmV4dCBCbG9jayBpbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t8bnVsbH1cbiAgICovXG4gIGdldCBuZXh0QmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPT09IHRoaXMuX2Jsb2Nrcy5sZW5ndGggLSAxID8gbnVsbCA6IHRoaXMuX2Jsb2Nrc1t0aGlzLmN1cnJlbnRCbG9ja0luZGV4ICsgMV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBmaXJzdCBCbG9jayB3aXRoIGlucHV0cyBhZnRlciBjdXJyZW50IEJsb2NrXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9jayB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCBuZXh0Q29udGVudGZ1bEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2Nrcy5zbGljZSh0aGlzLmN1cnJlbnRCbG9ja0luZGV4ICsgMSkuZmluZCgodCkgPT4gISF0LmlucHV0cy5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgQmxvY2sgd2l0aCBpbnB1dHMgYmVmb3JlIGN1cnJlbnQgQmxvY2tcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IHByZXZpb3VzQ29udGVudGZ1bEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2Nrcy5zbGljZSgwLCB0aGlzLmN1cnJlbnRCbG9ja0luZGV4KS5yZXZlcnNlKCkuZmluZCgodCkgPT4gISF0LmlucHV0cy5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByZXZpb3VzIEJsb2NrIGluc3RhbmNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja3xudWxsfVxuICAgKi9cbiAgZ2V0IHByZXZpb3VzQmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPT09IDAgPyBudWxsIDogdGhpcy5fYmxvY2tzW3RoaXMuY3VycmVudEJsb2NrSW5kZXggLSAxXTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFycmF5IG9mIEJsb2NrIGluc3RhbmNlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2tbXX0ge0BsaW5rIEJsb2NrcyNhcnJheX1cbiAgICovXG4gIGdldCBibG9ja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrcy5hcnJheTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgZWFjaCBCbG9jayBpcyBlbXB0eVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0VkaXRvckVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmJsb2Nrcy5ldmVyeSgoZSkgPT4gZS5pc0VtcHR5KTtcbiAgfVxuICAvKipcbiAgICogU2hvdWxkIGJlIGNhbGxlZCBhZnRlciBFZGl0b3IuVUkgcHJlcGFyYXRpb25cbiAgICogRGVmaW5lIHRoaXMuX2Jsb2NrcyBwcm9wZXJ0eVxuICAgKi9cbiAgcHJlcGFyZSgpIHtcbiAgICBjb25zdCBlID0gbmV3IFNlKHRoaXMuRWRpdG9yLlVJLm5vZGVzLnJlZGFjdG9yKTtcbiAgICB0aGlzLl9ibG9ja3MgPSBuZXcgUHJveHkoZSwge1xuICAgICAgc2V0OiBTZS5zZXQsXG4gICAgICBnZXQ6IFNlLmdldFxuICAgIH0pLCB0aGlzLmxpc3RlbmVycy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJjb3B5XCIsXG4gICAgICAodCkgPT4gdGhpcy5FZGl0b3IuQmxvY2tFdmVudHMuaGFuZGxlQ29tbWFuZEModClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGUgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqIElmIHJlYWRPbmx5IGlzIHRydWU6XG4gICAqICAtIFVuYmluZCBldmVudCBoYW5kbGVycyBmcm9tIGNyZWF0ZWQgQmxvY2tzXG4gICAqXG4gICAqIGlmIHJlYWRPbmx5IGlzIGZhbHNlOlxuICAgKiAgLSBCaW5kIGV2ZW50IGhhbmRsZXJzIHRvIGFsbCBleGlzdGluZyBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSBcInJlYWQgb25seVwiIHN0YXRlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/IHRoaXMuZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkgOiB0aGlzLmVuYWJsZU1vZHVsZUJpbmRpbmdzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgQmxvY2sgaW5zdGFuY2UgYnkgdG9vbCBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gYmxvY2sgY3JlYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sIC0gdG9vbHMgcGFzc2VkIGluIGVkaXRvciBjb25maWcge0BsaW5rIEVkaXRvckNvbmZpZyN0b29sc31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkXSAtIHVuaXF1ZSBpZCBmb3IgdGhpcyBibG9ja1xuICAgKiBAcGFyYW0ge0Jsb2NrVG9vbERhdGF9IFtvcHRpb25zLmRhdGFdIC0gY29uc3RydWN0b3IgcGFyYW1zXG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGNvbXBvc2VCbG9jayh7XG4gICAgdG9vbDogZSxcbiAgICBkYXRhOiB0ID0ge30sXG4gICAgaWQ6IG8gPSB2b2lkIDAsXG4gICAgdHVuZXM6IGkgPSB7fVxuICB9KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuRWRpdG9yLlJlYWRPbmx5LmlzRW5hYmxlZCwgciA9IHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHMuZ2V0KGUpLCBhID0gbmV3IFIoe1xuICAgICAgaWQ6IG8sXG4gICAgICBkYXRhOiB0LFxuICAgICAgdG9vbDogcixcbiAgICAgIGFwaTogdGhpcy5FZGl0b3IuQVBJLFxuICAgICAgcmVhZE9ubHk6IG4sXG4gICAgICB0dW5lc0RhdGE6IGlcbiAgICB9LCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIpO1xuICAgIHJldHVybiBuIHx8IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMuYmluZEJsb2NrRXZlbnRzKGEpO1xuICAgIH0sIHsgdGltZW91dDogMmUzIH0pLCBhO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IGJsb2NrIGludG8gX2Jsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGluc2VydCBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZF0gLSBibG9jaydzIHVuaXF1ZSBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudG9vbF0gLSBwbHVnaW4gbmFtZSwgYnkgZGVmYXVsdCBtZXRob2QgaW5zZXJ0cyB0aGUgZGVmYXVsdCBibG9jayB0eXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5kYXRhXSAtIHBsdWdpbiBkYXRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbmRleF0gLSBpbmRleCB3aGVyZSB0byBpbnNlcnQgbmV3IEJsb2NrXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubmVlZFRvRm9jdXNdIC0gZmxhZyBzaG93cyBpZiBuZWVkZWQgdG8gdXBkYXRlIGN1cnJlbnQgQmxvY2sgaW5kZXhcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXBsYWNlXSAtIGZsYWcgc2hvd3MgaWYgYmxvY2sgYnkgcGFzc2VkIGluZGV4IHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIGluc2VydGVkIG9uZVxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBpbnNlcnQoe1xuICAgIGlkOiBlID0gdm9pZCAwLFxuICAgIHRvb2w6IHQgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2ssXG4gICAgZGF0YTogbyA9IHt9LFxuICAgIGluZGV4OiBpLFxuICAgIG5lZWRUb0ZvY3VzOiBuID0gITAsXG4gICAgcmVwbGFjZTogciA9ICExLFxuICAgIHR1bmVzOiBhID0ge31cbiAgfSA9IHt9KSB7XG4gICAgbGV0IGwgPSBpO1xuICAgIGwgPT09IHZvaWQgMCAmJiAobCA9IHRoaXMuY3VycmVudEJsb2NrSW5kZXggKyAociA/IDAgOiAxKSk7XG4gICAgY29uc3QgZCA9IHRoaXMuY29tcG9zZUJsb2NrKHtcbiAgICAgIGlkOiBlLFxuICAgICAgdG9vbDogdCxcbiAgICAgIGRhdGE6IG8sXG4gICAgICB0dW5lczogYVxuICAgIH0pO1xuICAgIHJldHVybiByICYmIHRoaXMuYmxvY2tEaWRNdXRhdGVkKG50LCB0aGlzLmdldEJsb2NrQnlJbmRleChsKSwge1xuICAgICAgaW5kZXg6IGxcbiAgICB9KSwgdGhpcy5fYmxvY2tzLmluc2VydChsLCBkLCByKSwgdGhpcy5ibG9ja0RpZE11dGF0ZWQoc3QsIGQsIHtcbiAgICAgIGluZGV4OiBsXG4gICAgfSksIG4gPyB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gbCA6IGwgPD0gdGhpcy5jdXJyZW50QmxvY2tJbmRleCAmJiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4KyssIGQ7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgc2V2ZXJhbCBibG9ja3MgYXQgb25jZVxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2tzIC0gYmxvY2tzIHRvIGluc2VydFxuICAgKiBAcGFyYW0gaW5kZXggLSBpbmRleCB3aGVyZSB0byBpbnNlcnRcbiAgICovXG4gIGluc2VydE1hbnkoZSwgdCA9IDApIHtcbiAgICB0aGlzLl9ibG9ja3MuaW5zZXJ0TWFueShlLCB0KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIEJsb2NrIGRhdGEuXG4gICAqXG4gICAqIEN1cnJlbnRseSB3ZSBkb24ndCBoYXZlIGFuICd1cGRhdGUnIG1ldGhvZCBpbiB0aGUgVG9vbHMgQVBJLCBzbyB3ZSBqdXN0IGNyZWF0ZSBhIG5ldyBibG9jayB3aXRoIHRoZSBzYW1lIGlkIGFuZCB0eXBlXG4gICAqIFNob3VsZCBub3QgdHJpZ2dlciAnYmxvY2stcmVtb3ZlZCcgb3IgJ2Jsb2NrLWFkZGVkJyBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gYmxvY2sgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBkYXRhIC0gbmV3IGRhdGFcbiAgICovXG4gIGFzeW5jIHVwZGF0ZShlLCB0KSB7XG4gICAgY29uc3QgbyA9IGF3YWl0IGUuZGF0YSwgaSA9IHRoaXMuY29tcG9zZUJsb2NrKHtcbiAgICAgIGlkOiBlLmlkLFxuICAgICAgdG9vbDogZS5uYW1lLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgbywgdCksXG4gICAgICB0dW5lczogZS50dW5lc1xuICAgIH0pLCBuID0gdGhpcy5nZXRCbG9ja0luZGV4KGUpO1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3MucmVwbGFjZShuLCBpKSwgdGhpcy5ibG9ja0RpZE11dGF0ZWQocnQsIGksIHtcbiAgICAgIGluZGV4OiBuXG4gICAgfSksIGk7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2UgcGFzc2VkIEJsb2NrIHdpdGggdGhlIG5ldyBvbmUgd2l0aCBzcGVjaWZpZWQgVG9vbCBhbmQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBibG9jayB0byByZXBsYWNlXG4gICAqIEBwYXJhbSBuZXdUb29sIC0gbmV3IFRvb2wgbmFtZVxuICAgKiBAcGFyYW0gZGF0YSAtIG5ldyBUb29sIGRhdGFcbiAgICovXG4gIHJlcGxhY2UoZSwgdCwgbykge1xuICAgIGNvbnN0IGkgPSB0aGlzLmdldEJsb2NrSW5kZXgoZSk7XG4gICAgdGhpcy5pbnNlcnQoe1xuICAgICAgdG9vbDogdCxcbiAgICAgIGRhdGE6IG8sXG4gICAgICBpbmRleDogaSxcbiAgICAgIHJlcGxhY2U6ICEwXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBwYXN0ZWQgY29udGVudC4gQ2FsbCBvblBhc3RlIGNhbGxiYWNrIGFmdGVyIGluc2VydC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvb2xOYW1lIC0gbmFtZSBvZiBUb29sIHRvIGluc2VydFxuICAgKiBAcGFyYW0ge1Bhc3RlRXZlbnR9IHBhc3RlRXZlbnQgLSBwYXN0ZWQgZGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcGxhY2UgLSBzaG91bGQgcmVwbGFjZSBjdXJyZW50IGJsb2NrXG4gICAqL1xuICBwYXN0ZShlLCB0LCBvID0gITEpIHtcbiAgICBjb25zdCBpID0gdGhpcy5pbnNlcnQoe1xuICAgICAgdG9vbDogZSxcbiAgICAgIHJlcGxhY2U6IG9cbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpLmNhbGwoWC5PTl9QQVNURSwgdCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChuKSB7XG4gICAgICBUKGAke2V9OiBvblBhc3RlIGNhbGxiYWNrIGNhbGwgaXMgZmFpbGVkYCwgXCJlcnJvclwiLCBuKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBuZXcgZGVmYXVsdCBibG9jayBhdCBwYXNzZWQgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggd2hlcmUgQmxvY2sgc2hvdWxkIGJlIGluc2VydGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVlZFRvRm9jdXMgLSBpZiB0cnVlLCB1cGRhdGVzIGN1cnJlbnQgQmxvY2sgaW5kZXhcbiAgICpcbiAgICogVE9ETzogUmVtb3ZlIG1ldGhvZCBhbmQgdXNlIGluc2VydCgpIHdpdGggaW5kZXggaW5zdGVhZCAoPylcbiAgICogQHJldHVybnMge0Jsb2NrfSBpbnNlcnRlZCBCbG9ja1xuICAgKi9cbiAgaW5zZXJ0RGVmYXVsdEJsb2NrQXRJbmRleChlLCB0ID0gITEpIHtcbiAgICBjb25zdCBvID0gdGhpcy5jb21wb3NlQmxvY2soeyB0b29sOiB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2sgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc1tlXSA9IG8sIHRoaXMuYmxvY2tEaWRNdXRhdGVkKHN0LCBvLCB7XG4gICAgICBpbmRleDogZVxuICAgIH0pLCB0ID8gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IGUgOiBlIDw9IHRoaXMuY3VycmVudEJsb2NrSW5kZXggJiYgdGhpcy5jdXJyZW50QmxvY2tJbmRleCsrLCBvO1xuICB9XG4gIC8qKlxuICAgKiBBbHdheXMgaW5zZXJ0cyBhdCB0aGUgZW5kXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGluc2VydEF0RW5kKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gdGhpcy5ibG9ja3MubGVuZ3RoIC0gMSwgdGhpcy5pbnNlcnQoKTtcbiAgfVxuICAvKipcbiAgICogTWVyZ2UgdHdvIGJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSB0YXJnZXRCbG9jayAtIHByZXZpb3VzIGJsb2NrIHdpbGwgYmUgYXBwZW5kIHRvIHRoaXMgYmxvY2tcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2tUb01lcmdlIC0gYmxvY2sgdGhhdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRhcmdldCBibG9ja1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gLSB0aGUgc2VxdWVuY2UgdGhhdCBjYW4gYmUgY29udGludWVkXG4gICAqL1xuICBhc3luYyBtZXJnZUJsb2NrcyhlLCB0KSB7XG4gICAgY29uc3QgbyA9IGF3YWl0IHQuZGF0YTtcbiAgICBXKG8pIHx8IGF3YWl0IGUubWVyZ2VXaXRoKG8pLCB0aGlzLnJlbW92ZUJsb2NrKHQpLCB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gdGhpcy5fYmxvY2tzLmluZGV4T2YoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBwYXNzZWQgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gQmxvY2sgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSBhZGRMYXN0QmxvY2sgLSBpZiB0cnVlLCBhZGRzIG5ldyBkZWZhdWx0IGJsb2NrIGF0IHRoZSBlbmQuIEB0b2RvIHJlbW92ZSB0aGlzIGxvZ2ljIGFuZCB1c2UgZXZlbnQtYnVzIGluc3RlYWRcbiAgICovXG4gIHJlbW92ZUJsb2NrKGUsIHQgPSAhMCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgobykgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2Jsb2Nrcy5pbmRleE9mKGUpO1xuICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlSW5kZXgoaSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgYSBCbG9jayB0byByZW1vdmVcIik7XG4gICAgICBlLmRlc3Ryb3koKSwgdGhpcy5fYmxvY2tzLnJlbW92ZShpKSwgdGhpcy5ibG9ja0RpZE11dGF0ZWQobnQsIGUsIHtcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH0pLCB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID49IGkgJiYgdGhpcy5jdXJyZW50QmxvY2tJbmRleC0tLCB0aGlzLmJsb2Nrcy5sZW5ndGggPyBpID09PSAwICYmICh0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gMCkgOiAodGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IC0xLCB0ICYmIHRoaXMuaW5zZXJ0KCkpLCBvKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBvbmx5IHNlbGVjdGVkIEJsb2Nrc1xuICAgKiBhbmQgcmV0dXJucyBmaXJzdCBCbG9jayBpbmRleCB3aGVyZSBzdGFydGVkIHJlbW92aW5nLi4uXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgcmVtb3ZlU2VsZWN0ZWRCbG9ja3MoKSB7XG4gICAgbGV0IGU7XG4gICAgZm9yIChsZXQgdCA9IHRoaXMuYmxvY2tzLmxlbmd0aCAtIDE7IHQgPj0gMDsgdC0tKVxuICAgICAgdGhpcy5ibG9ja3NbdF0uc2VsZWN0ZWQgJiYgKHRoaXMucmVtb3ZlQmxvY2sodGhpcy5ibG9ja3NbdF0pLCBlID0gdCk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVudGlvbiFcbiAgICogQWZ0ZXIgcmVtb3ZpbmcgaW5zZXJ0IHRoZSBuZXcgZGVmYXVsdCB0eXBlZCBCbG9jayBhbmQgZm9jdXMgb24gaXRcbiAgICogUmVtb3ZlcyBhbGwgYmxvY2tzXG4gICAqL1xuICByZW1vdmVBbGxCbG9ja3MoKSB7XG4gICAgZm9yIChsZXQgZSA9IHRoaXMuYmxvY2tzLmxlbmd0aCAtIDE7IGUgPj0gMDsgZS0tKVxuICAgICAgdGhpcy5fYmxvY2tzLnJlbW92ZShlKTtcbiAgICB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gLTEsIHRoaXMuaW5zZXJ0KCksIHRoaXMuY3VycmVudEJsb2NrLmZpcnN0SW5wdXQuZm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogU3BsaXQgY3VycmVudCBCbG9ja1xuICAgKiAxLiBFeHRyYWN0IGNvbnRlbnQgZnJvbSBDYXJldCBwb3NpdGlvbiB0byB0aGUgQmxvY2tgcyBlbmRcbiAgICogMi4gSW5zZXJ0IGEgbmV3IEJsb2NrIGJlbG93IGN1cnJlbnQgb25lIHdpdGggZXh0cmFjdGVkIGNvbnRlbnRcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgc3BsaXQoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuRWRpdG9yLkNhcmV0LmV4dHJhY3RGcmFnbWVudEZyb21DYXJldFBvc2l0aW9uKCksIHQgPSBjLm1ha2UoXCJkaXZcIik7XG4gICAgdC5hcHBlbmRDaGlsZChlKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgdGV4dDogYy5pc0VtcHR5KHQpID8gXCJcIiA6IHQuaW5uZXJIVE1MXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoeyBkYXRhOiBvIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrIGJ5IHBhc3NlZCBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCB0byBnZXQuIC0xIHRvIGdldCBsYXN0XG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldEJsb2NrQnlJbmRleChlKSB7XG4gICAgcmV0dXJuIGUgPT09IC0xICYmIChlID0gdGhpcy5fYmxvY2tzLmxlbmd0aCAtIDEpLCB0aGlzLl9ibG9ja3NbZV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaW5kZXggZm9yIHBhc3NlZCBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBibG9jayB0byBmaW5kIGluZGV4XG4gICAqL1xuICBnZXRCbG9ja0luZGV4KGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzLmluZGV4T2YoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEJsb2NrIGJ5IHBhc3NlZCBpZFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBpZCBvZiBibG9jayB0byBnZXRcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0QmxvY2tCeUlkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzLmFycmF5LmZpbmQoKHQpID0+IHQuaWQgPT09IGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sgaW5zdGFuY2UgYnkgaHRtbCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudCAtIGh0bWwgZWxlbWVudCB0byBnZXQgQmxvY2sgYnlcbiAgICovXG4gIGdldEJsb2NrKGUpIHtcbiAgICBjLmlzRWxlbWVudChlKSB8fCAoZSA9IGUucGFyZW50Tm9kZSk7XG4gICAgY29uc3QgdCA9IHRoaXMuX2Jsb2Nrcy5ub2RlcywgbyA9IGUuY2xvc2VzdChgLiR7Ui5DU1Mud3JhcHBlcn1gKSwgaSA9IHQuaW5kZXhPZihvKTtcbiAgICBpZiAoaSA+PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc1tpXTtcbiAgfVxuICAvKipcbiAgICogMSkgRmluZCBmaXJzdC1sZXZlbCBCbG9jayBmcm9tIHBhc3NlZCBjaGlsZCBOb2RlXG4gICAqIDIpIE1hcmsgaXQgYXMgY3VycmVudFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkTm9kZSAtIGxvb2sgYWhlYWQgZnJvbSB0aGlzIG5vZGUuXG4gICAqIEByZXR1cm5zIHtCbG9jayB8IHVuZGVmaW5lZH0gY2FuIHJldHVybiB1bmRlZmluZWQgaW4gY2FzZSB3aGVuIHRoZSBwYXNzZWQgY2hpbGQgbm90ZSBpcyBub3QgYSBwYXJ0IG9mIHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgKi9cbiAgc2V0Q3VycmVudEJsb2NrQnlDaGlsZE5vZGUoZSkge1xuICAgIGMuaXNFbGVtZW50KGUpIHx8IChlID0gZS5wYXJlbnROb2RlKTtcbiAgICBjb25zdCB0ID0gZS5jbG9zZXN0KGAuJHtSLkNTUy53cmFwcGVyfWApO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gdC5jbG9zZXN0KGAuJHt0aGlzLkVkaXRvci5VSS5DU1MuZWRpdG9yV3JhcHBlcn1gKTtcbiAgICBpZiAobyAhPSBudWxsICYmIG8uaXNFcXVhbE5vZGUodGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlcikpXG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IHRoaXMuX2Jsb2Nrcy5ub2Rlcy5pbmRleE9mKHQpLCB0aGlzLmN1cnJlbnRCbG9jay51cGRhdGVDdXJyZW50SW5wdXQoKSwgdGhpcy5jdXJyZW50QmxvY2s7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBibG9jayB3aGljaCBjb250ZW50cyBwYXNzZWQgbm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkTm9kZSAtIG5vZGUgdG8gZ2V0IEJsb2NrIGJ5XG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldEJsb2NrQnlDaGlsZE5vZGUoZSkge1xuICAgIGlmICghZSB8fCAhKGUgaW5zdGFuY2VvZiBOb2RlKSlcbiAgICAgIHJldHVybjtcbiAgICBjLmlzRWxlbWVudChlKSB8fCAoZSA9IGUucGFyZW50Tm9kZSk7XG4gICAgY29uc3QgdCA9IGUuY2xvc2VzdChgLiR7Ui5DU1Mud3JhcHBlcn1gKTtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MuZmluZCgobykgPT4gby5ob2xkZXIgPT09IHQpO1xuICB9XG4gIC8qKlxuICAgKiBTd2FwIEJsb2NrcyBQb3NpdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gaW5kZXggb2YgZmlyc3QgYmxvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggLSBpbmRleCBvZiBzZWNvbmQgYmxvY2tcbiAgICogQGRlcHJlY2F0ZWQg4oCUIHVzZSAnbW92ZScgaW5zdGVhZFxuICAgKi9cbiAgc3dhcChlLCB0KSB7XG4gICAgdGhpcy5fYmxvY2tzLnN3YXAoZSwgdCksIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSB0O1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIGEgYmxvY2sgdG8gYSBuZXcgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggLSBpbmRleCB3aGVyZSB0byBtb3ZlIEJsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggLSBpbmRleCBvZiBCbG9jayB0byBtb3ZlXG4gICAqL1xuICBtb3ZlKGUsIHQgPSB0aGlzLmN1cnJlbnRCbG9ja0luZGV4KSB7XG4gICAgaWYgKGlzTmFOKGUpIHx8IGlzTmFOKHQpKSB7XG4gICAgICBUKFwiV2FybmluZyBkdXJpbmcgJ21vdmUnIGNhbGw6IGluY29ycmVjdCBpbmRpY2VzIHByb3ZpZGVkLlwiLCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy52YWxpZGF0ZUluZGV4KGUpIHx8ICF0aGlzLnZhbGlkYXRlSW5kZXgodCkpIHtcbiAgICAgIFQoXCJXYXJuaW5nIGR1cmluZyAnbW92ZScgY2FsbDogaW5kaWNlcyBjYW5ub3QgYmUgbG93ZXIgdGhhbiAwIG9yIGdyZWF0ZXIgdGhhbiB0aGUgYW1vdW50IG9mIGJsb2Nrcy5cIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ibG9ja3MubW92ZShlLCB0KSwgdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IGUsIHRoaXMuYmxvY2tEaWRNdXRhdGVkKHRpLCB0aGlzLmN1cnJlbnRCbG9jaywge1xuICAgICAgZnJvbUluZGV4OiB0LFxuICAgICAgdG9JbmRleDogZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBwYXNzZWQgQmxvY2sgdG8gdGhlIG5ldyBUb29sXG4gICAqIFVzZXMgQ29udmVyc2lvbiBDb25maWdcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrVG9Db252ZXJ0IC0gQmxvY2sgdGhhdCBzaG91bGQgYmUgY29udmVydGVkXG4gICAqIEBwYXJhbSB0YXJnZXRUb29sTmFtZSAtIG5hbWUgb2YgdGhlIFRvb2wgdG8gY29udmVydCB0b1xuICAgKiBAcGFyYW0gYmxvY2tEYXRhT3ZlcnJpZGVzIC0gb3B0aW9uYWwgbmV3IEJsb2NrIGRhdGEgb3ZlcnJpZGVzXG4gICAqL1xuICBhc3luYyBjb252ZXJ0KGUsIHQsIG8pIHtcbiAgICBpZiAoIWF3YWl0IGUuc2F2ZSgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbnZlcnQgQmxvY2suIEZhaWxlZCB0byBleHRyYWN0IG9yaWdpbmFsIEJsb2NrIGRhdGEuXCIpO1xuICAgIGNvbnN0IG4gPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLmdldCh0KTtcbiAgICBpZiAoIW4pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBjb252ZXJ0IEJsb2NrLiBUb29sIMKrJHt0fcK7IG5vdCBmb3VuZC5gKTtcbiAgICBjb25zdCByID0gYXdhaXQgZS5leHBvcnREYXRhQXNTdHJpbmcoKSwgYSA9IFYoXG4gICAgICByLFxuICAgICAgbi5zYW5pdGl6ZUNvbmZpZ1xuICAgICk7XG4gICAgbGV0IGwgPSB0byhhLCBuLmNvbnZlcnNpb25Db25maWcpO1xuICAgIG8gJiYgKGwgPSBPYmplY3QuYXNzaWduKGwsIG8pKSwgdGhpcy5yZXBsYWNlKGUsIG4ubmFtZSwgbCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgY3VycmVudCBCbG9jayBJbmRleCAtMSB3aGljaCBtZWFucyB1bmtub3duXG4gICAqIGFuZCBjbGVhciBoaWdobGlnaHRzXG4gICAqL1xuICBkcm9wUG9pbnRlcigpIHtcbiAgICB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gLTE7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBFZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBuZWVkVG9BZGREZWZhdWx0QmxvY2sgLSAxKSBpbiBpbnRlcm5hbCBjYWxscyAoZm9yIGV4YW1wbGUsIGluIGFwaS5ibG9ja3MucmVuZGVyKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlIGRvbid0IG5lZWQgdG8gYWRkIGFuIGVtcHR5IGRlZmF1bHQgYmxvY2tcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMikgaW4gYXBpLmJsb2Nrcy5jbGVhciB3ZSBzaG91bGQgYWRkIGVtcHR5IGJsb2NrXG4gICAqL1xuICBhc3luYyBjbGVhcihlID0gITEpIHtcbiAgICBjb25zdCB0ID0gbmV3IG9pKCk7XG4gICAgdGhpcy5ibG9ja3MuZm9yRWFjaCgobykgPT4ge1xuICAgICAgdC5hZGQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUJsb2NrKG8sICExKTtcbiAgICAgIH0pO1xuICAgIH0pLCBhd2FpdCB0LmNvbXBsZXRlZCwgdGhpcy5kcm9wUG9pbnRlcigpLCBlICYmIHRoaXMuaW5zZXJ0KCksIHRoaXMuRWRpdG9yLlVJLmNoZWNrRW1wdGluZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFucyB1cCBhbGwgdGhlIGJsb2NrIHRvb2xzJyByZXNvdXJjZXNcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBlZGl0b3IgaXMgZGVzdHJveWVkXG4gICAqL1xuICBhc3luYyBkZXN0cm95KCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuYmxvY2tzLm1hcCgoZSkgPT4gZS5kZXN0cm95KCkpKTtcbiAgfVxuICAvKipcbiAgICogQmluZCBCbG9jayBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byB3aGljaCBldmVudCBzaG91bGQgYmUgYm91bmRcbiAgICovXG4gIGJpbmRCbG9ja0V2ZW50cyhlKSB7XG4gICAgY29uc3QgeyBCbG9ja0V2ZW50czogdCB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ob2xkZXIsIFwia2V5ZG93blwiLCAobykgPT4ge1xuICAgICAgdC5rZXlkb3duKG8pO1xuICAgIH0pLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihlLmhvbGRlciwgXCJrZXl1cFwiLCAobykgPT4ge1xuICAgICAgdC5rZXl1cChvKTtcbiAgICB9KSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ob2xkZXIsIFwiZHJhZ292ZXJcIiwgKG8pID0+IHtcbiAgICAgIHQuZHJhZ092ZXIobyk7XG4gICAgfSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUuaG9sZGVyLCBcImRyYWdsZWF2ZVwiLCAobykgPT4ge1xuICAgICAgdC5kcmFnTGVhdmUobyk7XG4gICAgfSksIGUub24oXCJkaWRNdXRhdGVkXCIsIChvKSA9PiB0aGlzLmJsb2NrRGlkTXV0YXRlZChydCwgbywge1xuICAgICAgaW5kZXg6IHRoaXMuZ2V0QmxvY2tJbmRleChvKVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZSBtdXRhYmxlIGhhbmRsZXJzIGFuZCBiaW5kaW5nc1xuICAgKi9cbiAgZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLmNsZWFyQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgYWxsIG1vZHVsZSBoYW5kbGVycyBhbmQgYmluZGluZ3MgZm9yIGFsbCBCbG9ja3NcbiAgICovXG4gIGVuYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImN1dFwiLFxuICAgICAgKGUpID0+IHRoaXMuRWRpdG9yLkJsb2NrRXZlbnRzLmhhbmRsZUNvbW1hbmRYKGUpXG4gICAgKSwgdGhpcy5ibG9ja3MuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5iaW5kQmxvY2tFdmVudHMoZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBnaXZlbiBpbmRleCBpcyBub3QgbG93ZXIgdGhhbiAwIG9yIGhpZ2hlciB0aGFuIHRoZSBhbW91bnQgb2YgYmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIGJsb2NrcyBhcnJheSB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZhbGlkYXRlSW5kZXgoZSkge1xuICAgIHJldHVybiAhKGUgPCAwIHx8IGUgPj0gdGhpcy5fYmxvY2tzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEJsb2NrIG11dGF0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBtdXRhdGlvblR5cGUgLSB3aGF0IGhhcHBlbmVkIHdpdGggYmxvY2tcbiAgICogQHBhcmFtIGJsb2NrIC0gbXV0YXRlZCBibG9ja1xuICAgKiBAcGFyYW0gZGV0YWlsRGF0YSAtIGFkZGl0aW9uYWwgZGF0YSB0byBwYXNzIHdpdGggY2hhbmdlIGV2ZW50XG4gICAqL1xuICBibG9ja0RpZE11dGF0ZWQoZSwgdCwgbykge1xuICAgIGNvbnN0IGkgPSBuZXcgQ3VzdG9tRXZlbnQoZSwge1xuICAgICAgZGV0YWlsOiB7XG4gICAgICAgIHRhcmdldDogbmV3IGVlKHQpLFxuICAgICAgICAuLi5vXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KHB0LCB7XG4gICAgICBldmVudDogaVxuICAgIH0pLCB0O1xuICB9XG59XG5jbGFzcyBuaSBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmFueUJsb2NrU2VsZWN0ZWRDYWNoZSA9IG51bGwsIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITEsIHRoaXMubmF0aXZlSW5wdXRTZWxlY3RlZCA9ICExLCB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgQ29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtTYW5pdGl6ZXJDb25maWd9XG4gICAqL1xuICBnZXQgc2FuaXRpemVyQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwOiB7fSxcbiAgICAgIGgxOiB7fSxcbiAgICAgIGgyOiB7fSxcbiAgICAgIGgzOiB7fSxcbiAgICAgIGg0OiB7fSxcbiAgICAgIGg1OiB7fSxcbiAgICAgIGg2OiB7fSxcbiAgICAgIG9sOiB7fSxcbiAgICAgIHVsOiB7fSxcbiAgICAgIGxpOiB7fSxcbiAgICAgIGJyOiAhMCxcbiAgICAgIGltZzoge1xuICAgICAgICBzcmM6ICEwLFxuICAgICAgICB3aWR0aDogITAsXG4gICAgICAgIGhlaWdodDogITBcbiAgICAgIH0sXG4gICAgICBhOiB7XG4gICAgICAgIGhyZWY6ICEwXG4gICAgICB9LFxuICAgICAgYjoge30sXG4gICAgICBpOiB7fSxcbiAgICAgIHU6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRmxhZyB0aGF0IGlkZW50aWZpZXMgYWxsIEJsb2NrcyBzZWxlY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYWxsQmxvY2tzU2VsZWN0ZWQoKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGUgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHJldHVybiBlLmJsb2Nrcy5ldmVyeSgodCkgPT4gdC5zZWxlY3RlZCA9PT0gITApO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0ZWQgYWxsIGJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIC0gc3RhdGUgdG8gc2V0XG4gICAqL1xuICBzZXQgYWxsQmxvY2tzU2VsZWN0ZWQoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0IH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmJsb2Nrcy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBvLnNlbGVjdGVkID0gZTtcbiAgICB9KSwgdGhpcy5jbGVhckNhY2hlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZsYWcgdGhhdCBpZGVudGlmaWVzIGFueSBCbG9jayBzZWxlY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYW55QmxvY2tTZWxlY3RlZCgpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogZSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgcmV0dXJuIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlID09PSBudWxsICYmICh0aGlzLmFueUJsb2NrU2VsZWN0ZWRDYWNoZSA9IGUuYmxvY2tzLnNvbWUoKHQpID0+IHQuc2VsZWN0ZWQgPT09ICEwKSksIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gc2VsZWN0ZWQgQmxvY2tzIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja1tdfVxuICAgKi9cbiAgZ2V0IHNlbGVjdGVkQmxvY2tzKCkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmZpbHRlcigoZSkgPT4gZS5zZWxlY3RlZCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBQcmVwYXJhdGlvblxuICAgKiBSZWdpc3RlcnMgU2hvcnRjdXRzIENNRCtBIGFuZCBDTUQrQ1xuICAgKiB0byBzZWxlY3QgYWxsIGFuZCBjb3B5IHRoZW1cbiAgICovXG4gIHByZXBhcmUoKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgYigpLCBhZS5hZGQoe1xuICAgICAgbmFtZTogXCJDTUQrQVwiLFxuICAgICAgaGFuZGxlcjogKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIFJlYWRPbmx5OiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICAgICAgaWYgKG8uaXNFbmFibGVkKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnNlbGVjdEFsbEJsb2NrcygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0LmN1cnJlbnRCbG9jayAmJiB0aGlzLmhhbmRsZUNvbW1hbmRBKGUpO1xuICAgICAgfSxcbiAgICAgIG9uOiB0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3RvclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGUgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqICAtIFJlbW92ZSBhbGwgcmFuZ2VzXG4gICAqICAtIFVuc2VsZWN0IGFsbCBCbG9ja3NcbiAgICovXG4gIHRvZ2dsZVJlYWRPbmx5KCkge1xuICAgIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksIHRoaXMuYWxsQmxvY2tzU2VsZWN0ZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHNlbGVjdGlvbiBvZiBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcj99IGluZGV4IC0gQmxvY2sgaW5kZXggYWNjb3JkaW5nIHRvIHRoZSBCbG9ja01hbmFnZXIncyBpbmRleGVzXG4gICAqL1xuICB1blNlbGVjdEJsb2NrQnlJbmRleChlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGxldCBvO1xuICAgIGlzTmFOKGUpID8gbyA9IHQuY3VycmVudEJsb2NrIDogbyA9IHQuZ2V0QmxvY2tCeUluZGV4KGUpLCBvLnNlbGVjdGVkID0gITEsIHRoaXMuY2xlYXJDYWNoZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBzZWxlY3Rpb24gZnJvbSBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gcmVhc29uIC0gZXZlbnQgY2F1c2VkIGNsZWFyIG9mIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc3RvcmVTZWxlY3Rpb24gLSBpZiB0cnVlLCByZXN0b3JlIHNhdmVkIHNlbGVjdGlvblxuICAgKi9cbiAgY2xlYXJTZWxlY3Rpb24oZSwgdCA9ICExKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IG8sIENhcmV0OiBpLCBSZWN0YW5nbGVTZWxlY3Rpb246IG4gfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITEsIHRoaXMubmF0aXZlSW5wdXRTZWxlY3RlZCA9ICExLCB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICExO1xuICAgIGNvbnN0IHIgPSBlICYmIGUgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50LCBhID0gciAmJiBsdChlLmtleUNvZGUpO1xuICAgIGlmICh0aGlzLmFueUJsb2NrU2VsZWN0ZWQgJiYgciAmJiBhICYmICFiLmlzU2VsZWN0aW9uRXhpc3RzKSB7XG4gICAgICBjb25zdCBsID0gby5yZW1vdmVTZWxlY3RlZEJsb2NrcygpO1xuICAgICAgby5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KGwsICEwKSwgaS5zZXRUb0Jsb2NrKG8uY3VycmVudEJsb2NrKSwgeGUoKCkgPT4ge1xuICAgICAgICBjb25zdCBkID0gZS5rZXk7XG4gICAgICAgIGkuaW5zZXJ0Q29udGVudEF0Q2FyZXRQb3NpdGlvbihkLmxlbmd0aCA+IDEgPyBcIlwiIDogZCk7XG4gICAgICB9LCAyMCkoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24uY2xlYXIoZSksICF0aGlzLmFueUJsb2NrU2VsZWN0ZWQgfHwgbi5pc1JlY3RBY3RpdmF0ZWQoKSkge1xuICAgICAgdGhpcy5FZGl0b3IuUmVjdGFuZ2xlU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQgJiYgdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpLCB0aGlzLmFsbEJsb2Nrc1NlbGVjdGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFJlZHVjZSBlYWNoIEJsb2NrIGFuZCBjb3B5IGl0cyBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Q2xpcGJvYXJkRXZlbnR9IGUgLSBjb3B5L2N1dCBldmVudFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGNvcHlTZWxlY3RlZEJsb2NrcyhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHQgPSBjLm1ha2UoXCJkaXZcIik7XG4gICAgdGhpcy5zZWxlY3RlZEJsb2Nrcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBjb25zdCByID0gVihuLmhvbGRlci5pbm5lckhUTUwsIHRoaXMuc2FuaXRpemVyQ29uZmlnKSwgYSA9IGMubWFrZShcInBcIik7XG4gICAgICBhLmlubmVySFRNTCA9IHIsIHQuYXBwZW5kQ2hpbGQoYSk7XG4gICAgfSk7XG4gICAgY29uc3QgbyA9IEFycmF5LmZyb20odC5jaGlsZE5vZGVzKS5tYXAoKG4pID0+IG4udGV4dENvbnRlbnQpLmpvaW4oYFxuXG5gKSwgaSA9IHQuaW5uZXJIVE1MO1xuICAgIHJldHVybiBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgbyksIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGkpLCBQcm9taXNlLmFsbCh0aGlzLnNlbGVjdGVkQmxvY2tzLm1hcCgobikgPT4gbi5zYXZlKCkpKS50aGVuKChuKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YSh0aGlzLkVkaXRvci5QYXN0ZS5NSU1FX1RZUEUsIEpTT04uc3RyaW5naWZ5KG4pKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3QgQmxvY2sgYnkgaXRzIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyP30gaW5kZXggLSBCbG9jayBpbmRleCBhY2NvcmRpbmcgdG8gdGhlIEJsb2NrTWFuYWdlcidzIGluZGV4ZXNcbiAgICovXG4gIHNlbGVjdEJsb2NrQnlJbmRleChlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gdC5nZXRCbG9ja0J5SW5kZXgoZSk7XG4gICAgbyAhPT0gdm9pZCAwICYmIHRoaXMuc2VsZWN0QmxvY2sobyk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdCBwYXNzZWQgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byBzZWxlY3RcbiAgICovXG4gIHNlbGVjdEJsb2NrKGUpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5zYXZlKCksIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksIGUuc2VsZWN0ZWQgPSAhMCwgdGhpcy5jbGVhckNhY2hlKCksIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHNlbGVjdGlvbiBmcm9tIHBhc3NlZCBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayAtIEJsb2NrIHRvIHVuc2VsZWN0XG4gICAqL1xuICB1bnNlbGVjdEJsb2NrKGUpIHtcbiAgICBlLnNlbGVjdGVkID0gITEsIHRoaXMuY2xlYXJDYWNoZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBhbnlCbG9ja1NlbGVjdGVkIGNhY2hlXG4gICAqL1xuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlIGRlc3RydWN0aW9uXG4gICAqIERlLXJlZ2lzdGVycyBTaG9ydGN1dCBDTUQrQVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBhZS5yZW1vdmUodGhpcy5FZGl0b3IuVUkubm9kZXMucmVkYWN0b3IsIFwiQ01EK0FcIik7XG4gIH1cbiAgLyoqXG4gICAqIEZpcnN0IENNRCtBIHNlbGVjdHMgYWxsIGlucHV0IGNvbnRlbnQgYnkgbmF0aXZlIGJlaGF2aW91cixcbiAgICogbmV4dCBDTUQrQSBrZXlwcmVzcyBzZWxlY3RzIGFsbCBibG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBoYW5kbGVDb21tYW5kQShlKSB7XG4gICAgaWYgKHRoaXMuRWRpdG9yLlJlY3RhbmdsZVNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpLCBjLmlzTmF0aXZlSW5wdXQoZS50YXJnZXQpICYmICF0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5yZWFkeVRvQmxvY2tTZWxlY3Rpb24gPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9jayhlLnRhcmdldCksIG8gPSB0LmlucHV0cztcbiAgICBpZiAoby5sZW5ndGggPiAxICYmICF0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5yZWFkeVRvQmxvY2tTZWxlY3Rpb24gPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG8ubGVuZ3RoID09PSAxICYmICF0aGlzLm5lZWRUb1NlbGVjdEFsbCkge1xuICAgICAgdGhpcy5uZWVkVG9TZWxlY3RBbGwgPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uZWVkVG9TZWxlY3RBbGwgPyAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnNlbGVjdEFsbEJsb2NrcygpLCB0aGlzLm5lZWRUb1NlbGVjdEFsbCA9ICExLCB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICExLCB0aGlzLkVkaXRvci5Db252ZXJzaW9uVG9vbGJhci5jbG9zZSgpKSA6IHRoaXMucmVhZHlUb0Jsb2NrU2VsZWN0aW9uICYmIChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuc2VsZWN0QmxvY2sodCksIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3QgQWxsIEJsb2Nrc1xuICAgKiBFYWNoIEJsb2NrIGhhcyBzZWxlY3RlZCBzZXR0ZXIgdGhhdCBtYWtlcyBCbG9jayBjb3B5YWJsZVxuICAgKi9cbiAgc2VsZWN0QWxsQmxvY2tzKCkge1xuICAgIHRoaXMuc2VsZWN0aW9uLnNhdmUoKSwgYi5nZXQoKS5yZW1vdmVBbGxSYW5nZXMoKSwgdGhpcy5hbGxCbG9ja3NTZWxlY3RlZCA9ICEwLCB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gIH1cbn1cbmNsYXNzIHdlIGV4dGVuZHMgeSB7XG4gIC8qKlxuICAgKiBBbGxvd2VkIGNhcmV0IHBvc2l0aW9ucyBpbiBpbnB1dFxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm5zIHt7U1RBUlQ6IHN0cmluZywgRU5EOiBzdHJpbmcsIERFRkFVTFQ6IHN0cmluZ319XG4gICAqL1xuICBnZXQgcG9zaXRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBTVEFSVDogXCJzdGFydFwiLFxuICAgICAgRU5EOiBcImVuZFwiLFxuICAgICAgREVGQVVMVDogXCJkZWZhdWx0XCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFbGVtZW50cyBzdHlsZXMgdGhhdCBjYW4gYmUgdXNlZnVsIGZvciBDYXJldCBNb2R1bGVcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaGFkb3dDYXJldDogXCJjZHgtc2hhZG93LWNhcmV0XCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQncyBkZWVwZXN0IGZpcnN0IG5vZGUgYW5kIGNoZWNrcyBpZiBvZmZzZXQgaXMgemVyb1xuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0F0U3RhcnQoKSB7XG4gICAgY29uc3QgeyBjdXJyZW50QmxvY2s6IGUgfSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlcjtcbiAgICBpZiAoIWUuZm9jdXNhYmxlKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGNvbnN0IHQgPSBiLmdldCgpLCBvID0gYy5nZXREZWVwZXN0Tm9kZShlLmN1cnJlbnRJbnB1dCk7XG4gICAgbGV0IGkgPSB0LmZvY3VzTm9kZTtcbiAgICBpZiAoYy5pc05hdGl2ZUlucHV0KG8pKVxuICAgICAgcmV0dXJuIG8uc2VsZWN0aW9uRW5kID09PSAwO1xuICAgIGlmICghdC5hbmNob3JOb2RlKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCBuID0gaS50ZXh0Q29udGVudC5zZWFyY2goL1xcUy8pO1xuICAgIG4gPT09IC0xICYmIChuID0gMCk7XG4gICAgbGV0IHIgPSB0LmZvY3VzT2Zmc2V0O1xuICAgIHJldHVybiBpLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSAmJiBpLmNoaWxkTm9kZXMubGVuZ3RoICYmIChpLmNoaWxkTm9kZXNbcl0gPyAoaSA9IGkuY2hpbGROb2Rlc1tyXSwgciA9IDApIDogKGkgPSBpLmNoaWxkTm9kZXNbciAtIDFdLCByID0gaS50ZXh0Q29udGVudC5sZW5ndGgpKSwgKGMuaXNMaW5lQnJlYWtUYWcobykgfHwgYy5pc0VtcHR5KG8pKSAmJiB0aGlzLmdldEhpZ2hlckxldmVsU2libGluZ3MoaSwgXCJsZWZ0XCIpLmV2ZXJ5KChkKSA9PiB7XG4gICAgICBjb25zdCB1ID0gYy5pc0xpbmVCcmVha1RhZyhkKSwgaCA9IGQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGMuaXNMaW5lQnJlYWtUYWcoZC5jaGlsZHJlblswXSksIGYgPSB1IHx8IGg7XG4gICAgICByZXR1cm4gYy5pc0VtcHR5KGQpICYmICFmO1xuICAgIH0pICYmIHIgPT09IG4gPyAhMCA6IG8gPT09IG51bGwgfHwgaSA9PT0gbyAmJiByIDw9IG47XG4gIH1cbiAgLyoqXG4gICAqIEdldCdzIGRlZXBlc3QgbGFzdCBub2RlIGFuZCBjaGVja3MgaWYgb2Zmc2V0IGlzIGxhc3Qgbm9kZSB0ZXh0IGxlbmd0aFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0F0RW5kKCkge1xuICAgIGNvbnN0IHsgY3VycmVudEJsb2NrOiBlIH0gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXI7XG4gICAgaWYgKCFlLmZvY3VzYWJsZSlcbiAgICAgIHJldHVybiAhMDtcbiAgICBjb25zdCB0ID0gYi5nZXQoKTtcbiAgICBsZXQgbyA9IHQuZm9jdXNOb2RlO1xuICAgIGNvbnN0IGkgPSBjLmdldERlZXBlc3ROb2RlKGUuY3VycmVudElucHV0LCAhMCk7XG4gICAgaWYgKGMuaXNOYXRpdmVJbnB1dChpKSlcbiAgICAgIHJldHVybiBpLnNlbGVjdGlvbkVuZCA9PT0gaS52YWx1ZS5sZW5ndGg7XG4gICAgaWYgKCF0LmZvY3VzTm9kZSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBsZXQgbiA9IHQuZm9jdXNPZmZzZXQ7XG4gICAgaWYgKG8ubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFICYmIG8uY2hpbGROb2Rlcy5sZW5ndGggJiYgKG8uY2hpbGROb2Rlc1tuIC0gMV0gPyAobyA9IG8uY2hpbGROb2Rlc1tuIC0gMV0sIG4gPSBvLnRleHRDb250ZW50Lmxlbmd0aCkgOiAobyA9IG8uY2hpbGROb2Rlc1swXSwgbiA9IDApKSwgYy5pc0xpbmVCcmVha1RhZyhpKSB8fCBjLmlzRW1wdHkoaSkpIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLmdldEhpZ2hlckxldmVsU2libGluZ3MobywgXCJyaWdodFwiKTtcbiAgICAgIGlmIChhLmV2ZXJ5KChkLCB1KSA9PiB1ID09PSBhLmxlbmd0aCAtIDEgJiYgYy5pc0xpbmVCcmVha1RhZyhkKSB8fCBjLmlzRW1wdHkoZCkgJiYgIWMuaXNMaW5lQnJlYWtUYWcoZCkpICYmIG4gPT09IG8udGV4dENvbnRlbnQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGNvbnN0IHIgPSBpLnRleHRDb250ZW50LnJlcGxhY2UoL1xccyskLywgXCJcIik7XG4gICAgcmV0dXJuIG8gPT09IGkgJiYgbiA+PSByLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIGdldHMgQmxvY2sgaW5zdGFuY2UgYW5kIHB1dHMgY2FyZXQgdG8gdGhlIHRleHQgbm9kZSB3aXRoIG9mZnNldFxuICAgKiBUaGVyZSB0d28gd2F5cyB0aGF0IG1ldGhvZCBhcHBsaWVzIGNhcmV0IHBvc2l0aW9uOlxuICAgKiAgIC0gZmlyc3QgZm91bmQgdGV4dCBub2RlOiBzZXRzIGF0IHRoZSBiZWdpbm5pbmcsIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0XG4gICAqICAgLSBsYXN0IGZvdW5kIHRleHQgbm9kZTogc2V0cyBhdCB0aGUgZW5kIG9mIHRoZSBub2RlLiBBbHNvLCB5b3UgY2FuIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3VyXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgY2xhc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uIC0gcG9zaXRpb24gd2hlcmUgdG8gc2V0IGNhcmV0LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBkZWZhdWx0IC0gbGVhdmUgZGVmYXVsdCBiZWhhdmlvdXIgYW5kIGFwcGx5IG9mZnNldCBpZiBpdCdzIHBhc3NlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gY2FyZXQgb2Zmc2V0IHJlZ2FyZGluZyB0byB0aGUgdGV4dCBub2RlXG4gICAqL1xuICBzZXRUb0Jsb2NrKGUsIHQgPSB0aGlzLnBvc2l0aW9ucy5ERUZBVUxULCBvID0gMCkge1xuICAgIHZhciBkO1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBpLCBCbG9ja1NlbGVjdGlvbjogbiB9ID0gdGhpcy5FZGl0b3I7XG4gICAgaWYgKG4uY2xlYXJTZWxlY3Rpb24oKSwgIWUuZm9jdXNhYmxlKSB7XG4gICAgICAoZCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSkgPT0gbnVsbCB8fCBkLnJlbW92ZUFsbFJhbmdlcygpLCBuLnNlbGVjdEJsb2NrKGUpLCBpLmN1cnJlbnRCbG9jayA9IGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSB0aGlzLnBvc2l0aW9ucy5TVEFSVDpcbiAgICAgICAgciA9IGUuZmlyc3RJbnB1dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRoaXMucG9zaXRpb25zLkVORDpcbiAgICAgICAgciA9IGUubGFzdElucHV0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHIgPSBlLmN1cnJlbnRJbnB1dDtcbiAgICB9XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBjLmdldERlZXBlc3ROb2RlKHIsIHQgPT09IHRoaXMucG9zaXRpb25zLkVORCksIGwgPSBjLmdldENvbnRlbnRMZW5ndGgoYSk7XG4gICAgc3dpdGNoICghMCkge1xuICAgICAgY2FzZSB0ID09PSB0aGlzLnBvc2l0aW9ucy5TVEFSVDpcbiAgICAgICAgbyA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0ID09PSB0aGlzLnBvc2l0aW9ucy5FTkQ6XG4gICAgICBjYXNlIG8gPiBsOlxuICAgICAgICBvID0gbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuc2V0KGEsIG8pLCBpLnNldEN1cnJlbnRCbG9ja0J5Q2hpbGROb2RlKGUuaG9sZGVyKSwgaS5jdXJyZW50QmxvY2suY3VycmVudElucHV0ID0gcjtcbiAgfVxuICAvKipcbiAgICogU2V0IGNhcmV0IHRvIHRoZSBjdXJyZW50IGlucHV0IG9mIGN1cnJlbnQgQmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGlucHV0IC0gaW5wdXQgd2hlcmUgY2FyZXQgc2hvdWxkIGJlIHNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbiBvZiB0aGUgY2FyZXQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGRlZmF1bHQgLSBsZWF2ZSBkZWZhdWx0IGJlaGF2aW91ciBhbmQgYXBwbHkgb2Zmc2V0IGlmIGl0J3MgcGFzc2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBjYXJldCBvZmZzZXQgcmVnYXJkaW5nIHRvIHRoZSB0ZXh0IG5vZGVcbiAgICovXG4gIHNldFRvSW5wdXQoZSwgdCA9IHRoaXMucG9zaXRpb25zLkRFRkFVTFQsIG8gPSAwKSB7XG4gICAgY29uc3QgeyBjdXJyZW50QmxvY2s6IGkgfSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlciwgbiA9IGMuZ2V0RGVlcGVzdE5vZGUoZSk7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIHRoaXMucG9zaXRpb25zLlNUQVJUOlxuICAgICAgICB0aGlzLnNldChuLCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRoaXMucG9zaXRpb25zLkVORDpcbiAgICAgICAgdGhpcy5zZXQobiwgYy5nZXRDb250ZW50TGVuZ3RoKG4pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvICYmIHRoaXMuc2V0KG4sIG8pO1xuICAgIH1cbiAgICBpLmN1cnJlbnRJbnB1dCA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgRG9jdW1lbnQgUmFuZ2UgYW5kIHNldHMgY2FyZXQgdG8gdGhlIGVsZW1lbnQgd2l0aCBvZmZzZXRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gb2Zmc2V0XG4gICAqL1xuICBzZXQoZSwgdCA9IDApIHtcbiAgICBjb25zdCB7IHRvcDogaSwgYm90dG9tOiBuIH0gPSBiLnNldEN1cnNvcihlLCB0KSwgeyBpbm5lckhlaWdodDogciB9ID0gd2luZG93O1xuICAgIGkgPCAwID8gd2luZG93LnNjcm9sbEJ5KDAsIGkgLSAzMCkgOiBuID4gciAmJiB3aW5kb3cuc2Nyb2xsQnkoMCwgbiAtIHIgKyAzMCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBDYXJldCB0byB0aGUgbGFzdCBCbG9ja1xuICAgKiBJZiBsYXN0IGJsb2NrIGlzIG5vdCBlbXB0eSwgYXBwZW5kIGFub3RoZXIgZW1wdHkgYmxvY2tcbiAgICovXG4gIHNldFRvVGhlTGFzdEJsb2NrKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubGFzdEJsb2NrO1xuICAgIGlmIChlKVxuICAgICAgaWYgKGUudG9vbC5pc0RlZmF1bHQgJiYgZS5pc0VtcHR5KVxuICAgICAgICB0aGlzLnNldFRvQmxvY2soZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnRBdEVuZCgpO1xuICAgICAgICB0aGlzLnNldFRvQmxvY2sodCk7XG4gICAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgY29udGVudCBmcmFnbWVudCBvZiBjdXJyZW50IEJsb2NrIGZyb20gQ2FyZXQgcG9zaXRpb24gdG8gdGhlIGVuZCBvZiB0aGUgQmxvY2tcbiAgICovXG4gIGV4dHJhY3RGcmFnbWVudEZyb21DYXJldFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IGUgPSBiLmdldCgpO1xuICAgIGlmIChlLnJhbmdlQ291bnQpIHtcbiAgICAgIGNvbnN0IHQgPSBlLmdldFJhbmdlQXQoMCksIG8gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLmN1cnJlbnRJbnB1dDtcbiAgICAgIGlmICh0LmRlbGV0ZUNvbnRlbnRzKCksIG8pXG4gICAgICAgIGlmIChjLmlzTmF0aXZlSW5wdXQobykpIHtcbiAgICAgICAgICBjb25zdCBpID0gbywgbiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgciA9IGkudmFsdWUuc3Vic3RyaW5nKDAsIGkuc2VsZWN0aW9uU3RhcnQpLCBhID0gaS52YWx1ZS5zdWJzdHJpbmcoaS5zZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgcmV0dXJuIG4udGV4dENvbnRlbnQgPSBhLCBpLnZhbHVlID0gciwgbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBpID0gdC5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgcmV0dXJuIGkuc2VsZWN0Tm9kZUNvbnRlbnRzKG8pLCBpLnNldFN0YXJ0KHQuZW5kQ29udGFpbmVyLCB0LmVuZE9mZnNldCksIGkuZXh0cmFjdENvbnRlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldCdzIGNhcmV0IHRvIHRoZSBuZXh0IEJsb2NrIG9yIFRvb2xgcyBpbnB1dFxuICAgKiBCZWZvcmUgbW92aW5nIGNhcmV0LCB3ZSBzaG91bGQgY2hlY2sgaWYgY2FyZXQgcG9zaXRpb24gaXMgYXQgdGhlIGVuZCBvZiBQbHVnaW5zIG5vZGVcbiAgICogVXNpbmcge0BsaW5rIERvbSNnZXREZWVwZXN0Tm9kZX0gdG8gZ2V0IGEgbGFzdCBub2RlIGFuZCBtYXRjaCB3aXRoIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgLSBwYXNzIHRydWUgdG8gc2tpcCBjaGVjayBmb3IgY2FyZXQgcG9zaXRpb25cbiAgICovXG4gIG5hdmlnYXRlTmV4dChlID0gITEpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCB9ID0gdGhpcy5FZGl0b3IsIHsgY3VycmVudEJsb2NrOiBvLCBuZXh0QmxvY2s6IGkgfSA9IHQsIHsgbmV4dElucHV0OiBuIH0gPSBvLCByID0gdGhpcy5pc0F0RW5kO1xuICAgIGxldCBhID0gaTtcbiAgICBjb25zdCBsID0gZSB8fCByO1xuICAgIGlmIChuICYmIGwpXG4gICAgICByZXR1cm4gdGhpcy5zZXRUb0lucHV0KG4sIHRoaXMucG9zaXRpb25zLlNUQVJUKSwgITA7XG4gICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgIGlmIChvLnRvb2wuaXNEZWZhdWx0IHx8ICFsKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBhID0gdC5pbnNlcnRBdEVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gbCA/ICh0aGlzLnNldFRvQmxvY2soYSwgdGhpcy5wb3NpdGlvbnMuU1RBUlQpLCAhMCkgOiAhMTtcbiAgfVxuICAvKipcbiAgICogU2V0J3MgY2FyZXQgdG8gdGhlIHByZXZpb3VzIFRvb2xgcyBpbnB1dCBvciBCbG9ja1xuICAgKiBCZWZvcmUgbW92aW5nIGNhcmV0LCB3ZSBzaG91bGQgY2hlY2sgaWYgY2FyZXQgcG9zaXRpb24gaXMgc3RhcnQgb2YgdGhlIFBsdWdpbnMgbm9kZVxuICAgKiBVc2luZyB7QGxpbmsgRG9tI2dldERlZXBlc3ROb2RlfSB0byBnZXQgYSBsYXN0IG5vZGUgYW5kIG1hdGNoIHdpdGggY3VycmVudCBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIHBhc3MgdHJ1ZSB0byBza2lwIGNoZWNrIGZvciBjYXJldCBwb3NpdGlvblxuICAgKi9cbiAgbmF2aWdhdGVQcmV2aW91cyhlID0gITEpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogdCwgcHJldmlvdXNCbG9jazogbyB9ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCB7IHByZXZpb3VzSW5wdXQ6IGkgfSA9IHQsIG4gPSBlIHx8IHRoaXMuaXNBdFN0YXJ0O1xuICAgIHJldHVybiBpICYmIG4gPyAodGhpcy5zZXRUb0lucHV0KGksIHRoaXMucG9zaXRpb25zLkVORCksICEwKSA6IG8gIT09IG51bGwgJiYgbiA/ICh0aGlzLnNldFRvQmxvY2sobywgdGhpcy5wb3NpdGlvbnMuRU5EKSwgITApIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgc2hhZG93IGVsZW1lbnQgYWZ0ZXIgcGFzc2VkIGVsZW1lbnQgd2hlcmUgY2FyZXQgY2FuIGJlIHBsYWNlZFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IGFmdGVyIHdoaWNoIHNoYWRvdyBjYXJldCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICovXG4gIGNyZWF0ZVNoYWRvdyhlKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHQuY2xhc3NMaXN0LmFkZCh3ZS5DU1Muc2hhZG93Q2FyZXQpLCBlLmluc2VydEFkamFjZW50RWxlbWVudChcImJlZm9yZWVuZFwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogUmVzdG9yZXMgY2FyZXQgcG9zaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgd2hlcmUgY2FyZXQgc2hvdWxkIGJlIHJlc3RvcmVkXG4gICAqL1xuICByZXN0b3JlQ2FyZXQoZSkge1xuICAgIGNvbnN0IHQgPSBlLnF1ZXJ5U2VsZWN0b3IoYC4ke3dlLkNTUy5zaGFkb3dDYXJldH1gKTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgbmV3IGIoKS5leHBhbmRUb1RhZyh0KTtcbiAgICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBpLnNlbGVjdE5vZGUodCksIGkuZXh0cmFjdENvbnRlbnRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgcGFzc2VkIGNvbnRlbnQgYXQgY2FyZXQgcG9zaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgLSBjb250ZW50IHRvIGluc2VydFxuICAgKi9cbiAgaW5zZXJ0Q29udGVudEF0Q2FyZXRQb3NpdGlvbihlKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGkgPSBiLmdldCgpLCBuID0gYi5yYW5nZTtcbiAgICBvLmlubmVySFRNTCA9IGUsIEFycmF5LmZyb20oby5jaGlsZE5vZGVzKS5mb3JFYWNoKChkKSA9PiB0LmFwcGVuZENoaWxkKGQpKSwgdC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCAmJiB0LmFwcGVuZENoaWxkKG5ldyBUZXh0KCkpO1xuICAgIGNvbnN0IHIgPSB0Lmxhc3RDaGlsZDtcbiAgICBuLmRlbGV0ZUNvbnRlbnRzKCksIG4uaW5zZXJ0Tm9kZSh0KTtcbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSwgbCA9IHIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gciA6IHIuZmlyc3RDaGlsZDtcbiAgICBsICE9PSBudWxsICYmIGwudGV4dENvbnRlbnQgIT09IG51bGwgJiYgYS5zZXRTdGFydChsLCBsLnRleHRDb250ZW50Lmxlbmd0aCksIGkucmVtb3ZlQWxsUmFuZ2VzKCksIGkuYWRkUmFuZ2UoYSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgZmlyc3QtbGV2ZWwgKGZpcnN0IGNoaWxkIG9mIFtjb250ZW50ZWRpdGFibGVdKSBzaWJsaW5ncyBmcm9tIHBhc3NlZCBub2RlXG4gICAqIFRoZW4geW91IGNhbiBjaGVjayBpdCBmb3IgZW1wdGluZXNzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxkaXYgY29udGVudGVkaXRhYmxlPlxuICAgKiA8cD48L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGxlZnQgZmlyc3QtbGV2ZWwgc2libGluZ3NcbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIDxibG9ja3F1b3RlPjxhPjxiPmFkYWRkYWQ8L2I+PGE+PGJsb2NrcXVvdGU+ICAgICAgIDwtLSBwYXNzZWQgbm9kZSBmb3IgZXhhbXBsZSA8Yj5cbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIDxwPjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCByaWdodCBmaXJzdC1sZXZlbCBzaWJsaW5nc1xuICAgKiA8cD48L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogPC9kaXY+XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZyb20gLSBlbGVtZW50IGZyb20gd2hpY2ggc2libGluZ3Mgc2hvdWxkIGJlIHNlYXJjaGVkXG4gICAqIEBwYXJhbSB7J2xlZnQnIHwgJ3JpZ2h0J30gZGlyZWN0aW9uIC0gZGlyZWN0aW9uIG9mIHNlYXJjaFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRbXX1cbiAgICovXG4gIGdldEhpZ2hlckxldmVsU2libGluZ3MoZSwgdCkge1xuICAgIGxldCBvID0gZTtcbiAgICBjb25zdCBpID0gW107XG4gICAgZm9yICg7IG8ucGFyZW50Tm9kZSAmJiBvLnBhcmVudE5vZGUuY29udGVudEVkaXRhYmxlICE9PSBcInRydWVcIjsgKVxuICAgICAgbyA9IG8ucGFyZW50Tm9kZTtcbiAgICBjb25zdCBuID0gdCA9PT0gXCJsZWZ0XCIgPyBcInByZXZpb3VzU2libGluZ1wiIDogXCJuZXh0U2libGluZ1wiO1xuICAgIGZvciAoOyBvW25dOyApXG4gICAgICBvID0gb1tuXSwgaS5wdXNoKG8pO1xuICAgIHJldHVybiBpO1xuICB9XG59XG5jbGFzcyBzaSBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLm9uTW91c2VVcCA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLm9mZihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdGhpcy5vbk1vdXNlT3ZlciksIHRoaXMubGlzdGVuZXJzLm9mZihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIHRoaXMub25Nb3VzZVVwKTtcbiAgICB9LCB0aGlzLm9uTW91c2VPdmVyID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBCbG9ja1NlbGVjdGlvbjogbyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ID09PSBudWxsICYmIGUudGFyZ2V0ID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpID0gdC5nZXRCbG9ja0J5Q2hpbGROb2RlKGUucmVsYXRlZFRhcmdldCkgfHwgdGhpcy5sYXN0U2VsZWN0ZWRCbG9jaywgbiA9IHQuZ2V0QmxvY2tCeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgICBpZiAoISghaSB8fCAhbikgJiYgbiAhPT0gaSkge1xuICAgICAgICBpZiAoaSA9PT0gdGhpcy5maXJzdFNlbGVjdGVkQmxvY2spIHtcbiAgICAgICAgICBiLmdldCgpLnJlbW92ZUFsbFJhbmdlcygpLCBpLnNlbGVjdGVkID0gITAsIG4uc2VsZWN0ZWQgPSAhMCwgby5jbGVhckNhY2hlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuID09PSB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jaykge1xuICAgICAgICAgIGkuc2VsZWN0ZWQgPSAhMSwgbi5zZWxlY3RlZCA9ICExLCBvLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpLCB0aGlzLnRvZ2dsZUJsb2Nrc1NlbGVjdGVkU3RhdGUoaSwgbiksIHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgPSBuO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBwcmVwYXJhdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQsIFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICB0aGlzLmVuYWJsZUNyb3NzQmxvY2tTZWxlY3Rpb24oZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdXAgbGlzdGVuZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBtb3VzZSBkb3duIGV2ZW50XG4gICAqL1xuICB3YXRjaFNlbGVjdGlvbihlKSB7XG4gICAgaWYgKGUuYnV0dG9uICE9PSBQdC5MRUZUKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0IH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jayA9IHQuZ2V0QmxvY2soZS50YXJnZXQpLCB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrID0gdGhpcy5maXJzdFNlbGVjdGVkQmxvY2ssIHRoaXMubGlzdGVuZXJzLm9uKGRvY3VtZW50LCBcIm1vdXNlb3ZlclwiLCB0aGlzLm9uTW91c2VPdmVyKSwgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQsIFwibW91c2V1cFwiLCB0aGlzLm9uTW91c2VVcCk7XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybiBib29sZWFuIGlzIGNyb3NzIGJsb2NrIHNlbGVjdGlvbiBzdGFydGVkXG4gICAqL1xuICBnZXQgaXNDcm9zc0Jsb2NrU2VsZWN0aW9uU3RhcnRlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jayAmJiAhIXRoaXMubGFzdFNlbGVjdGVkQmxvY2s7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZSBzZWxlY3Rpb24gc3RhdGUgb2YgdGhlIG5leHQgQmxvY2tcbiAgICogVXNlZCBmb3IgQ0JTIHZpYSBTaGlmdCArIGFycm93IGtleXNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBuZXh0IC0gaWYgdHJ1ZSwgdG9nZ2xlIG5leHQgYmxvY2suIFByZXZpb3VzIG90aGVyd2lzZVxuICAgKi9cbiAgdG9nZ2xlQmxvY2tTZWxlY3RlZFN0YXRlKGUgPSAhMCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBCbG9ja1NlbGVjdGlvbjogbyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayB8fCAodGhpcy5sYXN0U2VsZWN0ZWRCbG9jayA9IHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrID0gdC5jdXJyZW50QmxvY2spLCB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jayA9PT0gdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayAmJiAodGhpcy5maXJzdFNlbGVjdGVkQmxvY2suc2VsZWN0ZWQgPSAhMCwgby5jbGVhckNhY2hlKCksIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCkpO1xuICAgIGNvbnN0IGkgPSB0LmJsb2Nrcy5pbmRleE9mKHRoaXMubGFzdFNlbGVjdGVkQmxvY2spICsgKGUgPyAxIDogLTEpLCBuID0gdC5ibG9ja3NbaV07XG4gICAgbiAmJiAodGhpcy5sYXN0U2VsZWN0ZWRCbG9jay5zZWxlY3RlZCAhPT0gbi5zZWxlY3RlZCA/IChuLnNlbGVjdGVkID0gITAsIG8uY2xlYXJDYWNoZSgpKSA6ICh0aGlzLmxhc3RTZWxlY3RlZEJsb2NrLnNlbGVjdGVkID0gITEsIG8uY2xlYXJDYWNoZSgpKSwgdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayA9IG4sIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKSwgbi5ob2xkZXIuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBzYXZlZCBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSByZWFzb24gLSBldmVudCBjYXVzZWQgY2xlYXIgb2Ygc2VsZWN0aW9uXG4gICAqL1xuICBjbGVhcihlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIEJsb2NrU2VsZWN0aW9uOiBvLCBDYXJldDogaSB9ID0gdGhpcy5FZGl0b3IsIG4gPSB0LmJsb2Nrcy5pbmRleE9mKHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrKSwgciA9IHQuYmxvY2tzLmluZGV4T2YodGhpcy5sYXN0U2VsZWN0ZWRCbG9jayk7XG4gICAgaWYgKG8uYW55QmxvY2tTZWxlY3RlZCAmJiBuID4gLTEgJiYgciA+IC0xICYmIGUgJiYgZSBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQpXG4gICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICBjYXNlIHYuRE9XTjpcbiAgICAgICAgY2FzZSB2LlJJR0hUOlxuICAgICAgICAgIGkuc2V0VG9CbG9jayh0LmJsb2Nrc1tNYXRoLm1heChuLCByKV0sIGkucG9zaXRpb25zLkVORCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugdi5VUDpcbiAgICAgICAgY2FzZSB2LkxFRlQ6XG4gICAgICAgICAgaS5zZXRUb0Jsb2NrKHQuYmxvY2tzW01hdGgubWluKG4sIHIpXSwgaS5wb3NpdGlvbnMuU1RBUlQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGkuc2V0VG9CbG9jayh0LmJsb2Nrc1tNYXRoLm1heChuLCByKV0sIGkucG9zaXRpb25zLkVORCk7XG4gICAgICB9XG4gICAgdGhpcy5maXJzdFNlbGVjdGVkQmxvY2sgPSB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBDcm9zcyBCbG9jayBTZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIG1vdXNlIGRvd24gZXZlbnRcbiAgICovXG4gIGVuYWJsZUNyb3NzQmxvY2tTZWxlY3Rpb24oZSkge1xuICAgIGNvbnN0IHsgVUk6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGIuaXNDb2xsYXBzZWQgfHwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSksIHQubm9kZXMucmVkYWN0b3IuY29udGFpbnMoZS50YXJnZXQpID8gdGhpcy53YXRjaFNlbGVjdGlvbihlKSA6IHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2UgYmxvY2tzIHNlbGVjdGlvbiBzdGF0ZSBiZXR3ZWVuIHBhc3NlZCB0d28gYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBmaXJzdEJsb2NrIC0gZmlyc3QgYmxvY2sgaW4gcmFuZ2VcbiAgICogQHBhcmFtIHtCbG9ja30gbGFzdEJsb2NrIC0gbGFzdCBibG9jayBpbiByYW5nZVxuICAgKi9cbiAgdG9nZ2xlQmxvY2tzU2VsZWN0ZWRTdGF0ZShlLCB0KSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IG8sIEJsb2NrU2VsZWN0aW9uOiBpIH0gPSB0aGlzLkVkaXRvciwgbiA9IG8uYmxvY2tzLmluZGV4T2YoZSksIHIgPSBvLmJsb2Nrcy5pbmRleE9mKHQpLCBhID0gZS5zZWxlY3RlZCAhPT0gdC5zZWxlY3RlZDtcbiAgICBmb3IgKGxldCBsID0gTWF0aC5taW4obiwgcik7IGwgPD0gTWF0aC5tYXgobiwgcik7IGwrKykge1xuICAgICAgY29uc3QgZCA9IG8uYmxvY2tzW2xdO1xuICAgICAgZCAhPT0gdGhpcy5maXJzdFNlbGVjdGVkQmxvY2sgJiYgZCAhPT0gKGEgPyBlIDogdCkgJiYgKG8uYmxvY2tzW2xdLnNlbGVjdGVkID0gIW8uYmxvY2tzW2xdLnNlbGVjdGVkLCBpLmNsZWFyQ2FjaGUoKSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyByaSBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmlzU3RhcnRlZEF0RWRpdG9yID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogaWYgc3RhdGUgaXMgdHJ1ZTpcbiAgICogIC0gZGlzYWJsZSBhbGwgZHJhZy1uLWRyb3AgZXZlbnQgaGFuZGxlcnNcbiAgICpcbiAgICogaWYgc3RhdGUgaXMgZmFsc2U6XG4gICAqICAtIHJlc3RvcmUgZHJhZy1uLWRyb3AgZXZlbnQgaGFuZGxlcnNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSBcInJlYWQgb25seVwiIHN0YXRlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/IHRoaXMuZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkgOiB0aGlzLmVuYWJsZU1vZHVsZUJpbmRpbmdzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBkcmFnIGV2ZW50cyBsaXN0ZW5lcnMgdG8gZWRpdG9yIHpvbmVcbiAgICovXG4gIGVuYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIGNvbnN0IHsgVUk6IGUgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUubm9kZXMuaG9sZGVyLCBcImRyb3BcIiwgYXN5bmMgKHQpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0Ryb3AodCk7XG4gICAgfSwgITApLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihlLm5vZGVzLmhvbGRlciwgXCJkcmFnc3RhcnRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzRHJhZ1N0YXJ0KCk7XG4gICAgfSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUubm9kZXMuaG9sZGVyLCBcImRyYWdvdmVyXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NEcmFnT3Zlcih0KTtcbiAgICB9LCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFVuYmluZCBkcmFnLW4tZHJvcCBldmVudCBoYW5kbGVyc1xuICAgKi9cbiAgZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLmNsZWFyQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBkcm9wIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RHJhZ0V2ZW50fSBkcm9wRXZlbnQgLSBkcm9wIGV2ZW50XG4gICAqL1xuICBhc3luYyBwcm9jZXNzRHJvcChlKSB7XG4gICAgY29uc3Qge1xuICAgICAgQmxvY2tNYW5hZ2VyOiB0LFxuICAgICAgQ2FyZXQ6IG8sXG4gICAgICBQYXN0ZTogaVxuICAgIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCksIHQuYmxvY2tzLmZvckVhY2goKHIpID0+IHtcbiAgICAgIHIuZHJvcFRhcmdldCA9ICExO1xuICAgIH0pLCBiLmlzQXRFZGl0b3IgJiYgIWIuaXNDb2xsYXBzZWQgJiYgdGhpcy5pc1N0YXJ0ZWRBdEVkaXRvciAmJiBkb2N1bWVudC5leGVjQ29tbWFuZChcImRlbGV0ZVwiKSwgdGhpcy5pc1N0YXJ0ZWRBdEVkaXRvciA9ICExO1xuICAgIGNvbnN0IG4gPSB0LnNldEN1cnJlbnRCbG9ja0J5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICBpZiAobilcbiAgICAgIHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sobiwgby5wb3NpdGlvbnMuRU5EKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHIgPSB0LnNldEN1cnJlbnRCbG9ja0J5Q2hpbGROb2RlKHQubGFzdEJsb2NrLmhvbGRlcik7XG4gICAgICB0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHIsIG8ucG9zaXRpb25zLkVORCk7XG4gICAgfVxuICAgIGF3YWl0IGkucHJvY2Vzc0RhdGFUcmFuc2ZlcihlLmRhdGFUcmFuc2ZlciwgITApO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgZHJhZyBzdGFydCBldmVudFxuICAgKi9cbiAgcHJvY2Vzc0RyYWdTdGFydCgpIHtcbiAgICBiLmlzQXRFZGl0b3IgJiYgIWIuaXNDb2xsYXBzZWQgJiYgKHRoaXMuaXNTdGFydGVkQXRFZGl0b3IgPSAhMCksIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtEcmFnRXZlbnR9IGRyYWdFdmVudCAtIGRyYWcgZXZlbnRcbiAgICovXG4gIHByb2Nlc3NEcmFnT3ZlcihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59XG5jbGFzcyBhaSBleHRlbmRzIHkge1xuICAvKipcbiAgICogUHJlcGFyZSB0aGUgbW9kdWxlXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyB1c2VkIGJ5IHRoZSBtb2RpZmljYXRpb24gb2JzZXJ2ZXIgbW9kdWxlXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyAtIEVkaXRvciBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0gb3B0aW9ucy5ldmVudHNEaXNwYXRjaGVyIC0gY29tbW9uIEVkaXRvciBldmVudCBidXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgY29uZmlnOiBlLCBldmVudHNEaXNwYXRjaGVyOiB0IH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWc6IGUsXG4gICAgICBldmVudHNEaXNwYXRjaGVyOiB0XG4gICAgfSksIHRoaXMuZGlzYWJsZWQgPSAhMSwgdGhpcy5iYXRjaGluZ1RpbWVvdXQgPSBudWxsLCB0aGlzLmJhdGNoaW5nT25DaGFuZ2VRdWV1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuYmF0Y2hUaW1lID0gNDAwLCB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobykgPT4ge1xuICAgICAgdGhpcy5yZWRhY3RvckNoYW5nZWQobyk7XG4gICAgfSksIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vbihwdCwgKG8pID0+IHtcbiAgICAgIHRoaXMucGFydGljdWxhckJsb2NrQ2hhbmdlZChvLmV2ZW50KTtcbiAgICB9KSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9uKGZ0LCAoKSA9PiB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9KSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9uKGd0LCAoKSA9PiB7XG4gICAgICB0aGlzLmVuYWJsZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9uQ2hhbmdlIGV2ZW50XG4gICAqL1xuICBlbmFibGUoKSB7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoXG4gICAgICB0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3RvcixcbiAgICAgIHtcbiAgICAgICAgY2hpbGRMaXN0OiAhMCxcbiAgICAgICAgc3VidHJlZTogITAsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6ICEwLFxuICAgICAgICBhdHRyaWJ1dGVzOiAhMFxuICAgICAgfVxuICAgICksIHRoaXMuZGlzYWJsZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgb25DaGFuZ2UgZXZlbnRcbiAgICovXG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKSwgdGhpcy5kaXNhYmxlZCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIG9uQ2hhbmdlIGV2ZW50IHBhc3NlZCB0byBFZGl0b3IuanMgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBzb21lIG9mIG91ciBjdXN0b20gY2hhbmdlIGV2ZW50c1xuICAgKi9cbiAgcGFydGljdWxhckJsb2NrQ2hhbmdlZChlKSB7XG4gICAgdGhpcy5kaXNhYmxlZCB8fCAhTSh0aGlzLmNvbmZpZy5vbkNoYW5nZSkgfHwgKHRoaXMuYmF0Y2hpbmdPbkNoYW5nZVF1ZXVlLnNldChgYmxvY2s6JHtlLmRldGFpbC50YXJnZXQuaWR9OmV2ZW50OiR7ZS50eXBlfWAsIGUpLCB0aGlzLmJhdGNoaW5nVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5iYXRjaGluZ1RpbWVvdXQpLCB0aGlzLmJhdGNoaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbGV0IHQ7XG4gICAgICB0aGlzLmJhdGNoaW5nT25DaGFuZ2VRdWV1ZS5zaXplID09PSAxID8gdCA9IHRoaXMuYmF0Y2hpbmdPbkNoYW5nZVF1ZXVlLnZhbHVlcygpLm5leHQoKS52YWx1ZSA6IHQgPSBBcnJheS5mcm9tKHRoaXMuYmF0Y2hpbmdPbkNoYW5nZVF1ZXVlLnZhbHVlcygpKSwgdGhpcy5jb25maWcub25DaGFuZ2UgJiYgdGhpcy5jb25maWcub25DaGFuZ2UodGhpcy5FZGl0b3IuQVBJLm1ldGhvZHMsIHQpLCB0aGlzLmJhdGNoaW5nT25DaGFuZ2VRdWV1ZS5jbGVhcigpO1xuICAgIH0sIHRoaXMuYmF0Y2hUaW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpcmVkIG9uIGV2ZXJ5IGJsb2NrcyB3cmFwcGVyIGRvbSBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIG11dGF0aW9ucyAtIG11dGF0aW9ucyBoYXBwZW5lZFxuICAgKi9cbiAgcmVkYWN0b3JDaGFuZ2VkKGUpIHtcbiAgICB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIuZW1pdChBZSwge1xuICAgICAgbXV0YXRpb25zOiBlXG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEN0ID0gY2xhc3MgZXh0ZW5kcyB5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5NSU1FX1RZUEUgPSBcImFwcGxpY2F0aW9uL3gtZWRpdG9yLWpzXCIsIHRoaXMudG9vbHNUYWdzID0ge30sIHRoaXMudGFnc0J5VG9vbCA9IHt9LCB0aGlzLnRvb2xzUGF0dGVybnMgPSBbXSwgdGhpcy50b29sc0ZpbGVzID0ge30sIHRoaXMuZXhjZXB0aW9uTGlzdCA9IFtdLCB0aGlzLnByb2Nlc3NUb29sID0gKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGUgPSBzLmNyZWF0ZSh7fSwge30sICExKTtcbiAgICAgICAgaWYgKHMucGFzdGVDb25maWcgPT09ICExKSB7XG4gICAgICAgICAgdGhpcy5leGNlcHRpb25MaXN0LnB1c2gocy5uYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFNKGUub25QYXN0ZSkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmdldFRhZ3NDb25maWcocyksIHRoaXMuZ2V0RmlsZXNDb25maWcocyksIHRoaXMuZ2V0UGF0dGVybnNDb25maWcocyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIFQoXG4gICAgICAgICAgYFBhc3RlIGhhbmRsaW5nIGZvciDCqyR7cy5uYW1lfcK7IFRvb2wgaGFzbid0IGJlZW4gc2V0IHVwIGJlY2F1c2Ugb2YgdGhlIGVycm9yYCxcbiAgICAgICAgICBcIndhcm5cIixcbiAgICAgICAgICBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5oYW5kbGVQYXN0ZUV2ZW50ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBlLCBUb29sYmFyOiB0IH0gPSB0aGlzLkVkaXRvciwgbyA9IGUuc2V0Q3VycmVudEJsb2NrQnlDaGlsZE5vZGUocy50YXJnZXQpO1xuICAgICAgIW8gfHwgdGhpcy5pc05hdGl2ZUJlaGF2aW91cihzLnRhcmdldCkgJiYgIXMuY2xpcGJvYXJkRGF0YS50eXBlcy5pbmNsdWRlcyhcIkZpbGVzXCIpIHx8IG8gJiYgdGhpcy5leGNlcHRpb25MaXN0LmluY2x1ZGVzKG8ubmFtZSkgfHwgKHMucHJldmVudERlZmF1bHQoKSwgdGhpcy5wcm9jZXNzRGF0YVRyYW5zZmVyKHMuY2xpcGJvYXJkRGF0YSksIHQuY2xvc2UoKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2V0IG9uUGFzdGUgY2FsbGJhY2sgYW5kIGNvbGxlY3QgdG9vbHNgIHBhc3RlIGNvbmZpZ3VyYXRpb25zXG4gICAqL1xuICBhc3luYyBwcmVwYXJlKCkge1xuICAgIHRoaXMucHJvY2Vzc1Rvb2xzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSByZWFkIG9ubHkgZmxhZyB2YWx1ZVxuICAgKi9cbiAgdG9nZ2xlUmVhZE9ubHkocykge1xuICAgIHMgPyB0aGlzLnVuc2V0Q2FsbGJhY2soKSA6IHRoaXMuc2V0Q2FsbGJhY2soKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIHBhc3RlZCBvciBkcm9wcGVkIGRhdGEgdHJhbnNmZXIgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7RGF0YVRyYW5zZmVyfSBkYXRhVHJhbnNmZXIgLSBwYXN0ZWQgb3IgZHJvcHBlZCBkYXRhIHRyYW5zZmVyIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRHJhZ05Ecm9wIC0gdHJ1ZSBpZiBkYXRhIHRyYW5zZmVyIGNvbWVzIGZyb20gZHJhZyduJ2Ryb3AgZXZlbnRzXG4gICAqL1xuICBhc3luYyBwcm9jZXNzRGF0YVRyYW5zZmVyKHMsIGUgPSAhMSkge1xuICAgIGNvbnN0IHsgVG9vbHM6IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gcy50eXBlcztcbiAgICBpZiAoKG8uaW5jbHVkZXMgPyBvLmluY2x1ZGVzKFwiRmlsZXNcIikgOiBvLmNvbnRhaW5zKFwiRmlsZXNcIikpICYmICFXKHRoaXMudG9vbHNGaWxlcykpIHtcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0ZpbGVzKHMuZmlsZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuID0gcy5nZXREYXRhKHRoaXMuTUlNRV9UWVBFKSwgciA9IHMuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgbGV0IGEgPSBzLmdldERhdGEoXCJ0ZXh0L2h0bWxcIik7XG4gICAgaWYgKG4pXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmluc2VydEVkaXRvckpTRGF0YShKU09OLnBhcnNlKG4pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgZSAmJiByLnRyaW0oKSAmJiBhLnRyaW0oKSAmJiAoYSA9IFwiPHA+XCIgKyAoYS50cmltKCkgPyBhIDogcikgKyBcIjwvcD5cIik7XG4gICAgY29uc3QgbCA9IE9iamVjdC5rZXlzKHRoaXMudG9vbHNUYWdzKS5yZWR1Y2UoKGgsIGYpID0+IChoW2YudG9Mb3dlckNhc2UoKV0gPSB0aGlzLnRvb2xzVGFnc1tmXS5zYW5pdGl6YXRpb25Db25maWcgPz8ge30sIGgpLCB7fSksIGQgPSBPYmplY3QuYXNzaWduKHt9LCBsLCB0LmdldEFsbElubGluZVRvb2xzU2FuaXRpemVDb25maWcoKSwgeyBicjoge30gfSksIHUgPSBWKGEsIGQpO1xuICAgICF1LnRyaW0oKSB8fCB1LnRyaW0oKSA9PT0gciB8fCAhYy5pc0hUTUxTdHJpbmcodSkgPyBhd2FpdCB0aGlzLnByb2Nlc3NUZXh0KHIpIDogYXdhaXQgdGhpcy5wcm9jZXNzVGV4dCh1LCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcGFzdGVkIHRleHQgYW5kIGRpdmlkZSB0aGVtIGludG8gQmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gdGV4dCB0byBwcm9jZXNzLiBDYW4gYmUgSFRNTCBvciBwbGFpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0hUTUwgLSBpZiBwYXNzZWQgc3RyaW5nIGlzIEhUTUwsIHRoaXMgcGFyYW1ldGVyIHNob3VsZCBiZSB0cnVlXG4gICAqL1xuICBhc3luYyBwcm9jZXNzVGV4dChzLCBlID0gITEpIHtcbiAgICBjb25zdCB7IENhcmV0OiB0LCBCbG9ja01hbmFnZXI6IG8gfSA9IHRoaXMuRWRpdG9yLCBpID0gZSA/IHRoaXMucHJvY2Vzc0hUTUwocykgOiB0aGlzLnByb2Nlc3NQbGFpbihzKTtcbiAgICBpZiAoIWkubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaVswXS5pc0Jsb2NrID8gdGhpcy5wcm9jZXNzU2luZ2xlQmxvY2soaS5wb3AoKSkgOiB0aGlzLnByb2Nlc3NJbmxpbmVQYXN0ZShpLnBvcCgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgciA9IG8uY3VycmVudEJsb2NrICYmIG8uY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIG8uY3VycmVudEJsb2NrLmlzRW1wdHk7XG4gICAgaS5tYXAoXG4gICAgICBhc3luYyAoYSwgbCkgPT4gdGhpcy5pbnNlcnRCbG9jayhhLCBsID09PSAwICYmIHIpXG4gICAgKSwgby5jdXJyZW50QmxvY2sgJiYgdC5zZXRUb0Jsb2NrKG8uY3VycmVudEJsb2NrLCB0LnBvc2l0aW9ucy5FTkQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgb25QYXN0ZSBjYWxsYmFjayBoYW5kbGVyXG4gICAqL1xuICBzZXRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vbih0aGlzLkVkaXRvci5VSS5ub2Rlcy5ob2xkZXIsIFwicGFzdGVcIiwgdGhpcy5oYW5kbGVQYXN0ZUV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogVW5zZXQgb25QYXN0ZSBjYWxsYmFjayBoYW5kbGVyXG4gICAqL1xuICB1bnNldENhbGxiYWNrKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLm9mZih0aGlzLkVkaXRvci5VSS5ub2Rlcy5ob2xkZXIsIFwicGFzdGVcIiwgdGhpcy5oYW5kbGVQYXN0ZUV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFuZCBwcm9jZXNzIHRvb2xgcyBwYXN0ZSBjb25maWdzXG4gICAqL1xuICBwcm9jZXNzVG9vbHMoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHM7XG4gICAgQXJyYXkuZnJvbShzLnZhbHVlcygpKS5mb3JFYWNoKHRoaXMucHJvY2Vzc1Rvb2wpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGFncyBuYW1lIGxpc3QgZnJvbSBlaXRoZXIgdGFnIG5hbWUgb3Igc2FuaXRpemF0aW9uIGNvbmZpZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBvYmplY3R9IHRhZ09yU2FuaXRpemVDb25maWcgLSB0YWcgbmFtZSBvciBzYW5pdGl6ZSBjb25maWcgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119IGFycmF5IG9mIHRhZ3MuXG4gICAqL1xuICBjb2xsZWN0VGFnTmFtZXMocykge1xuICAgIHJldHVybiBHKHMpID8gW3NdIDogRChzKSA/IE9iamVjdC5rZXlzKHMpIDogW107XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0YWdzIHRvIHN1YnN0aXR1dGUgYnkgVG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIEJsb2NrVG9vbCBvYmplY3RcbiAgICovXG4gIGdldFRhZ3NDb25maWcocykge1xuICAgIGlmIChzLnBhc3RlQ29uZmlnID09PSAhMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gcy5wYXN0ZUNvbmZpZy50YWdzIHx8IFtdLCB0ID0gW107XG4gICAgZS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5jb2xsZWN0VGFnTmFtZXMobyk7XG4gICAgICB0LnB1c2goLi4uaSksIGkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMudG9vbHNUYWdzLCBuKSkge1xuICAgICAgICAgIFQoXG4gICAgICAgICAgICBgUGFzdGUgaGFuZGxlciBmb3Igwqske3MubmFtZX3CuyBUb29sIG9uIMKrJHtufcK7IHRhZyBpcyBza2lwcGVkIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSB1c2VkIGJ5IMKrJHt0aGlzLnRvb2xzVGFnc1tuXS50b29sLm5hbWV9wrsgVG9vbC5gLFxuICAgICAgICAgICAgXCJ3YXJuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gRChvKSA/IG9bbl0gOiBudWxsO1xuICAgICAgICB0aGlzLnRvb2xzVGFnc1tuLnRvVXBwZXJDYXNlKCldID0ge1xuICAgICAgICAgIHRvb2w6IHMsXG4gICAgICAgICAgc2FuaXRpemF0aW9uQ29uZmlnOiByXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy50YWdzQnlUb29sW3MubmFtZV0gPSB0Lm1hcCgobykgPT4gby50b1VwcGVyQ2FzZSgpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGZpbGVzYCB0eXBlcyBhbmQgZXh0ZW5zaW9ucyB0byBzdWJzdGl0dXRlIGJ5IFRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2wgLSBCbG9ja1Rvb2wgb2JqZWN0XG4gICAqL1xuICBnZXRGaWxlc0NvbmZpZyhzKSB7XG4gICAgaWYgKHMucGFzdGVDb25maWcgPT09ICExKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZmlsZXM6IGUgPSB7fSB9ID0gcy5wYXN0ZUNvbmZpZztcbiAgICBsZXQgeyBleHRlbnNpb25zOiB0LCBtaW1lVHlwZXM6IG8gfSA9IGU7XG4gICAgIXQgJiYgIW8gfHwgKHQgJiYgIUFycmF5LmlzQXJyYXkodCkgJiYgKFQoYMKrZXh0ZW5zaW9uc8K7IHByb3BlcnR5IG9mIHRoZSBvbkRyb3AgY29uZmlnIGZvciDCqyR7cy5uYW1lfcK7IFRvb2wgc2hvdWxkIGJlIGFuIGFycmF5YCksIHQgPSBbXSksIG8gJiYgIUFycmF5LmlzQXJyYXkobykgJiYgKFQoYMKrbWltZVR5cGVzwrsgcHJvcGVydHkgb2YgdGhlIG9uRHJvcCBjb25maWcgZm9yIMKrJHtzLm5hbWV9wrsgVG9vbCBzaG91bGQgYmUgYW4gYXJyYXlgKSwgbyA9IFtdKSwgbyAmJiAobyA9IG8uZmlsdGVyKChpKSA9PiBqdChpKSA/ICEwIDogKFQoYE1JTUUgdHlwZSB2YWx1ZSDCqyR7aX3CuyBmb3IgdGhlIMKrJHtzLm5hbWV9wrsgVG9vbCBpcyBub3QgYSB2YWxpZCBNSU1FIHR5cGVgLCBcIndhcm5cIiksICExKSkpLCB0aGlzLnRvb2xzRmlsZXNbcy5uYW1lXSA9IHtcbiAgICAgIGV4dGVuc2lvbnM6IHQgfHwgW10sXG4gICAgICBtaW1lVHlwZXM6IG8gfHwgW11cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IFJlZ0V4cCBwYXR0ZXJucyB0byBzdWJzdGl0dXRlIGJ5IFRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2wgLSBCbG9ja1Rvb2wgb2JqZWN0XG4gICAqL1xuICBnZXRQYXR0ZXJuc0NvbmZpZyhzKSB7XG4gICAgcy5wYXN0ZUNvbmZpZyA9PT0gITEgfHwgIXMucGFzdGVDb25maWcucGF0dGVybnMgfHwgVyhzLnBhc3RlQ29uZmlnLnBhdHRlcm5zKSB8fCBPYmplY3QuZW50cmllcyhzLnBhc3RlQ29uZmlnLnBhdHRlcm5zKS5mb3JFYWNoKChbZSwgdF0pID0+IHtcbiAgICAgIHQgaW5zdGFuY2VvZiBSZWdFeHAgfHwgVChcbiAgICAgICAgYFBhdHRlcm4gJHt0fSBmb3Igwqske3MubmFtZX3CuyBUb29sIGlzIHNraXBwZWQgYmVjYXVzZSBpdCBzaG91bGQgYmUgYSBSZWdleHAgaW5zdGFuY2UuYCxcbiAgICAgICAgXCJ3YXJuXCJcbiAgICAgICksIHRoaXMudG9vbHNQYXR0ZXJucy5wdXNoKHtcbiAgICAgICAga2V5OiBlLFxuICAgICAgICBwYXR0ZXJuOiB0LFxuICAgICAgICB0b29sOiBzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYnJvd3NlciBiZWhhdmlvciBzdWl0cyBiZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIGVsZW1lbnQgd2hlcmUgY29udGVudCBoYXMgYmVlbiBwYXN0ZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc05hdGl2ZUJlaGF2aW91cihzKSB7XG4gICAgcmV0dXJuIGMuaXNOYXRpdmVJbnB1dChzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGZpbGVzIGZyb20gZGF0YSB0cmFuc2ZlciBvYmplY3QgYW5kIGluc2VydCByZWxhdGVkIFRvb2xzXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZUxpc3R9IGl0ZW1zIC0gcGFzdGVkIG9yIGRyb3BwZWQgaXRlbXNcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NGaWxlcyhzKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGUgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGxldCB0O1xuICAgIHQgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIEFycmF5LmZyb20ocykubWFwKChuKSA9PiB0aGlzLnByb2Nlc3NGaWxlKG4pKVxuICAgICksIHQgPSB0LmZpbHRlcigobikgPT4gISFuKTtcbiAgICBjb25zdCBpID0gZS5jdXJyZW50QmxvY2sudG9vbC5pc0RlZmF1bHQgJiYgZS5jdXJyZW50QmxvY2suaXNFbXB0eTtcbiAgICB0LmZvckVhY2goXG4gICAgICAobiwgcikgPT4ge1xuICAgICAgICBlLnBhc3RlKG4udHlwZSwgbi5ldmVudCwgciA9PT0gMCAmJiBpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgZmlsZSBhbmQgZmluZCBUb29sIHRvIGhhbmRsZSBpdFxuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgLSBmaWxlIHRvIHByb2Nlc3NcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NGaWxlKHMpIHtcbiAgICBjb25zdCBlID0gVXQocyksIHQgPSBPYmplY3QuZW50cmllcyh0aGlzLnRvb2xzRmlsZXMpLmZpbmQoKFtuLCB7IG1pbWVUeXBlczogciwgZXh0ZW5zaW9uczogYSB9XSkgPT4ge1xuICAgICAgY29uc3QgW2wsIGRdID0gcy50eXBlLnNwbGl0KFwiL1wiKSwgdSA9IGEuZmluZCgoZikgPT4gZi50b0xvd2VyQ2FzZSgpID09PSBlLnRvTG93ZXJDYXNlKCkpLCBoID0gci5maW5kKChmKSA9PiB7XG4gICAgICAgIGNvbnN0IFt4LCBwXSA9IGYuc3BsaXQoXCIvXCIpO1xuICAgICAgICByZXR1cm4geCA9PT0gbCAmJiAocCA9PT0gZCB8fCBwID09PSBcIipcIik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXUgfHwgISFoO1xuICAgIH0pO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbb10gPSB0O1xuICAgIHJldHVybiB7XG4gICAgICBldmVudDogdGhpcy5jb21wb3NlUGFzdGVFdmVudChcImZpbGVcIiwge1xuICAgICAgICBmaWxlOiBzXG4gICAgICB9KSxcbiAgICAgIHR5cGU6IG9cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdCBIVE1MIHN0cmluZyB0byBibG9ja3MgYW5kIHJldHVybiBpdCBhcyBhcnJheSBvZiBCbG9jayBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbm5lckhUTUwgLSBodG1sIHN0cmluZyB0byBwcm9jZXNzXG4gICAqIEByZXR1cm5zIHtQYXN0ZURhdGFbXX1cbiAgICovXG4gIHByb2Nlc3NIVE1MKHMpIHtcbiAgICBjb25zdCB7IFRvb2xzOiBlIH0gPSB0aGlzLkVkaXRvciwgdCA9IGMubWFrZShcIkRJVlwiKTtcbiAgICByZXR1cm4gdC5pbm5lckhUTUwgPSBzLCB0aGlzLmdldE5vZGVzKHQpLm1hcCgoaSkgPT4ge1xuICAgICAgbGV0IG4sIHIgPSBlLmRlZmF1bHRUb29sLCBhID0gITE7XG4gICAgICBzd2l0Y2ggKGkubm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgICAgbiA9IGMubWFrZShcImRpdlwiKSwgbi5hcHBlbmRDaGlsZChpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpcbiAgICAgICAgICBuID0gaSwgYSA9ICEwLCB0aGlzLnRvb2xzVGFnc1tuLnRhZ05hbWVdICYmIChyID0gdGhpcy50b29sc1RhZ3Nbbi50YWdOYW1lXS50b29sKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdGFnczogbCB9ID0gci5wYXN0ZUNvbmZpZyB8fCB7IHRhZ3M6IFtdIH0sIGQgPSBsLnJlZHVjZSgoZiwgeCkgPT4gKHRoaXMuY29sbGVjdFRhZ05hbWVzKHgpLmZvckVhY2goKG0pID0+IHtcbiAgICAgICAgY29uc3QgTCA9IEQoeCkgPyB4W21dIDogbnVsbDtcbiAgICAgICAgZlttLnRvTG93ZXJDYXNlKCldID0gTCB8fCB7fTtcbiAgICAgIH0pLCBmKSwge30pLCB1ID0gT2JqZWN0LmFzc2lnbih7fSwgZCwgci5iYXNlU2FuaXRpemVDb25maWcpO1xuICAgICAgaWYgKG4udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInRhYmxlXCIpIHtcbiAgICAgICAgY29uc3QgZiA9IFYobi5vdXRlckhUTUwsIHUpO1xuICAgICAgICBuID0gYy5tYWtlKFwiZGl2XCIsIHZvaWQgMCwge1xuICAgICAgICAgIGlubmVySFRNTDogZlxuICAgICAgICB9KS5maXJzdENoaWxkO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG4uaW5uZXJIVE1MID0gVihuLmlubmVySFRNTCwgdSk7XG4gICAgICBjb25zdCBoID0gdGhpcy5jb21wb3NlUGFzdGVFdmVudChcInRhZ1wiLCB7XG4gICAgICAgIGRhdGE6IG5cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogbixcbiAgICAgICAgaXNCbG9jazogYSxcbiAgICAgICAgdG9vbDogci5uYW1lLFxuICAgICAgICBldmVudDogaFxuICAgICAgfTtcbiAgICB9KS5maWx0ZXIoKGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBjLmlzRW1wdHkoaS5jb250ZW50KSwgciA9IGMuaXNTaW5nbGVUYWcoaS5jb250ZW50KTtcbiAgICAgIHJldHVybiAhbiB8fCByO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdCBwbGFpbiB0ZXh0IGJ5IG5ldyBsaW5lIHN5bWJvbHMgYW5kIHJldHVybiBpdCBhcyBhcnJheSBvZiBCbG9jayBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwbGFpbiAtIHN0cmluZyB0byBwcm9jZXNzXG4gICAqIEByZXR1cm5zIHtQYXN0ZURhdGFbXX1cbiAgICovXG4gIHByb2Nlc3NQbGFpbihzKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0QmxvY2s6IGUgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB0ID0gZTtcbiAgICByZXR1cm4gcy5zcGxpdCgvXFxyP1xcbi8pLmZpbHRlcigobykgPT4gby50cmltKCkpLm1hcCgobykgPT4ge1xuICAgICAgY29uc3QgaSA9IGMubWFrZShcImRpdlwiKTtcbiAgICAgIGkudGV4dENvbnRlbnQgPSBvO1xuICAgICAgY29uc3QgbiA9IHRoaXMuY29tcG9zZVBhc3RlRXZlbnQoXCJ0YWdcIiwge1xuICAgICAgICBkYXRhOiBpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IGksXG4gICAgICAgIHRvb2w6IHQsXG4gICAgICAgIGlzQmxvY2s6ICExLFxuICAgICAgICBldmVudDogblxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBwYXN0ZSBvZiBzaW5nbGUgQmxvY2sgdG9vbCBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7UGFzdGVEYXRhfSBkYXRhVG9JbnNlcnQgLSBkYXRhIG9mIEJsb2NrIHRvIGluc2VydFxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc1NpbmdsZUJsb2NrKHMpIHtcbiAgICBjb25zdCB7IENhcmV0OiBlLCBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yLCB7IGN1cnJlbnRCbG9jazogbyB9ID0gdDtcbiAgICBpZiAoIW8gfHwgcy50b29sICE9PSBvLm5hbWUgfHwgIWMuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMocy5jb250ZW50LmlubmVySFRNTCkpIHtcbiAgICAgIHRoaXMuaW5zZXJ0QmxvY2socywgKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8udG9vbC5pc0RlZmF1bHQpICYmIG8uaXNFbXB0eSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuaW5zZXJ0Q29udGVudEF0Q2FyZXRQb3NpdGlvbihzLmNvbnRlbnQuaW5uZXJIVE1MKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBwYXN0ZSB0byBzaW5nbGUgQmxvY2s6XG4gICAqIDEuIEZpbmQgcGF0dGVybnNgIG1hdGNoZXNcbiAgICogMi4gSW5zZXJ0IG5ldyBibG9jayBpZiBpdCBpcyBub3QgdGhlIHNhbWUgdHlwZSBhcyBjdXJyZW50IG9uZVxuICAgKiAzLiBKdXN0IGluc2VydCB0ZXh0IGlmIHRoZXJlIGlzIG5vIHN1YnN0aXR1dGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtQYXN0ZURhdGF9IGRhdGFUb0luc2VydCAtIGRhdGEgb2YgQmxvY2sgdG8gaW5zZXJ0XG4gICAqL1xuICBhc3luYyBwcm9jZXNzSW5saW5lUGFzdGUocykge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBlLCBDYXJldDogdCB9ID0gdGhpcy5FZGl0b3IsIHsgY29udGVudDogbyB9ID0gcztcbiAgICBpZiAoZS5jdXJyZW50QmxvY2sgJiYgZS5jdXJyZW50QmxvY2sudG9vbC5pc0RlZmF1bHQgJiYgby50ZXh0Q29udGVudC5sZW5ndGggPCBDdC5QQVRURVJOX1BST0NFU1NJTkdfTUFYX0xFTkdUSCkge1xuICAgICAgY29uc3QgbiA9IGF3YWl0IHRoaXMucHJvY2Vzc1BhdHRlcm4oby50ZXh0Q29udGVudCk7XG4gICAgICBpZiAobikge1xuICAgICAgICBjb25zdCByID0gZS5jdXJyZW50QmxvY2sgJiYgZS5jdXJyZW50QmxvY2sudG9vbC5pc0RlZmF1bHQgJiYgZS5jdXJyZW50QmxvY2suaXNFbXB0eSwgYSA9IGUucGFzdGUobi50b29sLCBuLmV2ZW50LCByKTtcbiAgICAgICAgdC5zZXRUb0Jsb2NrKGEsIHQucG9zaXRpb25zLkVORCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGUuY3VycmVudEJsb2NrICYmIGUuY3VycmVudEJsb2NrLmN1cnJlbnRJbnB1dCkge1xuICAgICAgY29uc3QgbiA9IGUuY3VycmVudEJsb2NrLnRvb2wuYmFzZVNhbml0aXplQ29uZmlnO1xuICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXG4gICAgICAgIFwiaW5zZXJ0SFRNTFwiLFxuICAgICAgICAhMSxcbiAgICAgICAgVihvLmlubmVySFRNTCwgbilcbiAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmluc2VydEJsb2NrKHMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgcGF0dGVybnNgIG1hdGNoZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHByb2Nlc3NcbiAgICogQHJldHVybnMge1Byb21pc2U8e2V2ZW50OiBQYXN0ZUV2ZW50LCB0b29sOiBzdHJpbmd9Pn1cbiAgICovXG4gIGFzeW5jIHByb2Nlc3NQYXR0ZXJuKHMpIHtcbiAgICBjb25zdCBlID0gdGhpcy50b29sc1BhdHRlcm5zLmZpbmQoKG8pID0+IHtcbiAgICAgIGNvbnN0IGkgPSBvLnBhdHRlcm4uZXhlYyhzKTtcbiAgICAgIHJldHVybiBpID8gcyA9PT0gaS5zaGlmdCgpIDogITE7XG4gICAgfSk7XG4gICAgcmV0dXJuIGUgPyB7XG4gICAgICBldmVudDogdGhpcy5jb21wb3NlUGFzdGVFdmVudChcInBhdHRlcm5cIiwge1xuICAgICAgICBrZXk6IGUua2V5LFxuICAgICAgICBkYXRhOiBzXG4gICAgICB9KSxcbiAgICAgIHRvb2w6IGUudG9vbC5uYW1lXG4gICAgfSA6IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHBhc3RlZCBCbG9jayBjb250ZW50IHRvIEVkaXRvclxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRGF0YX0gZGF0YSAtIGRhdGEgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuUmVwbGFjZUN1cnJlbnRCbG9jayAtIGlmIHRydWUgYW5kIGlzIGN1cnJlbnQgQmxvY2sgaXMgZW1wdHksIHdpbGwgcmVwbGFjZSBjdXJyZW50IEJsb2NrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgaW5zZXJ0QmxvY2socywgZSA9ICExKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIENhcmV0OiBvIH0gPSB0aGlzLkVkaXRvciwgeyBjdXJyZW50QmxvY2s6IGkgfSA9IHQ7XG4gICAgbGV0IG47XG4gICAgaWYgKGUgJiYgaSAmJiBpLmlzRW1wdHkpIHtcbiAgICAgIG4gPSB0LnBhc3RlKHMudG9vbCwgcy5ldmVudCwgITApLCBvLnNldFRvQmxvY2sobiwgby5wb3NpdGlvbnMuRU5EKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbiA9IHQucGFzdGUocy50b29sLCBzLmV2ZW50KSwgby5zZXRUb0Jsb2NrKG4sIG8ucG9zaXRpb25zLkVORCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBkYXRhIHBhc3NlZCBhcyBhcHBsaWNhdGlvbi94LWVkaXRvci1qcyBKU09OXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJsb2NrcyDigJQgQmxvY2tzJyBkYXRhIHRvIGluc2VydFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGluc2VydEVkaXRvckpTRGF0YShzKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGUsIENhcmV0OiB0LCBUb29sczogbyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgYnQoXG4gICAgICBzLFxuICAgICAgKG4pID0+IG8uYmxvY2tUb29scy5nZXQobikuc2FuaXRpemVDb25maWdcbiAgICApLmZvckVhY2goKHsgdG9vbDogbiwgZGF0YTogciB9LCBhKSA9PiB7XG4gICAgICBsZXQgbCA9ICExO1xuICAgICAgYSA9PT0gMCAmJiAobCA9IGUuY3VycmVudEJsb2NrICYmIGUuY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIGUuY3VycmVudEJsb2NrLmlzRW1wdHkpO1xuICAgICAgY29uc3QgZCA9IGUuaW5zZXJ0KHtcbiAgICAgICAgdG9vbDogbixcbiAgICAgICAgZGF0YTogcixcbiAgICAgICAgcmVwbGFjZTogbFxuICAgICAgfSk7XG4gICAgICB0LnNldFRvQmxvY2soZCwgdC5wb3NpdGlvbnMuRU5EKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggbm9kZXMgZnJvbSBFbGVtZW50IG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gY3VycmVudCBub2RlXG4gICAqIEBwYXJhbSB7Tm9kZVtdfSBub2RlcyAtIHByb2Nlc3NlZCBub2Rlc1xuICAgKiBAcGFyYW0ge05vZGV9IGRlc3ROb2RlIC0gZGVzdGluYXRpb24gbm9kZVxuICAgKi9cbiAgcHJvY2Vzc0VsZW1lbnROb2RlKHMsIGUsIHQpIHtcbiAgICBjb25zdCBvID0gT2JqZWN0LmtleXModGhpcy50b29sc1RhZ3MpLCBpID0gcywgeyB0b29sOiBuIH0gPSB0aGlzLnRvb2xzVGFnc1tpLnRhZ05hbWVdIHx8IHt9LCByID0gdGhpcy50YWdzQnlUb29sW24gPT0gbnVsbCA/IHZvaWQgMCA6IG4ubmFtZV0gfHwgW10sIGEgPSBvLmluY2x1ZGVzKGkudGFnTmFtZSksIGwgPSBjLmJsb2NrRWxlbWVudHMuaW5jbHVkZXMoaS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpLCBkID0gQXJyYXkuZnJvbShpLmNoaWxkcmVuKS5zb21lKFxuICAgICAgKHsgdGFnTmFtZTogaCB9KSA9PiBvLmluY2x1ZGVzKGgpICYmICFyLmluY2x1ZGVzKGgpXG4gICAgKSwgdSA9IEFycmF5LmZyb20oaS5jaGlsZHJlbikuc29tZShcbiAgICAgICh7IHRhZ05hbWU6IGggfSkgPT4gYy5ibG9ja0VsZW1lbnRzLmluY2x1ZGVzKGgudG9Mb3dlckNhc2UoKSlcbiAgICApO1xuICAgIGlmICghbCAmJiAhYSAmJiAhZClcbiAgICAgIHJldHVybiB0LmFwcGVuZENoaWxkKGkpLCBbLi4uZSwgdF07XG4gICAgaWYgKGEgJiYgIWQgfHwgbCAmJiAhdSAmJiAhZClcbiAgICAgIHJldHVybiBbLi4uZSwgdCwgaV07XG4gIH1cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGRpdmlkZSBIVE1MIHN0cmluZyB0byB0d28gdHlwZXMgb2Ygbm9kZXM6XG4gICAqIDEuIEJsb2NrIGVsZW1lbnRcbiAgICogMi4gRG9jdW1lbnQgRnJhZ21lbnRzIGNvbnRhaW5lZCB0ZXh0IGFuZCBtYXJrdXAgdGFncyBsaWtlIGEsIGIsIGkgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHdyYXBwZXIgLSB3cmFwcGVyIG9mIHBhc3RlciBIVE1MIGNvbnRlbnRcbiAgICogQHJldHVybnMge05vZGVbXX1cbiAgICovXG4gIGdldE5vZGVzKHMpIHtcbiAgICBjb25zdCBlID0gQXJyYXkuZnJvbShzLmNoaWxkTm9kZXMpO1xuICAgIGxldCB0O1xuICAgIGNvbnN0IG8gPSAoaSwgbikgPT4ge1xuICAgICAgaWYgKGMuaXNFbXB0eShuKSAmJiAhYy5pc1NpbmdsZVRhZyhuKSlcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICBjb25zdCByID0gaVtpLmxlbmd0aCAtIDFdO1xuICAgICAgbGV0IGEgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgc3dpdGNoIChyICYmIGMuaXNGcmFnbWVudChyKSAmJiAoYSA9IGkucG9wKCkpLCBuLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgICAgICAgaWYgKHQgPSB0aGlzLnByb2Nlc3NFbGVtZW50Tm9kZShuLCBpLCBhKSwgdClcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOlxuICAgICAgICAgIHJldHVybiBhLmFwcGVuZENoaWxkKG4pLCBbLi4uaSwgYV07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFsuLi5pLCBhXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbLi4uaSwgLi4uQXJyYXkuZnJvbShuLmNoaWxkTm9kZXMpLnJlZHVjZShvLCBbXSldO1xuICAgIH07XG4gICAgcmV0dXJuIGUucmVkdWNlKG8sIFtdKTtcbiAgfVxuICAvKipcbiAgICogQ29tcG9zZSBwYXN0ZSBldmVudCB3aXRoIHBhc3NlZCB0eXBlIGFuZCBkZXRhaWxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7UGFzdGVFdmVudERldGFpbH0gZGV0YWlsIC0gZXZlbnQgZGV0YWlsXG4gICAqL1xuICBjb21wb3NlUGFzdGVFdmVudChzLCBlKSB7XG4gICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChzLCB7XG4gICAgICBkZXRhaWw6IGVcbiAgICB9KTtcbiAgfVxufTtcbmxldCBUdCA9IEN0O1xuVHQuUEFUVEVSTl9QUk9DRVNTSU5HX01BWF9MRU5HVEggPSA0NTA7XG5jbGFzcyBsaSBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnRvb2xzRG9udFN1cHBvcnRSZWFkT25seSA9IFtdLCB0aGlzLnJlYWRPbmx5RW5hYmxlZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0YXRlIG9mIHJlYWQgb25seSBtb2RlXG4gICAqL1xuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRPbmx5RW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogU2V0IGluaXRpYWwgc3RhdGVcbiAgICovXG4gIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgY29uc3QgeyBUb29sczogZSB9ID0gdGhpcy5FZGl0b3IsIHsgYmxvY2tUb29sczogdCB9ID0gZSwgbyA9IFtdO1xuICAgIEFycmF5LmZyb20odC5lbnRyaWVzKCkpLmZvckVhY2goKFtpLCBuXSkgPT4ge1xuICAgICAgbi5pc1JlYWRPbmx5U3VwcG9ydGVkIHx8IG8ucHVzaChpKTtcbiAgICB9KSwgdGhpcy50b29sc0RvbnRTdXBwb3J0UmVhZE9ubHkgPSBvLCB0aGlzLmNvbmZpZy5yZWFkT25seSAmJiBvLmxlbmd0aCA+IDAgJiYgdGhpcy50aHJvd0NyaXRpY2FsRXJyb3IoKSwgdGhpcy50b2dnbGUodGhpcy5jb25maWcucmVhZE9ubHkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgcmVhZC1vbmx5IG1vZGUgb3IgdG9nZ2xlIGN1cnJlbnQgc3RhdGVcbiAgICogQ2FsbCBhbGwgTW9kdWxlcyBgdG9nZ2xlUmVhZE9ubHlgIG1ldGhvZCBhbmQgcmUtcmVuZGVyIEVkaXRvclxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIC0gKG9wdGlvbmFsKSByZWFkLW9ubHkgc3RhdGUgb3IgdG9nZ2xlXG4gICAqL1xuICBhc3luYyB0b2dnbGUoZSA9ICF0aGlzLnJlYWRPbmx5RW5hYmxlZCkge1xuICAgIGUgJiYgdGhpcy50b29sc0RvbnRTdXBwb3J0UmVhZE9ubHkubGVuZ3RoID4gMCAmJiB0aGlzLnRocm93Q3JpdGljYWxFcnJvcigpO1xuICAgIGNvbnN0IHQgPSB0aGlzLnJlYWRPbmx5RW5hYmxlZDtcbiAgICB0aGlzLnJlYWRPbmx5RW5hYmxlZCA9IGU7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuRWRpdG9yKVxuICAgICAgdGhpcy5FZGl0b3JbaV0udG9nZ2xlUmVhZE9ubHkgJiYgdGhpcy5FZGl0b3JbaV0udG9nZ2xlUmVhZE9ubHkoZSk7XG4gICAgaWYgKHQgPT09IGUpXG4gICAgICByZXR1cm4gdGhpcy5yZWFkT25seUVuYWJsZWQ7XG4gICAgY29uc3QgbyA9IGF3YWl0IHRoaXMuRWRpdG9yLlNhdmVyLnNhdmUoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmNsZWFyKCksIGF3YWl0IHRoaXMuRWRpdG9yLlJlbmRlcmVyLnJlbmRlcihvLmJsb2NrcyksIHRoaXMucmVhZE9ubHlFbmFibGVkO1xuICB9XG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgYWJvdXQgdG9vbHMgd2hpY2ggZG9uJ3Qgc3VwcG9ydCByZWFkLW9ubHkgbW9kZVxuICAgKi9cbiAgdGhyb3dDcml0aWNhbEVycm9yKCkge1xuICAgIHRocm93IG5ldyB1dChcbiAgICAgIGBUbyBlbmFibGUgcmVhZC1vbmx5IG1vZGUgYWxsIGNvbm5lY3RlZCB0b29scyBzaG91bGQgc3VwcG9ydCBpdC4gVG9vbHMgJHt0aGlzLnRvb2xzRG9udFN1cHBvcnRSZWFkT25seS5qb2luKFwiLCBcIil9IGRvbid0IHN1cHBvcnQgcmVhZC1vbmx5IG1vZGUuYFxuICAgICk7XG4gIH1cbn1cbmNsYXNzIGZlIGV4dGVuZHMgeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuaXNSZWN0U2VsZWN0aW9uQWN0aXZhdGVkID0gITEsIHRoaXMuU0NST0xMX1NQRUVEID0gMywgdGhpcy5IRUlHSFRfT0ZfU0NST0xMX1pPTkUgPSA0MCwgdGhpcy5CT1RUT01fU0NST0xMX1pPTkUgPSAxLCB0aGlzLlRPUF9TQ1JPTExfWk9ORSA9IDIsIHRoaXMuTUFJTl9NT1VTRV9CVVRUT04gPSAwLCB0aGlzLm1vdXNlZG93biA9ICExLCB0aGlzLmlzU2Nyb2xsaW5nID0gITEsIHRoaXMuaW5TY3JvbGxab25lID0gbnVsbCwgdGhpcy5zdGFydFggPSAwLCB0aGlzLnN0YXJ0WSA9IDAsIHRoaXMubW91c2VYID0gMCwgdGhpcy5tb3VzZVkgPSAwLCB0aGlzLnN0YWNrT2ZTZWxlY3RlZCA9IFtdLCB0aGlzLmxpc3RlbmVySWRzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIENTUyBjbGFzc2VzIGZvciB0aGUgQmxvY2tcbiAgICpcbiAgICogQHJldHVybnMge3t3cmFwcGVyOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3ZlcmxheTogXCJjb2RleC1lZGl0b3Itb3ZlcmxheVwiLFxuICAgICAgb3ZlcmxheUNvbnRhaW5lcjogXCJjb2RleC1lZGl0b3Itb3ZlcmxheV9fY29udGFpbmVyXCIsXG4gICAgICByZWN0OiBcImNvZGV4LWVkaXRvci1vdmVybGF5X19yZWN0YW5nbGVcIixcbiAgICAgIHRvcFNjcm9sbFpvbmU6IFwiY29kZXgtZWRpdG9yLW92ZXJsYXlfX3Njcm9sbC16b25lLS10b3BcIixcbiAgICAgIGJvdHRvbVNjcm9sbFpvbmU6IFwiY29kZXgtZWRpdG9yLW92ZXJsYXlfX3Njcm9sbC16b25lLS1ib3R0b21cIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBQcmVwYXJhdGlvblxuICAgKiBDcmVhdGluZyByZWN0IGFuZCBoYW5nIGhhbmRsZXJzXG4gICAqL1xuICBwcmVwYXJlKCkge1xuICAgIHRoaXMuZW5hYmxlTW9kdWxlQmluZGluZ3MoKTtcbiAgfVxuICAvKipcbiAgICogSW5pdCByZWN0IHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZVggLSBYIGNvb3JkIG9mIG1vdXNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlWSAtIFkgY29vcmQgb2YgbW91c2VcbiAgICovXG4gIHN0YXJ0U2VsZWN0aW9uKGUsIHQpIHtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlIC0gd2luZG93LnBhZ2VYT2Zmc2V0LCB0IC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICBvLmNsb3Nlc3QoYC4ke3RoaXMuRWRpdG9yLlRvb2xiYXIuQ1NTLnRvb2xiYXJ9YCkgfHwgKHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmFsbEJsb2Nrc1NlbGVjdGVkID0gITEsIHRoaXMuY2xlYXJTZWxlY3Rpb24oKSwgdGhpcy5zdGFja09mU2VsZWN0ZWQgPSBbXSk7XG4gICAgY29uc3QgbiA9IFtcbiAgICAgIGAuJHtSLkNTUy5jb250ZW50fWAsXG4gICAgICBgLiR7dGhpcy5FZGl0b3IuVG9vbGJhci5DU1MudG9vbGJhcn1gLFxuICAgICAgYC4ke3RoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuQ1NTLmlubGluZVRvb2xiYXJ9YFxuICAgIF0sIHIgPSBvLmNsb3Nlc3QoXCIuXCIgKyB0aGlzLkVkaXRvci5VSS5DU1MuZWRpdG9yV3JhcHBlciksIGEgPSBuLnNvbWUoKGwpID0+ICEhby5jbG9zZXN0KGwpKTtcbiAgICAhciB8fCBhIHx8ICh0aGlzLm1vdXNlZG93biA9ICEwLCB0aGlzLnN0YXJ0WCA9IGUsIHRoaXMuc3RhcnRZID0gdCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBwYXJhbXMgdG8gZW5kIHNlbGVjdGlvblxuICAgKi9cbiAgZW5kU2VsZWN0aW9uKCkge1xuICAgIHRoaXMubW91c2Vkb3duID0gITEsIHRoaXMuc3RhcnRYID0gMCwgdGhpcy5zdGFydFkgPSAwLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICB9XG4gIC8qKlxuICAgKiBpcyBSZWN0U2VsZWN0aW9uIEFjdGl2YXRlZFxuICAgKi9cbiAgaXNSZWN0QWN0aXZhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzUmVjdFNlbGVjdGlvbkFjdGl2YXRlZDtcbiAgfVxuICAvKipcbiAgICogTWFyayB0aGF0IHNlbGVjdGlvbiBpcyBlbmRcbiAgICovXG4gIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgIHRoaXMuaXNSZWN0U2VsZWN0aW9uQWN0aXZhdGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgTW9kdWxlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVyc1xuICAgKi9cbiAgZW5hYmxlTW9kdWxlQmluZGluZ3MoKSB7XG4gICAgY29uc3QgeyBjb250YWluZXI6IGUgfSA9IHRoaXMuZ2VuSFRNTCgpO1xuICAgIHRoaXMubGlzdGVuZXJzLm9uKGUsIFwibW91c2Vkb3duXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NNb3VzZURvd24odCk7XG4gICAgfSwgITEpLCB0aGlzLmxpc3RlbmVycy5vbihkb2N1bWVudC5ib2R5LCBcIm1vdXNlbW92ZVwiLCBJZSgodCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzTW91c2VNb3ZlKHQpO1xuICAgIH0sIDEwKSwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQuYm9keSwgXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc01vdXNlTGVhdmUoKTtcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24od2luZG93LCBcInNjcm9sbFwiLCBJZSgodCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzU2Nyb2xsKHQpO1xuICAgIH0sIDEwKSwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQuYm9keSwgXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc01vdXNlVXAoKTtcbiAgICB9LCAhMSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBkb3duIGV2ZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBldmVudCBwYXlsb2FkXG4gICAqL1xuICBwcm9jZXNzTW91c2VEb3duKGUpIHtcbiAgICBpZiAoZS5idXR0b24gIT09IHRoaXMuTUFJTl9NT1VTRV9CVVRUT04pXG4gICAgICByZXR1cm47XG4gICAgZS50YXJnZXQuY2xvc2VzdChjLmFsbElucHV0c1NlbGVjdG9yKSAhPT0gbnVsbCB8fCB0aGlzLnN0YXJ0U2VsZWN0aW9uKGUucGFnZVgsIGUucGFnZVkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgbW92ZSBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgZXZlbnQgcGF5bG9hZFxuICAgKi9cbiAgcHJvY2Vzc01vdXNlTW92ZShlKSB7XG4gICAgdGhpcy5jaGFuZ2luZ1JlY3RhbmdsZShlKSwgdGhpcy5zY3JvbGxCeVpvbmVzKGUuY2xpZW50WSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBsZWF2ZVxuICAgKi9cbiAgcHJvY2Vzc01vdXNlTGVhdmUoKSB7XG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpLCB0aGlzLmVuZFNlbGVjdGlvbigpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBldmVudCBwYXlsb2FkXG4gICAqL1xuICBwcm9jZXNzU2Nyb2xsKGUpIHtcbiAgICB0aGlzLmNoYW5naW5nUmVjdGFuZ2xlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgdXBcbiAgICovXG4gIHByb2Nlc3NNb3VzZVVwKCkge1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKSwgdGhpcy5lbmRTZWxlY3Rpb24oKTtcbiAgfVxuICAvKipcbiAgICogU2Nyb2xsIElmIG1vdXNlIGluIHNjcm9sbCB6b25lXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRZIC0gWSBjb29yZCBvZiBtb3VzZVxuICAgKi9cbiAgc2Nyb2xsQnlab25lcyhlKSB7XG4gICAgaWYgKHRoaXMuaW5TY3JvbGxab25lID0gbnVsbCwgZSA8PSB0aGlzLkhFSUdIVF9PRl9TQ1JPTExfWk9ORSAmJiAodGhpcy5pblNjcm9sbFpvbmUgPSB0aGlzLlRPUF9TQ1JPTExfWk9ORSksIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgLSBlIDw9IHRoaXMuSEVJR0hUX09GX1NDUk9MTF9aT05FICYmICh0aGlzLmluU2Nyb2xsWm9uZSA9IHRoaXMuQk9UVE9NX1NDUk9MTF9aT05FKSwgIXRoaXMuaW5TY3JvbGxab25lKSB7XG4gICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gITE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNTY3JvbGxpbmcgfHwgKHRoaXMuc2Nyb2xsVmVydGljYWwodGhpcy5pblNjcm9sbFpvbmUgPT09IHRoaXMuVE9QX1NDUk9MTF9aT05FID8gLXRoaXMuU0NST0xMX1NQRUVEIDogdGhpcy5TQ1JPTExfU1BFRUQpLCB0aGlzLmlzU2Nyb2xsaW5nID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcmVxdWlyZWQgSFRNTCBlbGVtZW50c1xuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0PHN0cmluZywgRWxlbWVudD59XG4gICAqL1xuICBnZW5IVE1MKCkge1xuICAgIGNvbnN0IHsgVUk6IGUgfSA9IHRoaXMuRWRpdG9yLCB0ID0gZS5ub2Rlcy5ob2xkZXIucXVlcnlTZWxlY3RvcihcIi5cIiArIGUuQ1NTLmVkaXRvcldyYXBwZXIpLCBvID0gYy5tYWtlKFwiZGl2XCIsIGZlLkNTUy5vdmVybGF5LCB7fSksIGkgPSBjLm1ha2UoXCJkaXZcIiwgZmUuQ1NTLm92ZXJsYXlDb250YWluZXIsIHt9KSwgbiA9IGMubWFrZShcImRpdlwiLCBmZS5DU1MucmVjdCwge30pO1xuICAgIHJldHVybiBpLmFwcGVuZENoaWxkKG4pLCBvLmFwcGVuZENoaWxkKGkpLCB0LmFwcGVuZENoaWxkKG8pLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUgPSBuLCB7XG4gICAgICBjb250YWluZXI6IHQsXG4gICAgICBvdmVybGF5OiBvXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIHNjcm9sbGluZyBpZiBibG9ja1NlbGVjdGlvbiBpcyBhY3RpdmUgYW5kIG1vdXNlIGlzIGluIHNjcm9sbCB6b25lXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZCAtIHNwZWVkIG9mIHNjcm9sbGluZ1xuICAgKi9cbiAgc2Nyb2xsVmVydGljYWwoZSkge1xuICAgIGlmICghKHRoaXMuaW5TY3JvbGxab25lICYmIHRoaXMubW91c2Vkb3duKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIHdpbmRvdy5zY3JvbGxCeSgwLCBlKSwgdGhpcy5tb3VzZVkgKz0gd2luZG93LnBhZ2VZT2Zmc2V0IC0gdCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNjcm9sbFZlcnRpY2FsKGUpO1xuICAgIH0sIDApO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjaGFuZ2UgaW4gdGhlIHJlY3RhbmdsZSBhbmQgaXRzIGVmZmVjdFxuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gbW91c2UgZXZlbnRcbiAgICovXG4gIGNoYW5naW5nUmVjdGFuZ2xlKGUpIHtcbiAgICBpZiAoIXRoaXMubW91c2Vkb3duKVxuICAgICAgcmV0dXJuO1xuICAgIGUucGFnZVkgIT09IHZvaWQgMCAmJiAodGhpcy5tb3VzZVggPSBlLnBhZ2VYLCB0aGlzLm1vdXNlWSA9IGUucGFnZVkpO1xuICAgIGNvbnN0IHsgcmlnaHRQb3M6IHQsIGxlZnRQb3M6IG8sIGluZGV4OiBpIH0gPSB0aGlzLmdlbkluZm9Gb3JNb3VzZVNlbGVjdGlvbigpLCBuID0gdGhpcy5zdGFydFggPiB0ICYmIHRoaXMubW91c2VYID4gdCwgciA9IHRoaXMuc3RhcnRYIDwgbyAmJiB0aGlzLm1vdXNlWCA8IG87XG4gICAgdGhpcy5yZWN0Q3Jvc3Nlc0Jsb2NrcyA9ICEobiB8fCByKSwgdGhpcy5pc1JlY3RTZWxlY3Rpb25BY3RpdmF0ZWQgfHwgKHRoaXMucmVjdENyb3NzZXNCbG9ja3MgPSAhMSwgdGhpcy5pc1JlY3RTZWxlY3Rpb25BY3RpdmF0ZWQgPSAhMCwgdGhpcy5zaHJpbmtSZWN0YW5nbGVUb1BvaW50KCksIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiKSwgdGhpcy51cGRhdGVSZWN0YW5nbGVTaXplKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSwgaSAhPT0gdm9pZCAwICYmICh0aGlzLnRyeVNlbGVjdE5leHRCbG9jayhpKSwgdGhpcy5pbnZlcnNlU2VsZWN0aW9uKCksIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCkpO1xuICB9XG4gIC8qKlxuICAgKiBTaHJpbmsgcmVjdCB0byBzaW5ndWxhciBwb2ludFxuICAgKi9cbiAgc2hyaW5rUmVjdGFuZ2xlVG9Qb2ludCgpIHtcbiAgICB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUubGVmdCA9IGAke3RoaXMuc3RhcnRYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLnRvcCA9IGAke3RoaXMuc3RhcnRZIC0gd2luZG93LnBhZ2VZT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLmJvdHRvbSA9IGBjYWxjKDEwMCUgLSAke3RoaXMuc3RhcnRZIC0gd2luZG93LnBhZ2VZT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLnJpZ2h0ID0gYGNhbGMoMTAwJSAtICR7dGhpcy5zdGFydFggLSB3aW5kb3cucGFnZVhPZmZzZXR9cHhgO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3Qgb3IgdW5zZWxlY3QgYWxsIG9mIGJsb2NrcyBpbiBhcnJheSBpZiByZWN0IGlzIG91dCBvciBpbiBzZWxlY3RhYmxlIGFyZWFcbiAgICovXG4gIGludmVyc2VTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SW5kZXgodGhpcy5zdGFja09mU2VsZWN0ZWRbMF0pLnNlbGVjdGVkO1xuICAgIGlmICh0aGlzLnJlY3RDcm9zc2VzQmxvY2tzICYmICF0KVxuICAgICAgZm9yIChjb25zdCBvIG9mIHRoaXMuc3RhY2tPZlNlbGVjdGVkKVxuICAgICAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5zZWxlY3RCbG9ja0J5SW5kZXgobyk7XG4gICAgaWYgKCF0aGlzLnJlY3RDcm9zc2VzQmxvY2tzICYmIHQpXG4gICAgICBmb3IgKGNvbnN0IG8gb2YgdGhpcy5zdGFja09mU2VsZWN0ZWQpXG4gICAgICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnVuU2VsZWN0QmxvY2tCeUluZGV4KG8pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHNpemUgb2YgcmVjdGFuZ2xlXG4gICAqL1xuICB1cGRhdGVSZWN0YW5nbGVTaXplKCkge1xuICAgIHRoaXMubW91c2VZID49IHRoaXMuc3RhcnRZID8gKHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS50b3AgPSBgJHt0aGlzLnN0YXJ0WSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5ib3R0b20gPSBgY2FsYygxMDAlIC0gJHt0aGlzLm1vdXNlWSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGApIDogKHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5ib3R0b20gPSBgY2FsYygxMDAlIC0gJHt0aGlzLnN0YXJ0WSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS50b3AgPSBgJHt0aGlzLm1vdXNlWSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGApLCB0aGlzLm1vdXNlWCA+PSB0aGlzLnN0YXJ0WCA/ICh0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUubGVmdCA9IGAke3RoaXMuc3RhcnRYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLnJpZ2h0ID0gYGNhbGMoMTAwJSAtICR7dGhpcy5tb3VzZVggLSB3aW5kb3cucGFnZVhPZmZzZXR9cHhgKSA6ICh0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUucmlnaHQgPSBgY2FsYygxMDAlIC0gJHt0aGlzLnN0YXJ0WCAtIHdpbmRvdy5wYWdlWE9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5sZWZ0ID0gYCR7dGhpcy5tb3VzZVggLSB3aW5kb3cucGFnZVhPZmZzZXR9cHhgKTtcbiAgfVxuICAvKipcbiAgICogQ29sbGVjdHMgaW5mb3JtYXRpb24gbmVlZGVkIHRvIGRldGVybWluZSB0aGUgYmVoYXZpb3Igb2YgdGhlIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBpbmRleCAtIGluZGV4IG5leHQgQmxvY2ssIGxlZnRQb3MgLSBzdGFydCBvZiBsZWZ0IGJvcmRlciBvZiBCbG9jaywgcmlnaHRQb3MgLSByaWdodCBib3JkZXJcbiAgICovXG4gIGdlbkluZm9Gb3JNb3VzZVNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAvIDIsIG8gPSB0aGlzLm1vdXNlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCwgaSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodCwgbyksIG4gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUNoaWxkTm9kZShpKTtcbiAgICBsZXQgcjtcbiAgICBuICE9PSB2b2lkIDAgJiYgKHIgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmZpbmRJbmRleCgoaCkgPT4gaC5ob2xkZXIgPT09IG4uaG9sZGVyKSk7XG4gICAgY29uc3QgYSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5sYXN0QmxvY2suaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBSLkNTUy5jb250ZW50KSwgbCA9IE51bWJlci5wYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhKS53aWR0aCwgMTApIC8gMiwgZCA9IHQgLSBsLCB1ID0gdCArIGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiByLFxuICAgICAgbGVmdFBvczogZCxcbiAgICAgIHJpZ2h0UG9zOiB1XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0IGJsb2NrIHdpdGggaW5kZXggaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIGluZGV4IC0gaW5kZXggb2YgYmxvY2sgaW4gcmVkYWN0b3JcbiAgICovXG4gIGFkZEJsb2NrSW5TZWxlY3Rpb24oZSkge1xuICAgIHRoaXMucmVjdENyb3NzZXNCbG9ja3MgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uc2VsZWN0QmxvY2tCeUluZGV4KGUpLCB0aGlzLnN0YWNrT2ZTZWxlY3RlZC5wdXNoKGUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgYmxvY2sgdG8gdGhlIHNlbGVjdGlvbiBhbmQgZGV0ZXJtaW5lcyB3aGljaCBibG9ja3Mgc2hvdWxkIGJlIHNlbGVjdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmRleCAtIGluZGV4IG9mIG5ldyBibG9jayBpbiB0aGUgcmVhY3RvclxuICAgKi9cbiAgdHJ5U2VsZWN0TmV4dEJsb2NrKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zdGFja09mU2VsZWN0ZWRbdGhpcy5zdGFja09mU2VsZWN0ZWQubGVuZ3RoIC0gMV0gPT09IGUsIG8gPSB0aGlzLnN0YWNrT2ZTZWxlY3RlZC5sZW5ndGgsIGkgPSAxLCBuID0gLTEsIHIgPSAwO1xuICAgIGlmICh0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gLSB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMl0gPiAwO1xuICAgIGxldCBsID0gcjtcbiAgICBvID4gMSAmJiAobCA9IGEgPyBpIDogbik7XG4gICAgY29uc3QgZCA9IGUgPiB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gJiYgbCA9PT0gaSwgdSA9IGUgPCB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gJiYgbCA9PT0gbiwgZiA9ICEoZCB8fCB1IHx8IGwgPT09IHIpO1xuICAgIGlmICghZiAmJiAoZSA+IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSB8fCB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gPT09IHZvaWQgMCkpIHtcbiAgICAgIGxldCBtID0gdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDFdICsgMSB8fCBlO1xuICAgICAgZm9yIChtOyBtIDw9IGU7IG0rKylcbiAgICAgICAgdGhpcy5hZGRCbG9ja0luU2VsZWN0aW9uKG0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWYgJiYgZSA8IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSkge1xuICAgICAgZm9yIChsZXQgbSA9IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSAtIDE7IG0gPj0gZTsgbS0tKVxuICAgICAgICB0aGlzLmFkZEJsb2NrSW5TZWxlY3Rpb24obSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZilcbiAgICAgIHJldHVybjtcbiAgICBsZXQgeCA9IG8gLSAxLCBwO1xuICAgIGZvciAoZSA+IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSA/IHAgPSAoKSA9PiBlID4gdGhpcy5zdGFja09mU2VsZWN0ZWRbeF0gOiBwID0gKCkgPT4gZSA8IHRoaXMuc3RhY2tPZlNlbGVjdGVkW3hdOyBwKCk7IClcbiAgICAgIHRoaXMucmVjdENyb3NzZXNCbG9ja3MgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24udW5TZWxlY3RCbG9ja0J5SW5kZXgodGhpcy5zdGFja09mU2VsZWN0ZWRbeF0pLCB0aGlzLnN0YWNrT2ZTZWxlY3RlZC5wb3AoKSwgeC0tO1xuICB9XG59XG5jbGFzcyBjaSBleHRlbmRzIHkge1xuICAvKipcbiAgICogUmVuZGVycyBwYXNzZWQgYmxvY2tzIGFzIG9uZSBiYXRjaFxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2tzRGF0YSAtIGJsb2NrcyB0byByZW5kZXJcbiAgICovXG4gIGFzeW5jIHJlbmRlcihlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCh0KSA9PiB7XG4gICAgICBjb25zdCB7IFRvb2xzOiBvLCBCbG9ja01hbmFnZXI6IGkgfSA9IHRoaXMuRWRpdG9yO1xuICAgICAgaWYgKGUubGVuZ3RoID09PSAwKVxuICAgICAgICBpLmluc2VydCgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG4gPSBlLm1hcCgoeyB0eXBlOiByLCBkYXRhOiBhLCB0dW5lczogbCwgaWQ6IGQgfSkgPT4ge1xuICAgICAgICAgIG8uYXZhaWxhYmxlLmhhcyhyKSA9PT0gITEgJiYgKFkoYFRvb2wgwqske3J9wrsgaXMgbm90IGZvdW5kLiBDaGVjayAndG9vbHMnIHByb3BlcnR5IGF0IHRoZSBFZGl0b3IuanMgY29uZmlnLmAsIFwid2FyblwiKSwgYSA9IHRoaXMuY29tcG9zZVN0dWJEYXRhRm9yVG9vbChyLCBhLCBkKSwgciA9IG8uc3R1YlRvb2wpO1xuICAgICAgICAgIGxldCB1O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1ID0gaS5jb21wb3NlQmxvY2soe1xuICAgICAgICAgICAgICBpZDogZCxcbiAgICAgICAgICAgICAgdG9vbDogcixcbiAgICAgICAgICAgICAgZGF0YTogYSxcbiAgICAgICAgICAgICAgdHVuZXM6IGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgICAgIFQoYEJsb2NrIMKrJHtyfcK7IHNraXBwZWQgYmVjYXVzZSBvZiBwbHVnaW5zIGVycm9yYCwgXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgIGRhdGE6IGEsXG4gICAgICAgICAgICAgIGVycm9yOiBoXG4gICAgICAgICAgICB9KSwgYSA9IHRoaXMuY29tcG9zZVN0dWJEYXRhRm9yVG9vbChyLCBhLCBkKSwgciA9IG8uc3R1YlRvb2wsIHUgPSBpLmNvbXBvc2VCbG9jayh7XG4gICAgICAgICAgICAgIGlkOiBkLFxuICAgICAgICAgICAgICB0b29sOiByLFxuICAgICAgICAgICAgICBkYXRhOiBhLFxuICAgICAgICAgICAgICB0dW5lczogbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICB9KTtcbiAgICAgICAgaS5pbnNlcnRNYW55KG4pO1xuICAgICAgfVxuICAgICAgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICB0KCk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDJlMyB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGRhdGEgZm9yIHRoZSBTdHViIFRvb2wgdGhhdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB1bmF2YWlsYWJsZSB0b29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gdW5hdmFpbGFibGUgdG9vbCBuYW1lIHRvIHN0dWJcbiAgICogQHBhcmFtIGRhdGEgLSBkYXRhIG9mIHVuYXZhaWxhYmxlIGJsb2NrXG4gICAqIEBwYXJhbSBbaWRdIC0gaWQgb2YgdW5hdmFpbGFibGUgYmxvY2tcbiAgICovXG4gIGNvbXBvc2VTdHViRGF0YUZvclRvb2woZSwgdCwgbykge1xuICAgIGNvbnN0IHsgVG9vbHM6IGkgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGxldCBuID0gZTtcbiAgICBpZiAoaS51bmF2YWlsYWJsZS5oYXMoZSkpIHtcbiAgICAgIGNvbnN0IHIgPSBpLnVuYXZhaWxhYmxlLmdldChlKS50b29sYm94O1xuICAgICAgciAhPT0gdm9pZCAwICYmIHJbMF0udGl0bGUgIT09IHZvaWQgMCAmJiAobiA9IHJbMF0udGl0bGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2F2ZWREYXRhOiB7XG4gICAgICAgIGlkOiBvLFxuICAgICAgICB0eXBlOiBlLFxuICAgICAgICBkYXRhOiB0XG4gICAgICB9LFxuICAgICAgdGl0bGU6IG5cbiAgICB9O1xuICB9XG59XG5jbGFzcyBkaSBleHRlbmRzIHkge1xuICAvKipcbiAgICogQ29tcG9zZXMgbmV3IGNoYWluIG9mIFByb21pc2VzIHRvIGZpcmUgdGhlbSBhbHRlcm5hdGVsbHlcbiAgICpcbiAgICogQHJldHVybnMge091dHB1dERhdGF9XG4gICAqL1xuICBhc3luYyBzYXZlKCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBlLCBUb29sczogdCB9ID0gdGhpcy5FZGl0b3IsIG8gPSBlLmJsb2NrcywgaSA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBvLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaS5wdXNoKHRoaXMuZ2V0U2F2ZWREYXRhKGEpKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbiA9IGF3YWl0IFByb21pc2UuYWxsKGkpLCByID0gYXdhaXQgYnQobiwgKGEpID0+IHQuYmxvY2tUb29scy5nZXQoYSkuc2FuaXRpemVDb25maWcpO1xuICAgICAgcmV0dXJuIHRoaXMubWFrZU91dHB1dChyKTtcbiAgICB9IGNhdGNoIChuKSB7XG4gICAgICBZKFwiU2F2aW5nIGZhaWxlZCBkdWUgdG8gdGhlIEVycm9yICVvXCIsIFwiZXJyb3JcIiwgbik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTYXZlcyBhbmQgdmFsaWRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gRWRpdG9yJ3MgVG9vbFxuICAgKiBAcmV0dXJucyB7VmFsaWRhdGVkRGF0YX0gLSBUb29sJ3MgdmFsaWRhdGVkIGRhdGFcbiAgICovXG4gIGFzeW5jIGdldFNhdmVkRGF0YShlKSB7XG4gICAgY29uc3QgdCA9IGF3YWl0IGUuc2F2ZSgpLCBvID0gdCAmJiBhd2FpdCBlLnZhbGlkYXRlKHQuZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnQsXG4gICAgICBpc1ZhbGlkOiBvXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBvdXRwdXQgb2JqZWN0IHdpdGggc2F2ZWQgZGF0YSwgdGltZSBhbmQgdmVyc2lvbiBvZiBlZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIHtWYWxpZGF0ZWREYXRhfSBhbGxFeHRyYWN0ZWREYXRhIC0gZGF0YSBleHRyYWN0ZWQgZnJvbSBCbG9ja3NcbiAgICogQHJldHVybnMge091dHB1dERhdGF9XG4gICAqL1xuICBtYWtlT3V0cHV0KGUpIHtcbiAgICBjb25zdCB0ID0gW107XG4gICAgcmV0dXJuIGUuZm9yRWFjaCgoeyBpZDogbywgdG9vbDogaSwgZGF0YTogbiwgdHVuZXM6IHIsIGlzVmFsaWQ6IGEgfSkgPT4ge1xuICAgICAgaWYgKCFhKSB7XG4gICAgICAgIFQoYEJsb2NrIMKrJHtpfcK7IHNraXBwZWQgYmVjYXVzZSBzYXZlZCBkYXRhIGlzIGludmFsaWRgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IHRoaXMuRWRpdG9yLlRvb2xzLnN0dWJUb29sKSB7XG4gICAgICAgIHQucHVzaChuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbCA9IHtcbiAgICAgICAgaWQ6IG8sXG4gICAgICAgIHR5cGU6IGksXG4gICAgICAgIGRhdGE6IG4sXG4gICAgICAgIC4uLiFXKHIpICYmIHtcbiAgICAgICAgICB0dW5lczogclxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdC5wdXNoKGwpO1xuICAgIH0pLCB7XG4gICAgICB0aW1lOiArLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICBibG9ja3M6IHQsXG4gICAgICB2ZXJzaW9uOiBcIjIuMjkuMVwiXG4gICAgfTtcbiAgfVxufVxuKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPCBcInVcIikge1xuICAgICAgdmFyIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBzLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiLmNlLXBhcmFncmFwaHtsaW5lLWhlaWdodDoxLjZlbTtvdXRsaW5lOm5vbmV9LmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpiZWZvcmV7Y29udGVudDphdHRyKGRhdGEtcGxhY2Vob2xkZXIpO2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NDAwO29wYWNpdHk6MH0uY29kZXgtZWRpdG9yLS1lbXB0eSAuY2UtYmxvY2s6Zmlyc3QtY2hpbGQgLmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpiZWZvcmV7b3BhY2l0eToxfS5jb2RleC1lZGl0b3ItLXRvb2xib3gtb3BlbmVkIC5jZS1ibG9jazpmaXJzdC1jaGlsZCAuY2UtcGFyYWdyYXBoW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmJlZm9yZSwuY29kZXgtZWRpdG9yLS1lbXB0eSAuY2UtYmxvY2s6Zmlyc3QtY2hpbGQgLmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpmb2N1czpiZWZvcmV7b3BhY2l0eTowfS5jZS1wYXJhZ3JhcGggcDpmaXJzdC1vZi10eXBle21hcmdpbi10b3A6MH0uY2UtcGFyYWdyYXBoIHA6bGFzdC1vZi10eXBle21hcmdpbi1ib3R0b206MH1cIikpLCBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJ2aXRlLXBsdWdpbi1jc3MtaW5qZWN0ZWQtYnktanNcIiwgZSk7XG4gIH1cbn0pKCk7XG5jb25zdCBoaSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOCA5VjcuMkM4IDcuMDg5NTQgOC4wODk1NCA3IDguMiA3TDEyIDdNMTYgOVY3LjJDMTYgNy4wODk1NCAxNS45MTA1IDcgMTUuOCA3TDEyIDdNMTIgN0wxMiAxN00xMiAxN0gxME0xMiAxN0gxNFwiLz48L3N2Zz4nO1xuLyoqXG4gKiBCYXNlIFBhcmFncmFwaCBCbG9jayBmb3IgdGhlIEVkaXRvci5qcy5cbiAqIFJlcHJlc2VudHMgYSByZWd1bGFyIHRleHQgYmxvY2tcbiAqXG4gKiBAYXV0aG9yIENvZGVYICh0ZWFtQGNvZGV4LnNvKVxuICogQGNvcHlyaWdodCBDb2RlWCAyMDE4XG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqL1xuY2xhc3MgS2Uge1xuICAvKipcbiAgICogRGVmYXVsdCBwbGFjZWhvbGRlciBmb3IgUGFyYWdyYXBoIFRvb2xcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQGNsYXNzXG4gICAqL1xuICBzdGF0aWMgZ2V0IERFRkFVTFRfUExBQ0VIT0xERVIoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciBwbHVnaW5gcyBtYWluIEVsZW1lbnQgYW5kIGZpbGwgaXQgd2l0aCBzYXZlZCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBjb25zdHJ1Y3RvciBwYXJhbXNcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBwYXJhbXMuZGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxuICAgKiBAcGFyYW0ge1BhcmFncmFwaENvbmZpZ30gcGFyYW1zLmNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYXBpIC0gZWRpdG9yLmpzIGFwaVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5IC0gcmVhZCBvbmx5IG1vZGUgZmxhZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkYXRhOiBlLCBjb25maWc6IHQsIGFwaTogbywgcmVhZE9ubHk6IGkgfSkge1xuICAgIHRoaXMuYXBpID0gbywgdGhpcy5yZWFkT25seSA9IGksIHRoaXMuX0NTUyA9IHtcbiAgICAgIGJsb2NrOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICB3cmFwcGVyOiBcImNlLXBhcmFncmFwaFwiXG4gICAgfSwgdGhpcy5yZWFkT25seSB8fCAodGhpcy5vbktleVVwID0gdGhpcy5vbktleVVwLmJpbmQodGhpcykpLCB0aGlzLl9wbGFjZWhvbGRlciA9IHQucGxhY2Vob2xkZXIgPyB0LnBsYWNlaG9sZGVyIDogS2UuREVGQVVMVF9QTEFDRUhPTERFUiwgdGhpcy5fZGF0YSA9IHt9LCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fcHJlc2VydmVCbGFuayA9IHQucHJlc2VydmVCbGFuayAhPT0gdm9pZCAwID8gdC5wcmVzZXJ2ZUJsYW5rIDogITEsIHRoaXMuZGF0YSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRleHQgY29udGVudCBpcyBlbXB0eSBhbmQgc2V0IGVtcHR5IHN0cmluZyB0byBpbm5lciBodG1sLlxuICAgKiBXZSBuZWVkIHRoaXMgYmVjYXVzZSBzb21lIGJyb3dzZXJzIChlLmcuIFNhZmFyaSkgaW5zZXJ0IDxicj4gaW50byBlbXB0eSBjb250ZW50ZWRpdGFubGUgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlIC0ga2V5IHVwIGV2ZW50XG4gICAqL1xuICBvbktleVVwKGUpIHtcbiAgICBpZiAoZS5jb2RlICE9PSBcIkJhY2tzcGFjZVwiICYmIGUuY29kZSAhPT0gXCJEZWxldGVcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRleHRDb250ZW50OiB0IH0gPSB0aGlzLl9lbGVtZW50O1xuICAgIHQgPT09IFwiXCIgJiYgKHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBUb29sJ3Mgdmlld1xuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkcmF3VmlldygpIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICByZXR1cm4gZS5jbGFzc0xpc3QuYWRkKHRoaXMuX0NTUy53cmFwcGVyLCB0aGlzLl9DU1MuYmxvY2spLCBlLmNvbnRlbnRFZGl0YWJsZSA9ICExLCBlLmRhdGFzZXQucGxhY2Vob2xkZXIgPSB0aGlzLmFwaS5pMThuLnQodGhpcy5fcGxhY2Vob2xkZXIpLCB0aGlzLl9kYXRhLnRleHQgJiYgKGUuaW5uZXJIVE1MID0gdGhpcy5fZGF0YS50ZXh0KSwgdGhpcy5yZWFkT25seSB8fCAoZS5jb250ZW50RWRpdGFibGUgPSAhMCwgZS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5vbktleVVwKSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBUb29sJ3Mgdmlld1xuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTERpdkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQgPSB0aGlzLmRyYXdWaWV3KCksIHRoaXMuX2VsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCB0aGF0IHNwZWNpZmllZCBob3cgdG8gbWVyZ2UgdHdvIFRleHQgYmxvY2tzLlxuICAgKiBDYWxsZWQgYnkgRWRpdG9yLmpzIGJ5IGJhY2tzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge1BhcmFncmFwaERhdGF9IGRhdGFcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbWVyZ2UoZSkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICB0ZXh0OiB0aGlzLmRhdGEudGV4dCArIGUudGV4dFxuICAgIH07XG4gICAgdGhpcy5kYXRhID0gdDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgUGFyYWdyYXBoIGJsb2NrIGRhdGE6XG4gICAqIC0gY2hlY2sgZm9yIGVtcHRpbmVzc1xuICAgKlxuICAgKiBAcGFyYW0ge1BhcmFncmFwaERhdGF9IHNhdmVkRGF0YSDigJQgZGF0YSByZWNlaXZlZCBhZnRlciBzYXZpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIHNhdmVkIGRhdGEgaXMgbm90IGNvcnJlY3QsIG90aGVyd2lzZSB0cnVlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHZhbGlkYXRlKGUpIHtcbiAgICByZXR1cm4gIShlLnRleHQudHJpbSgpID09PSBcIlwiICYmICF0aGlzLl9wcmVzZXJ2ZUJsYW5rKTtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBUb29sJ3MgZGF0YSBmcm9tIHRoZSB2aWV3XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IHRvb2xzQ29udGVudCAtIFBhcmFncmFwaCB0b29scyByZW5kZXJlZCB2aWV3XG4gICAqIEByZXR1cm5zIHtQYXJhZ3JhcGhEYXRhfSAtIHNhdmVkIGRhdGFcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2F2ZShlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGUuaW5uZXJIVE1MXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT24gcGFzdGUgY2FsbGJhY2sgZmlyZWQgZnJvbSBFZGl0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7UGFzdGVFdmVudH0gZXZlbnQgLSBldmVudCB3aXRoIHBhc3RlZCBkYXRhXG4gICAqL1xuICBvblBhc3RlKGUpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgdGV4dDogZS5kZXRhaWwuZGF0YS5pbm5lckhUTUxcbiAgICB9O1xuICAgIHRoaXMuZGF0YSA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBDb252ZXJzaW9uIFRvb2xiYXIuIFBhcmFncmFwaCBjYW4gYmUgY29udmVydGVkIHRvL2Zyb20gb3RoZXIgdG9vbHNcbiAgICovXG4gIHN0YXRpYyBnZXQgY29udmVyc2lvbkNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwb3J0OiBcInRleHRcIixcbiAgICAgIC8vIHRvIGNvbnZlcnQgUGFyYWdyYXBoIHRvIG90aGVyIGJsb2NrLCB1c2UgJ3RleHQnIHByb3BlcnR5IG9mIHNhdmVkIGRhdGFcbiAgICAgIGltcG9ydDogXCJ0ZXh0XCJcbiAgICAgIC8vIHRvIGNvdmVydCBvdGhlciBibG9jaydzIGV4cG9ydGVkIHN0cmluZyB0byBQYXJhZ3JhcGgsIGZpbGwgJ3RleHQnIHByb3BlcnR5IG9mIHRvb2wgZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBydWxlc1xuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDoge1xuICAgICAgICBicjogITBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgdG8gbm90aWZ5IHRoZSBjb3JlIHRoYXQgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCBpc1JlYWRPbmx5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgVG9vbHNgcyBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtQYXJhZ3JhcGhEYXRhfSBDdXJyZW50IGRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5fZWxlbWVudC5pbm5lckhUTUw7XG4gICAgICB0aGlzLl9kYXRhLnRleHQgPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKipcbiAgICogU3RvcmUgZGF0YSBpbiBwbHVnaW46XG4gICAqIC0gYXQgdGhlIHRoaXMuX2RhdGEgcHJvcGVydHlcbiAgICogLSBhdCB0aGUgSFRNTFxuICAgKlxuICAgKiBAcGFyYW0ge1BhcmFncmFwaERhdGF9IGRhdGEg4oCUIGRhdGEgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXQgZGF0YShlKSB7XG4gICAgdGhpcy5fZGF0YSA9IGUgfHwge30sIHRoaXMuX2VsZW1lbnQgIT09IG51bGwgJiYgdGhpcy5oeWRyYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbGwgdG9vbCdzIHZpZXcgd2l0aCBkYXRhXG4gICAqL1xuICBoeWRyYXRlKCkge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9kYXRhLnRleHQgfHwgXCJcIjtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXNlZCBieSBFZGl0b3IgcGFzdGUgaGFuZGxpbmcgQVBJLlxuICAgKiBQcm92aWRlcyBjb25maWd1cmF0aW9uIHRvIGhhbmRsZSBQIHRhZ3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHt7dGFnczogc3RyaW5nW119fVxuICAgKi9cbiAgc3RhdGljIGdldCBwYXN0ZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnczogW1wiUFwiXVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEljb24gYW5kIHRpdGxlIGZvciBkaXNwbGF5aW5nIGF0IHRoZSBUb29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHt7aWNvbjogc3RyaW5nLCB0aXRsZTogc3RyaW5nfX1cbiAgICovXG4gIHN0YXRpYyBnZXQgdG9vbGJveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogaGksXG4gICAgICB0aXRsZTogXCJUZXh0XCJcbiAgICB9O1xuICB9XG59XG5jbGFzcyBYZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29tbWFuZE5hbWUgPSBcImJvbGRcIiwgdGhpcy5DU1MgPSB7XG4gICAgICBidXR0b246IFwiY2UtaW5saW5lLXRvb2xcIixcbiAgICAgIGJ1dHRvbkFjdGl2ZTogXCJjZS1pbmxpbmUtdG9vbC0tYWN0aXZlXCIsXG4gICAgICBidXR0b25Nb2RpZmllcjogXCJjZS1pbmxpbmUtdG9vbC0tYm9sZFwiXG4gICAgfSwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIGJ1dHRvbjogdm9pZCAwXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FuaXRpemVyIFJ1bGVcbiAgICogTGVhdmUgPGI+IHRhZ3NcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGI6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGJ1dHRvbiBmb3IgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCB0aGlzLm5vZGVzLmJ1dHRvbi50eXBlID0gXCJidXR0b25cIiwgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5idXR0b24sIHRoaXMuQ1NTLmJ1dHRvbk1vZGlmaWVyKSwgdGhpcy5ub2Rlcy5idXR0b24uaW5uZXJIVE1MID0gX28sIHRoaXMubm9kZXMuYnV0dG9uO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwIHJhbmdlIHdpdGggPGI+IHRhZ1xuICAgKi9cbiAgc3Vycm91bmQoKSB7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHNlbGVjdGlvbiBhbmQgc2V0IGFjdGl2YXRlZCBzdGF0ZSB0byBidXR0b24gaWYgdGhlcmUgYXJlIDxiPiB0YWdcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjaGVja1N0YXRlKCkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZSh0aGlzLmNvbW1hbmROYW1lKTtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLkNTUy5idXR0b25BY3RpdmUsIGUpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSBzaG9ydGN1dFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBzaG9ydGN1dCgpIHtcbiAgICByZXR1cm4gXCJDTUQrQlwiO1xuICB9XG59XG5YZS5pc0lubGluZSA9ICEwO1xuWGUudGl0bGUgPSBcIkJvbGRcIjtcbmNsYXNzIFZlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb21tYW5kTmFtZSA9IFwiaXRhbGljXCIsIHRoaXMuQ1NTID0ge1xuICAgICAgYnV0dG9uOiBcImNlLWlubGluZS10b29sXCIsXG4gICAgICBidXR0b25BY3RpdmU6IFwiY2UtaW5saW5lLXRvb2wtLWFjdGl2ZVwiLFxuICAgICAgYnV0dG9uTW9kaWZpZXI6IFwiY2UtaW5saW5lLXRvb2wtLWl0YWxpY1wiXG4gICAgfSwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIGJ1dHRvbjogbnVsbFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBSdWxlXG4gICAqIExlYXZlIDxpPiB0YWdzXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHNhbml0aXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpOiB7fVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBidXR0b24gZm9yIElubGluZSBUb29sYmFyXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSwgdGhpcy5ub2Rlcy5idXR0b24udHlwZSA9IFwiYnV0dG9uXCIsIHRoaXMubm9kZXMuYnV0dG9uLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuYnV0dG9uLCB0aGlzLkNTUy5idXR0b25Nb2RpZmllciksIHRoaXMubm9kZXMuYnV0dG9uLmlubmVySFRNTCA9IERvLCB0aGlzLm5vZGVzLmJ1dHRvbjtcbiAgfVxuICAvKipcbiAgICogV3JhcCByYW5nZSB3aXRoIDxpPiB0YWdcbiAgICovXG4gIHN1cnJvdW5kKCkge1xuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKHRoaXMuY29tbWFuZE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBzZWxlY3Rpb24gYW5kIHNldCBhY3RpdmF0ZWQgc3RhdGUgdG8gYnV0dG9uIGlmIHRoZXJlIGFyZSA8aT4gdGFnXG4gICAqL1xuICBjaGVja1N0YXRlKCkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZSh0aGlzLmNvbW1hbmROYW1lKTtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLkNTUy5idXR0b25BY3RpdmUsIGUpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSBzaG9ydGN1dFxuICAgKi9cbiAgZ2V0IHNob3J0Y3V0KCkge1xuICAgIHJldHVybiBcIkNNRCtJXCI7XG4gIH1cbn1cblZlLmlzSW5saW5lID0gITA7XG5WZS50aXRsZSA9IFwiSXRhbGljXCI7XG5jbGFzcyBxZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGk6IGUgfSkge1xuICAgIHRoaXMuY29tbWFuZExpbmsgPSBcImNyZWF0ZUxpbmtcIiwgdGhpcy5jb21tYW5kVW5saW5rID0gXCJ1bmxpbmtcIiwgdGhpcy5FTlRFUl9LRVkgPSAxMywgdGhpcy5DU1MgPSB7XG4gICAgICBidXR0b246IFwiY2UtaW5saW5lLXRvb2xcIixcbiAgICAgIGJ1dHRvbkFjdGl2ZTogXCJjZS1pbmxpbmUtdG9vbC0tYWN0aXZlXCIsXG4gICAgICBidXR0b25Nb2RpZmllcjogXCJjZS1pbmxpbmUtdG9vbC0tbGlua1wiLFxuICAgICAgYnV0dG9uVW5saW5rOiBcImNlLWlubGluZS10b29sLS11bmxpbmtcIixcbiAgICAgIGlucHV0OiBcImNlLWlubGluZS10b29sLWlucHV0XCIsXG4gICAgICBpbnB1dFNob3dlZDogXCJjZS1pbmxpbmUtdG9vbC1pbnB1dC0tc2hvd2VkXCJcbiAgICB9LCB0aGlzLm5vZGVzID0ge1xuICAgICAgYnV0dG9uOiBudWxsLFxuICAgICAgaW5wdXQ6IG51bGxcbiAgICB9LCB0aGlzLmlucHV0T3BlbmVkID0gITEsIHRoaXMudG9vbGJhciA9IGUudG9vbGJhciwgdGhpcy5pbmxpbmVUb29sYmFyID0gZS5pbmxpbmVUb29sYmFyLCB0aGlzLm5vdGlmaWVyID0gZS5ub3RpZmllciwgdGhpcy5pMThuID0gZS5pMThuLCB0aGlzLnNlbGVjdGlvbiA9IG5ldyBiKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBSdWxlXG4gICAqIExlYXZlIDxhPiB0YWdzXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHNhbml0aXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhOiB7XG4gICAgICAgIGhyZWY6ICEwLFxuICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgIHJlbDogXCJub2ZvbGxvd1wiXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGJ1dHRvbiBmb3IgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCB0aGlzLm5vZGVzLmJ1dHRvbi50eXBlID0gXCJidXR0b25cIiwgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5idXR0b24sIHRoaXMuQ1NTLmJ1dHRvbk1vZGlmaWVyKSwgdGhpcy5ub2Rlcy5idXR0b24uaW5uZXJIVE1MID0gaXQsIHRoaXMubm9kZXMuYnV0dG9uO1xuICB9XG4gIC8qKlxuICAgKiBJbnB1dCBmb3IgdGhlIGxpbmtcbiAgICovXG4gIHJlbmRlckFjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksIHRoaXMubm9kZXMuaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLmkxOG4udChcIkFkZCBhIGxpbmtcIiksIHRoaXMubm9kZXMuaW5wdXQuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5pbnB1dCksIHRoaXMubm9kZXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICAgIGUua2V5Q29kZSA9PT0gdGhpcy5FTlRFUl9LRVkgJiYgdGhpcy5lbnRlclByZXNzZWQoZSk7XG4gICAgfSksIHRoaXMubm9kZXMuaW5wdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGlja3Mgb24gdGhlIElubGluZSBUb29sYmFyIGljb25cbiAgICpcbiAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgLSByYW5nZSB0byB3cmFwIHdpdGggbGlua1xuICAgKi9cbiAgc3Vycm91bmQoZSkge1xuICAgIGlmIChlKSB7XG4gICAgICB0aGlzLmlucHV0T3BlbmVkID8gKHRoaXMuc2VsZWN0aW9uLnJlc3RvcmUoKSwgdGhpcy5zZWxlY3Rpb24ucmVtb3ZlRmFrZUJhY2tncm91bmQoKSkgOiAodGhpcy5zZWxlY3Rpb24uc2V0RmFrZUJhY2tncm91bmQoKSwgdGhpcy5zZWxlY3Rpb24uc2F2ZSgpKTtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlbGVjdGlvbi5maW5kUGFyZW50VGFnKFwiQVwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmV4cGFuZFRvVGFnKHQpLCB0aGlzLnVubGluaygpLCB0aGlzLmNsb3NlQWN0aW9ucygpLCB0aGlzLmNoZWNrU3RhdGUoKSwgdGhpcy50b29sYmFyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50b2dnbGVBY3Rpb25zKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHNlbGVjdGlvbiBhbmQgc2V0IGFjdGl2YXRlZCBzdGF0ZSB0byBidXR0b24gaWYgdGhlcmUgYXJlIDxhPiB0YWdcbiAgICovXG4gIGNoZWNrU3RhdGUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuc2VsZWN0aW9uLmZpbmRQYXJlbnRUYWcoXCJBXCIpO1xuICAgIGlmIChlKSB7XG4gICAgICB0aGlzLm5vZGVzLmJ1dHRvbi5pbm5lckhUTUwgPSB6bywgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5idXR0b25VbmxpbmspLCB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmJ1dHRvbkFjdGl2ZSksIHRoaXMub3BlbkFjdGlvbnMoKTtcbiAgICAgIGNvbnN0IHQgPSBlLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICB0aGlzLm5vZGVzLmlucHV0LnZhbHVlID0gdCAhPT0gXCJudWxsXCIgPyB0IDogXCJcIiwgdGhpcy5zZWxlY3Rpb24uc2F2ZSgpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5ub2Rlcy5idXR0b24uaW5uZXJIVE1MID0gaXQsIHRoaXMubm9kZXMuYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1MuYnV0dG9uVW5saW5rKSwgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5idXR0b25BY3RpdmUpO1xuICAgIHJldHVybiAhIWU7XG4gIH1cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGNhbGxlZCB3aXRoIElubGluZSBUb29sYmFyIGNsb3NpbmdcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2xvc2VBY3Rpb25zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHNob3J0Y3V0XG4gICAqL1xuICBnZXQgc2hvcnRjdXQoKSB7XG4gICAgcmV0dXJuIFwiQ01EK0tcIjtcbiAgfVxuICAvKipcbiAgICogU2hvdy9jbG9zZSBsaW5rIGlucHV0XG4gICAqL1xuICB0b2dnbGVBY3Rpb25zKCkge1xuICAgIHRoaXMuaW5wdXRPcGVuZWQgPyB0aGlzLmNsb3NlQWN0aW9ucyghMSkgOiB0aGlzLm9wZW5BY3Rpb25zKCEwKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBuZWVkRm9jdXMgLSBvbiBsaW5rIGNyZWF0aW9uIHdlIG5lZWQgdG8gZm9jdXMgaW5wdXQuIE9uIGVkaXRpbmcgLSBub3BlLlxuICAgKi9cbiAgb3BlbkFjdGlvbnMoZSA9ICExKSB7XG4gICAgdGhpcy5ub2Rlcy5pbnB1dC5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmlucHV0U2hvd2VkKSwgZSAmJiB0aGlzLm5vZGVzLmlucHV0LmZvY3VzKCksIHRoaXMuaW5wdXRPcGVuZWQgPSAhMDtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBjbGVhclNhdmVkU2VsZWN0aW9uIOKAlCB3ZSBkb24ndCBuZWVkIHRvIGNsZWFyIHNhdmVkIHNlbGVjdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbiB0b2dnbGUtY2xpY2tzIG9uIHRoZSBpY29uIG9mIG9wZW5lZCBUb29sYmFyXG4gICAqL1xuICBjbG9zZUFjdGlvbnMoZSA9ICEwKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uLmlzRmFrZUJhY2tncm91bmRFbmFibGVkKSB7XG4gICAgICBjb25zdCB0ID0gbmV3IGIoKTtcbiAgICAgIHQuc2F2ZSgpLCB0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCksIHRoaXMuc2VsZWN0aW9uLnJlbW92ZUZha2VCYWNrZ3JvdW5kKCksIHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLm5vZGVzLmlucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1MuaW5wdXRTaG93ZWQpLCB0aGlzLm5vZGVzLmlucHV0LnZhbHVlID0gXCJcIiwgZSAmJiB0aGlzLnNlbGVjdGlvbi5jbGVhclNhdmVkKCksIHRoaXMuaW5wdXRPcGVuZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogRW50ZXIgcHJlc3NlZCBvbiBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0gZW50ZXIga2V5ZG93biBldmVudFxuICAgKi9cbiAgZW50ZXJQcmVzc2VkKGUpIHtcbiAgICBsZXQgdCA9IHRoaXMubm9kZXMuaW5wdXQudmFsdWUgfHwgXCJcIjtcbiAgICBpZiAoIXQudHJpbSgpKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCksIHRoaXMudW5saW5rKCksIGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5jbG9zZUFjdGlvbnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlVVJMKHQpKSB7XG4gICAgICB0aGlzLm5vdGlmaWVyLnNob3coe1xuICAgICAgICBtZXNzYWdlOiBcIlBhc3RlZCBsaW5rIGlzIG5vdCB2YWxpZC5cIixcbiAgICAgICAgc3R5bGU6IFwiZXJyb3JcIlxuICAgICAgfSksIFQoXCJJbmNvcnJlY3QgTGluayBwYXN0ZWRcIiwgXCJ3YXJuXCIsIHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0ID0gdGhpcy5wcmVwYXJlTGluayh0KSwgdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpLCB0aGlzLnNlbGVjdGlvbi5yZW1vdmVGYWtlQmFja2dyb3VuZCgpLCB0aGlzLmluc2VydExpbmsodCksIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKSwgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdGhpcy5zZWxlY3Rpb24uY29sbGFwc2VUb0VuZCgpLCB0aGlzLmlubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZWN0cyBpZiBwYXNzZWQgc3RyaW5nIGlzIFVSTFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmFsaWRhdGVVUkwoZSkge1xuICAgIHJldHVybiAhL1xccy8udGVzdChlKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBsaW5rIGJlZm9yZSBpbmplY3Rpb25cbiAgICogLSBzYW5pdGl6ZVxuICAgKiAtIGFkZCBwcm90b2NvbCBmb3IgbGlua3MgbGlrZSAnZ29vZ2xlLmNvbSdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmsgLSByYXcgdXNlciBpbnB1dFxuICAgKi9cbiAgcHJlcGFyZUxpbmsoZSkge1xuICAgIHJldHVybiBlID0gZS50cmltKCksIGUgPSB0aGlzLmFkZFByb3RvY29sKGUpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgJ2h0dHAnIHByb3RvY29sIHRvIHRoZSBsaW5rcyBsaWtlICd2Yy5ydScsICdnb29nbGUuY29tJ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluayAtIHN0cmluZyB0byBwcm9jZXNzXG4gICAqL1xuICBhZGRQcm90b2NvbChlKSB7XG4gICAgaWYgKC9eKFxcdyspOihcXC9cXC8pPy8udGVzdChlKSlcbiAgICAgIHJldHVybiBlO1xuICAgIGNvbnN0IHQgPSAvXlxcL1teL1xcc10vLnRlc3QoZSksIG8gPSBlLnN1YnN0cmluZygwLCAxKSA9PT0gXCIjXCIsIGkgPSAvXlxcL1xcL1teL1xcc10vLnRlc3QoZSk7XG4gICAgcmV0dXJuICF0ICYmICFvICYmICFpICYmIChlID0gXCJodHRwOi8vXCIgKyBlKSwgZTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyA8YT4gdGFnIHdpdGggXCJocmVmXCJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmsgLSBcImhyZWZcIiB2YWx1ZVxuICAgKi9cbiAgaW5zZXJ0TGluayhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2VsZWN0aW9uLmZpbmRQYXJlbnRUYWcoXCJBXCIpO1xuICAgIHQgJiYgdGhpcy5zZWxlY3Rpb24uZXhwYW5kVG9UYWcodCksIGRvY3VtZW50LmV4ZWNDb21tYW5kKHRoaXMuY29tbWFuZExpbmssICExLCBlKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyA8YT4gdGFnXG4gICAqL1xuICB1bmxpbmsoKSB7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kVW5saW5rKTtcbiAgfVxufVxucWUuaXNJbmxpbmUgPSAhMDtcbnFlLnRpdGxlID0gXCJMaW5rXCI7XG5jbGFzcyBTdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIHN0dWIgdG9vbCBkYXRhXG4gICAqIEBwYXJhbSBvcHRpb25zLmFwaSAtIEVkaXRvci5qcyBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogZSwgYXBpOiB0IH0pIHtcbiAgICB0aGlzLkNTUyA9IHtcbiAgICAgIHdyYXBwZXI6IFwiY2Utc3R1YlwiLFxuICAgICAgaW5mbzogXCJjZS1zdHViX19pbmZvXCIsXG4gICAgICB0aXRsZTogXCJjZS1zdHViX190aXRsZVwiLFxuICAgICAgc3VidGl0bGU6IFwiY2Utc3R1Yl9fc3VidGl0bGVcIlxuICAgIH0sIHRoaXMuYXBpID0gdCwgdGhpcy50aXRsZSA9IGUudGl0bGUgfHwgdGhpcy5hcGkuaTE4bi50KFwiRXJyb3JcIiksIHRoaXMuc3VidGl0bGUgPSB0aGlzLmFwaS5pMThuLnQoXCJUaGUgYmxvY2sgY2FuIG5vdCBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5LlwiKSwgdGhpcy5zYXZlZERhdGEgPSBlLnNhdmVkRGF0YSwgdGhpcy53cmFwcGVyID0gdGhpcy5tYWtlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc3R1YiBob2xkZXJcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLndyYXBwZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBvcmlnaW5hbCBUb29sIGRhdGFcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrVG9vbERhdGF9XG4gICAqL1xuICBzYXZlKCkge1xuICAgIHJldHVybiB0aGlzLnNhdmVkRGF0YTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIFRvb2wgaHRtbCBtYXJrdXBcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgbWFrZSgpIHtcbiAgICBjb25zdCBlID0gYy5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLndyYXBwZXIpLCB0ID0gVW8sIG8gPSBjLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MuaW5mbyksIGkgPSBjLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MudGl0bGUsIHtcbiAgICAgIHRleHRDb250ZW50OiB0aGlzLnRpdGxlXG4gICAgfSksIG4gPSBjLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1Muc3VidGl0bGUsIHtcbiAgICAgIHRleHRDb250ZW50OiB0aGlzLnN1YnRpdGxlXG4gICAgfSk7XG4gICAgcmV0dXJuIGUuaW5uZXJIVE1MID0gdCwgby5hcHBlbmRDaGlsZChpKSwgby5hcHBlbmRDaGlsZChuKSwgZS5hcHBlbmRDaGlsZChvKSwgZTtcbiAgfVxufVxuU3QuaXNSZWFkT25seVN1cHBvcnRlZCA9ICEwO1xuY2xhc3MgdWkgZXh0ZW5kcyBZZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IEJlLklubGluZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aXRsZSBmb3IgSW5saW5lIFRvb2wgaWYgc3BlY2lmaWVkIGJ5IHVzZXJcbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlW1dlLlRpdGxlXTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cyBuZXcgSW5saW5lVG9vbCBpbnN0YW5jZSBmcm9tIGNvbnN0cnVjdGFibGVcbiAgICovXG4gIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0YWJsZSh7XG4gICAgICBhcGk6IHRoaXMuYXBpLmdldE1ldGhvZHNGb3JUb29sKHRoaXMpLFxuICAgICAgY29uZmlnOiB0aGlzLnNldHRpbmdzXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIHBpIGV4dGVuZHMgWWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBCZS5UdW5lO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIG5ldyBCbG9ja1R1bmUgaW5zdGFuY2UgZnJvbSBjb25zdHJ1Y3RhYmxlXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gVHVuZSBkYXRhXG4gICAqIEBwYXJhbSBibG9jayAtIEJsb2NrIEFQSSBvYmplY3RcbiAgICovXG4gIGNyZWF0ZShlLCB0KSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdGFibGUoe1xuICAgICAgYXBpOiB0aGlzLmFwaS5nZXRNZXRob2RzRm9yVG9vbCh0aGlzKSxcbiAgICAgIGNvbmZpZzogdGhpcy5zZXR0aW5ncyxcbiAgICAgIGJsb2NrOiB0LFxuICAgICAgZGF0YTogZVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBQIGV4dGVuZHMgTWFwIHtcbiAgLyoqXG4gICAqIFJldHVybnMgQmxvY2sgVG9vbHMgY29sbGVjdGlvblxuICAgKi9cbiAgZ2V0IGJsb2NrVG9vbHMoKSB7XG4gICAgY29uc3QgZSA9IEFycmF5LmZyb20odGhpcy5lbnRyaWVzKCkpLmZpbHRlcigoWywgdF0pID0+IHQuaXNCbG9jaygpKTtcbiAgICByZXR1cm4gbmV3IFAoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgSW5saW5lIFRvb2xzIGNvbGxlY3Rpb25cbiAgICovXG4gIGdldCBpbmxpbmVUb29scygpIHtcbiAgICBjb25zdCBlID0gQXJyYXkuZnJvbSh0aGlzLmVudHJpZXMoKSkuZmlsdGVyKChbLCB0XSkgPT4gdC5pc0lubGluZSgpKTtcbiAgICByZXR1cm4gbmV3IFAoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgQmxvY2sgVHVuZXMgY29sbGVjdGlvblxuICAgKi9cbiAgZ2V0IGJsb2NrVHVuZXMoKSB7XG4gICAgY29uc3QgZSA9IEFycmF5LmZyb20odGhpcy5lbnRyaWVzKCkpLmZpbHRlcigoWywgdF0pID0+IHQuaXNUdW5lKCkpO1xuICAgIHJldHVybiBuZXcgUChlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpbnRlcm5hbCBUb29scyBjb2xsZWN0aW9uXG4gICAqL1xuICBnZXQgaW50ZXJuYWxUb29scygpIHtcbiAgICBjb25zdCBlID0gQXJyYXkuZnJvbSh0aGlzLmVudHJpZXMoKSkuZmlsdGVyKChbLCB0XSkgPT4gdC5pc0ludGVybmFsKTtcbiAgICByZXR1cm4gbmV3IFAoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbHMgY29sbGVjdGlvbiBwcm92aWRlZCBieSB1c2VyXG4gICAqL1xuICBnZXQgZXh0ZXJuYWxUb29scygpIHtcbiAgICBjb25zdCBlID0gQXJyYXkuZnJvbSh0aGlzLmVudHJpZXMoKSkuZmlsdGVyKChbLCB0XSkgPT4gIXQuaXNJbnRlcm5hbCk7XG4gICAgcmV0dXJuIG5ldyBQKGUpO1xuICB9XG59XG52YXIgZmkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGdpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwgSXQgPSAocywgZSwgdCwgbykgPT4ge1xuICBmb3IgKHZhciBpID0gbyA+IDEgPyB2b2lkIDAgOiBvID8gZ2koZSwgdCkgOiBlLCBuID0gcy5sZW5ndGggLSAxLCByOyBuID49IDA7IG4tLSlcbiAgICAociA9IHNbbl0pICYmIChpID0gKG8gPyByKGUsIHQsIGkpIDogcihpKSkgfHwgaSk7XG4gIHJldHVybiBvICYmIGkgJiYgZmkoZSwgdCwgaSksIGk7XG59O1xuY2xhc3MgWmUgZXh0ZW5kcyBZZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IEJlLkJsb2NrLCB0aGlzLmlubGluZVRvb2xzID0gbmV3IFAoKSwgdGhpcy50dW5lcyA9IG5ldyBQKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgbmV3IFRvb2wgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBUb29sIGRhdGFcbiAgICogQHBhcmFtIGJsb2NrIC0gQmxvY2tBUEkgZm9yIGN1cnJlbnQgQmxvY2tcbiAgICogQHBhcmFtIHJlYWRPbmx5IC0gVHJ1ZSBpZiBFZGl0b3IgaXMgaW4gcmVhZC1vbmx5IG1vZGVcbiAgICovXG4gIGNyZWF0ZShlLCB0LCBvKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdGFibGUoe1xuICAgICAgZGF0YTogZSxcbiAgICAgIGJsb2NrOiB0LFxuICAgICAgcmVhZE9ubHk6IG8sXG4gICAgICBhcGk6IHRoaXMuYXBpLmdldE1ldGhvZHNGb3JUb29sKHRoaXMpLFxuICAgICAgY29uZmlnOiB0aGlzLnNldHRpbmdzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiByZWFkLW9ubHkgbW9kZSBpcyBzdXBwb3J0ZWQgYnkgVG9vbFxuICAgKi9cbiAgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZVtzZS5Jc1JlYWRPbmx5U3VwcG9ydGVkXSA9PT0gITA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBUb29sIHN1cHBvcnRzIGxpbmVicmVha3NcbiAgICovXG4gIGdldCBpc0xpbmVCcmVha3NFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGVbc2UuSXNFbmFibGVkTGluZUJyZWFrc107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCB0b29sYm94IGNvbmZpZ3VyYXRpb24gKGludGVybmFsIG9yIHVzZXItc3BlY2lmaWVkKS5cbiAgICpcbiAgICogTWVyZ2VzIGludGVybmFsIGFuZCB1c2VyLWRlZmluZWQgdG9vbGJveCBjb25maWdzIGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgcnVsZXM6XG4gICAqXG4gICAqIC0gSWYgYm90aCBpbnRlcm5hbCBhbmQgdXNlci1kZWZpbmVkIHRvb2xib3ggY29uZmlncyBhcmUgYXJyYXlzIHRoZWlyIGl0ZW1zIGFyZSBtZXJnZWQuXG4gICAqIExlbmd0aCBvZiB0aGUgc2Vjb25kIG9uZSBpcyBrZXB0LlxuICAgKlxuICAgKiAtIElmIGJvdGggYXJlIG9iamVjdHMgdGhlaXIgcHJvcGVydGllcyBhcmUgbWVyZ2VkLlxuICAgKlxuICAgKiAtIElmIG9uZSBpcyBhbiBvYmplY3QgYW5kIGFub3RoZXIgaXMgYW4gYXJyYXkgdGhhbiBpbnRlcm5hbCBjb25maWcgaXMgcmVwbGFjZWQgd2l0aCB1c2VyLWRlZmluZWRcbiAgICogY29uZmlnLiBUaGlzIGlzIG1hZGUgdG8gYWxsb3cgdXNlciB0byBvdmVycmlkZSBkZWZhdWx0IHRvb2wncyB0b29sYm94IHJlcHJlc2VudGF0aW9uIChzaW5nbGUvbXVsdGlwbGUgZW50cmllcylcbiAgICovXG4gIGdldCB0b29sYm94KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbnN0cnVjdGFibGVbc2UuVG9vbGJveF0sIHQgPSB0aGlzLmNvbmZpZ1t2ZS5Ub29sYm94XTtcbiAgICBpZiAoIVcoZSkgJiYgdCAhPT0gITEpXG4gICAgICByZXR1cm4gdCA/IEFycmF5LmlzQXJyYXkoZSkgPyBBcnJheS5pc0FycmF5KHQpID8gdC5tYXAoKG8sIGkpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IGVbaV07XG4gICAgICAgIHJldHVybiBuID8ge1xuICAgICAgICAgIC4uLm4sXG4gICAgICAgICAgLi4ub1xuICAgICAgICB9IDogbztcbiAgICAgIH0pIDogW3RdIDogQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5lLFxuICAgICAgICAgIC4uLnRcbiAgICAgICAgfVxuICAgICAgXSA6IEFycmF5LmlzQXJyYXkoZSkgPyBlIDogW2VdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRvb2wgY29udmVyc2lvbiBjb25maWd1cmF0aW9uXG4gICAqL1xuICBnZXQgY29udmVyc2lvbkNvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlW3NlLkNvbnZlcnNpb25Db25maWddO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGVuYWJsZWQgaW5saW5lIHRvb2xzIGZvciBUb29sXG4gICAqL1xuICBnZXQgZW5hYmxlZElubGluZVRvb2xzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZ1t2ZS5FbmFibGVkSW5saW5lVG9vbHNdIHx8ICExO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGVuYWJsZWQgdHVuZXMgZm9yIFRvb2xcbiAgICovXG4gIGdldCBlbmFibGVkQmxvY2tUdW5lcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWdbdmUuRW5hYmxlZEJsb2NrVHVuZXNdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRvb2wgcGFzdGUgY29uZmlndXJhdGlvblxuICAgKi9cbiAgZ2V0IHBhc3RlQ29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGVbc2UuUGFzdGVDb25maWddID8/IHt9O1xuICB9XG4gIGdldCBzYW5pdGl6ZUNvbmZpZygpIHtcbiAgICBjb25zdCBlID0gc3VwZXIuc2FuaXRpemVDb25maWcsIHQgPSB0aGlzLmJhc2VTYW5pdGl6ZUNvbmZpZztcbiAgICBpZiAoVyhlKSlcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IG8gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gZSlcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgaSkpIHtcbiAgICAgICAgY29uc3QgbiA9IGVbaV07XG4gICAgICAgIEQobikgPyBvW2ldID0gT2JqZWN0LmFzc2lnbih7fSwgdCwgbikgOiBvW2ldID0gbjtcbiAgICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuICBnZXQgYmFzZVNhbml0aXplQ29uZmlnKCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmlubGluZVRvb2xzLnZhbHVlcygpKS5mb3JFYWNoKCh0KSA9PiBPYmplY3QuYXNzaWduKGUsIHQuc2FuaXRpemVDb25maWcpKSwgQXJyYXkuZnJvbSh0aGlzLnR1bmVzLnZhbHVlcygpKS5mb3JFYWNoKCh0KSA9PiBPYmplY3QuYXNzaWduKGUsIHQuc2FuaXRpemVDb25maWcpKSwgZTtcbiAgfVxufVxuSXQoW1xuICBsZVxuXSwgWmUucHJvdG90eXBlLCBcInNhbml0aXplQ29uZmlnXCIsIDEpO1xuSXQoW1xuICBsZVxuXSwgWmUucHJvdG90eXBlLCBcImJhc2VTYW5pdGl6ZUNvbmZpZ1wiLCAxKTtcbmNsYXNzIGJpIHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0gY29uZmlnIC0gdG9vbHMgY29uZmlnXG4gICAqIEBwYXJhbSBlZGl0b3JDb25maWcgLSBFZGl0b3JKUyBjb25maWdcbiAgICogQHBhcmFtIGFwaSAtIEVkaXRvckpTIEFQSSBtb2R1bGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQsIG8pIHtcbiAgICB0aGlzLmFwaSA9IG8sIHRoaXMuY29uZmlnID0gZSwgdGhpcy5lZGl0b3JDb25maWcgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRvb2wgb2JqZWN0IGJhc2VkIG9uIGl0J3MgdHlwZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIHRvb2wgbmFtZVxuICAgKi9cbiAgZ2V0KGUpIHtcbiAgICBjb25zdCB7IGNsYXNzOiB0LCBpc0ludGVybmFsOiBvID0gITEsIC4uLmkgfSA9IHRoaXMuY29uZmlnW2VdLCBuID0gdGhpcy5nZXRDb25zdHJ1Y3Rvcih0KTtcbiAgICByZXR1cm4gbmV3IG4oe1xuICAgICAgbmFtZTogZSxcbiAgICAgIGNvbnN0cnVjdGFibGU6IHQsXG4gICAgICBjb25maWc6IGksXG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgaXNEZWZhdWx0OiBlID09PSB0aGlzLmVkaXRvckNvbmZpZy5kZWZhdWx0QmxvY2ssXG4gICAgICBkZWZhdWx0UGxhY2Vob2xkZXI6IHRoaXMuZWRpdG9yQ29uZmlnLnBsYWNlaG9sZGVyLFxuICAgICAgaXNJbnRlcm5hbDogb1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGFwcHJvcHJpYXRlIFRvb2wgb2JqZWN0IGNvbnN0cnVjdG9yIGZvciBUb29sIGNvbnN0cnVjdGFibGVcbiAgICpcbiAgICogQHBhcmFtIGNvbnN0cnVjdGFibGUgLSBUb29scyBjb25zdHJ1Y3RhYmxlXG4gICAqL1xuICBnZXRDb25zdHJ1Y3RvcihlKSB7XG4gICAgc3dpdGNoICghMCkge1xuICAgICAgY2FzZSBlW1dlLklzSW5saW5lXTpcbiAgICAgICAgcmV0dXJuIHVpO1xuICAgICAgY2FzZSBlW0J0LklzVHVuZV06XG4gICAgICAgIHJldHVybiBwaTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaZTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIE10IHtcbiAgLyoqXG4gICAqIE1vdmVEb3duVHVuZSBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge0FQSX0gYXBpIOKAlCBFZGl0b3IncyBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpOiBlIH0pIHtcbiAgICB0aGlzLkNTUyA9IHtcbiAgICAgIGFuaW1hdGlvbjogXCJ3b2JibGVcIlxuICAgIH0sIHRoaXMuYXBpID0gZTtcbiAgfVxuICAvKipcbiAgICogVHVuZSdzIGFwcGVhcmFuY2UgaW4gYmxvY2sgc2V0dGluZ3MgbWVudVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBrdCxcbiAgICAgIHRpdGxlOiB0aGlzLmFwaS5pMThuLnQoXCJNb3ZlIGRvd25cIiksXG4gICAgICBvbkFjdGl2YXRlOiAoKSA9PiB0aGlzLmhhbmRsZUNsaWNrKCksXG4gICAgICBuYW1lOiBcIm1vdmUtZG93blwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGNsaWNrcyBvbiAnbW92ZSBkb3duJyBidXR0b25cbiAgICovXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSwgdCA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRCbG9ja0J5SW5kZXgoZSArIDEpO1xuICAgIGlmICghdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBtb3ZlIEJsb2NrIGRvd24gc2luY2UgaXQgaXMgYWxyZWFkeSB0aGUgbGFzdFwiKTtcbiAgICBjb25zdCBvID0gdC5ob2xkZXIsIGkgPSBvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBuID0gTWF0aC5hYnMod2luZG93LmlubmVySGVpZ2h0IC0gby5vZmZzZXRIZWlnaHQpO1xuICAgIGkudG9wIDwgd2luZG93LmlubmVySGVpZ2h0ICYmIChuID0gd2luZG93LnNjcm9sbFkgKyBvLm9mZnNldEhlaWdodCksIHdpbmRvdy5zY3JvbGxUbygwLCBuKSwgdGhpcy5hcGkuYmxvY2tzLm1vdmUoZSArIDEpLCB0aGlzLmFwaS50b29sYmFyLnRvZ2dsZUJsb2NrU2V0dGluZ3MoITApO1xuICB9XG59XG5NdC5pc1R1bmUgPSAhMDtcbmNsYXNzIEx0IHtcbiAgLyoqXG4gICAqIERlbGV0ZVR1bmUgY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtBUEl9IGFwaSAtIEVkaXRvcidzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGk6IGUgfSkge1xuICAgIHRoaXMuYXBpID0gZTtcbiAgfVxuICAvKipcbiAgICogVHVuZSdzIGFwcGVhcmFuY2UgaW4gYmxvY2sgc2V0dGluZ3MgbWVudVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBObyxcbiAgICAgIHRpdGxlOiB0aGlzLmFwaS5pMThuLnQoXCJEZWxldGVcIiksXG4gICAgICBuYW1lOiBcImRlbGV0ZVwiLFxuICAgICAgY29uZmlybWF0aW9uOiB7XG4gICAgICAgIHRpdGxlOiB0aGlzLmFwaS5pMThuLnQoXCJDbGljayB0byBkZWxldGVcIiksXG4gICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHRoaXMuaGFuZGxlQ2xpY2soKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBibG9jayBjb25kaXRpb25zIHBhc3NlZFxuICAgKi9cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgdGhpcy5hcGkuYmxvY2tzLmRlbGV0ZSgpO1xuICB9XG59XG5MdC5pc1R1bmUgPSAhMDtcbmNsYXNzIEF0IHtcbiAgLyoqXG4gICAqIE1vdmVVcFR1bmUgY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtBUEl9IGFwaSAtIEVkaXRvcidzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGk6IGUgfSkge1xuICAgIHRoaXMuQ1NTID0ge1xuICAgICAgYW5pbWF0aW9uOiBcIndvYmJsZVwiXG4gICAgfSwgdGhpcy5hcGkgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBUdW5lJ3MgYXBwZWFyYW5jZSBpbiBibG9jayBzZXR0aW5ncyBtZW51XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IE9vLFxuICAgICAgdGl0bGU6IHRoaXMuYXBpLmkxOG4udChcIk1vdmUgdXBcIiksXG4gICAgICBvbkFjdGl2YXRlOiAoKSA9PiB0aGlzLmhhbmRsZUNsaWNrKCksXG4gICAgICBuYW1lOiBcIm1vdmUtdXBcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgY3VycmVudCBibG9jayB1cFxuICAgKi9cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRDdXJyZW50QmxvY2tJbmRleCgpLCB0ID0gdGhpcy5hcGkuYmxvY2tzLmdldEJsb2NrQnlJbmRleChlKSwgbyA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRCbG9ja0J5SW5kZXgoZSAtIDEpO1xuICAgIGlmIChlID09PSAwIHx8ICF0IHx8ICFvKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIG1vdmUgQmxvY2sgdXAgc2luY2UgaXQgaXMgYWxyZWFkeSB0aGUgZmlyc3RcIik7XG4gICAgY29uc3QgaSA9IHQuaG9sZGVyLCBuID0gby5ob2xkZXIsIHIgPSBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBhID0gbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgbDtcbiAgICBhLnRvcCA+IDAgPyBsID0gTWF0aC5hYnMoci50b3ApIC0gTWF0aC5hYnMoYS50b3ApIDogbCA9IE1hdGguYWJzKHIudG9wKSArIGEuaGVpZ2h0LCB3aW5kb3cuc2Nyb2xsQnkoMCwgLTEgKiBsKSwgdGhpcy5hcGkuYmxvY2tzLm1vdmUoZSAtIDEpLCB0aGlzLmFwaS50b29sYmFyLnRvZ2dsZUJsb2NrU2V0dGluZ3MoITApO1xuICB9XG59XG5BdC5pc1R1bmUgPSAhMDtcbnZhciBtaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwga2kgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCB2aSA9IChzLCBlLCB0LCBvKSA9PiB7XG4gIGZvciAodmFyIGkgPSBvID4gMSA/IHZvaWQgMCA6IG8gPyBraShlLCB0KSA6IGUsIG4gPSBzLmxlbmd0aCAtIDEsIHI7IG4gPj0gMDsgbi0tKVxuICAgIChyID0gc1tuXSkgJiYgKGkgPSAobyA/IHIoZSwgdCwgaSkgOiByKGkpKSB8fCBpKTtcbiAgcmV0dXJuIG8gJiYgaSAmJiBtaShlLCB0LCBpKSwgaTtcbn07XG5jbGFzcyBfdCBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnN0dWJUb29sID0gXCJzdHViXCIsIHRoaXMudG9vbHNBdmFpbGFibGUgPSBuZXcgUCgpLCB0aGlzLnRvb2xzVW5hdmFpbGFibGUgPSBuZXcgUCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGF2YWlsYWJsZSBUb29sc1xuICAgKi9cbiAgZ2V0IGF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sc0F2YWlsYWJsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB1bmF2YWlsYWJsZSBUb29sc1xuICAgKi9cbiAgZ2V0IHVuYXZhaWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xzVW5hdmFpbGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBUb29scyBmb3IgdGhlIElubGluZSBUb29sYmFyXG4gICAqL1xuICBnZXQgaW5saW5lVG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlLmlubGluZVRvb2xzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZWRpdG9yIGJsb2NrIHRvb2xzXG4gICAqL1xuICBnZXQgYmxvY2tUb29scygpIHtcbiAgICByZXR1cm4gdGhpcy5hdmFpbGFibGUuYmxvY2tUb29scztcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGF2YWlsYWJsZSBCbG9jayBUdW5lc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtIG9iamVjdCBvZiBJbmxpbmUgVG9vbCdzIGNsYXNzZXNcbiAgICovXG4gIGdldCBibG9ja1R1bmVzKCkge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZS5ibG9ja1R1bmVzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGRlZmF1bHQgVG9vbCBvYmplY3RcbiAgICovXG4gIGdldCBkZWZhdWx0VG9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja1Rvb2xzLmdldCh0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2spO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGludGVybmFsIHRvb2xzXG4gICAqL1xuICBnZXQgaW50ZXJuYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlLmludGVybmFsVG9vbHM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgaW5zdGFuY2VzIHZpYSBwYXNzZWQgb3IgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgcHJlcGFyZSgpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0ZVRvb2xzKCksIHRoaXMuY29uZmlnLnRvb2xzID0gTWUoe30sIHRoaXMuaW50ZXJuYWxUb29scywgdGhpcy5jb25maWcudG9vbHMpLCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29uZmlnLCBcInRvb2xzXCIpIHx8IE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLnRvb2xzKS5sZW5ndGggPT09IDApXG4gICAgICB0aHJvdyBFcnJvcihcIkNhbid0IHN0YXJ0IHdpdGhvdXQgdG9vbHNcIik7XG4gICAgY29uc3QgZSA9IHRoaXMucHJlcGFyZUNvbmZpZygpO1xuICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBiaShlLCB0aGlzLmNvbmZpZywgdGhpcy5FZGl0b3IuQVBJKTtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRMaXN0T2ZQcmVwYXJlRnVuY3Rpb25zKGUpO1xuICAgIGlmICh0Lmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBhd2FpdCB6dCh0LCAobykgPT4ge1xuICAgICAgdGhpcy50b29sUHJlcGFyZU1ldGhvZFN1Y2Nlc3Mobyk7XG4gICAgfSwgKG8pID0+IHtcbiAgICAgIHRoaXMudG9vbFByZXBhcmVNZXRob2RGYWxsYmFjayhvKTtcbiAgICB9KSwgdGhpcy5wcmVwYXJlQmxvY2tUb29scygpO1xuICB9XG4gIGdldEFsbElubGluZVRvb2xzU2FuaXRpemVDb25maWcoKSB7XG4gICAgY29uc3QgZSA9IHt9O1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuaW5saW5lVG9vbHMudmFsdWVzKCkpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZSwgdC5zYW5pdGl6ZUNvbmZpZyk7XG4gICAgfSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxzIGVhY2ggVG9vbCByZXNldCBtZXRob2QgdG8gY2xlYW4gdXAgYW55dGhpbmcgc2V0IGJ5IFRvb2xcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLmF2YWlsYWJsZSkuZm9yRWFjaChhc3luYyAoZSkgPT4ge1xuICAgICAgTShlLnJlc2V0KSAmJiBhd2FpdCBlLnJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaW50ZXJuYWwgdG9vbHNcbiAgICogSW5jbHVkZXMgQm9sZCwgSXRhbGljLCBMaW5rIGFuZCBQYXJhZ3JhcGhcbiAgICovXG4gIGdldCBpbnRlcm5hbFRvb2xzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBib2xkOiB7XG4gICAgICAgIGNsYXNzOiBYZSxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBpdGFsaWM6IHtcbiAgICAgICAgY2xhc3M6IFZlLFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfSxcbiAgICAgIGxpbms6IHtcbiAgICAgICAgY2xhc3M6IHFlLFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfSxcbiAgICAgIHBhcmFncmFwaDoge1xuICAgICAgICBjbGFzczogS2UsXG4gICAgICAgIGlubGluZVRvb2xiYXI6ICEwLFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfSxcbiAgICAgIHN0dWI6IHtcbiAgICAgICAgY2xhc3M6IFN0LFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfSxcbiAgICAgIG1vdmVVcDoge1xuICAgICAgICBjbGFzczogQXQsXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgZGVsZXRlOiB7XG4gICAgICAgIGNsYXNzOiBMdCxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBtb3ZlRG93bjoge1xuICAgICAgICBjbGFzczogTXQsXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVG9vbCBwcmVwYXJlIG1ldGhvZCBzdWNjZXNzIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gYXBwZW5kIHRvb2wgdG8gYXZhaWxhYmxlIGxpc3RcbiAgICovXG4gIHRvb2xQcmVwYXJlTWV0aG9kU3VjY2VzcyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZmFjdG9yeS5nZXQoZS50b29sTmFtZSk7XG4gICAgaWYgKHQuaXNJbmxpbmUoKSkge1xuICAgICAgY29uc3QgaSA9IFtcInJlbmRlclwiLCBcInN1cnJvdW5kXCIsIFwiY2hlY2tTdGF0ZVwiXS5maWx0ZXIoKG4pID0+ICF0LmNyZWF0ZSgpW25dKTtcbiAgICAgIGlmIChpLmxlbmd0aCkge1xuICAgICAgICBUKFxuICAgICAgICAgIGBJbmNvcnJlY3QgSW5saW5lIFRvb2w6ICR7dC5uYW1lfS4gU29tZSBvZiByZXF1aXJlZCBtZXRob2RzIGlzIG5vdCBpbXBsZW1lbnRlZCAlb2AsXG4gICAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgICAgaVxuICAgICAgICApLCB0aGlzLnRvb2xzVW5hdmFpbGFibGUuc2V0KHQubmFtZSwgdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50b29sc0F2YWlsYWJsZS5zZXQodC5uYW1lLCB0KTtcbiAgfVxuICAvKipcbiAgICogVG9vbCBwcmVwYXJlIG1ldGhvZCBmYWlsIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gYXBwZW5kIHRvb2wgdG8gdW5hdmFpbGFibGUgbGlzdFxuICAgKi9cbiAgdG9vbFByZXBhcmVNZXRob2RGYWxsYmFjayhlKSB7XG4gICAgdGhpcy50b29sc1VuYXZhaWxhYmxlLnNldChlLnRvb2xOYW1lLCB0aGlzLmZhY3RvcnkuZ2V0KGUudG9vbE5hbWUpKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgcHJlcGFyZSBmdW5jdGlvbiBvZiBwbHVnaW5zIHdpdGggdXNlciBvciBkZWZhdWx0IGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGxpc3Qgb2YgZnVuY3Rpb25zIHRoYXQgbmVlZHMgdG8gYmUgZmlyZWQgc2VxdWVudGlhbGx5XG4gICAqIEBwYXJhbSBjb25maWcgLSB0b29scyBjb25maWdcbiAgICovXG4gIGdldExpc3RPZlByZXBhcmVGdW5jdGlvbnMoZSkge1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW28sIGldKSA9PiB7XG4gICAgICB0LnB1c2goe1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgICAgIGZ1bmN0aW9uOiBNKGkuY2xhc3MucHJlcGFyZSkgPyBpLmNsYXNzLnByZXBhcmUgOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0b29sTmFtZTogbyxcbiAgICAgICAgICBjb25maWc6IGkuY29uZmlnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLCB0O1xuICB9XG4gIC8qKlxuICAgKiBBc3NpZ24gZW5hYmxlZCBJbmxpbmUgVG9vbHMgYW5kIEJsb2NrIFR1bmVzIGZvciBCbG9jayBUb29sXG4gICAqL1xuICBwcmVwYXJlQmxvY2tUb29scygpIHtcbiAgICBBcnJheS5mcm9tKHRoaXMuYmxvY2tUb29scy52YWx1ZXMoKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5hc3NpZ25JbmxpbmVUb29sc1RvQmxvY2tUb29sKGUpLCB0aGlzLmFzc2lnbkJsb2NrVHVuZXNUb0Jsb2NrVG9vbChlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXNzaWduIGVuYWJsZWQgSW5saW5lIFRvb2xzIGZvciBCbG9jayBUb29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gQmxvY2sgVG9vbFxuICAgKi9cbiAgYXNzaWduSW5saW5lVG9vbHNUb0Jsb2NrVG9vbChlKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIgIT09ICExKSB7XG4gICAgICBpZiAoZS5lbmFibGVkSW5saW5lVG9vbHMgPT09ICEwKSB7XG4gICAgICAgIGUuaW5saW5lVG9vbHMgPSBuZXcgUChcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIpID8gdGhpcy5jb25maWcuaW5saW5lVG9vbGJhci5tYXAoKHQpID0+IFt0LCB0aGlzLmlubGluZVRvb2xzLmdldCh0KV0pIDogQXJyYXkuZnJvbSh0aGlzLmlubGluZVRvb2xzLmVudHJpZXMoKSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgQXJyYXkuaXNBcnJheShlLmVuYWJsZWRJbmxpbmVUb29scykgJiYgKGUuaW5saW5lVG9vbHMgPSBuZXcgUChcbiAgICAgICAgZS5lbmFibGVkSW5saW5lVG9vbHMubWFwKCh0KSA9PiBbdCwgdGhpcy5pbmxpbmVUb29scy5nZXQodCldKVxuICAgICAgKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBc3NpZ24gZW5hYmxlZCBCbG9jayBUdW5lcyBmb3IgQmxvY2sgVG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCDigJQgQmxvY2sgVG9vbFxuICAgKi9cbiAgYXNzaWduQmxvY2tUdW5lc1RvQmxvY2tUb29sKGUpIHtcbiAgICBpZiAoZS5lbmFibGVkQmxvY2tUdW5lcyAhPT0gITEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGUuZW5hYmxlZEJsb2NrVHVuZXMpKSB7XG4gICAgICAgIGNvbnN0IHQgPSBuZXcgUChcbiAgICAgICAgICBlLmVuYWJsZWRCbG9ja1R1bmVzLm1hcCgobykgPT4gW28sIHRoaXMuYmxvY2tUdW5lcy5nZXQobyldKVxuICAgICAgICApO1xuICAgICAgICBlLnR1bmVzID0gbmV3IFAoWy4uLnQsIC4uLnRoaXMuYmxvY2tUdW5lcy5pbnRlcm5hbFRvb2xzXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29uZmlnLnR1bmVzKSkge1xuICAgICAgICBjb25zdCB0ID0gbmV3IFAoXG4gICAgICAgICAgdGhpcy5jb25maWcudHVuZXMubWFwKChvKSA9PiBbbywgdGhpcy5ibG9ja1R1bmVzLmdldChvKV0pXG4gICAgICAgICk7XG4gICAgICAgIGUudHVuZXMgPSBuZXcgUChbLi4udCwgLi4udGhpcy5ibG9ja1R1bmVzLmludGVybmFsVG9vbHNdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS50dW5lcyA9IHRoaXMuYmxvY2tUdW5lcy5pbnRlcm5hbFRvb2xzO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgVG9vbHMgY29uZmlndXJhdGlvbiBvYmplY3RzIGFuZCB0aHJvdyBFcnJvciBmb3IgdXNlciBpZiBpdCBpcyBpbnZhbGlkXG4gICAqL1xuICB2YWxpZGF0ZVRvb2xzKCkge1xuICAgIGZvciAoY29uc3QgZSBpbiB0aGlzLmNvbmZpZy50b29scylcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb25maWcudG9vbHMsIGUpKSB7XG4gICAgICAgIGlmIChlIGluIHRoaXMuaW50ZXJuYWxUb29scylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbmZpZy50b29sc1tlXTtcbiAgICAgICAgaWYgKCFNKHQpICYmICFNKHQuY2xhc3MpKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgYFRvb2wgwqske2V9wrsgbXVzdCBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGZ1bmN0aW9uIGluIHRoZSDCq2NsYXNzwrsgcHJvcGVydHlgXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogVW5pZnkgdG9vbHMgY29uZmlnXG4gICAqL1xuICBwcmVwYXJlQ29uZmlnKCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdGhpcy5jb25maWcudG9vbHMpXG4gICAgICBEKHRoaXMuY29uZmlnLnRvb2xzW3RdKSA/IGVbdF0gPSB0aGlzLmNvbmZpZy50b29sc1t0XSA6IGVbdF0gPSB7IGNsYXNzOiB0aGlzLmNvbmZpZy50b29sc1t0XSB9O1xuICAgIHJldHVybiBlO1xuICB9XG59XG52aShbXG4gIGxlXG5dLCBfdC5wcm90b3R5cGUsIFwiZ2V0QWxsSW5saW5lVG9vbHNTYW5pdGl6ZUNvbmZpZ1wiLCAxKTtcbmNvbnN0IHhpID0gYDpyb290ey0tc2VsZWN0aW9uQ29sb3I6ICNlMWYyZmY7LS1pbmxpbmVTZWxlY3Rpb25Db2xvcjogI2Q0ZWNmZjstLWJnLWxpZ2h0OiAjZWZmMmY1Oy0tZ3JheVRleHQ6ICM3MDc2ODQ7LS1jb2xvci1kYXJrOiAjMUQyMDJCOy0tY29sb3ItYWN0aXZlLWljb246ICMzODhBRTU7LS1jb2xvci1ncmF5LWJvcmRlcjogcmdiYSgyMDEsIDIwMSwgMjA0LCAuNDgpOy0tY29udGVudC13aWR0aDogNjUwcHg7LS1uYXJyb3ctbW9kZS1yaWdodC1wYWRkaW5nOiA1MHB4Oy0tdG9vbGJveC1idXR0b25zLXNpemU6IDI2cHg7LS10b29sYm94LWJ1dHRvbnMtc2l6ZS0tbW9iaWxlOiAzNnB4Oy0taWNvbi1zaXplOiAyMHB4Oy0taWNvbi1zaXplLS1tb2JpbGU6IDI4cHg7LS1ibG9jay1wYWRkaW5nLXZlcnRpY2FsOiAuNGVtOy0tY29sb3ItbGluZS1ncmF5OiAjRUZGMEYxIH0uY29kZXgtZWRpdG9ye3Bvc2l0aW9uOnJlbGF0aXZlOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDt6LWluZGV4OjF9LmNvZGV4LWVkaXRvciAuaGlkZXtkaXNwbGF5Om5vbmV9LmNvZGV4LWVkaXRvcl9fcmVkYWN0b3IgW2NvbnRlbnRlZGl0YWJsZV06ZW1wdHk6YWZ0ZXJ7Y29udGVudDpcIlxcXFxmZWZmXCJ9QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY29kZXgtZWRpdG9yLS1uYXJyb3cgLmNvZGV4LWVkaXRvcl9fcmVkYWN0b3J7bWFyZ2luLXJpZ2h0OjUwcHh9fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93LmNvZGV4LWVkaXRvci0tcnRsIC5jb2RleC1lZGl0b3JfX3JlZGFjdG9ye21hcmdpbi1sZWZ0OjUwcHg7bWFyZ2luLXJpZ2h0OjB9fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93IC5jZS10b29sYmFyX19hY3Rpb25ze3JpZ2h0Oi01cHh9fS5jb2RleC1lZGl0b3ItY29weWFibGV7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjFweDt3aWR0aDoxcHg7dG9wOi00MDAlO29wYWNpdHk6LjAwMX0uY29kZXgtZWRpdG9yLW92ZXJsYXl7cG9zaXRpb246Zml4ZWQ7dG9wOjBweDtsZWZ0OjBweDtyaWdodDowcHg7Ym90dG9tOjBweDt6LWluZGV4Ojk5OTtwb2ludGVyLWV2ZW50czpub25lO292ZXJmbG93OmhpZGRlbn0uY29kZXgtZWRpdG9yLW92ZXJsYXlfX2NvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZTtwb2ludGVyLWV2ZW50czphdXRvO3otaW5kZXg6MH0uY29kZXgtZWRpdG9yLW92ZXJsYXlfX3JlY3RhbmdsZXtwb3NpdGlvbjphYnNvbHV0ZTtwb2ludGVyLWV2ZW50czpub25lO2JhY2tncm91bmQtY29sb3I6IzJlYWFkYzMzO2JvcmRlcjoxcHggc29saWQgdHJhbnNwYXJlbnR9LmNvZGV4LWVkaXRvciBzdmd7bWF4LWhlaWdodDoxMDAlfS5jb2RleC1lZGl0b3IgcGF0aHtzdHJva2U6Y3VycmVudENvbG9yfS5jb2RleC1lZGl0b3IgOjotbW96LXNlbGVjdGlvbntiYWNrZ3JvdW5kLWNvbG9yOiNkNGVjZmZ9LmNvZGV4LWVkaXRvciA6OnNlbGVjdGlvbntiYWNrZ3JvdW5kLWNvbG9yOiNkNGVjZmZ9LmNvZGV4LWVkaXRvci0tdG9vbGJveC1vcGVuZWQgW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTpmb2N1czpiZWZvcmV7b3BhY2l0eTowIWltcG9ydGFudH0uY2Utc2Nyb2xsLWxvY2tlZHtvdmVyZmxvdzpoaWRkZW59LmNlLXNjcm9sbC1sb2NrZWQtLWhhcmR7b3ZlcmZsb3c6aGlkZGVuO3RvcDpjYWxjKC0xICogdmFyKC0td2luZG93LXNjcm9sbC1vZmZzZXQpKTtwb3NpdGlvbjpmaXhlZDt3aWR0aDoxMDAlfS5jZS10b29sYmFye3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDtyaWdodDowO3RvcDowOy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlO3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZTt3aWxsLWNoYW5nZTpvcGFjaXR5LHRvcDtkaXNwbGF5Om5vbmV9LmNlLXRvb2xiYXItLW9wZW5lZHtkaXNwbGF5OmJsb2NrfS5jZS10b29sYmFyX19jb250ZW50e21heC13aWR0aDo2NTBweDttYXJnaW46MCBhdXRvO3Bvc2l0aW9uOnJlbGF0aXZlfS5jZS10b29sYmFyX19wbHVze2NvbG9yOiMxZDIwMmI7Y3Vyc29yOnBvaW50ZXI7d2lkdGg6MjZweDtoZWlnaHQ6MjZweDtib3JkZXItcmFkaXVzOjdweDtkaXNwbGF5Oi13ZWJraXQtaW5saW5lLWJveDtkaXNwbGF5Oi1tcy1pbmxpbmUtZmxleGJveDtkaXNwbGF5OmlubGluZS1mbGV4Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lOy1tcy1mbGV4LW5lZ2F0aXZlOjA7ZmxleC1zaHJpbms6MH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS10b29sYmFyX19wbHVze3dpZHRoOjM2cHg7aGVpZ2h0OjM2cHh9fUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2UtdG9vbGJhcl9fcGx1czpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjV9fS5jZS10b29sYmFyX19wbHVzLS1hY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojZWZmMmY1Oy13ZWJraXQtYW5pbWF0aW9uOmJvdW5jZUluIC43NXMgMTthbmltYXRpb246Ym91bmNlSW4gLjc1cyAxOy13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTpmb3J3YXJkczthbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzfS5jZS10b29sYmFyX19wbHVzLXNob3J0Y3V0e29wYWNpdHk6LjY7d29yZC1zcGFjaW5nOi0ycHg7bWFyZ2luLXRvcDo1cHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtdG9vbGJhcl9fcGx1c3twb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjRThFOEVCOy13ZWJraXQtYm94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggcmdiYSgxMywyMCwzMywuMTMpO2JveC1zaGFkb3c6MCAzcHggMTVweCAtM3B4ICMwZDE0MjEyMTtib3JkZXItcmFkaXVzOjZweDt6LWluZGV4OjI7cG9zaXRpb246c3RhdGljfS5jZS10b29sYmFyX19wbHVzLS1sZWZ0LW9yaWVudGVkOmJlZm9yZXtsZWZ0OjE1cHg7bWFyZ2luLWxlZnQ6MH0uY2UtdG9vbGJhcl9fcGx1cy0tcmlnaHQtb3JpZW50ZWQ6YmVmb3Jle2xlZnQ6YXV0bztyaWdodDoxNXB4O21hcmdpbi1sZWZ0OjB9fS5jZS10b29sYmFyX19hY3Rpb25ze3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjEwMCU7b3BhY2l0eTowO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7cGFkZGluZy1yaWdodDo1cHh9LmNlLXRvb2xiYXJfX2FjdGlvbnMtLW9wZW5lZHtvcGFjaXR5OjF9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtdG9vbGJhcl9fYWN0aW9uc3tyaWdodDphdXRvfX0uY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRue2NvbG9yOiMxZDIwMmI7d2lkdGg6MjZweDtoZWlnaHQ6MjZweDtib3JkZXItcmFkaXVzOjdweDtkaXNwbGF5Oi13ZWJraXQtaW5saW5lLWJveDtkaXNwbGF5Oi1tcy1pbmxpbmUtZmxleGJveDtkaXNwbGF5OmlubGluZS1mbGV4Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTttYXJnaW4tbGVmdDozcHg7Y3Vyc29yOnBvaW50ZXI7dXNlci1zZWxlY3Q6bm9uZX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS10b29sYmFyX19zZXR0aW5ncy1idG57d2lkdGg6MzZweDtoZWlnaHQ6MzZweH19QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS10b29sYmFyX19zZXR0aW5ncy1idG46aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZWZmMmY1fX0uY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRuLS1hY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojZWZmMmY1Oy13ZWJraXQtYW5pbWF0aW9uOmJvdW5jZUluIC43NXMgMTthbmltYXRpb246Ym91bmNlSW4gLjc1cyAxOy13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTpmb3J3YXJkczthbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzfUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bnt3aWR0aDoyNHB4fX0uY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRuLS1oaWRkZW57ZGlzcGxheTpub25lfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bntwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjRThFOEVCOy13ZWJraXQtYm94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggcmdiYSgxMywyMCwzMywuMTMpO2JveC1zaGFkb3c6MCAzcHggMTVweCAtM3B4ICMwZDE0MjEyMTtib3JkZXItcmFkaXVzOjZweDt6LWluZGV4OjI7cG9zaXRpb246c3RhdGljfS5jZS10b29sYmFyX19zZXR0aW5ncy1idG4tLWxlZnQtb3JpZW50ZWQ6YmVmb3Jle2xlZnQ6MTVweDttYXJnaW4tbGVmdDowfS5jZS10b29sYmFyX19zZXR0aW5ncy1idG4tLXJpZ2h0LW9yaWVudGVkOmJlZm9yZXtsZWZ0OmF1dG87cmlnaHQ6MTVweDttYXJnaW4tbGVmdDowfX0uY2UtdG9vbGJhcl9fcGx1cyBzdmcsLmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0biBzdmd7d2lkdGg6MjRweDtoZWlnaHQ6MjRweH1AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jb2RleC1lZGl0b3ItLW5hcnJvdyAuY2UtdG9vbGJhcl9fcGx1c3tsZWZ0OjVweH19QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY29kZXgtZWRpdG9yLS1uYXJyb3cgLmNlLXRvb2xib3ggLmNlLXBvcG92ZXJ7cmlnaHQ6MDtsZWZ0OmF1dG87bGVmdDppbml0aWFsfX0uY2UtaW5saW5lLXRvb2xiYXJ7LS15LW9mZnNldDogOHB4O3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNFOEU4RUI7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCByZ2JhKDEzLDIwLDMzLC4xMyk7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggIzBkMTQyMTIxO2JvcmRlci1yYWRpdXM6NnB4O3otaW5kZXg6MjtvcGFjaXR5OjA7dmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjI1cyBlYXNlO3RyYW5zaXRpb246b3BhY2l0eSAuMjVzIGVhc2U7d2lsbC1jaGFuZ2U6b3BhY2l0eSxsZWZ0LHRvcDt0b3A6MDtsZWZ0OjA7ei1pbmRleDozfS5jZS1pbmxpbmUtdG9vbGJhci0tbGVmdC1vcmllbnRlZDpiZWZvcmV7bGVmdDoxNXB4O21hcmdpbi1sZWZ0OjB9LmNlLWlubGluZS10b29sYmFyLS1yaWdodC1vcmllbnRlZDpiZWZvcmV7bGVmdDphdXRvO3JpZ2h0OjE1cHg7bWFyZ2luLWxlZnQ6MH0uY2UtaW5saW5lLXRvb2xiYXItLXNob3dlZHtvcGFjaXR5OjE7dmlzaWJpbGl0eTp2aXNpYmxlfS5jZS1pbmxpbmUtdG9vbGJhciBbaGlkZGVuXXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fS5jZS1pbmxpbmUtdG9vbGJhcl9fdG9nZ2xlci1hbmQtYnV0dG9uLXdyYXBwZXJ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDt3aWR0aDoxMDAlO3BhZGRpbmc6MCA2cHh9LmNlLWlubGluZS10b29sYmFyX19idXR0b25ze2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXh9LmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3BhZGRpbmc6NnB4O21hcmdpbjowIDZweCAwIC02cHg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCByZ2JhKDIwMSwyMDEsMjA0LC40OCk7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duOmhvdmVye2JhY2tncm91bmQ6I2VmZjJmNX19LmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bi0taGlkZGVue2Rpc3BsYXk6bm9uZX0uY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duLWNvbnRlbnQsLmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bi1hcnJvd3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4fS5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24tY29udGVudCBzdmcsLmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bi1hcnJvdyBzdmd7d2lkdGg6MjBweDtoZWlnaHQ6MjBweH0uY2UtaW5saW5lLXRvb2xiYXJfX3Nob3J0Y3V0e29wYWNpdHk6LjY7d29yZC1zcGFjaW5nOi0zcHg7bWFyZ2luLXRvcDozcHh9LmNlLWlubGluZS10b29se2Rpc3BsYXk6LXdlYmtpdC1pbmxpbmUtYm94O2Rpc3BsYXk6LW1zLWlubGluZS1mbGV4Ym94O2Rpc3BsYXk6aW5saW5lLWZsZXg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtwYWRkaW5nOjZweCAxcHg7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyOjA7b3V0bGluZTpub25lO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7dmVydGljYWwtYWxpZ246Ym90dG9tO2NvbG9yOmluaGVyaXQ7bWFyZ2luOjA7Ym9yZGVyLXJhZGl1czowO2xpbmUtaGVpZ2h0Om5vcm1hbH0uY2UtaW5saW5lLXRvb2wgc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtaW5saW5lLXRvb2wgc3Zne3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHh9fUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2UtaW5saW5lLXRvb2w6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZWZmMmY1fX0uY2UtaW5saW5lLXRvb2wtLWFjdGl2ZXtjb2xvcjojMzg4YWU1fS5jZS1pbmxpbmUtdG9vbC0tZm9jdXNlZHtiYWNrZ3JvdW5kOnJnYmEoMzQsMTg2LDI1NSwuMDgpIWltcG9ydGFudH0uY2UtaW5saW5lLXRvb2wtLWZvY3VzZWR7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMCAwcHggMXB4IHJnYmEoNywxNjEsMjI3LC4wOCk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCAxcHggIzA3YTFlMzE0fS5jZS1pbmxpbmUtdG9vbC0tZm9jdXNlZC1hbmltYXRlZHstd2Via2l0LWFuaW1hdGlvbi1uYW1lOmJ1dHRvbkNsaWNrZWQ7YW5pbWF0aW9uLW5hbWU6YnV0dG9uQ2xpY2tlZDstd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjouMjVzO2FuaW1hdGlvbi1kdXJhdGlvbjouMjVzfS5jZS1pbmxpbmUtdG9vbC0tbGluayAuaWNvbi0tdW5saW5rLC5jZS1pbmxpbmUtdG9vbC0tdW5saW5rIC5pY29uLS1saW5re2Rpc3BsYXk6bm9uZX0uY2UtaW5saW5lLXRvb2wtLXVubGluayAuaWNvbi0tdW5saW5re2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1ib3R0b206LTFweH0uY2UtaW5saW5lLXRvb2wtaW5wdXR7b3V0bGluZTpub25lO2JvcmRlcjowO2JvcmRlci1yYWRpdXM6MCAwIDRweCA0cHg7bWFyZ2luOjA7Zm9udC1zaXplOjEzcHg7cGFkZGluZzoxMHB4O3dpZHRoOjEwMCU7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2Rpc3BsYXk6bm9uZTtmb250LXdlaWdodDo1MDA7Ym9yZGVyLXRvcDoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpOy13ZWJraXQtYXBwZWFyYW5jZTpub25lO2ZvbnQtZmFtaWx5OmluaGVyaXR9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtaW5saW5lLXRvb2wtaW5wdXR7Zm9udC1zaXplOjE1cHg7Zm9udC13ZWlnaHQ6NTAwfX0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NH0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NH0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODR9LmNlLWlubGluZS10b29sLWlucHV0OjotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NH0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6OnBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODR9LmNlLWlubGluZS10b29sLWlucHV0LS1zaG93ZWR7ZGlzcGxheTpibG9ja30uY2UtY29udmVyc2lvbi10b29sYmFye3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNFOEU4RUI7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCByZ2JhKDEzLDIwLDMzLC4xMyk7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggIzBkMTQyMTIxO2JvcmRlci1yYWRpdXM6NnB4O3otaW5kZXg6MjtvcGFjaXR5OjA7dmlzaWJpbGl0eTpoaWRkZW47d2lsbC1jaGFuZ2U6dHJhbnNmb3JtLG9wYWNpdHk7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UsLXdlYmtpdC10cmFuc2Zvcm0gLjFzIGVhc2U7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLC13ZWJraXQtdHJhbnNmb3JtIC4xcyBlYXNlO3RyYW5zaXRpb246dHJhbnNmb3JtIC4xcyBlYXNlLG9wYWNpdHkgLjFzIGVhc2U7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjFzIGVhc2Usb3BhY2l0eSAuMXMgZWFzZSwtd2Via2l0LXRyYW5zZm9ybSAuMXMgZWFzZTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpO2xlZnQ6LTFweDt3aWR0aDoxOTBweDttYXJnaW4tdG9wOjVweDstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveH0uY2UtY29udmVyc2lvbi10b29sYmFyLS1sZWZ0LW9yaWVudGVkOmJlZm9yZXtsZWZ0OjE1cHg7bWFyZ2luLWxlZnQ6MH0uY2UtY29udmVyc2lvbi10b29sYmFyLS1yaWdodC1vcmllbnRlZDpiZWZvcmV7bGVmdDphdXRvO3JpZ2h0OjE1cHg7bWFyZ2luLWxlZnQ6MH0uY2UtY29udmVyc2lvbi10b29sYmFyLS1zaG93ZWR7b3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTstd2Via2l0LXRyYW5zZm9ybTpub25lO3RyYW5zZm9ybTpub25lfS5jZS1jb252ZXJzaW9uLXRvb2xiYXIgW2hpZGRlbl17ZGlzcGxheTpub25lIWltcG9ydGFudH0uY2UtY29udmVyc2lvbi10b29sYmFyX19idXR0b25ze2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXh9LmNlLWNvbnZlcnNpb24tdG9vbGJhcl9fbGFiZWx7Y29sb3I6IzcwNzY4NDtmb250LXNpemU6MTFweDtmb250LXdlaWdodDo1MDA7bGV0dGVyLXNwYWNpbmc6LjMzcHg7cGFkZGluZzoxMHB4IDEwcHggNXB4O3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZX0uY2UtY29udmVyc2lvbi10b29se2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7cGFkZGluZzo1cHggMTBweDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoyMHB4O2ZvbnQtd2VpZ2h0OjUwMDtjdXJzb3I6cG9pbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn0uY2UtY29udmVyc2lvbi10b29sLS1oaWRkZW57ZGlzcGxheTpub25lfS5jZS1jb252ZXJzaW9uLXRvb2wtLWZvY3VzZWR7YmFja2dyb3VuZDpyZ2JhKDM0LDE4NiwyNTUsLjA4KSFpbXBvcnRhbnR9LmNlLWNvbnZlcnNpb24tdG9vbC0tZm9jdXNlZHstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAwIDBweCAxcHggcmdiYSg3LDE2MSwyMjcsLjA4KTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDFweCAjMDdhMWUzMTR9LmNlLWNvbnZlcnNpb24tdG9vbC0tZm9jdXNlZC1hbmltYXRlZHstd2Via2l0LWFuaW1hdGlvbi1uYW1lOmJ1dHRvbkNsaWNrZWQ7YW5pbWF0aW9uLW5hbWU6YnV0dG9uQ2xpY2tlZDstd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjouMjVzO2FuaW1hdGlvbi1kdXJhdGlvbjouMjVzfS5jZS1jb252ZXJzaW9uLXRvb2w6aG92ZXJ7YmFja2dyb3VuZDojZWZmMmY1fS5jZS1jb252ZXJzaW9uLXRvb2xfX2ljb257ZGlzcGxheTotd2Via2l0LWlubGluZS1ib3g7ZGlzcGxheTotbXMtaW5saW5lLWZsZXhib3g7ZGlzcGxheTppbmxpbmUtZmxleDt3aWR0aDoyNnB4O2hlaWdodDoyNnB4Oy13ZWJraXQtYm94LXNoYWRvdzowIDAgMCAxcHggcmdiYSgyMDEsMjAxLDIwNCwuNDgpO2JveC1zaGFkb3c6MCAwIDAgMXB4ICNjOWM5Y2M3YTtib3JkZXItcmFkaXVzOjVweDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JhY2tncm91bmQ6I2ZmZjstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjA7bWFyZ2luLXJpZ2h0OjEwcHh9LmNlLWNvbnZlcnNpb24tdG9vbF9faWNvbiBzdmd7d2lkdGg6MjBweDtoZWlnaHQ6MjBweH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1jb252ZXJzaW9uLXRvb2xfX2ljb257d2lkdGg6MzZweDtoZWlnaHQ6MzZweDtib3JkZXItcmFkaXVzOjhweH0uY2UtY29udmVyc2lvbi10b29sX19pY29uIHN2Z3t3aWR0aDoyOHB4O2hlaWdodDoyOHB4fX0uY2UtY29udmVyc2lvbi10b29sLS1sYXN0e21hcmdpbi1yaWdodDowIWltcG9ydGFudH0uY2UtY29udmVyc2lvbi10b29sLS1hY3RpdmV7Y29sb3I6IzM4OGFlNSFpbXBvcnRhbnR9LmNlLWNvbnZlcnNpb24tdG9vbC0tYWN0aXZley13ZWJraXQtYW5pbWF0aW9uOmJvdW5jZUluIC43NXMgMTthbmltYXRpb246Ym91bmNlSW4gLjc1cyAxOy13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTpmb3J3YXJkczthbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzfS5jZS1jb252ZXJzaW9uLXRvb2xfX3NlY29uZGFyeS1sYWJlbHtjb2xvcjojNzA3Njg0O2ZvbnQtc2l6ZToxMnB4O21hcmdpbi1sZWZ0OmF1dG87d2hpdGUtc3BhY2U6bm93cmFwO2xldHRlci1zcGFjaW5nOi0uMWVtO3BhZGRpbmctcmlnaHQ6NXB4O21hcmdpbi1ib3R0b206LTJweDtvcGFjaXR5Oi42fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLWNvbnZlcnNpb24tdG9vbF9fc2Vjb25kYXJ5LWxhYmVse2Rpc3BsYXk6bm9uZX19LmNlLXNldHRpbmdzX19idXR0b257ZGlzcGxheTotd2Via2l0LWlubGluZS1ib3g7ZGlzcGxheTotbXMtaW5saW5lLWZsZXhib3g7ZGlzcGxheTppbmxpbmUtZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3BhZGRpbmc6NnB4IDFweDtib3JkZXItcmFkaXVzOjNweDtjdXJzb3I6cG9pbnRlcjtib3JkZXI6MDtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDt2ZXJ0aWNhbC1hbGlnbjpib3R0b207Y29sb3I6aW5oZXJpdDttYXJnaW46MDtsaW5lLWhlaWdodDozMnB4fS5jZS1zZXR0aW5nc19fYnV0dG9uIHN2Z3t3aWR0aDoyMHB4O2hlaWdodDoyMHB4fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXNldHRpbmdzX19idXR0b24gc3Zne3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHh9fUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2Utc2V0dGluZ3NfX2J1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjV9fS5jZS1zZXR0aW5nc19fYnV0dG9uLS1hY3RpdmV7Y29sb3I6IzM4OGFlNX0uY2Utc2V0dGluZ3NfX2J1dHRvbi0tZm9jdXNlZHtiYWNrZ3JvdW5kOnJnYmEoMzQsMTg2LDI1NSwuMDgpIWltcG9ydGFudH0uY2Utc2V0dGluZ3NfX2J1dHRvbi0tZm9jdXNlZHstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAwIDBweCAxcHggcmdiYSg3LDE2MSwyMjcsLjA4KTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDFweCAjMDdhMWUzMTR9LmNlLXNldHRpbmdzX19idXR0b24tLWZvY3VzZWQtYW5pbWF0ZWR7LXdlYmtpdC1hbmltYXRpb24tbmFtZTpidXR0b25DbGlja2VkO2FuaW1hdGlvbi1uYW1lOmJ1dHRvbkNsaWNrZWQ7LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246LjI1czthbmltYXRpb24tZHVyYXRpb246LjI1c30uY2Utc2V0dGluZ3NfX2J1dHRvbjpub3QoOm50aC1jaGlsZCgzbiszKSl7bWFyZ2luLXJpZ2h0OjNweH0uY2Utc2V0dGluZ3NfX2J1dHRvbjpudGgtY2hpbGQobis0KXttYXJnaW4tdG9wOjNweH0uY2Utc2V0dGluZ3NfX2J1dHRvbi0tZGlzYWJsZWR7Y3Vyc29yOm5vdC1hbGxvd2VkIWltcG9ydGFudH0uY2Utc2V0dGluZ3NfX2J1dHRvbi0tZGlzYWJsZWR7b3BhY2l0eTouM30uY2Utc2V0dGluZ3NfX2J1dHRvbi0tc2VsZWN0ZWR7Y29sb3I6IzM4OGFlNX1AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jb2RleC1lZGl0b3ItLW5hcnJvdyAuY2Utc2V0dGluZ3MgLmNlLXBvcG92ZXJ7cmlnaHQ6MDtsZWZ0OmF1dG87bGVmdDppbml0aWFsfX1ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZS1pbnswJXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIGZhZGUtaW57MCV7b3BhY2l0eTowfXRve29wYWNpdHk6MX19LmNlLWJsb2Nrey13ZWJraXQtYW5pbWF0aW9uOmZhZGUtaW4gLjNzIGVhc2U7YW5pbWF0aW9uOmZhZGUtaW4gLjNzIGVhc2U7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOm5vbmU7YW5pbWF0aW9uLWZpbGwtbW9kZTpub25lOy13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTppbml0aWFsO2FuaW1hdGlvbi1maWxsLW1vZGU6aW5pdGlhbH0uY2UtYmxvY2s6Zmlyc3Qtb2YtdHlwZXttYXJnaW4tdG9wOjB9LmNlLWJsb2NrLS1zZWxlY3RlZCAuY2UtYmxvY2tfX2NvbnRlbnR7YmFja2dyb3VuZDojZTFmMmZmfS5jZS1ibG9jay0tc2VsZWN0ZWQgLmNlLWJsb2NrX19jb250ZW50IFtjb250ZW50ZWRpdGFibGVdey13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uY2UtYmxvY2stLXNlbGVjdGVkIC5jZS1ibG9ja19fY29udGVudCBpbWcsLmNlLWJsb2NrLS1zZWxlY3RlZCAuY2UtYmxvY2tfX2NvbnRlbnQgLmNlLXN0dWJ7b3BhY2l0eTouNTV9LmNlLWJsb2NrLS1zdHJldGNoZWQgLmNlLWJsb2NrX19jb250ZW50e21heC13aWR0aDpub25lfS5jZS1ibG9ja19fY29udGVudHtwb3NpdGlvbjpyZWxhdGl2ZTttYXgtd2lkdGg6NjUwcHg7bWFyZ2luOjAgYXV0bzstd2Via2l0LXRyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuMTVzIGVhc2U7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4xNXMgZWFzZX0uY2UtYmxvY2stLWRyb3AtdGFyZ2V0IC5jZS1ibG9ja19fY29udGVudDpiZWZvcmV7Y29udGVudDpcIlwiO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxMDAlO2xlZnQ6LTIwcHg7bWFyZ2luLXRvcDotMXB4O2hlaWdodDo4cHg7d2lkdGg6OHB4O2JvcmRlcjpzb2xpZCAjMzg4QUU1O2JvcmRlci13aWR0aDoxcHggMXB4IDAgMDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46cmlnaHQ7dHJhbnNmb3JtLW9yaWdpbjpyaWdodDstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoNDVkZWcpO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5jZS1ibG9jay0tZHJvcC10YXJnZXQgLmNlLWJsb2NrX19jb250ZW50OmFmdGVye2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTAwJTtoZWlnaHQ6MXB4O3dpZHRoOjEwMCU7Y29sb3I6IzM4OGFlNTtiYWNrZ3JvdW5kOnJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoOTBkZWcsIzM4OEFFNSwjMzg4QUU1IDFweCwjZmZmIDFweCwjZmZmIDZweCl9LmNlLWJsb2NrIGF7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC10ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9LmNlLWJsb2NrIGJ7Zm9udC13ZWlnaHQ6NzAwfS5jZS1ibG9jayBpe2ZvbnQtc3R5bGU6aXRhbGljfUAtd2Via2l0LWtleWZyYW1lcyBib3VuY2VJbnswJSwyMCUsNDAlLDYwJSw4MCUsdG97LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCguOSwuOSwuOSk7dHJhbnNmb3JtOnNjYWxlM2QoLjksLjksLjkpfTIwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEuMDMsMS4wMywxLjAzKTt0cmFuc2Zvcm06c2NhbGUzZCgxLjAzLDEuMDMsMS4wMyl9NjAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMSwxLDEpO3RyYW5zZm9ybTpzY2FsZVooMSl9fUBrZXlmcmFtZXMgYm91bmNlSW57MCUsMjAlLDQwJSw2MCUsODAlLHRvey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpfTAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoLjksLjksLjkpO3RyYW5zZm9ybTpzY2FsZTNkKC45LC45LC45KX0yMCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLjAzLDEuMDMsMS4wMyk7dHJhbnNmb3JtOnNjYWxlM2QoMS4wMywxLjAzLDEuMDMpfTYwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEsMSwxKTt0cmFuc2Zvcm06c2NhbGVaKDEpfX1ALXdlYmtpdC1rZXlmcmFtZXMgc2VsZWN0aW9uQm91bmNlezAlLDIwJSw0MCUsNjAlLDgwJSx0b3std2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKX01MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLjAxLDEuMDEsMS4wMSk7dHJhbnNmb3JtOnNjYWxlM2QoMS4wMSwxLjAxLDEuMDEpfTcwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEsMSwxKTt0cmFuc2Zvcm06c2NhbGVaKDEpfX1Aa2V5ZnJhbWVzIHNlbGVjdGlvbkJvdW5jZXswJSwyMCUsNDAlLDYwJSw4MCUsdG97LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9NTAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMS4wMSwxLjAxLDEuMDEpO3RyYW5zZm9ybTpzY2FsZTNkKDEuMDEsMS4wMSwxLjAxKX03MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLDEsMSk7dHJhbnNmb3JtOnNjYWxlWigxKX19QC13ZWJraXQta2V5ZnJhbWVzIGJ1dHRvbkNsaWNrZWR7MCUsMjAlLDQwJSw2MCUsODAlLHRvey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpfTAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoLjk1LC45NSwuOTUpO3RyYW5zZm9ybTpzY2FsZTNkKC45NSwuOTUsLjk1KX02MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLjAyLDEuMDIsMS4wMik7dHJhbnNmb3JtOnNjYWxlM2QoMS4wMiwxLjAyLDEuMDIpfTgwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEsMSwxKTt0cmFuc2Zvcm06c2NhbGVaKDEpfX1Aa2V5ZnJhbWVzIGJ1dHRvbkNsaWNrZWR7MCUsMjAlLDQwJSw2MCUsODAlLHRvey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpfTAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoLjk1LC45NSwuOTUpO3RyYW5zZm9ybTpzY2FsZTNkKC45NSwuOTUsLjk1KX02MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLjAyLDEuMDIsMS4wMik7dHJhbnNmb3JtOnNjYWxlM2QoMS4wMiwxLjAyLDEuMDIpfTgwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEsMSwxKTt0cmFuc2Zvcm06c2NhbGVaKDEpfX0uY2R4LWJsb2Nre3BhZGRpbmc6LjRlbSAwfS5jZHgtYmxvY2s6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7bGluZS1oZWlnaHQ6bm9ybWFsIWltcG9ydGFudH0uY2R4LWlucHV0e2JvcmRlcjoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpOy13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDFweCAycHggMCByZ2JhKDM1LDQ0LDcyLC4wNik7Ym94LXNoYWRvdzppbnNldCAwIDFweCAycHggIzIzMmM0ODBmO2JvcmRlci1yYWRpdXM6M3B4O3BhZGRpbmc6MTBweCAxMnB4O291dGxpbmU6bm9uZTt3aWR0aDoxMDAlOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH0uY2R4LWlucHV0W2RhdGEtcGxhY2Vob2xkZXJdOmJlZm9yZXtwb3NpdGlvbjpzdGF0aWMhaW1wb3J0YW50fS5jZHgtaW5wdXRbZGF0YS1wbGFjZWhvbGRlcl06YmVmb3Jle2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjA7d2hpdGUtc3BhY2U6bm93cmFwO3BvaW50ZXItZXZlbnRzOm5vbmV9LmNkeC1zZXR0aW5ncy1idXR0b257ZGlzcGxheTotd2Via2l0LWlubGluZS1ib3g7ZGlzcGxheTotbXMtaW5saW5lLWZsZXhib3g7ZGlzcGxheTppbmxpbmUtZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3BhZGRpbmc6NnB4IDFweDtib3JkZXItcmFkaXVzOjNweDtjdXJzb3I6cG9pbnRlcjtib3JkZXI6MDtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDt2ZXJ0aWNhbC1hbGlnbjpib3R0b207Y29sb3I6aW5oZXJpdDttYXJnaW46MDttaW4td2lkdGg6MjZweDttaW4taGVpZ2h0OjI2cHh9LmNkeC1zZXR0aW5ncy1idXR0b24gc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2R4LXNldHRpbmdzLWJ1dHRvbiBzdmd7d2lkdGg6MjhweDtoZWlnaHQ6MjhweH19QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZHgtc2V0dGluZ3MtYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VmZjJmNX19LmNkeC1zZXR0aW5ncy1idXR0b24tLWZvY3VzZWR7YmFja2dyb3VuZDpyZ2JhKDM0LDE4NiwyNTUsLjA4KSFpbXBvcnRhbnR9LmNkeC1zZXR0aW5ncy1idXR0b24tLWZvY3VzZWR7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMCAwcHggMXB4IHJnYmEoNywxNjEsMjI3LC4wOCk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCAxcHggIzA3YTFlMzE0fS5jZHgtc2V0dGluZ3MtYnV0dG9uLS1mb2N1c2VkLWFuaW1hdGVkey13ZWJraXQtYW5pbWF0aW9uLW5hbWU6YnV0dG9uQ2xpY2tlZDthbmltYXRpb24tbmFtZTpidXR0b25DbGlja2VkOy13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOi4yNXM7YW5pbWF0aW9uLWR1cmF0aW9uOi4yNXN9LmNkeC1zZXR0aW5ncy1idXR0b24tLWFjdGl2ZXtjb2xvcjojMzg4YWU1fS5jZHgtc2V0dGluZ3MtYnV0dG9uIHN2Z3t3aWR0aDphdXRvO2hlaWdodDphdXRvfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNkeC1zZXR0aW5ncy1idXR0b257d2lkdGg6MzZweDtoZWlnaHQ6MzZweDtib3JkZXItcmFkaXVzOjhweH19LmNkeC1sb2FkZXJ7cG9zaXRpb246cmVsYXRpdmU7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDIwMSwyMDEsMjA0LC40OCl9LmNkeC1sb2FkZXI6YmVmb3Jle2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTt0b3A6NTAlO3dpZHRoOjE4cHg7aGVpZ2h0OjE4cHg7bWFyZ2luOi0xMXB4IDAgMCAtMTFweDtib3JkZXI6MnB4IHNvbGlkIHJnYmEoMjAxLDIwMSwyMDQsLjQ4KTtib3JkZXItbGVmdC1jb2xvcjojMzg4YWU1O2JvcmRlci1yYWRpdXM6NTAlOy13ZWJraXQtYW5pbWF0aW9uOmNkeFJvdGF0aW9uIDEuMnMgaW5maW5pdGUgbGluZWFyO2FuaW1hdGlvbjpjZHhSb3RhdGlvbiAxLjJzIGluZmluaXRlIGxpbmVhcn1ALXdlYmtpdC1rZXlmcmFtZXMgY2R4Um90YXRpb257MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIGNkeFJvdGF0aW9uezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDApfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19LmNkeC1idXR0b257cGFkZGluZzoxM3B4O2JvcmRlci1yYWRpdXM6M3B4O2JvcmRlcjoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpO2ZvbnQtc2l6ZToxNC45cHg7YmFja2dyb3VuZDojZmZmOy13ZWJraXQtYm94LXNoYWRvdzowIDJweCAycHggMCByZ2JhKDE4LDMwLDU3LC4wNCk7Ym94LXNoYWRvdzowIDJweCAycHggIzEyMWUzOTBhO2NvbG9yOiM3MDc2ODQ7dGV4dC1hbGlnbjpjZW50ZXI7Y3Vyc29yOnBvaW50ZXJ9QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZHgtYnV0dG9uOmhvdmVye2JhY2tncm91bmQ6I0ZCRkNGRTstd2Via2l0LWJveC1zaGFkb3c6MCAxcHggM3B4IDAgcmdiYSgxOCwzMCw1NywuMDgpO2JveC1zaGFkb3c6MCAxcHggM3B4ICMxMjFlMzkxNH19LmNkeC1idXR0b24gc3Zne2hlaWdodDoyMHB4O21hcmdpbi1yaWdodDouMmVtO21hcmdpbi10b3A6LTJweH0uY2Utc3R1YntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO3BhZGRpbmc6MTJweCAxOHB4O21hcmdpbjoxMHB4IDA7Ym9yZGVyLXJhZGl1czoxMHB4O2JhY2tncm91bmQ6I2VmZjJmNTtib3JkZXI6MXB4IHNvbGlkICNFRkYwRjE7Y29sb3I6IzcwNzY4NDtmb250LXNpemU6MTRweH0uY2Utc3R1YiBzdmd7d2lkdGg6MjBweDtoZWlnaHQ6MjBweH0uY2Utc3R1Yl9faW5mb3ttYXJnaW4tbGVmdDoxNHB4fS5jZS1zdHViX190aXRsZXtmb250LXdlaWdodDo1MDA7dGV4dC10cmFuc2Zvcm06Y2FwaXRhbGl6ZX0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRse2RpcmVjdGlvbjpydGx9LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2R4LWxpc3R7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDo0MHB4fS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXRvb2xiYXJfX3BsdXN7cmlnaHQ6LTI2cHg7bGVmdDphdXRvfS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXRvb2xiYXJfX2FjdGlvbnN7cmlnaHQ6YXV0bztsZWZ0Oi0yNnB4fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2UtdG9vbGJhcl9fYWN0aW9uc3ttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDphdXRvO3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLWxlZnQ6MTBweH19LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2Utc2V0dGluZ3N7bGVmdDo1cHg7cmlnaHQ6YXV0b30uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS1zZXR0aW5nczpiZWZvcmV7cmlnaHQ6YXV0bztsZWZ0OjI1cHh9LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2Utc2V0dGluZ3NfX2J1dHRvbjpub3QoOm50aC1jaGlsZCgzbiszKSl7bWFyZ2luLWxlZnQ6M3B4O21hcmdpbi1yaWdodDowfS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLWNvbnZlcnNpb24tdG9vbF9faWNvbnttYXJnaW4tcmlnaHQ6MDttYXJnaW4tbGVmdDoxMHB4fS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bntib3JkZXItcmlnaHQ6MHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjFweCBzb2xpZCByZ2JhKDIwMSwyMDEsMjA0LC40OCk7bWFyZ2luOjAgLTZweCAwIDZweH0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24gLmljb24tLXRvZ2dsZXItZG93bnttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDo0cHh9QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY29kZXgtZWRpdG9yLS1uYXJyb3cuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXRvb2xiYXJfX3BsdXN7bGVmdDowcHg7cmlnaHQ6NXB4fX1AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jb2RleC1lZGl0b3ItLW5hcnJvdy5jb2RleC1lZGl0b3ItLXJ0bCAuY2UtdG9vbGJhcl9fYWN0aW9uc3tsZWZ0Oi01cHh9fS5jZHgtc2VhcmNoLWZpZWxkey0taWNvbi1tYXJnaW4tcmlnaHQ6IDEwcHg7YmFja2dyb3VuZDpyZ2JhKDIzMiwyMzIsMjM1LC40OSk7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDIyNiwyMjYsMjI5LC4yKTtib3JkZXItcmFkaXVzOjZweDtwYWRkaW5nOjJweDtkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOmF1dG8gYXV0byAxZnI7Z3JpZC10ZW1wbGF0ZS1yb3dzOmF1dG99LmNkeC1zZWFyY2gtZmllbGRfX2ljb257d2lkdGg6MjZweDtoZWlnaHQ6MjZweDtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luLXJpZ2h0OnZhcigtLWljb24tbWFyZ2luLXJpZ2h0KX0uY2R4LXNlYXJjaC1maWVsZF9faWNvbiBzdmd7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtjb2xvcjojNzA3Njg0fS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dHtmb250LXNpemU6MTRweDtvdXRsaW5lOm5vbmU7Zm9udC13ZWlnaHQ6NTAwO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Ym9yZGVyOjA7YmFja2dyb3VuZDp0cmFuc3BhcmVudDttYXJnaW46MDtwYWRkaW5nOjA7bGluZS1oZWlnaHQ6MjJweDttaW4td2lkdGg6Y2FsYygxMDAlIC0gMjZweCAtIHZhcigtLWljb24tbWFyZ2luLXJpZ2h0KSl9LmNkeC1zZWFyY2gtZmllbGRfX2lucHV0Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NTAwfS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dDo6LW1vei1wbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0O2ZvbnQtd2VpZ2h0OjUwMH0uY2R4LXNlYXJjaC1maWVsZF9faW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NTAwfS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dDo6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NTAwfS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dDo6cGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo1MDB9LmNlLXBvcG92ZXJ7LS1ib3JkZXItcmFkaXVzOiA2cHg7LS13aWR0aDogMjAwcHg7LS1tYXgtaGVpZ2h0OiAyNzBweDstLXBhZGRpbmc6IDZweDstLW9mZnNldC1mcm9tLXRhcmdldDogOHB4Oy0tY29sb3ItYm9yZGVyOiAjZThlOGViOy0tY29sb3Itc2hhZG93OiByZ2JhKDEzLDIwLDMzLC4xMyk7LS1jb2xvci1iYWNrZ3JvdW5kOiB3aGl0ZTstLWNvbG9yLXRleHQtcHJpbWFyeTogYmxhY2s7LS1jb2xvci10ZXh0LXNlY29uZGFyeTogIzcwNzY4NDstLWNvbG9yLWJvcmRlci1pY29uOiByZ2JhKDIwMSwgMjAxLCAyMDQsIC40OCk7LS1jb2xvci1ib3JkZXItaWNvbi1kaXNhYmxlZDogI0VGRjBGMTstLWNvbG9yLXRleHQtaWNvbi1hY3RpdmU6ICMzODhBRTU7LS1jb2xvci1iYWNrZ3JvdW5kLWljb24tYWN0aXZlOiByZ2JhKDU2LCAxMzgsIDIyOSwgLjEpOy0tY29sb3ItYmFja2dyb3VuZC1pdGVtLWZvY3VzOiByZ2JhKDM0LCAxODYsIDI1NSwgLjA4KTstLWNvbG9yLXNoYWRvdy1pdGVtLWZvY3VzOiByZ2JhKDcsIDE2MSwgMjI3LCAuMDgpOy0tY29sb3ItYmFja2dyb3VuZC1pdGVtLWhvdmVyOiAjZWZmMmY1Oy0tY29sb3ItYmFja2dyb3VuZC1pdGVtLWNvbmZpcm06ICNFMjRBNEE7LS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tY29uZmlybS1ob3ZlcjogI0NFNDM0MzttaW4td2lkdGg6dmFyKC0td2lkdGgpO3dpZHRoOnZhcigtLXdpZHRoKTttYXgtaGVpZ2h0OnZhcigtLW1heC1oZWlnaHQpO2JvcmRlci1yYWRpdXM6dmFyKC0tYm9yZGVyLXJhZGl1cyk7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDstd2Via2l0LWJveC1zaGFkb3c6MCAzcHggMTVweCAtM3B4IHZhcigtLWNvbG9yLXNoYWRvdyk7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggdmFyKC0tY29sb3Itc2hhZG93KTtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOmNhbGMoMTAwJSArIHZhcigtLW9mZnNldC1mcm9tLXRhcmdldCkpO2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZCk7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt6LWluZGV4OjQ7b3BhY2l0eTowO21heC1oZWlnaHQ6MDtwb2ludGVyLWV2ZW50czpub25lO3BhZGRpbmc6MDtib3JkZXI6bm9uZX0uY2UtcG9wb3Zlci0tb3BlbmVke29wYWNpdHk6MTtwYWRkaW5nOnZhcigtLXBhZGRpbmcpO21heC1oZWlnaHQ6dmFyKC0tbWF4LWhlaWdodCk7cG9pbnRlci1ldmVudHM6YXV0bzstd2Via2l0LWFuaW1hdGlvbjpwYW5lbFNob3dpbmcgLjFzIGVhc2U7YW5pbWF0aW9uOnBhbmVsU2hvd2luZyAuMXMgZWFzZTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlcil9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci0tb3BlbmVkey13ZWJraXQtYW5pbWF0aW9uOnBhbmVsU2hvd2luZ01vYmlsZSAuMjVzIGVhc2U7YW5pbWF0aW9uOnBhbmVsU2hvd2luZ01vYmlsZSAuMjVzIGVhc2V9fS5jZS1wb3BvdmVyX19pdGVtc3tvdmVyZmxvdy15OmF1dG87LW1zLXNjcm9sbC1jaGFpbmluZzpub25lO292ZXJzY3JvbGwtYmVoYXZpb3I6Y29udGFpbn1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyX19vdmVybGF5e3Bvc2l0aW9uOmZpeGVkO3RvcDowO2JvdHRvbTowO2xlZnQ6MDtyaWdodDowO2JhY2tncm91bmQ6IzFEMjAyQjt6LWluZGV4OjM7b3BhY2l0eTouNTstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMTJzIGVhc2UtaW47dHJhbnNpdGlvbjpvcGFjaXR5IC4xMnMgZWFzZS1pbjt3aWxsLWNoYW5nZTpvcGFjaXR5O3Zpc2liaWxpdHk6dmlzaWJsZX19LmNlLXBvcG92ZXJfX292ZXJsYXktLWhpZGRlbntkaXNwbGF5Om5vbmV9LmNlLXBvcG92ZXItLW9wZW4tdG9we3RvcDpjYWxjKC0xICogKHZhcigtLW9mZnNldC1mcm9tLXRhcmdldCkgKyB2YXIoLS1wb3BvdmVyLWhlaWdodCkpKX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyey0tb2Zmc2V0OiA1cHg7cG9zaXRpb246Zml4ZWQ7bWF4LXdpZHRoOm5vbmU7bWluLXdpZHRoOmNhbGMoMTAwJSAtIHZhcigtLW9mZnNldCkgKiAyKTtsZWZ0OnZhcigtLW9mZnNldCk7cmlnaHQ6dmFyKC0tb2Zmc2V0KTtib3R0b206Y2FsYyh2YXIoLS1vZmZzZXQpICsgZW52KHNhZmUtYXJlYS1pbnNldC1ib3R0b20pKTt0b3A6YXV0bztib3JkZXItcmFkaXVzOjEwcHh9LmNlLXBvcG92ZXIgLmNlLXBvcG92ZXJfX3NlYXJjaHtkaXNwbGF5Om5vbmV9fS5jZS1wb3BvdmVyX19zZWFyY2gsLmNlLXBvcG92ZXJfX2N1c3RvbS1jb250ZW50Om5vdCg6ZW1wdHkpe21hcmdpbi1ib3R0b206NXB4fS5jZS1wb3BvdmVyX19ub3RoaW5nLWZvdW5kLW1lc3NhZ2V7Y29sb3I6IzcwNzY4NDtkaXNwbGF5Om5vbmU7Y3Vyc29yOmRlZmF1bHQ7cGFkZGluZzozcHg7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MjBweDtmb250LXdlaWdodDo1MDA7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5jZS1wb3BvdmVyX19ub3RoaW5nLWZvdW5kLW1lc3NhZ2UtLWRpc3BsYXllZHtkaXNwbGF5OmJsb2NrfS5jZS1wb3BvdmVyX19jdXN0b20tY29udGVudDpub3QoOmVtcHR5KXtwYWRkaW5nOjRweH1AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jZS1wb3BvdmVyX19jdXN0b20tY29udGVudDpub3QoOmVtcHR5KXtwYWRkaW5nOjB9fS5jZS1wb3BvdmVyX19jdXN0b20tY29udGVudC0taGlkZGVue2Rpc3BsYXk6bm9uZX0uY2UtcG9wb3Zlci1pdGVtey0tYm9yZGVyLXJhZGl1czogNnB4Oy0taWNvbi1zaXplOiAyMHB4Oy0taWNvbi1zaXplLW1vYmlsZTogMjhweDtib3JkZXItcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7cGFkZGluZzozcHg7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1wcmltYXJ5KTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci1pdGVte3BhZGRpbmc6NHB4fX0uY2UtcG9wb3Zlci1pdGVtOm5vdCg6bGFzdC1vZi10eXBlKXttYXJnaW4tYm90dG9tOjFweH0uY2UtcG9wb3Zlci1pdGVtX19pY29ue2JvcmRlci1yYWRpdXM6NXB4O3dpZHRoOjI2cHg7aGVpZ2h0OjI2cHg7LXdlYmtpdC1ib3gtc2hhZG93OjAgMCAwIDFweCB2YXIoLS1jb2xvci1ib3JkZXItaWNvbik7Ym94LXNoYWRvdzowIDAgMCAxcHggdmFyKC0tY29sb3ItYm9yZGVyLWljb24pO2JhY2tncm91bmQ6I2ZmZjtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luLXJpZ2h0OjEwcHh9LmNlLXBvcG92ZXItaXRlbV9faWNvbiBzdmd7d2lkdGg6MjBweDtoZWlnaHQ6MjBweH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLWl0ZW1fX2ljb257d2lkdGg6MzZweDtoZWlnaHQ6MzZweDtib3JkZXItcmFkaXVzOjhweH0uY2UtcG9wb3Zlci1pdGVtX19pY29uIHN2Z3t3aWR0aDp2YXIoLS1pY29uLXNpemUtbW9iaWxlKTtoZWlnaHQ6dmFyKC0taWNvbi1zaXplLW1vYmlsZSl9fS5jZS1wb3BvdmVyLWl0ZW1fX3RpdGxle2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC13ZWlnaHQ6NTAwO292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXA7dGV4dC1vdmVyZmxvdzplbGxpcHNpc31AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLWl0ZW1fX3RpdGxle2ZvbnQtc2l6ZToxNnB4fX0uY2UtcG9wb3Zlci1pdGVtX19zZWNvbmRhcnktdGl0bGV7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpO2ZvbnQtc2l6ZToxMnB4O21hcmdpbi1sZWZ0OmF1dG87d2hpdGUtc3BhY2U6bm93cmFwO2xldHRlci1zcGFjaW5nOi0uMWVtO3BhZGRpbmctcmlnaHQ6NXB4O21hcmdpbi1ib3R0b206LTJweDtvcGFjaXR5Oi42fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItaXRlbV9fc2Vjb25kYXJ5LXRpdGxle2Rpc3BsYXk6bm9uZX19LmNlLXBvcG92ZXItaXRlbS0tYWN0aXZle2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1pY29uLWFjdGl2ZSk7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1pY29uLWFjdGl2ZSl9LmNlLXBvcG92ZXItaXRlbS0tYWN0aXZlIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb257LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfS5jZS1wb3BvdmVyLWl0ZW0tLWRpc2FibGVke2NvbG9yOnZhcigtLWNvbG9yLXRleHQtc2Vjb25kYXJ5KTtjdXJzb3I6ZGVmYXVsdDtwb2ludGVyLWV2ZW50czpub25lfS5jZS1wb3BvdmVyLWl0ZW0tLWRpc2FibGVkIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb257LXdlYmtpdC1ib3gtc2hhZG93OjAgMCAwIDFweCB2YXIoLS1jb2xvci1ib3JkZXItaWNvbi1kaXNhYmxlZCk7Ym94LXNoYWRvdzowIDAgMCAxcHggdmFyKC0tY29sb3ItYm9yZGVyLWljb24tZGlzYWJsZWQpfS5jZS1wb3BvdmVyLWl0ZW0tLWZvY3VzZWQ6bm90KC5jZS1wb3BvdmVyLWl0ZW0tLW5vLWZvY3VzKXtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQtaXRlbS1mb2N1cykhaW1wb3J0YW50fS5jZS1wb3BvdmVyLWl0ZW0tLWZvY3VzZWQ6bm90KC5jZS1wb3BvdmVyLWl0ZW0tLW5vLWZvY3VzKXstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAwIDBweCAxcHggdmFyKC0tY29sb3Itc2hhZG93LWl0ZW0tZm9jdXMpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMXB4IHZhcigtLWNvbG9yLXNoYWRvdy1pdGVtLWZvY3VzKX0uY2UtcG9wb3Zlci1pdGVtLS1oaWRkZW57ZGlzcGxheTpub25lfUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2UtcG9wb3Zlci1pdGVtOmhvdmVye2N1cnNvcjpwb2ludGVyfS5jZS1wb3BvdmVyLWl0ZW06aG92ZXI6bm90KC5jZS1wb3BvdmVyLWl0ZW0tLW5vLWhvdmVyKXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yLWJhY2tncm91bmQtaXRlbS1ob3Zlcil9LmNlLXBvcG92ZXItaXRlbTpob3ZlciAuY2UtcG9wb3Zlci1pdGVtX19pY29uey13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZX19LmNlLXBvcG92ZXItaXRlbS0tY29uZmlybWF0aW9ue2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1pdGVtLWNvbmZpcm0pfS5jZS1wb3BvdmVyLWl0ZW0tLWNvbmZpcm1hdGlvbiAuY2UtcG9wb3Zlci1pdGVtX19pY29ue2NvbG9yOnZhcigtLWNvbG9yLWJhY2tncm91bmQtaXRlbS1jb25maXJtKX0uY2UtcG9wb3Zlci1pdGVtLS1jb25maXJtYXRpb24gLmNlLXBvcG92ZXItaXRlbV9fdGl0bGV7Y29sb3I6I2ZmZn1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLXBvcG92ZXItaXRlbS0tY29uZmlybWF0aW9uOm5vdCguY2UtcG9wb3Zlci1pdGVtLS1uby1ob3Zlcik6aG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tY29uZmlybS1ob3Zlcil9fS5jZS1wb3BvdmVyLWl0ZW0tLWNvbmZpcm1hdGlvbjpub3QoLmNlLXBvcG92ZXItaXRlbS0tbm8tZm9jdXMpLmNlLXBvcG92ZXItaXRlbS0tZm9jdXNlZHtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQtaXRlbS1jb25maXJtLWhvdmVyKSFpbXBvcnRhbnR9LmNlLXBvcG92ZXItaXRlbS0tY29uZmlybWF0aW9uIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb24sLmNlLXBvcG92ZXItaXRlbS0tYWN0aXZlIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb24sLmNlLXBvcG92ZXItaXRlbS0tZm9jdXNlZCAuY2UtcG9wb3Zlci1pdGVtX19pY29uey13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZX1ALXdlYmtpdC1rZXlmcmFtZXMgcGFuZWxTaG93aW5nezAle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpIHNjYWxlKC45KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KSBzY2FsZSguOSl9NzAle29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDJweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMnB4KX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfX1Aa2V5ZnJhbWVzIHBhbmVsU2hvd2luZ3swJXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KSBzY2FsZSguOSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCkgc2NhbGUoLjkpfTcwJXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgycHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDJweCl9dG97LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKX19QC13ZWJraXQta2V5ZnJhbWVzIHBhbmVsU2hvd2luZ01vYmlsZXswJXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgxNHB4KSBzY2FsZSguOTgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDE0cHgpIHNjYWxlKC45OCl9NzAle29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC00cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC00cHgpfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCl9fUBrZXlmcmFtZXMgcGFuZWxTaG93aW5nTW9iaWxlezAle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDE0cHgpIHNjYWxlKC45OCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTRweCkgc2NhbGUoLjk4KX03MCV7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTRweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTRweCl9dG97LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKX19LndvYmJsZXstd2Via2l0LWFuaW1hdGlvbi1uYW1lOndvYmJsZTthbmltYXRpb24tbmFtZTp3b2JibGU7LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246LjRzO2FuaW1hdGlvbi1kdXJhdGlvbjouNHN9QC13ZWJraXQta2V5ZnJhbWVzIHdvYmJsZXswJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9MTUley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC05JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtOSUsMCwwKX0zMCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoOSUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoOSUsMCwwKX00NSV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTQlLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC00JSwwLDApfTYwJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCg0JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCg0JSwwLDApfTc1JXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMSUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTElLDAsMCl9dG97LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApfX1Aa2V5ZnJhbWVzIHdvYmJsZXswJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9MTUley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC05JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtOSUsMCwwKX0zMCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoOSUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoOSUsMCwwKX00NSV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTQlLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC00JSwwLDApfTYwJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCg0JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCg0JSwwLDApfTc1JXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMSUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTElLDAsMCl9dG97LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApfX1cbmA7XG5jbGFzcyB3aSBleHRlbmRzIHkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmlzTW9iaWxlID0gITEsIHRoaXMuY29udGVudFJlY3RDYWNoZSA9IHZvaWQgMCwgdGhpcy5yZXNpemVEZWJvdW5jZXIgPSBldCgoKSA9PiB7XG4gICAgICB0aGlzLndpbmRvd1Jlc2l6ZSgpO1xuICAgIH0sIDIwMCk7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXRvci5qcyBVSSBDU1MgY2xhc3MgbmFtZXNcbiAgICpcbiAgICogQHJldHVybnMge3tlZGl0b3JXcmFwcGVyOiBzdHJpbmcsIGVkaXRvclpvbmU6IHN0cmluZ319XG4gICAqL1xuICBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlZGl0b3JXcmFwcGVyOiBcImNvZGV4LWVkaXRvclwiLFxuICAgICAgZWRpdG9yV3JhcHBlck5hcnJvdzogXCJjb2RleC1lZGl0b3ItLW5hcnJvd1wiLFxuICAgICAgZWRpdG9yWm9uZTogXCJjb2RleC1lZGl0b3JfX3JlZGFjdG9yXCIsXG4gICAgICBlZGl0b3Jab25lSGlkZGVuOiBcImNvZGV4LWVkaXRvcl9fcmVkYWN0b3ItLWhpZGRlblwiLFxuICAgICAgZWRpdG9yRW1wdHk6IFwiY29kZXgtZWRpdG9yLS1lbXB0eVwiLFxuICAgICAgZWRpdG9yUnRsRml4OiBcImNvZGV4LWVkaXRvci0tcnRsXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gV2lkdGggb2YgY2VudGVyIGNvbHVtbiBvZiBFZGl0b3JcbiAgICpcbiAgICogQHJldHVybnMge0RPTVJlY3R9XG4gICAqL1xuICBnZXQgY29udGVudFJlY3QoKSB7XG4gICAgaWYgKHRoaXMuY29udGVudFJlY3RDYWNoZSlcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRSZWN0Q2FjaGU7XG4gICAgY29uc3QgZSA9IHRoaXMubm9kZXMud3JhcHBlci5xdWVyeVNlbGVjdG9yKGAuJHtSLkNTUy5jb250ZW50fWApO1xuICAgIHJldHVybiBlID8gKHRoaXMuY29udGVudFJlY3RDYWNoZSA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRoaXMuY29udGVudFJlY3RDYWNoZSkgOiB7XG4gICAgICB3aWR0aDogNjUwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTWFraW5nIG1haW4gaW50ZXJmYWNlXG4gICAqL1xuICBhc3luYyBwcmVwYXJlKCkge1xuICAgIHRoaXMuY2hlY2tJc01vYmlsZSgpLCB0aGlzLm1ha2UoKSwgdGhpcy5sb2FkU3R5bGVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogSWYgcmVhZE9ubHkgaXMgdHJ1ZTpcbiAgICogIC0gcmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZyb20gbWFpbiBVSSBtb2R1bGUgZWxlbWVudHNcbiAgICpcbiAgICogaWYgcmVhZE9ubHkgaXMgZmFsc2U6XG4gICAqICAtIGVuYWJsZXMgYWxsIGxpc3RlbmVycyB0byBVSSBtb2R1bGUgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSBcInJlYWQgb25seVwiIHN0YXRlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/IHRoaXMuZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkgOiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLmVuYWJsZU1vZHVsZUJpbmRpbmdzKCk7XG4gICAgfSwge1xuICAgICAgdGltZW91dDogMmUzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIEVkaXRvciBpcyBlbXB0eSBhbmQgc2V0IENTUyBjbGFzcyB0byB3cmFwcGVyXG4gICAqL1xuICBjaGVja0VtcHRpbmVzcygpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogZSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC50b2dnbGUodGhpcy5DU1MuZWRpdG9yRW1wdHksIGUuaXNFZGl0b3JFbXB0eSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIG9uZSBvZiBUb29sYmFyIGlzIG9wZW5lZFxuICAgKiBVc2VkIHRvIHByZXZlbnQgZ2xvYmFsIGtleWRvd25zIChmb3IgZXhhbXBsZSwgRW50ZXIpIGNvbmZsaWN0cyB3aXRoIEVudGVyLW9uLXRvb2xiYXJcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc29tZVRvb2xiYXJPcGVuZWQoKSB7XG4gICAgY29uc3QgeyBUb29sYmFyOiBlLCBCbG9ja1NldHRpbmdzOiB0LCBJbmxpbmVUb29sYmFyOiBvLCBDb252ZXJzaW9uVG9vbGJhcjogaSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgcmV0dXJuIHQub3BlbmVkIHx8IG8ub3BlbmVkIHx8IGkub3BlbmVkIHx8IGUudG9vbGJveC5vcGVuZWQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGZvciBzb21lIEZsaXBwZXItYnV0dG9ucyBpcyB1bmRlciBmb2N1c1xuICAgKi9cbiAgZ2V0IHNvbWVGbGlwcGVyQnV0dG9uRm9jdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94Lmhhc0ZvY3VzKCkgPyAhMCA6IE9iamVjdC5lbnRyaWVzKHRoaXMuRWRpdG9yKS5maWx0ZXIoKFtlLCB0XSkgPT4gdC5mbGlwcGVyIGluc3RhbmNlb2YgcSkuc29tZSgoW2UsIHRdKSA9PiB0LmZsaXBwZXIuaGFzRm9jdXMoKSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIGVkaXRvcmBzIFVJXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm9kZXMuaG9sZGVyLmlubmVySFRNTCA9IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIGFsbCBFZGl0b3IncyB0b29sYmFyc1xuICAgKi9cbiAgY2xvc2VBbGxUb29sYmFycygpIHtcbiAgICBjb25zdCB7IFRvb2xiYXI6IGUsIEJsb2NrU2V0dGluZ3M6IHQsIElubGluZVRvb2xiYXI6IG8sIENvbnZlcnNpb25Ub29sYmFyOiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmNsb3NlKCksIG8uY2xvc2UoKSwgaS5jbG9zZSgpLCBlLnRvb2xib3guY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgZm9yIG1vYmlsZSBtb2RlIGFuZCBjYWNoZSBhIHJlc3VsdFxuICAgKi9cbiAgY2hlY2tJc01vYmlsZSgpIHtcbiAgICB0aGlzLmlzTW9iaWxlID0gd2luZG93LmlubmVyV2lkdGggPCBkdDtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgRWRpdG9yLmpzIGludGVyZmFjZVxuICAgKi9cbiAgbWFrZSgpIHtcbiAgICB0aGlzLm5vZGVzLmhvbGRlciA9IGMuZ2V0SG9sZGVyKHRoaXMuY29uZmlnLmhvbGRlciksIHRoaXMubm9kZXMud3JhcHBlciA9IGMubWFrZShcImRpdlwiLCBbXG4gICAgICB0aGlzLkNTUy5lZGl0b3JXcmFwcGVyLFxuICAgICAgLi4udGhpcy5pc1J0bCA/IFt0aGlzLkNTUy5lZGl0b3JSdGxGaXhdIDogW11cbiAgICBdKSwgdGhpcy5ub2Rlcy5yZWRhY3RvciA9IGMubWFrZShcImRpdlwiLCB0aGlzLkNTUy5lZGl0b3Jab25lKSwgdGhpcy5ub2Rlcy5ob2xkZXIub2Zmc2V0V2lkdGggPCB0aGlzLmNvbnRlbnRSZWN0LndpZHRoICYmIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmVkaXRvcldyYXBwZXJOYXJyb3cpLCB0aGlzLm5vZGVzLnJlZGFjdG9yLnN0eWxlLnBhZGRpbmdCb3R0b20gPSB0aGlzLmNvbmZpZy5taW5IZWlnaHQgKyBcInB4XCIsIHRoaXMubm9kZXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLnJlZGFjdG9yKSwgdGhpcy5ub2Rlcy5ob2xkZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy53cmFwcGVyKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyBDU1NcbiAgICovXG4gIGxvYWRTdHlsZXMoKSB7XG4gICAgY29uc3QgZSA9IFwiZWRpdG9yLWpzLXN0eWxlc1wiO1xuICAgIGlmIChjLmdldChlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gYy5tYWtlKFwic3R5bGVcIiwgbnVsbCwge1xuICAgICAgaWQ6IGUsXG4gICAgICB0ZXh0Q29udGVudDogeGkudG9TdHJpbmcoKVxuICAgIH0pO1xuICAgIHRoaXMuY29uZmlnLnN0eWxlICYmICFXKHRoaXMuY29uZmlnLnN0eWxlKSAmJiB0aGlzLmNvbmZpZy5zdHlsZS5ub25jZSAmJiB0LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIHRoaXMuY29uZmlnLnN0eWxlLm5vbmNlKSwgYy5wcmVwZW5kKGRvY3VtZW50LmhlYWQsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kIGV2ZW50cyBvbiB0aGUgRWRpdG9yLmpzIGludGVyZmFjZVxuICAgKi9cbiAgZW5hYmxlTW9kdWxlQmluZGluZ3MoKSB7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24odGhpcy5ub2Rlcy5yZWRhY3RvciwgXCJjbGlja1wiLCAobykgPT4ge1xuICAgICAgdGhpcy5yZWRhY3RvckNsaWNrZWQobyk7XG4gICAgfSwgITEpLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnJlZGFjdG9yLCBcIm1vdXNlZG93blwiLCAobykgPT4ge1xuICAgICAgdGhpcy5kb2N1bWVudFRvdWNoZWQobyk7XG4gICAgfSwge1xuICAgICAgY2FwdHVyZTogITAsXG4gICAgICBwYXNzaXZlOiAhMFxuICAgIH0pLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnJlZGFjdG9yLCBcInRvdWNoc3RhcnRcIiwgKG8pID0+IHtcbiAgICAgIHRoaXMuZG9jdW1lbnRUb3VjaGVkKG8pO1xuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6ICEwLFxuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZG9jdW1lbnQsIFwia2V5ZG93blwiLCAobykgPT4ge1xuICAgICAgdGhpcy5kb2N1bWVudEtleWRvd24obyk7XG4gICAgfSwgITApLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJtb3VzZWRvd25cIiwgKG8pID0+IHtcbiAgICAgIHRoaXMuZG9jdW1lbnRDbGlja2VkKG8pO1xuICAgIH0sICEwKTtcbiAgICBjb25zdCB0ID0gZXQoKCkgPT4ge1xuICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgfSwgMTgwKTtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdCwgITApLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih3aW5kb3csIFwicmVzaXplXCIsICgpID0+IHtcbiAgICAgIHRoaXMucmVzaXplRGVib3VuY2VyKCk7XG4gICAgfSwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgdGhpcy53YXRjaEJsb2NrSG92ZXJlZEV2ZW50cygpO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0ZW4gcmVkYWN0b3IgbW91c2Vtb3ZlIHRvIGVtaXQgJ2Jsb2NrLWhvdmVyZWQnIGV2ZW50XG4gICAqL1xuICB3YXRjaEJsb2NrSG92ZXJlZEV2ZW50cygpIHtcbiAgICBsZXQgZTtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnJlZGFjdG9yLCBcIm1vdXNlbW92ZVwiLCBJZSgodCkgPT4ge1xuICAgICAgY29uc3QgbyA9IHQudGFyZ2V0LmNsb3Nlc3QoXCIuY2UtYmxvY2tcIik7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5hbnlCbG9ja1NlbGVjdGVkIHx8IG8gJiYgZSAhPT0gbyAmJiAoZSA9IG8sIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KHl0LCB7XG4gICAgICAgIGJsb2NrOiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUNoaWxkTm9kZShvKVxuICAgICAgfSkpO1xuICAgIH0sIDIwKSwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50cyBvbiB0aGUgRWRpdG9yLmpzIGludGVyZmFjZVxuICAgKi9cbiAgZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLmNsZWFyQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZSB3aW5kb3cgaGFuZGxlclxuICAgKi9cbiAgd2luZG93UmVzaXplKCkge1xuICAgIHRoaXMuY29udGVudFJlY3RDYWNoZSA9IG51bGwsIHRoaXMuY2hlY2tJc01vYmlsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBbGwga2V5ZG93bnMgb24gZG9jdW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBkb2N1bWVudEtleWRvd24oZSkge1xuICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICBjYXNlIHYuRU5URVI6XG4gICAgICAgIHRoaXMuZW50ZXJQcmVzc2VkKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugdi5CQUNLU1BBQ0U6XG4gICAgICBjYXNlIHYuREVMRVRFOlxuICAgICAgICB0aGlzLmJhY2tzcGFjZVByZXNzZWQoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB2LkVTQzpcbiAgICAgICAgdGhpcy5lc2NhcGVQcmVzc2VkKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZGVmYXVsdEJlaGF2aW91cihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJZ25vcmUgYWxsIG90aGVyIGRvY3VtZW50J3Mga2V5ZG93biBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBkZWZhdWx0QmVoYXZpb3VyKGUpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogdCB9ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLCBvID0gZS50YXJnZXQuY2xvc2VzdChgLiR7dGhpcy5DU1MuZWRpdG9yV3JhcHBlcn1gKSwgaSA9IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleTtcbiAgICBpZiAodCAhPT0gdm9pZCAwICYmIG8gPT09IG51bGwpIHtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrRXZlbnRzLmtleWRvd24oZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG8gfHwgdCAmJiBpIHx8ICh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZHJvcFBvaW50ZXIoKSwgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBiYWNrc3BhY2VQcmVzc2VkKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQmxvY2tTZWxlY3Rpb246IG8sIENhcmV0OiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBpZiAoby5hbnlCbG9ja1NlbGVjdGVkICYmICFiLmlzU2VsZWN0aW9uRXhpc3RzKSB7XG4gICAgICBjb25zdCBuID0gdC5yZW1vdmVTZWxlY3RlZEJsb2NrcygpLCByID0gdC5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KG4sICEwKTtcbiAgICAgIGkuc2V0VG9CbG9jayhyLCBpLnBvc2l0aW9ucy5TVEFSVCksIG8uY2xlYXJTZWxlY3Rpb24oZSksIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKSwgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVzY2FwZSBwcmVzc2VkXG4gICAqIElmIHNvbWUgb2YgVG9vbGJhciBjb21wb25lbnRzIGFyZSBvcGVuZWQsIHRoZW4gY2xvc2UgaXQgb3RoZXJ3aXNlIGNsb3NlIFRvb2xiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBlc2NhcGUga2V5ZG93biBldmVudFxuICAgKi9cbiAgZXNjYXBlUHJlc3NlZChlKSB7XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSksIHRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5vcGVuZWQgPyAodGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94LmNsb3NlKCksIHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jaywgdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkVORCkpIDogdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQgPyB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmNsb3NlKCkgOiB0aGlzLkVkaXRvci5Db252ZXJzaW9uVG9vbGJhci5vcGVuZWQgPyB0aGlzLkVkaXRvci5Db252ZXJzaW9uVG9vbGJhci5jbG9zZSgpIDogdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5vcGVuZWQgPyB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCkgOiB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVudGVyIHByZXNzZWQgb24gZG9jdW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBlbnRlclByZXNzZWQoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBCbG9ja1NlbGVjdGlvbjogbyB9ID0gdGhpcy5FZGl0b3IsIGkgPSB0LmN1cnJlbnRCbG9ja0luZGV4ID49IDA7XG4gICAgaWYgKG8uYW55QmxvY2tTZWxlY3RlZCAmJiAhYi5pc1NlbGVjdGlvbkV4aXN0cykge1xuICAgICAgby5jbGVhclNlbGVjdGlvbihlKSwgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc29tZVRvb2xiYXJPcGVuZWQgJiYgaSAmJiBlLnRhcmdldC50YWdOYW1lID09PSBcIkJPRFlcIikge1xuICAgICAgY29uc3QgbiA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnQoKTtcbiAgICAgIHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sobiksIHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4obik7XG4gICAgfVxuICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpO1xuICB9XG4gIC8qKlxuICAgKiBBbGwgY2xpY2tzIG9uIGRvY3VtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBDbGljayBldmVudFxuICAgKi9cbiAgZG9jdW1lbnRDbGlja2VkKGUpIHtcbiAgICB2YXIgYSwgbDtcbiAgICBpZiAoIWUuaXNUcnVzdGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBlLnRhcmdldDtcbiAgICB0aGlzLm5vZGVzLmhvbGRlci5jb250YWlucyh0KSB8fCBiLmlzQXRFZGl0b3IgfHwgKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5kcm9wUG9pbnRlcigpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCkpO1xuICAgIGNvbnN0IGkgPSAoYSA9IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mubm9kZXMud3JhcHBlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY29udGFpbnModCksIG4gPSAobCA9IHRoaXMuRWRpdG9yLlRvb2xiYXIubm9kZXMuc2V0dGluZ3NUb2dnbGVyKSA9PSBudWxsID8gdm9pZCAwIDogbC5jb250YWlucyh0KSwgciA9IGkgfHwgbjtcbiAgICBpZiAodGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQgJiYgIXIpIHtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuY2xvc2UoKTtcbiAgICAgIGNvbnN0IGQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUNoaWxkTm9kZSh0KTtcbiAgICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oZCk7XG4gICAgfVxuICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpO1xuICB9XG4gIC8qKlxuICAgKiBGaXJzdCB0b3VjaCBvbiBlZGl0b3JcbiAgICogRmlyZWQgYmVmb3JlIGNsaWNrXG4gICAqXG4gICAqIFVzZWQgdG8gY2hhbmdlIGN1cnJlbnQgYmxvY2sg4oCUIHdlIG5lZWQgdG8gZG8gaXQgYmVmb3JlICdzZWxlY3Rpb25DaGFuZ2UnIGV2ZW50LlxuICAgKiBBbHNvOlxuICAgKiAtIE1vdmUgYW5kIHNob3cgdGhlIFRvb2xiYXJcbiAgICogLSBTZXQgYSBDYXJldFxuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnQgfCBUb3VjaEV2ZW50fSBldmVudCAtIHRvdWNoIG9yIG1vdXNlIGV2ZW50XG4gICAqL1xuICBkb2N1bWVudFRvdWNoZWQoZSkge1xuICAgIGxldCB0ID0gZS50YXJnZXQ7XG4gICAgaWYgKHQgPT09IHRoaXMubm9kZXMucmVkYWN0b3IpIHtcbiAgICAgIGNvbnN0IG8gPSBlIGluc3RhbmNlb2YgTW91c2VFdmVudCA/IGUuY2xpZW50WCA6IGUudG91Y2hlc1swXS5jbGllbnRYLCBpID0gZSBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBlLmNsaWVudFkgOiBlLnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgIHQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KG8sIGkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLnNldEN1cnJlbnRCbG9ja0J5Q2hpbGROb2RlKHQpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhpcy5FZGl0b3IuUmVjdGFuZ2xlU2VsZWN0aW9uLmlzUmVjdEFjdGl2YXRlZCgpIHx8IHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvVGhlTGFzdEJsb2NrKCk7XG4gICAgfVxuICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oKTtcbiAgfVxuICAvKipcbiAgICogQWxsIGNsaWNrcyBvbiB0aGUgcmVkYWN0b3Igem9uZVxuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gY2xpY2sgZXZlbnRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIC0gQnkgY2xpY2tzIG9uIHRoZSBFZGl0b3IncyBib3R0b20gem9uZTpcbiAgICogICAgICAtIGlmIGxhc3QgQmxvY2sgaXMgZW1wdHksIHNldCBhIENhcmV0IHRvIHRoaXNcbiAgICogICAgICAtIG90aGVyd2lzZSwgYWRkIGEgbmV3IGVtcHR5IEJsb2NrIGFuZCBzZXQgYSBDYXJldCB0byB0aGF0XG4gICAqL1xuICByZWRhY3RvckNsaWNrZWQoZSkge1xuICAgIGlmICghYi5pc0NvbGxhcHNlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZS50YXJnZXQsIG8gPSBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5O1xuICAgIGlmIChjLmlzQW5jaG9yKHQpICYmIG8pIHtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBjb25zdCBpID0gdC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLCBuID0gV3QoaSk7XG4gICAgICBLdChuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wcm9jZXNzQm90dG9tWm9uZUNsaWNrKGUpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB1c2VyIGNsaWNrcyBvbiB0aGUgRWRpdG9yJ3MgYm90dG9tIHpvbmU6XG4gICAqICAtIHNldCBjYXJldCB0byB0aGUgbGFzdCBibG9ja1xuICAgKiAgLSBvciBhZGQgbmV3IGVtcHR5IGJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIGNsaWNrIGV2ZW50XG4gICAqL1xuICBwcm9jZXNzQm90dG9tWm9uZUNsaWNrKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJbmRleCgtMSksIG8gPSBjLm9mZnNldCh0LmhvbGRlcikuYm90dG9tLCBpID0gZS5wYWdlWSwgeyBCbG9ja1NlbGVjdGlvbjogbiB9ID0gdGhpcy5FZGl0b3I7XG4gICAgaWYgKGUudGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCAmJiBlLnRhcmdldC5pc0VxdWFsTm9kZSh0aGlzLm5vZGVzLnJlZGFjdG9yKSAmJiAvKipcbiAgICAqIElmIHRoZXJlIGlzIGNyb3NzIGJsb2NrIHNlbGVjdGlvbiBzdGFydGVkLCB0YXJnZXQgd2lsbCBiZSBlcXVhbCB0byByZWRhY3RvciBzbyB3ZSBuZWVkIGFkZGl0aW9uYWwgY2hlY2tcbiAgICAqL1xuICAgICFuLmFueUJsb2NrU2VsZWN0ZWQgJiYgLyoqXG4gICAgKiBQcmV2ZW50IGNhcmV0IGp1bXBpbmcgKHRvIGxhc3QgYmxvY2spIHdoZW4gY2xpY2tpbmcgYmV0d2VlbiBibG9ja3NcbiAgICAqL1xuICAgIG8gPCBpKSB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGEsIENhcmV0OiBsLCBUb29sYmFyOiBkIH0gPSB0aGlzLkVkaXRvcjtcbiAgICAgICghYS5sYXN0QmxvY2sudG9vbC5pc0RlZmF1bHQgfHwgIWEubGFzdEJsb2NrLmlzRW1wdHkpICYmIGEuaW5zZXJ0QXRFbmQoKSwgbC5zZXRUb1RoZUxhc3RCbG9jaygpLCBkLm1vdmVBbmRPcGVuKGEubGFzdEJsb2NrKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBzZWxlY3Rpb24gY2hhbmdlcyBvbiBtb2JpbGUgZGV2aWNlc1xuICAgKiBVc2VzIGZvciBzaG93aW5nIHRoZSBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgc2VsZWN0aW9uQ2hhbmdlZCgpIHtcbiAgICBjb25zdCB7IENyb3NzQmxvY2tTZWxlY3Rpb246IGUsIEJsb2NrU2VsZWN0aW9uOiB0IH0gPSB0aGlzLkVkaXRvciwgbyA9IGIuYW5jaG9yRWxlbWVudDtcbiAgICBpZiAoZS5pc0Nyb3NzQmxvY2tTZWxlY3Rpb25TdGFydGVkICYmIHQuYW55QmxvY2tTZWxlY3RlZCAmJiBiLmdldCgpLnJlbW92ZUFsbFJhbmdlcygpLCAhbykge1xuICAgICAgYi5yYW5nZSB8fCB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSBvLmNsb3Nlc3QoYC4ke1IuQ1NTLmNvbnRlbnR9YCkgPT09IG51bGw7XG4gICAgaWYgKGkgJiYgKHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY29udGFpbnNOb2RlKG8pIHx8IHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKSwgIShvLmRhdGFzZXQuaW5saW5lVG9vbGJhciA9PT0gXCJ0cnVlXCIpKSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrIHx8IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZShvKTtcbiAgICBjb25zdCBuID0gaSAhPT0gITA7XG4gICAgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci50cnlUb1Nob3coITAsIG4pO1xuICB9XG59XG5jb25zdCB5aSA9IHtcbiAgLy8gQVBJIE1vZHVsZXNcbiAgQmxvY2tzQVBJOiBvbyxcbiAgQ2FyZXRBUEk6IGlvLFxuICBFdmVudHNBUEk6IG5vLFxuICBJMThuQVBJOiBIZSxcbiAgQVBJOiBzbyxcbiAgSW5saW5lVG9vbGJhckFQSTogcm8sXG4gIExpc3RlbmVyc0FQSTogYW8sXG4gIE5vdGlmaWVyQVBJOiB1byxcbiAgUmVhZE9ubHlBUEk6IHBvLFxuICBTYW5pdGl6ZXJBUEk6IHhvLFxuICBTYXZlckFQSTogd28sXG4gIFNlbGVjdGlvbkFQSTogeW8sXG4gIFN0eWxlc0FQSTogRW8sXG4gIFRvb2xiYXJBUEk6IEJvLFxuICBUb29sdGlwQVBJOiBNbyxcbiAgVWlBUEk6IExvLFxuICAvLyBUb29sYmFyIE1vZHVsZXNcbiAgQmxvY2tTZXR0aW5nczogWW8sXG4gIENvbnZlcnNpb25Ub29sYmFyOiAkLFxuICBUb29sYmFyOiBKbyxcbiAgSW5saW5lVG9vbGJhcjogUW8sXG4gIC8vIE1vZHVsZXNcbiAgQmxvY2tFdmVudHM6IGVpLFxuICBCbG9ja01hbmFnZXI6IGlpLFxuICBCbG9ja1NlbGVjdGlvbjogbmksXG4gIENhcmV0OiB3ZSxcbiAgQ3Jvc3NCbG9ja1NlbGVjdGlvbjogc2ksXG4gIERyYWdORHJvcDogcmksXG4gIE1vZGlmaWNhdGlvbnNPYnNlcnZlcjogYWksXG4gIFBhc3RlOiBUdCxcbiAgUmVhZE9ubHk6IGxpLFxuICBSZWN0YW5nbGVTZWxlY3Rpb246IGZlLFxuICBSZW5kZXJlcjogY2ksXG4gIFNhdmVyOiBkaSxcbiAgVG9vbHM6IF90LFxuICBVSTogd2lcbn07XG5jbGFzcyBFaSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VkaXRvckNvbmZpZ30gY29uZmlnIC0gdXNlciBjb25maWd1cmF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5tb2R1bGVJbnN0YW5jZXMgPSB7fSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyID0gbmV3IEVlKCk7XG4gICAgbGV0IHQsIG87XG4gICAgdGhpcy5pc1JlYWR5ID0gbmV3IFByb21pc2UoKGksIG4pID0+IHtcbiAgICAgIHQgPSBpLCBvID0gbjtcbiAgICB9KSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBlLCB0aGlzLnZhbGlkYXRlKCksIHRoaXMuaW5pdCgpLCBhd2FpdCB0aGlzLnN0YXJ0KCksIGF3YWl0IHRoaXMucmVuZGVyKCk7XG4gICAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogaSwgQ2FyZXQ6IG4sIFVJOiByLCBNb2RpZmljYXRpb25zT2JzZXJ2ZXI6IGEgfSA9IHRoaXMubW9kdWxlSW5zdGFuY2VzO1xuICAgICAgci5jaGVja0VtcHRpbmVzcygpLCBhLmVuYWJsZSgpLCB0aGlzLmNvbmZpZ3VyYXRpb24uYXV0b2ZvY3VzICYmIG4uc2V0VG9CbG9jayhpLmJsb2Nrc1swXSwgbi5wb3NpdGlvbnMuU1RBUlQpLCB0KCk7XG4gICAgfSkuY2F0Y2goKGkpID0+IHtcbiAgICAgIFQoYEVkaXRvci5qcyBpcyBub3QgcmVhZHkgYmVjYXVzZSBvZiAke2l9YCwgXCJlcnJvclwiKSwgbyhpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0dGluZyBmb3IgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0VkaXRvckNvbmZpZ3xzdHJpbmd9IGNvbmZpZyAtIEVkaXRvcidzIGNvbmZpZyB0byBzZXRcbiAgICovXG4gIHNldCBjb25maWd1cmF0aW9uKGUpIHtcbiAgICB2YXIgbywgaTtcbiAgICBEKGUpID8gdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi5lXG4gICAgfSA6IHRoaXMuY29uZmlnID0ge1xuICAgICAgaG9sZGVyOiBlXG4gICAgfSwgTGUoISF0aGlzLmNvbmZpZy5ob2xkZXJJZCwgXCJjb25maWcuaG9sZGVySWRcIiwgXCJjb25maWcuaG9sZGVyXCIpLCB0aGlzLmNvbmZpZy5ob2xkZXJJZCAmJiAhdGhpcy5jb25maWcuaG9sZGVyICYmICh0aGlzLmNvbmZpZy5ob2xkZXIgPSB0aGlzLmNvbmZpZy5ob2xkZXJJZCwgdGhpcy5jb25maWcuaG9sZGVySWQgPSBudWxsKSwgdGhpcy5jb25maWcuaG9sZGVyID09IG51bGwgJiYgKHRoaXMuY29uZmlnLmhvbGRlciA9IFwiZWRpdG9yanNcIiksIHRoaXMuY29uZmlnLmxvZ0xldmVsIHx8ICh0aGlzLmNvbmZpZy5sb2dMZXZlbCA9IGF0LlZFUkJPU0UpLCBGdCh0aGlzLmNvbmZpZy5sb2dMZXZlbCksIExlKCEhdGhpcy5jb25maWcuaW5pdGlhbEJsb2NrLCBcImNvbmZpZy5pbml0aWFsQmxvY2tcIiwgXCJjb25maWcuZGVmYXVsdEJsb2NrXCIpLCB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2sgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2sgfHwgdGhpcy5jb25maWcuaW5pdGlhbEJsb2NrIHx8IFwicGFyYWdyYXBoXCIsIHRoaXMuY29uZmlnLm1pbkhlaWdodCA9IHRoaXMuY29uZmlnLm1pbkhlaWdodCAhPT0gdm9pZCAwID8gdGhpcy5jb25maWcubWluSGVpZ2h0IDogMzAwO1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICB0eXBlOiB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2ssXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgdGhpcy5jb25maWcucGxhY2Vob2xkZXIgPSB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciB8fCAhMSwgdGhpcy5jb25maWcuc2FuaXRpemVyID0gdGhpcy5jb25maWcuc2FuaXRpemVyIHx8IHtcbiAgICAgIHA6ICEwLFxuICAgICAgYjogITAsXG4gICAgICBhOiAhMFxuICAgIH0sIHRoaXMuY29uZmlnLmhpZGVUb29sYmFyID0gdGhpcy5jb25maWcuaGlkZVRvb2xiYXIgPyB0aGlzLmNvbmZpZy5oaWRlVG9vbGJhciA6ICExLCB0aGlzLmNvbmZpZy50b29scyA9IHRoaXMuY29uZmlnLnRvb2xzIHx8IHt9LCB0aGlzLmNvbmZpZy5pMThuID0gdGhpcy5jb25maWcuaTE4biB8fCB7fSwgdGhpcy5jb25maWcuZGF0YSA9IHRoaXMuY29uZmlnLmRhdGEgfHwgeyBibG9ja3M6IFtdIH0sIHRoaXMuY29uZmlnLm9uUmVhZHkgPSB0aGlzLmNvbmZpZy5vblJlYWR5IHx8ICgoKSA9PiB7XG4gICAgfSksIHRoaXMuY29uZmlnLm9uQ2hhbmdlID0gdGhpcy5jb25maWcub25DaGFuZ2UgfHwgKCgpID0+IHtcbiAgICB9KSwgdGhpcy5jb25maWcuaW5saW5lVG9vbGJhciA9IHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIgIT09IHZvaWQgMCA/IHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIgOiAhMCwgKFcodGhpcy5jb25maWcuZGF0YSkgfHwgIXRoaXMuY29uZmlnLmRhdGEuYmxvY2tzIHx8IHRoaXMuY29uZmlnLmRhdGEuYmxvY2tzLmxlbmd0aCA9PT0gMCkgJiYgKHRoaXMuY29uZmlnLmRhdGEgPSB7IGJsb2NrczogW3RdIH0pLCB0aGlzLmNvbmZpZy5yZWFkT25seSA9IHRoaXMuY29uZmlnLnJlYWRPbmx5IHx8ICExLCAobyA9IHRoaXMuY29uZmlnLmkxOG4pICE9IG51bGwgJiYgby5tZXNzYWdlcyAmJiB6LnNldERpY3Rpb25hcnkodGhpcy5jb25maWcuaTE4bi5tZXNzYWdlcyksIHRoaXMuY29uZmlnLmkxOG4uZGlyZWN0aW9uID0gKChpID0gdGhpcy5jb25maWcuaTE4bikgPT0gbnVsbCA/IHZvaWQgMCA6IGkuZGlyZWN0aW9uKSB8fCBcImx0clwiO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByaXZhdGUgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybnMge0VkaXRvckNvbmZpZ31cbiAgICovXG4gIGdldCBjb25maWd1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGZvciByZXF1aXJlZCBmaWVsZHMgaW4gRWRpdG9yJ3MgY29uZmlnXG4gICAqL1xuICB2YWxpZGF0ZSgpIHtcbiAgICBjb25zdCB7IGhvbGRlcklkOiBlLCBob2xkZXI6IHQgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmIChlICYmIHQpXG4gICAgICB0aHJvdyBFcnJvcihcIsKraG9sZGVySWTCuyBhbmQgwqtob2xkZXLCuyBwYXJhbSBjYW4ndCBhc3NpZ24gYXQgdGhlIHNhbWUgdGltZS5cIik7XG4gICAgaWYgKEcodCkgJiYgIWMuZ2V0KHQpKVxuICAgICAgdGhyb3cgRXJyb3IoYGVsZW1lbnQgd2l0aCBJRCDCqyR7dH3CuyBpcyBtaXNzaW5nLiBQYXNzIGNvcnJlY3QgaG9sZGVyJ3MgSUQuYCk7XG4gICAgaWYgKHQgJiYgRCh0KSAmJiAhYy5pc0VsZW1lbnQodCkpXG4gICAgICB0aHJvdyBFcnJvcihcIsKraG9sZGVywrsgdmFsdWUgbXVzdCBiZSBhbiBFbGVtZW50IG5vZGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIG1vZHVsZXM6XG4gICAqICAtIG1ha2UgYW5kIHNhdmUgaW5zdGFuY2VzXG4gICAqICAtIGNvbmZpZ3VyZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmNvbnN0cnVjdE1vZHVsZXMoKSwgdGhpcy5jb25maWd1cmVNb2R1bGVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IEVkaXRvciFcbiAgICpcbiAgICogR2V0IGxpc3Qgb2YgbW9kdWxlcyB0aGF0IG5lZWRzIHRvIGJlIHByZXBhcmVkIGFuZCByZXR1cm4gYSBzZXF1ZW5jZSAoUHJvbWlzZSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBzdGFydCgpIHtcbiAgICBhd2FpdCBbXG4gICAgICBcIlRvb2xzXCIsXG4gICAgICBcIlVJXCIsXG4gICAgICBcIkJsb2NrTWFuYWdlclwiLFxuICAgICAgXCJQYXN0ZVwiLFxuICAgICAgXCJCbG9ja1NlbGVjdGlvblwiLFxuICAgICAgXCJSZWN0YW5nbGVTZWxlY3Rpb25cIixcbiAgICAgIFwiQ3Jvc3NCbG9ja1NlbGVjdGlvblwiLFxuICAgICAgXCJSZWFkT25seVwiXG4gICAgXS5yZWR1Y2UoXG4gICAgICAodCwgbykgPT4gdC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLm1vZHVsZUluc3RhbmNlc1tvXS5wcmVwYXJlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgICBpZiAoaSBpbnN0YW5jZW9mIHV0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGkubWVzc2FnZSk7XG4gICAgICAgICAgVChgTW9kdWxlICR7b30gd2FzIHNraXBwZWQgYmVjYXVzZSBvZiAlb2AsIFwid2FyblwiLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciBpbml0aWFsIGRhdGFcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVJbnN0YW5jZXMuUmVuZGVyZXIucmVuZGVyKHRoaXMuY29uZmlnLmRhdGEuYmxvY2tzKTtcbiAgfVxuICAvKipcbiAgICogTWFrZSBtb2R1bGVzIGluc3RhbmNlcyBhbmQgc2F2ZSBpdCB0byB0aGUgQHByb3BlcnR5IHRoaXMubW9kdWxlSW5zdGFuY2VzXG4gICAqL1xuICBjb25zdHJ1Y3RNb2R1bGVzKCkge1xuICAgIE9iamVjdC5lbnRyaWVzKHlpKS5mb3JFYWNoKChbZSwgdF0pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubW9kdWxlSW5zdGFuY2VzW2VdID0gbmV3IHQoe1xuICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWd1cmF0aW9uLFxuICAgICAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRoaXMuZXZlbnRzRGlzcGF0Y2hlclxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgVChcIltjb25zdHJ1Y3RNb2R1bGVzXVwiLCBgTW9kdWxlICR7ZX0gc2tpcHBlZCBiZWNhdXNlYCwgXCJlcnJvclwiLCBvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlcyBpbnN0YW5jZXMgY29uZmlndXJhdGlvbjpcbiAgICogIC0gcGFzcyBvdGhlciBtb2R1bGVzIHRvIHRoZSAnc3RhdGUnIHByb3BlcnR5XG4gICAqICAtIC4uLlxuICAgKi9cbiAgY29uZmlndXJlTW9kdWxlcygpIHtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5tb2R1bGVJbnN0YW5jZXMpXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tb2R1bGVJbnN0YW5jZXMsIGUpICYmICh0aGlzLm1vZHVsZUluc3RhbmNlc1tlXS5zdGF0ZSA9IHRoaXMuZ2V0TW9kdWxlc0RpZmYoZSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gbW9kdWxlcyB3aXRob3V0IHBhc3NlZCBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gbW9kdWxlIGZvciB3aXRjaCBtb2R1bGVzIGRpZmZlcmVuY2Ugc2hvdWxkIGJlIGNhbGN1bGF0ZWRcbiAgICovXG4gIGdldE1vZHVsZXNEaWZmKGUpIHtcbiAgICBjb25zdCB0ID0ge307XG4gICAgZm9yIChjb25zdCBvIGluIHRoaXMubW9kdWxlSW5zdGFuY2VzKVxuICAgICAgbyAhPT0gZSAmJiAodFtvXSA9IHRoaXMubW9kdWxlSW5zdGFuY2VzW29dKTtcbiAgICByZXR1cm4gdDtcbiAgfVxufVxuLyoqXG4gKiBFZGl0b3IuanNcbiAqXG4gKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4gKiBAc2VlIEVkaXRvci5qcyA8aHR0cHM6Ly9lZGl0b3Jqcy5pbz5cbiAqIEBhdXRob3IgQ29kZVggVGVhbSA8aHR0cHM6Ly9jb2RleC5zbz5cbiAqL1xuY2xhc3MgQmkge1xuICAvKiogRWRpdG9yIHZlcnNpb24gKi9cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBcIjIuMjkuMVwiO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VkaXRvckNvbmZpZ3xzdHJpbmd8dW5kZWZpbmVkfSBbY29uZmlndXJhdGlvbl0gLSB1c2VyIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBsZXQgdCA9ICgpID0+IHtcbiAgICB9O1xuICAgIEQoZSkgJiYgTShlLm9uUmVhZHkpICYmICh0ID0gZS5vblJlYWR5KTtcbiAgICBjb25zdCBvID0gbmV3IEVpKGUpO1xuICAgIHRoaXMuaXNSZWFkeSA9IG8uaXNSZWFkeS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuZXhwb3J0QVBJKG8pLCB0KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4cG9ydCBleHRlcm5hbCBBUEkgbWV0aG9kc1xuICAgKlxuICAgKiBAcGFyYW0ge0NvcmV9IGVkaXRvciDigJQgRWRpdG9yJ3MgaW5zdGFuY2VcbiAgICovXG4gIGV4cG9ydEFQSShlKSB7XG4gICAgY29uc3QgdCA9IFtcImNvbmZpZ3VyYXRpb25cIl0sIG8gPSAoKSA9PiB7XG4gICAgICBPYmplY3QudmFsdWVzKGUubW9kdWxlSW5zdGFuY2VzKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIE0obi5kZXN0cm95KSAmJiBuLmRlc3Ryb3koKSwgbi5saXN0ZW5lcnMucmVtb3ZlQWxsKCk7XG4gICAgICB9KSwgSW8oKSwgZSA9IG51bGw7XG4gICAgICBmb3IgKGNvbnN0IG4gaW4gdGhpcylcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG4pICYmIGRlbGV0ZSB0aGlzW25dO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG51bGwpO1xuICAgIH07XG4gICAgdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICB0aGlzW25dID0gZVtuXTtcbiAgICB9KSwgdGhpcy5kZXN0cm95ID0gbywgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGUubW9kdWxlSW5zdGFuY2VzLkFQSS5tZXRob2RzKSwgZGVsZXRlIHRoaXMuZXhwb3J0QVBJLCBPYmplY3QuZW50cmllcyh7XG4gICAgICBibG9ja3M6IHtcbiAgICAgICAgY2xlYXI6IFwiY2xlYXJcIixcbiAgICAgICAgcmVuZGVyOiBcInJlbmRlclwiXG4gICAgICB9LFxuICAgICAgY2FyZXQ6IHtcbiAgICAgICAgZm9jdXM6IFwiZm9jdXNcIlxuICAgICAgfSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBvbjogXCJvblwiLFxuICAgICAgICBvZmY6IFwib2ZmXCIsXG4gICAgICAgIGVtaXQ6IFwiZW1pdFwiXG4gICAgICB9LFxuICAgICAgc2F2ZXI6IHtcbiAgICAgICAgc2F2ZTogXCJzYXZlXCJcbiAgICAgIH1cbiAgICB9KS5mb3JFYWNoKChbbiwgcl0pID0+IHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHIpLmZvckVhY2goKFthLCBsXSkgPT4ge1xuICAgICAgICB0aGlzW2xdID0gZS5tb2R1bGVJbnN0YW5jZXMuQVBJLm1ldGhvZHNbbl1bYV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgQmkgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/editorjs/dist/editorjs.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/header/dist/header.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@editorjs/header/dist/header.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ c)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-header{padding:.6em 0 3px;margin:0;line-height:1.25em;outline:none}.ce-header p,.ce-header div{padding:0!important;margin:0!important}.ce-header[contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;display:none;cursor:text}.ce-header[contentEditable=true][data-placeholder]:empty:before{display:block}.ce-header[contentEditable=true][data-placeholder]:empty:focus:before{display:none}\")),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nconst i = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M19 17V10.2135C19 10.1287 18.9011 10.0824 18.836 10.1367L16 12.5\"/></svg>', a = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 11C16 10 19 9.5 19 12C19 13.9771 16.0684 13.9997 16.0012 16.8981C15.9999 16.9533 16.0448 17 16.1 17L19.3 17\"/></svg>', l = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 11C16 10.5 16.8323 10 17.6 10C18.3677 10 19.5 10.311 19.5 11.5C19.5 12.5315 18.7474 12.9022 18.548 12.9823C18.5378 12.9864 18.5395 13.0047 18.5503 13.0063C18.8115 13.0456 20 13.3065 20 14.8C20 16 19.5 17 17.8 17C17.8 17 16 17 16 16.3\"/></svg>', o = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M18 10L15.2834 14.8511C15.246 14.9178 15.294 15 15.3704 15C16.8489 15 18.7561 15 20.2 15M19 17C19 15.7187 19 14.8813 19 13.6\"/></svg>', h = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 15.9C16 15.9 16.3768 17 17.8 17C19.5 17 20 15.6199 20 14.7C20 12.7323 17.6745 12.0486 16.1635 12.9894C16.094 13.0327 16 12.9846 16 12.9027V10.1C16 10.0448 16.0448 10 16.1 10H19.8\"/></svg>', d = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M19.5 10C16.5 10.5 16 13.3285 16 15M16 15V15C16 16.1046 16.8954 17 18 17H18.3246C19.3251 17 20.3191 16.3492 20.2522 15.3509C20.0612 12.4958 16 12.6611 16 15Z\"/></svg>', u = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9 7L9 12M9 17V12M9 12L15 12M15 7V12M15 17L15 12\"/></svg>';\n/**\n * Header block for the Editor.js.\n *\n * @author CodeX (team@ifmo.su)\n * @copyright CodeX 2018\n * @license MIT\n * @version 2.0.0\n */\nclass c {\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {{data: HeaderData, config: HeaderConfig, api: object}}\n   *   data — previously saved data\n   *   config - user config for Tool\n   *   api - Editor.js API\n   *   readOnly - read only mode flag\n   */\n  constructor({ data: e, config: t, api: s, readOnly: r }) {\n    this.api = s, this.readOnly = r, this._CSS = {\n      block: this.api.styles.block,\n      wrapper: \"ce-header\"\n    }, this._settings = t, this._data = this.normalizeData(e), this._element = this.getTag();\n  }\n  /**\n   * Normalize input data\n   *\n   * @param {HeaderData} data - saved data to process\n   *\n   * @returns {HeaderData}\n   * @private\n   */\n  normalizeData(e) {\n    const t = {};\n    return typeof e != \"object\" && (e = {}), t.text = e.text || \"\", t.level = parseInt(e.level) || this.defaultLevel.number, t;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLHeadingElement}\n   * @public\n   */\n  render() {\n    return this._element;\n  }\n  /**\n   * Returns header block tunes config\n   *\n   * @returns {Array}\n   */\n  renderSettings() {\n    return this.levels.map((e) => ({\n      icon: e.svg,\n      label: this.api.i18n.t(`Heading ${e.number}`),\n      onActivate: () => this.setLevel(e.number),\n      closeOnActivate: !0,\n      isActive: this.currentLevel.number === e.number\n    }));\n  }\n  /**\n   * Callback for Block's settings buttons\n   *\n   * @param {number} level - level to set\n   */\n  setLevel(e) {\n    this.data = {\n      level: e,\n      text: this.data.text\n    };\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {HeaderData} data - saved data to merger with current block\n   * @public\n   */\n  merge(e) {\n    const t = {\n      text: this.data.text + e.text,\n      level: this.data.level\n    };\n    this.data = t;\n  }\n  /**\n   * Validate Text block data:\n   * - check for emptiness\n   *\n   * @param {HeaderData} blockData — data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(e) {\n    return e.text.trim() !== \"\";\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLHeadingElement} toolsContent - Text tools rendered view\n   * @returns {HeaderData} - saved data\n   * @public\n   */\n  save(e) {\n    return {\n      text: e.innerHTML,\n      level: this.currentLevel.number\n    };\n  }\n  /**\n   * Allow Header to be converted to/from other blocks\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // use 'text' property for other blocks\n      import: \"text\"\n      // fill 'text' property from other block's export string\n    };\n  }\n  /**\n   * Sanitizer Rules\n   */\n  static get sanitize() {\n    return {\n      level: !1,\n      text: {}\n    };\n  }\n  /**\n   * Returns true to notify core that read-only is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get current Tools`s data\n   *\n   * @returns {HeaderData} Current data\n   * @private\n   */\n  get data() {\n    return this._data.text = this._element.innerHTML, this._data.level = this.currentLevel.number, this._data;\n  }\n  /**\n   * Store data in plugin:\n   * - at the this._data property\n   * - at the HTML\n   *\n   * @param {HeaderData} data — data to set\n   * @private\n   */\n  set data(e) {\n    if (this._data = this.normalizeData(e), e.level !== void 0 && this._element.parentNode) {\n      const t = this.getTag();\n      t.innerHTML = this._element.innerHTML, this._element.parentNode.replaceChild(t, this._element), this._element = t;\n    }\n    e.text !== void 0 && (this._element.innerHTML = this._data.text || \"\");\n  }\n  /**\n   * Get tag for target level\n   * By default returns second-leveled header\n   *\n   * @returns {HTMLElement}\n   */\n  getTag() {\n    const e = document.createElement(this.currentLevel.tag);\n    return e.innerHTML = this._data.text || \"\", e.classList.add(this._CSS.wrapper), e.contentEditable = this.readOnly ? \"false\" : \"true\", e.dataset.placeholder = this.api.i18n.t(this._settings.placeholder || \"\"), e;\n  }\n  /**\n   * Get current level\n   *\n   * @returns {level}\n   */\n  get currentLevel() {\n    let e = this.levels.find((t) => t.number === this._data.level);\n    return e || (e = this.defaultLevel), e;\n  }\n  /**\n   * Return default level\n   *\n   * @returns {level}\n   */\n  get defaultLevel() {\n    if (this._settings.defaultLevel) {\n      const e = this.levels.find((t) => t.number === this._settings.defaultLevel);\n      if (e)\n        return e;\n      console.warn(\"(ง'̀-'́)ง Heading Tool: the default level specified was not found in available levels\");\n    }\n    return this.levels[1];\n  }\n  /**\n   * @typedef {object} level\n   * @property {number} number - level number\n   * @property {string} tag - tag corresponds with level number\n   * @property {string} svg - icon\n   */\n  /**\n   * Available header levels\n   *\n   * @returns {level[]}\n   */\n  get levels() {\n    const e = [\n      {\n        number: 1,\n        tag: \"H1\",\n        svg: i\n      },\n      {\n        number: 2,\n        tag: \"H2\",\n        svg: a\n      },\n      {\n        number: 3,\n        tag: \"H3\",\n        svg: l\n      },\n      {\n        number: 4,\n        tag: \"H4\",\n        svg: o\n      },\n      {\n        number: 5,\n        tag: \"H5\",\n        svg: h\n      },\n      {\n        number: 6,\n        tag: \"H6\",\n        svg: d\n      }\n    ];\n    return this._settings.levels ? e.filter(\n      (t) => this._settings.levels.includes(t.number)\n    ) : e;\n  }\n  /**\n   * Handle H1-H6 tags on paste to substitute it with header Tool\n   *\n   * @param {PasteEvent} event - event with pasted content\n   */\n  onPaste(e) {\n    const t = e.detail.data;\n    let s = this.defaultLevel.number;\n    switch (t.tagName) {\n      case \"H1\":\n        s = 1;\n        break;\n      case \"H2\":\n        s = 2;\n        break;\n      case \"H3\":\n        s = 3;\n        break;\n      case \"H4\":\n        s = 4;\n        break;\n      case \"H5\":\n        s = 5;\n        break;\n      case \"H6\":\n        s = 6;\n        break;\n    }\n    this._settings.levels && (s = this._settings.levels.reduce((r, n) => Math.abs(n - s) < Math.abs(r - s) ? n : r)), this.data = {\n      level: s,\n      text: t.innerHTML\n    };\n  }\n  /**\n   * Used by Editor.js paste handling API.\n   * Provides configuration to handle H1-H6 tags.\n   *\n   * @returns {{handler: (function(HTMLElement): {text: string}), tags: string[]}}\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\"]\n    };\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: u,\n      title: \"Heading\"\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2hlYWRlci9kaXN0L2hlYWRlci5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFlBQVksYUFBYSxJQUFJLHdCQUF3QixzQ0FBc0Msa0RBQWtELG1CQUFtQixTQUFTLG1CQUFtQixhQUFhLDRCQUE0QixvQkFBb0IsbUJBQW1CLDBEQUEwRCxrQkFBa0IsK0JBQStCLGNBQWMsZ0JBQWdCLGFBQWEsWUFBWSxnRUFBZ0UsY0FBYyxzRUFBc0UsYUFBYSxrQ0FBa0MsU0FBUyxtREFBbUQ7QUFDN3FCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQyxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQyxhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZWRpdG9yanMtYXBwLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy9oZWFkZXIvZGlzdC9oZWFkZXIubWpzP2ZlNmMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIil7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuY2UtaGVhZGVye3BhZGRpbmc6LjZlbSAwIDNweDttYXJnaW46MDtsaW5lLWhlaWdodDoxLjI1ZW07b3V0bGluZTpub25lfS5jZS1oZWFkZXIgcCwuY2UtaGVhZGVyIGRpdntwYWRkaW5nOjAhaW1wb3J0YW50O21hcmdpbjowIWltcG9ydGFudH0uY2UtaGVhZGVyW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7Y29udGVudDphdHRyKGRhdGEtcGxhY2Vob2xkZXIpO2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NDAwO2Rpc3BsYXk6bm9uZTtjdXJzb3I6dGV4dH0uY2UtaGVhZGVyW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpiZWZvcmV7ZGlzcGxheTpibG9ja30uY2UtaGVhZGVyW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpmb2N1czpiZWZvcmV7ZGlzcGxheTpub25lfVwiKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlKX19Y2F0Y2godCl7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLHQpfX0pKCk7XG5jb25zdCBpID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk02IDdMNiAxMk02IDE3TDYgMTJNNiAxMkwxMiAxMk0xMiA3VjEyTTEyIDE3TDEyIDEyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xOSAxN1YxMC4yMTM1QzE5IDEwLjEyODcgMTguOTAxMSAxMC4wODI0IDE4LjgzNiAxMC4xMzY3TDE2IDEyLjVcIi8+PC9zdmc+JywgYSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNiA3TDYgMTJNNiAxN0w2IDEyTTYgMTJMMTIgMTJNMTIgN1YxMk0xMiAxN0wxMiAxMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTYgMTFDMTYgMTAgMTkgOS41IDE5IDEyQzE5IDEzLjk3NzEgMTYuMDY4NCAxMy45OTk3IDE2LjAwMTIgMTYuODk4MUMxNS45OTk5IDE2Ljk1MzMgMTYuMDQ0OCAxNyAxNi4xIDE3TDE5LjMgMTdcIi8+PC9zdmc+JywgbCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNiA3TDYgMTJNNiAxN0w2IDEyTTYgMTJMMTIgMTJNMTIgN1YxMk0xMiAxN0wxMiAxMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTYgMTFDMTYgMTAuNSAxNi44MzIzIDEwIDE3LjYgMTBDMTguMzY3NyAxMCAxOS41IDEwLjMxMSAxOS41IDExLjVDMTkuNSAxMi41MzE1IDE4Ljc0NzQgMTIuOTAyMiAxOC41NDggMTIuOTgyM0MxOC41Mzc4IDEyLjk4NjQgMTguNTM5NSAxMy4wMDQ3IDE4LjU1MDMgMTMuMDA2M0MxOC44MTE1IDEzLjA0NTYgMjAgMTMuMzA2NSAyMCAxNC44QzIwIDE2IDE5LjUgMTcgMTcuOCAxN0MxNy44IDE3IDE2IDE3IDE2IDE2LjNcIi8+PC9zdmc+JywgbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNiA3TDYgMTJNNiAxN0w2IDEyTTYgMTJMMTIgMTJNMTIgN1YxMk0xMiAxN0wxMiAxMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTggMTBMMTUuMjgzNCAxNC44NTExQzE1LjI0NiAxNC45MTc4IDE1LjI5NCAxNSAxNS4zNzA0IDE1QzE2Ljg0ODkgMTUgMTguNzU2MSAxNSAyMC4yIDE1TTE5IDE3QzE5IDE1LjcxODcgMTkgMTQuODgxMyAxOSAxMy42XCIvPjwvc3ZnPicsIGggPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTYgN0w2IDEyTTYgMTdMNiAxMk02IDEyTDEyIDEyTTEyIDdWMTJNMTIgMTdMMTIgMTJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE2IDE1LjlDMTYgMTUuOSAxNi4zNzY4IDE3IDE3LjggMTdDMTkuNSAxNyAyMCAxNS42MTk5IDIwIDE0LjdDMjAgMTIuNzMyMyAxNy42NzQ1IDEyLjA0ODYgMTYuMTYzNSAxMi45ODk0QzE2LjA5NCAxMy4wMzI3IDE2IDEyLjk4NDYgMTYgMTIuOTAyN1YxMC4xQzE2IDEwLjA0NDggMTYuMDQ0OCAxMCAxNi4xIDEwSDE5LjhcIi8+PC9zdmc+JywgZCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNiA3TDYgMTJNNiAxN0w2IDEyTTYgMTJMMTIgMTJNMTIgN1YxMk0xMiAxN0wxMiAxMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTkuNSAxMEMxNi41IDEwLjUgMTYgMTMuMzI4NSAxNiAxNU0xNiAxNVYxNUMxNiAxNi4xMDQ2IDE2Ljg5NTQgMTcgMTggMTdIMTguMzI0NkMxOS4zMjUxIDE3IDIwLjMxOTEgMTYuMzQ5MiAyMC4yNTIyIDE1LjM1MDlDMjAuMDYxMiAxMi40OTU4IDE2IDEyLjY2MTEgMTYgMTVaXCIvPjwvc3ZnPicsIHUgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTkgN0w5IDEyTTkgMTdWMTJNOSAxMkwxNSAxMk0xNSA3VjEyTTE1IDE3TDE1IDEyXCIvPjwvc3ZnPic7XG4vKipcbiAqIEhlYWRlciBibG9jayBmb3IgdGhlIEVkaXRvci5qcy5cbiAqXG4gKiBAYXV0aG9yIENvZGVYICh0ZWFtQGlmbW8uc3UpXG4gKiBAY29weXJpZ2h0IENvZGVYIDIwMThcbiAqIEBsaWNlbnNlIE1JVFxuICogQHZlcnNpb24gMi4wLjBcbiAqL1xuY2xhc3MgYyB7XG4gIC8qKlxuICAgKiBSZW5kZXIgcGx1Z2luYHMgbWFpbiBFbGVtZW50IGFuZCBmaWxsIGl0IHdpdGggc2F2ZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge3tkYXRhOiBIZWFkZXJEYXRhLCBjb25maWc6IEhlYWRlckNvbmZpZywgYXBpOiBvYmplY3R9fVxuICAgKiAgIGRhdGEg4oCUIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxuICAgKiAgIGNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqICAgYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKiAgIHJlYWRPbmx5IC0gcmVhZCBvbmx5IG1vZGUgZmxhZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkYXRhOiBlLCBjb25maWc6IHQsIGFwaTogcywgcmVhZE9ubHk6IHIgfSkge1xuICAgIHRoaXMuYXBpID0gcywgdGhpcy5yZWFkT25seSA9IHIsIHRoaXMuX0NTUyA9IHtcbiAgICAgIGJsb2NrOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICB3cmFwcGVyOiBcImNlLWhlYWRlclwiXG4gICAgfSwgdGhpcy5fc2V0dGluZ3MgPSB0LCB0aGlzLl9kYXRhID0gdGhpcy5ub3JtYWxpemVEYXRhKGUpLCB0aGlzLl9lbGVtZW50ID0gdGhpcy5nZXRUYWcoKTtcbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplIGlucHV0IGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtIZWFkZXJEYXRhfSBkYXRhIC0gc2F2ZWQgZGF0YSB0byBwcm9jZXNzXG4gICAqXG4gICAqIEByZXR1cm5zIHtIZWFkZXJEYXRhfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm9ybWFsaXplRGF0YShlKSB7XG4gICAgY29uc3QgdCA9IHt9O1xuICAgIHJldHVybiB0eXBlb2YgZSAhPSBcIm9iamVjdFwiICYmIChlID0ge30pLCB0LnRleHQgPSBlLnRleHQgfHwgXCJcIiwgdC5sZXZlbCA9IHBhcnNlSW50KGUubGV2ZWwpIHx8IHRoaXMuZGVmYXVsdExldmVsLm51bWJlciwgdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFRvb2wncyB2aWV3XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MSGVhZGluZ0VsZW1lbnR9XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBoZWFkZXIgYmxvY2sgdHVuZXMgY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIHJlbmRlclNldHRpbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVscy5tYXAoKGUpID0+ICh7XG4gICAgICBpY29uOiBlLnN2ZyxcbiAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoYEhlYWRpbmcgJHtlLm51bWJlcn1gKSxcbiAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHRoaXMuc2V0TGV2ZWwoZS5udW1iZXIpLFxuICAgICAgY2xvc2VPbkFjdGl2YXRlOiAhMCxcbiAgICAgIGlzQWN0aXZlOiB0aGlzLmN1cnJlbnRMZXZlbC5udW1iZXIgPT09IGUubnVtYmVyXG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgQmxvY2sncyBzZXR0aW5ncyBidXR0b25zXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbCAtIGxldmVsIHRvIHNldFxuICAgKi9cbiAgc2V0TGV2ZWwoZSkge1xuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgIGxldmVsOiBlLFxuICAgICAgdGV4dDogdGhpcy5kYXRhLnRleHRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBzcGVjaWZpZWQgaG93IHRvIG1lcmdlIHR3byBUZXh0IGJsb2Nrcy5cbiAgICogQ2FsbGVkIGJ5IEVkaXRvci5qcyBieSBiYWNrc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtIZWFkZXJEYXRhfSBkYXRhIC0gc2F2ZWQgZGF0YSB0byBtZXJnZXIgd2l0aCBjdXJyZW50IGJsb2NrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG1lcmdlKGUpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgdGV4dDogdGhpcy5kYXRhLnRleHQgKyBlLnRleHQsXG4gICAgICBsZXZlbDogdGhpcy5kYXRhLmxldmVsXG4gICAgfTtcbiAgICB0aGlzLmRhdGEgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBUZXh0IGJsb2NrIGRhdGE6XG4gICAqIC0gY2hlY2sgZm9yIGVtcHRpbmVzc1xuICAgKlxuICAgKiBAcGFyYW0ge0hlYWRlckRhdGF9IGJsb2NrRGF0YSDigJQgZGF0YSByZWNlaXZlZCBhZnRlciBzYXZpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIHNhdmVkIGRhdGEgaXMgbm90IGNvcnJlY3QsIG90aGVyd2lzZSB0cnVlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHZhbGlkYXRlKGUpIHtcbiAgICByZXR1cm4gZS50ZXh0LnRyaW0oKSAhPT0gXCJcIjtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBUb29sJ3MgZGF0YSBmcm9tIHRoZSB2aWV3XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEhlYWRpbmdFbGVtZW50fSB0b29sc0NvbnRlbnQgLSBUZXh0IHRvb2xzIHJlbmRlcmVkIHZpZXdcbiAgICogQHJldHVybnMge0hlYWRlckRhdGF9IC0gc2F2ZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzYXZlKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogZS5pbm5lckhUTUwsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwubnVtYmVyXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQWxsb3cgSGVhZGVyIHRvIGJlIGNvbnZlcnRlZCB0by9mcm9tIG90aGVyIGJsb2Nrc1xuICAgKi9cbiAgc3RhdGljIGdldCBjb252ZXJzaW9uQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBleHBvcnQ6IFwidGV4dFwiLFxuICAgICAgLy8gdXNlICd0ZXh0JyBwcm9wZXJ0eSBmb3Igb3RoZXIgYmxvY2tzXG4gICAgICBpbXBvcnQ6IFwidGV4dFwiXG4gICAgICAvLyBmaWxsICd0ZXh0JyBwcm9wZXJ0eSBmcm9tIG90aGVyIGJsb2NrJ3MgZXhwb3J0IHN0cmluZ1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBSdWxlc1xuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6ICExLFxuICAgICAgdGV4dDoge31cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgdG8gbm90aWZ5IGNvcmUgdGhhdCByZWFkLW9ubHkgaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCBpc1JlYWRPbmx5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgVG9vbHNgcyBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtIZWFkZXJEYXRhfSBDdXJyZW50IGRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnRleHQgPSB0aGlzLl9lbGVtZW50LmlubmVySFRNTCwgdGhpcy5fZGF0YS5sZXZlbCA9IHRoaXMuY3VycmVudExldmVsLm51bWJlciwgdGhpcy5fZGF0YTtcbiAgfVxuICAvKipcbiAgICogU3RvcmUgZGF0YSBpbiBwbHVnaW46XG4gICAqIC0gYXQgdGhlIHRoaXMuX2RhdGEgcHJvcGVydHlcbiAgICogLSBhdCB0aGUgSFRNTFxuICAgKlxuICAgKiBAcGFyYW0ge0hlYWRlckRhdGF9IGRhdGEg4oCUIGRhdGEgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXQgZGF0YShlKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEgPSB0aGlzLm5vcm1hbGl6ZURhdGEoZSksIGUubGV2ZWwgIT09IHZvaWQgMCAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmdldFRhZygpO1xuICAgICAgdC5pbm5lckhUTUwgPSB0aGlzLl9lbGVtZW50LmlubmVySFRNTCwgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0LCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fZWxlbWVudCA9IHQ7XG4gICAgfVxuICAgIGUudGV4dCAhPT0gdm9pZCAwICYmICh0aGlzLl9lbGVtZW50LmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCB8fCBcIlwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRhZyBmb3IgdGFyZ2V0IGxldmVsXG4gICAqIEJ5IGRlZmF1bHQgcmV0dXJucyBzZWNvbmQtbGV2ZWxlZCBoZWFkZXJcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0VGFnKCkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuY3VycmVudExldmVsLnRhZyk7XG4gICAgcmV0dXJuIGUuaW5uZXJIVE1MID0gdGhpcy5fZGF0YS50ZXh0IHx8IFwiXCIsIGUuY2xhc3NMaXN0LmFkZCh0aGlzLl9DU1Mud3JhcHBlciksIGUuY29udGVudEVkaXRhYmxlID0gdGhpcy5yZWFkT25seSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiLCBlLmRhdGFzZXQucGxhY2Vob2xkZXIgPSB0aGlzLmFwaS5pMThuLnQodGhpcy5fc2V0dGluZ3MucGxhY2Vob2xkZXIgfHwgXCJcIiksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGxldmVsXG4gICAqXG4gICAqIEByZXR1cm5zIHtsZXZlbH1cbiAgICovXG4gIGdldCBjdXJyZW50TGV2ZWwoKSB7XG4gICAgbGV0IGUgPSB0aGlzLmxldmVscy5maW5kKCh0KSA9PiB0Lm51bWJlciA9PT0gdGhpcy5fZGF0YS5sZXZlbCk7XG4gICAgcmV0dXJuIGUgfHwgKGUgPSB0aGlzLmRlZmF1bHRMZXZlbCksIGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBkZWZhdWx0IGxldmVsXG4gICAqXG4gICAqIEByZXR1cm5zIHtsZXZlbH1cbiAgICovXG4gIGdldCBkZWZhdWx0TGV2ZWwoKSB7XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmRlZmF1bHRMZXZlbCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMubGV2ZWxzLmZpbmQoKHQpID0+IHQubnVtYmVyID09PSB0aGlzLl9zZXR0aW5ncy5kZWZhdWx0TGV2ZWwpO1xuICAgICAgaWYgKGUpXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgY29uc29sZS53YXJuKFwiKOC4hyfMgC0nzIEp4LiHIEhlYWRpbmcgVG9vbDogdGhlIGRlZmF1bHQgbGV2ZWwgc3BlY2lmaWVkIHdhcyBub3QgZm91bmQgaW4gYXZhaWxhYmxlIGxldmVsc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxzWzFdO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBsZXZlbFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbnVtYmVyIC0gbGV2ZWwgbnVtYmVyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YWcgLSB0YWcgY29ycmVzcG9uZHMgd2l0aCBsZXZlbCBudW1iZXJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN2ZyAtIGljb25cbiAgICovXG4gIC8qKlxuICAgKiBBdmFpbGFibGUgaGVhZGVyIGxldmVsc1xuICAgKlxuICAgKiBAcmV0dXJucyB7bGV2ZWxbXX1cbiAgICovXG4gIGdldCBsZXZlbHMoKSB7XG4gICAgY29uc3QgZSA9IFtcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxLFxuICAgICAgICB0YWc6IFwiSDFcIixcbiAgICAgICAgc3ZnOiBpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDIsXG4gICAgICAgIHRhZzogXCJIMlwiLFxuICAgICAgICBzdmc6IGFcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMyxcbiAgICAgICAgdGFnOiBcIkgzXCIsXG4gICAgICAgIHN2ZzogbFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA0LFxuICAgICAgICB0YWc6IFwiSDRcIixcbiAgICAgICAgc3ZnOiBvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDUsXG4gICAgICAgIHRhZzogXCJINVwiLFxuICAgICAgICBzdmc6IGhcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNixcbiAgICAgICAgdGFnOiBcIkg2XCIsXG4gICAgICAgIHN2ZzogZFxuICAgICAgfVxuICAgIF07XG4gICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLmxldmVscyA/IGUuZmlsdGVyKFxuICAgICAgKHQpID0+IHRoaXMuX3NldHRpbmdzLmxldmVscy5pbmNsdWRlcyh0Lm51bWJlcilcbiAgICApIDogZTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIEgxLUg2IHRhZ3Mgb24gcGFzdGUgdG8gc3Vic3RpdHV0ZSBpdCB3aXRoIGhlYWRlciBUb29sXG4gICAqXG4gICAqIEBwYXJhbSB7UGFzdGVFdmVudH0gZXZlbnQgLSBldmVudCB3aXRoIHBhc3RlZCBjb250ZW50XG4gICAqL1xuICBvblBhc3RlKGUpIHtcbiAgICBjb25zdCB0ID0gZS5kZXRhaWwuZGF0YTtcbiAgICBsZXQgcyA9IHRoaXMuZGVmYXVsdExldmVsLm51bWJlcjtcbiAgICBzd2l0Y2ggKHQudGFnTmFtZSkge1xuICAgICAgY2FzZSBcIkgxXCI6XG4gICAgICAgIHMgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJIMlwiOlxuICAgICAgICBzID0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSDNcIjpcbiAgICAgICAgcyA9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkg0XCI6XG4gICAgICAgIHMgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJINVwiOlxuICAgICAgICBzID0gNTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSDZcIjpcbiAgICAgICAgcyA9IDY7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl9zZXR0aW5ncy5sZXZlbHMgJiYgKHMgPSB0aGlzLl9zZXR0aW5ncy5sZXZlbHMucmVkdWNlKChyLCBuKSA9PiBNYXRoLmFicyhuIC0gcykgPCBNYXRoLmFicyhyIC0gcykgPyBuIDogcikpLCB0aGlzLmRhdGEgPSB7XG4gICAgICBsZXZlbDogcyxcbiAgICAgIHRleHQ6IHQuaW5uZXJIVE1MXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVXNlZCBieSBFZGl0b3IuanMgcGFzdGUgaGFuZGxpbmcgQVBJLlxuICAgKiBQcm92aWRlcyBjb25maWd1cmF0aW9uIHRvIGhhbmRsZSBIMS1INiB0YWdzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7e2hhbmRsZXI6IChmdW5jdGlvbihIVE1MRWxlbWVudCk6IHt0ZXh0OiBzdHJpbmd9KSwgdGFnczogc3RyaW5nW119fVxuICAgKi9cbiAgc3RhdGljIGdldCBwYXN0ZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnczogW1wiSDFcIiwgXCJIMlwiLCBcIkgzXCIsIFwiSDRcIiwgXCJINVwiLCBcIkg2XCJdXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IFRvb2wgdG9vbGJveCBzZXR0aW5nc1xuICAgKiBpY29uIC0gVG9vbCBpY29uJ3MgU1ZHXG4gICAqIHRpdGxlIC0gdGl0bGUgdG8gc2hvdyBpbiB0b29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHt7aWNvbjogc3RyaW5nLCB0aXRsZTogc3RyaW5nfX1cbiAgICovXG4gIHN0YXRpYyBnZXQgdG9vbGJveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogdSxcbiAgICAgIHRpdGxlOiBcIkhlYWRpbmdcIlxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCB7XG4gIGMgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/header/dist/header.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/image/dist/image.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@editorjs/image/dist/image.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ P)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var o=document.createElement(\"style\");o.appendChild(document.createTextNode('.image-tool{--bg-color: #cdd1e0;--front-color: #388ae5;--border-color: #e8e8eb}.image-tool__image{border-radius:3px;overflow:hidden;margin-bottom:10px}.image-tool__image-picture{max-width:100%;vertical-align:bottom;display:block}.image-tool__image-preloader{width:50px;height:50px;border-radius:50%;background-size:cover;margin:auto;position:relative;background-color:var(--bg-color);background-position:center center}.image-tool__image-preloader:after{content:\"\";position:absolute;z-index:3;width:60px;height:60px;border-radius:50%;border:2px solid var(--bg-color);border-top-color:var(--front-color);left:50%;top:50%;margin-top:-30px;margin-left:-30px;animation:image-preloader-spin 2s infinite linear;box-sizing:border-box}.image-tool__caption[contentEditable=true][data-placeholder]:before{position:absolute!important;content:attr(data-placeholder);color:#707684;font-weight:400;display:none}.image-tool__caption[contentEditable=true][data-placeholder]:empty:before{display:block}.image-tool__caption[contentEditable=true][data-placeholder]:empty:focus:before{display:none}.image-tool--empty .image-tool__image,.image-tool--empty .image-tool__caption,.image-tool--loading .image-tool__caption{display:none}.image-tool .cdx-button{display:flex;align-items:center;justify-content:center}.image-tool .cdx-button svg{height:auto;margin:0 6px 0 0}.image-tool--filled .cdx-button,.image-tool--filled .image-tool__image-preloader{display:none}.image-tool--loading .image-tool__image{min-height:200px;display:flex;border:1px solid var(--border-color);background-color:#fff}.image-tool--loading .image-tool__image-picture,.image-tool--loading .cdx-button{display:none}.image-tool--withBorder .image-tool__image{border:1px solid var(--border-color)}.image-tool--withBackground .image-tool__image{padding:15px;background:var(--bg-color)}.image-tool--withBackground .image-tool__image-picture{max-width:60%;margin:0 auto}.image-tool--stretched .image-tool__image-picture{width:100%}@keyframes image-preloader-spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}')),document.head.appendChild(o)}}catch(e){console.error(\"vite-plugin-css-injected-by-js\",e)}})();\nconst R = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M11 19V19C9.13623 19 8.20435 19 7.46927 18.6955C6.48915 18.2895 5.71046 17.5108 5.30448 16.5307C5 15.7956 5 14.8638 5 13V12C5 9.19108 5 7.78661 5.67412 6.77772C5.96596 6.34096 6.34096 5.96596 6.77772 5.67412C7.78661 5 9.19108 5 12 5H13.5C14.8956 5 15.5933 5 16.1611 5.17224C17.4395 5.56004 18.44 6.56046 18.8278 7.83886C19 8.40666 19 9.10444 19 10.5V10.5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 13V16M16 19V16M19 16H16M16 16H13\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M6.5 17.5L17.5 6.5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M18.9919 10.5H19.0015\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10.9919 19H11.0015\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 13L13 5\"/></svg>', H = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M18.9919 9.5H19.0015\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14.5 5H14.5096\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M14.625 5H15C17.2091 5 19 6.79086 19 9V9.375\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M9.375 5L9 5C6.79086 5 5 6.79086 5 9V9.375\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.3725 5H9.38207\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 9.5H5.00957\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M9.375 19H9C6.79086 19 5 17.2091 5 15V14.625\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.3725 19H9.38207\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 14.55H5.00957\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 13V16M16 19V16M19 16H16M16 16H13\"/></svg>', L = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5.13968 15.32L8.69058 11.5661C9.02934 11.2036 9.48873 11 9.96774 11C10.4467 11 10.9061 11.2036 11.2449 11.5661L15.3871 16M13.5806 14.0664L15.0132 12.533C15.3519 12.1705 15.8113 11.9668 16.2903 11.9668C16.7693 11.9668 17.2287 12.1705 17.5675 12.533L18.841 13.9634\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13.7778 9.33331H13.7867\"/></svg>', D = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M17 9L20 12L17 15\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14 12H20\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M7 9L4 12L7 15\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 12H10\"/></svg>';\nfunction M(E, a = null, i = {}) {\n  const c = document.createElement(E);\n  Array.isArray(a) ? c.classList.add(...a) : a && c.classList.add(a);\n  for (const r in i)\n    c[r] = i[r];\n  return c;\n}\nclass j {\n  /**\n   * @param {object} ui - image tool Ui module\n   * @param {object} ui.api - Editor.js API\n   * @param {ImageConfig} ui.config - user config\n   * @param {Function} ui.onSelectFile - callback for clicks on Select file button\n   * @param {boolean} ui.readOnly - read-only mode flag\n   */\n  constructor({ api: a, config: i, onSelectFile: c, readOnly: r }) {\n    this.api = a, this.config = i, this.onSelectFile = c, this.readOnly = r, this.nodes = {\n      wrapper: M(\"div\", [this.CSS.baseClass, this.CSS.wrapper]),\n      imageContainer: M(\"div\", [this.CSS.imageContainer]),\n      fileButton: this.createFileButton(),\n      imageEl: void 0,\n      imagePreloader: M(\"div\", this.CSS.imagePreloader),\n      caption: M(\"div\", [this.CSS.input, this.CSS.caption], {\n        contentEditable: !this.readOnly\n      })\n    }, this.nodes.caption.dataset.placeholder = this.config.captionPlaceholder, this.nodes.imageContainer.appendChild(this.nodes.imagePreloader), this.nodes.wrapper.appendChild(this.nodes.imageContainer), this.nodes.wrapper.appendChild(this.nodes.caption), this.nodes.wrapper.appendChild(this.nodes.fileButton);\n  }\n  /**\n   * CSS classes\n   *\n   * @returns {object}\n   */\n  get CSS() {\n    return {\n      baseClass: this.api.styles.block,\n      loading: this.api.styles.loader,\n      input: this.api.styles.input,\n      button: this.api.styles.button,\n      /**\n       * Tool's classes\n       */\n      wrapper: \"image-tool\",\n      imageContainer: \"image-tool__image\",\n      imagePreloader: \"image-tool__image-preloader\",\n      imageEl: \"image-tool__image-picture\",\n      caption: \"image-tool__caption\"\n    };\n  }\n  /**\n   * Ui statuses:\n   * - empty\n   * - uploading\n   * - filled\n   *\n   * @returns {{EMPTY: string, UPLOADING: string, FILLED: string}}\n   */\n  static get status() {\n    return {\n      EMPTY: \"empty\",\n      UPLOADING: \"loading\",\n      FILLED: \"filled\"\n    };\n  }\n  /**\n   * Renders tool UI\n   *\n   * @param {ImageToolData} toolData - saved tool data\n   * @returns {Element}\n   */\n  render(a) {\n    return !a.file || Object.keys(a.file).length === 0 ? this.toggleStatus(j.status.EMPTY) : this.toggleStatus(j.status.UPLOADING), this.nodes.wrapper;\n  }\n  /**\n   * Creates upload-file button\n   *\n   * @returns {Element}\n   */\n  createFileButton() {\n    const a = M(\"div\", [this.CSS.button]);\n    return a.innerHTML = this.config.buttonContent || `${L} ${this.api.i18n.t(\"Select an Image\")}`, a.addEventListener(\"click\", () => {\n      this.onSelectFile();\n    }), a;\n  }\n  /**\n   * Shows uploading preloader\n   *\n   * @param {string} src - preview source\n   * @returns {void}\n   */\n  showPreloader(a) {\n    this.nodes.imagePreloader.style.backgroundImage = `url(${a})`, this.toggleStatus(j.status.UPLOADING);\n  }\n  /**\n   * Hide uploading preloader\n   *\n   * @returns {void}\n   */\n  hidePreloader() {\n    this.nodes.imagePreloader.style.backgroundImage = \"\", this.toggleStatus(j.status.EMPTY);\n  }\n  /**\n   * Shows an image\n   *\n   * @param {string} url - image source\n   * @returns {void}\n   */\n  fillImage(a) {\n    const i = /\\.mp4$/.test(a) ? \"VIDEO\" : \"IMG\", c = {\n      src: a\n    };\n    let r = \"load\";\n    i === \"VIDEO\" && (c.autoplay = !0, c.loop = !0, c.muted = !0, c.playsinline = !0, r = \"loadeddata\"), this.nodes.imageEl = M(i, this.CSS.imageEl, c), this.nodes.imageEl.addEventListener(r, () => {\n      this.toggleStatus(j.status.FILLED), this.nodes.imagePreloader && (this.nodes.imagePreloader.style.backgroundImage = \"\");\n    }), this.nodes.imageContainer.appendChild(this.nodes.imageEl);\n  }\n  /**\n   * Shows caption input\n   *\n   * @param {string} text - caption text\n   * @returns {void}\n   */\n  fillCaption(a) {\n    this.nodes.caption && (this.nodes.caption.innerHTML = a);\n  }\n  /**\n   * Changes UI status\n   *\n   * @param {string} status - see {@link Ui.status} constants\n   * @returns {void}\n   */\n  toggleStatus(a) {\n    for (const i in j.status)\n      Object.prototype.hasOwnProperty.call(j.status, i) && this.nodes.wrapper.classList.toggle(`${this.CSS.wrapper}--${j.status[i]}`, a === j.status[i]);\n  }\n  /**\n   * Apply visual representation of activated tune\n   *\n   * @param {string} tuneName - one of available tunes {@link Tunes.tunes}\n   * @param {boolean} status - true for enable, false for disable\n   * @returns {void}\n   */\n  applyTune(a, i) {\n    this.nodes.wrapper.classList.toggle(`${this.CSS.wrapper}--${a}`, i);\n  }\n}\nfunction x(E) {\n  return E && E.__esModule && Object.prototype.hasOwnProperty.call(E, \"default\") ? E.default : E;\n}\nvar I = { exports: {} };\n(function(E, a) {\n  (function(i, c) {\n    E.exports = c();\n  })(window, function() {\n    return function(i) {\n      var c = {};\n      function r(n) {\n        if (c[n])\n          return c[n].exports;\n        var o = c[n] = { i: n, l: !1, exports: {} };\n        return i[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports;\n      }\n      return r.m = i, r.c = c, r.d = function(n, o, d) {\n        r.o(n, o) || Object.defineProperty(n, o, { enumerable: !0, get: d });\n      }, r.r = function(n) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(n, \"__esModule\", { value: !0 });\n      }, r.t = function(n, o) {\n        if (1 & o && (n = r(n)), 8 & o || 4 & o && typeof n == \"object\" && n && n.__esModule)\n          return n;\n        var d = /* @__PURE__ */ Object.create(null);\n        if (r.r(d), Object.defineProperty(d, \"default\", { enumerable: !0, value: n }), 2 & o && typeof n != \"string\")\n          for (var b in n)\n            r.d(d, b, (function(u) {\n              return n[u];\n            }).bind(null, b));\n        return d;\n      }, r.n = function(n) {\n        var o = n && n.__esModule ? function() {\n          return n.default;\n        } : function() {\n          return n;\n        };\n        return r.d(o, \"a\", o), o;\n      }, r.o = function(n, o) {\n        return Object.prototype.hasOwnProperty.call(n, o);\n      }, r.p = \"\", r(r.s = 3);\n    }([function(i, c) {\n      var r;\n      r = function() {\n        return this;\n      }();\n      try {\n        r = r || new Function(\"return this\")();\n      } catch {\n        typeof window == \"object\" && (r = window);\n      }\n      i.exports = r;\n    }, function(i, c, r) {\n      (function(n) {\n        var o = r(2), d = setTimeout;\n        function b() {\n        }\n        function u(e) {\n          if (!(this instanceof u))\n            throw new TypeError(\"Promises must be constructed via new\");\n          if (typeof e != \"function\")\n            throw new TypeError(\"not a function\");\n          this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], t(e, this);\n        }\n        function f(e, l) {\n          for (; e._state === 3; )\n            e = e._value;\n          e._state !== 0 ? (e._handled = !0, u._immediateFn(function() {\n            var s = e._state === 1 ? l.onFulfilled : l.onRejected;\n            if (s !== null) {\n              var g;\n              try {\n                g = s(e._value);\n              } catch (m) {\n                return void y(l.promise, m);\n              }\n              p(l.promise, g);\n            } else\n              (e._state === 1 ? p : y)(l.promise, e._value);\n          })) : e._deferreds.push(l);\n        }\n        function p(e, l) {\n          try {\n            if (l === e)\n              throw new TypeError(\"A promise cannot be resolved with itself.\");\n            if (l && (typeof l == \"object\" || typeof l == \"function\")) {\n              var s = l.then;\n              if (l instanceof u)\n                return e._state = 3, e._value = l, void w(e);\n              if (typeof s == \"function\")\n                return void t((g = s, m = l, function() {\n                  g.apply(m, arguments);\n                }), e);\n            }\n            e._state = 1, e._value = l, w(e);\n          } catch (h) {\n            y(e, h);\n          }\n          var g, m;\n        }\n        function y(e, l) {\n          e._state = 2, e._value = l, w(e);\n        }\n        function w(e) {\n          e._state === 2 && e._deferreds.length === 0 && u._immediateFn(function() {\n            e._handled || u._unhandledRejectionFn(e._value);\n          });\n          for (var l = 0, s = e._deferreds.length; l < s; l++)\n            f(e, e._deferreds[l]);\n          e._deferreds = null;\n        }\n        function v(e, l, s) {\n          this.onFulfilled = typeof e == \"function\" ? e : null, this.onRejected = typeof l == \"function\" ? l : null, this.promise = s;\n        }\n        function t(e, l) {\n          var s = !1;\n          try {\n            e(function(g) {\n              s || (s = !0, p(l, g));\n            }, function(g) {\n              s || (s = !0, y(l, g));\n            });\n          } catch (g) {\n            if (s)\n              return;\n            s = !0, y(l, g);\n          }\n        }\n        u.prototype.catch = function(e) {\n          return this.then(null, e);\n        }, u.prototype.then = function(e, l) {\n          var s = new this.constructor(b);\n          return f(this, new v(e, l, s)), s;\n        }, u.prototype.finally = o.a, u.all = function(e) {\n          return new u(function(l, s) {\n            if (!e || e.length === void 0)\n              throw new TypeError(\"Promise.all accepts an array\");\n            var g = Array.prototype.slice.call(e);\n            if (g.length === 0)\n              return l([]);\n            var m = g.length;\n            function h(T, C) {\n              try {\n                if (C && (typeof C == \"object\" || typeof C == \"function\")) {\n                  var S = C.then;\n                  if (typeof S == \"function\")\n                    return void S.call(C, function(O) {\n                      h(T, O);\n                    }, s);\n                }\n                g[T] = C, --m == 0 && l(g);\n              } catch (O) {\n                s(O);\n              }\n            }\n            for (var k = 0; k < g.length; k++)\n              h(k, g[k]);\n          });\n        }, u.resolve = function(e) {\n          return e && typeof e == \"object\" && e.constructor === u ? e : new u(function(l) {\n            l(e);\n          });\n        }, u.reject = function(e) {\n          return new u(function(l, s) {\n            s(e);\n          });\n        }, u.race = function(e) {\n          return new u(function(l, s) {\n            for (var g = 0, m = e.length; g < m; g++)\n              e[g].then(l, s);\n          });\n        }, u._immediateFn = typeof n == \"function\" && function(e) {\n          n(e);\n        } || function(e) {\n          d(e, 0);\n        }, u._unhandledRejectionFn = function(e) {\n          typeof console < \"u\" && console && console.warn(\"Possible Unhandled Promise Rejection:\", e);\n        }, c.a = u;\n      }).call(this, r(5).setImmediate);\n    }, function(i, c, r) {\n      c.a = function(n) {\n        var o = this.constructor;\n        return this.then(function(d) {\n          return o.resolve(n()).then(function() {\n            return d;\n          });\n        }, function(d) {\n          return o.resolve(n()).then(function() {\n            return o.reject(d);\n          });\n        });\n      };\n    }, function(i, c, r) {\n      function n(t) {\n        return (n = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(e) {\n          return typeof e;\n        } : function(e) {\n          return e && typeof Symbol == \"function\" && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n        })(t);\n      }\n      r(4);\n      var o, d, b, u, f, p, y, w = r(8), v = (d = function(t) {\n        return new Promise(function(e, l) {\n          t = u(t), (t = f(t)).beforeSend && t.beforeSend();\n          var s = window.XMLHttpRequest ? new window.XMLHttpRequest() : new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n          s.open(t.method, t.url), s.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), Object.keys(t.headers).forEach(function(m) {\n            var h = t.headers[m];\n            s.setRequestHeader(m, h);\n          });\n          var g = t.ratio;\n          s.upload.addEventListener(\"progress\", function(m) {\n            var h = Math.round(m.loaded / m.total * 100), k = Math.ceil(h * g / 100);\n            t.progress(Math.min(k, 100));\n          }, !1), s.addEventListener(\"progress\", function(m) {\n            var h = Math.round(m.loaded / m.total * 100), k = Math.ceil(h * (100 - g) / 100) + g;\n            t.progress(Math.min(k, 100));\n          }, !1), s.onreadystatechange = function() {\n            if (s.readyState === 4) {\n              var m = s.response;\n              try {\n                m = JSON.parse(m);\n              } catch {\n              }\n              var h = w.parseHeaders(s.getAllResponseHeaders()), k = { body: m, code: s.status, headers: h };\n              y(s.status) ? e(k) : l(k);\n            }\n          }, s.send(t.data);\n        });\n      }, b = function(t) {\n        return t.method = \"POST\", d(t);\n      }, u = function() {\n        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        if (t.url && typeof t.url != \"string\")\n          throw new Error(\"Url must be a string\");\n        if (t.url = t.url || \"\", t.method && typeof t.method != \"string\")\n          throw new Error(\"`method` must be a string or null\");\n        if (t.method = t.method ? t.method.toUpperCase() : \"GET\", t.headers && n(t.headers) !== \"object\")\n          throw new Error(\"`headers` must be an object or null\");\n        if (t.headers = t.headers || {}, t.type && (typeof t.type != \"string\" || !Object.values(o).includes(t.type)))\n          throw new Error(\"`type` must be taken from module's «contentType» library\");\n        if (t.progress && typeof t.progress != \"function\")\n          throw new Error(\"`progress` must be a function or null\");\n        if (t.progress = t.progress || function(e) {\n        }, t.beforeSend = t.beforeSend || function(e) {\n        }, t.ratio && typeof t.ratio != \"number\")\n          throw new Error(\"`ratio` must be a number\");\n        if (t.ratio < 0 || t.ratio > 100)\n          throw new Error(\"`ratio` must be in a 0-100 interval\");\n        if (t.ratio = t.ratio || 90, t.accept && typeof t.accept != \"string\")\n          throw new Error(\"`accept` must be a string with a list of allowed mime-types\");\n        if (t.accept = t.accept || \"*/*\", t.multiple && typeof t.multiple != \"boolean\")\n          throw new Error(\"`multiple` must be a true or false\");\n        if (t.multiple = t.multiple || !1, t.fieldName && typeof t.fieldName != \"string\")\n          throw new Error(\"`fieldName` must be a string\");\n        return t.fieldName = t.fieldName || \"files\", t;\n      }, f = function(t) {\n        switch (t.method) {\n          case \"GET\":\n            var e = p(t.data, o.URLENCODED);\n            delete t.data, t.url = /\\?/.test(t.url) ? t.url + \"&\" + e : t.url + \"?\" + e;\n            break;\n          case \"POST\":\n          case \"PUT\":\n          case \"DELETE\":\n          case \"UPDATE\":\n            var l = function() {\n              return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).type || o.JSON;\n            }(t);\n            (w.isFormData(t.data) || w.isFormElement(t.data)) && (l = o.FORM), t.data = p(t.data, l), l !== v.contentType.FORM && (t.headers[\"content-type\"] = l);\n        }\n        return t;\n      }, p = function() {\n        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        switch (arguments.length > 1 ? arguments[1] : void 0) {\n          case o.URLENCODED:\n            return w.urlEncode(t);\n          case o.JSON:\n            return w.jsonEncode(t);\n          case o.FORM:\n            return w.formEncode(t);\n          default:\n            return t;\n        }\n      }, y = function(t) {\n        return t >= 200 && t < 300;\n      }, { contentType: o = { URLENCODED: \"application/x-www-form-urlencoded; charset=utf-8\", FORM: \"multipart/form-data\", JSON: \"application/json; charset=utf-8\" }, request: d, get: function(t) {\n        return t.method = \"GET\", d(t);\n      }, post: b, transport: function(t) {\n        return t = u(t), w.selectFiles(t).then(function(e) {\n          for (var l = new FormData(), s = 0; s < e.length; s++)\n            l.append(t.fieldName, e[s], e[s].name);\n          w.isObject(t.data) && Object.keys(t.data).forEach(function(m) {\n            var h = t.data[m];\n            l.append(m, h);\n          });\n          var g = t.beforeSend;\n          return t.beforeSend = function() {\n            return g(e);\n          }, t.data = l, b(t);\n        });\n      }, selectFiles: function(t) {\n        return delete (t = u(t)).beforeSend, w.selectFiles(t);\n      } });\n      i.exports = v;\n    }, function(i, c, r) {\n      r.r(c);\n      var n = r(1);\n      window.Promise = window.Promise || n.a;\n    }, function(i, c, r) {\n      (function(n) {\n        var o = n !== void 0 && n || typeof self < \"u\" && self || window, d = Function.prototype.apply;\n        function b(u, f) {\n          this._id = u, this._clearFn = f;\n        }\n        c.setTimeout = function() {\n          return new b(d.call(setTimeout, o, arguments), clearTimeout);\n        }, c.setInterval = function() {\n          return new b(d.call(setInterval, o, arguments), clearInterval);\n        }, c.clearTimeout = c.clearInterval = function(u) {\n          u && u.close();\n        }, b.prototype.unref = b.prototype.ref = function() {\n        }, b.prototype.close = function() {\n          this._clearFn.call(o, this._id);\n        }, c.enroll = function(u, f) {\n          clearTimeout(u._idleTimeoutId), u._idleTimeout = f;\n        }, c.unenroll = function(u) {\n          clearTimeout(u._idleTimeoutId), u._idleTimeout = -1;\n        }, c._unrefActive = c.active = function(u) {\n          clearTimeout(u._idleTimeoutId);\n          var f = u._idleTimeout;\n          f >= 0 && (u._idleTimeoutId = setTimeout(function() {\n            u._onTimeout && u._onTimeout();\n          }, f));\n        }, r(6), c.setImmediate = typeof self < \"u\" && self.setImmediate || n !== void 0 && n.setImmediate || this && this.setImmediate, c.clearImmediate = typeof self < \"u\" && self.clearImmediate || n !== void 0 && n.clearImmediate || this && this.clearImmediate;\n      }).call(this, r(0));\n    }, function(i, c, r) {\n      (function(n, o) {\n        (function(d, b) {\n          if (!d.setImmediate) {\n            var u, f, p, y, w, v = 1, t = {}, e = !1, l = d.document, s = Object.getPrototypeOf && Object.getPrototypeOf(d);\n            s = s && s.setTimeout ? s : d, {}.toString.call(d.process) === \"[object process]\" ? u = function(h) {\n              o.nextTick(function() {\n                m(h);\n              });\n            } : function() {\n              if (d.postMessage && !d.importScripts) {\n                var h = !0, k = d.onmessage;\n                return d.onmessage = function() {\n                  h = !1;\n                }, d.postMessage(\"\", \"*\"), d.onmessage = k, h;\n              }\n            }() ? (y = \"setImmediate$\" + Math.random() + \"$\", w = function(h) {\n              h.source === d && typeof h.data == \"string\" && h.data.indexOf(y) === 0 && m(+h.data.slice(y.length));\n            }, d.addEventListener ? d.addEventListener(\"message\", w, !1) : d.attachEvent(\"onmessage\", w), u = function(h) {\n              d.postMessage(y + h, \"*\");\n            }) : d.MessageChannel ? ((p = new MessageChannel()).port1.onmessage = function(h) {\n              m(h.data);\n            }, u = function(h) {\n              p.port2.postMessage(h);\n            }) : l && \"onreadystatechange\" in l.createElement(\"script\") ? (f = l.documentElement, u = function(h) {\n              var k = l.createElement(\"script\");\n              k.onreadystatechange = function() {\n                m(h), k.onreadystatechange = null, f.removeChild(k), k = null;\n              }, f.appendChild(k);\n            }) : u = function(h) {\n              setTimeout(m, 0, h);\n            }, s.setImmediate = function(h) {\n              typeof h != \"function\" && (h = new Function(\"\" + h));\n              for (var k = new Array(arguments.length - 1), T = 0; T < k.length; T++)\n                k[T] = arguments[T + 1];\n              var C = { callback: h, args: k };\n              return t[v] = C, u(v), v++;\n            }, s.clearImmediate = g;\n          }\n          function g(h) {\n            delete t[h];\n          }\n          function m(h) {\n            if (e)\n              setTimeout(m, 0, h);\n            else {\n              var k = t[h];\n              if (k) {\n                e = !0;\n                try {\n                  (function(T) {\n                    var C = T.callback, S = T.args;\n                    switch (S.length) {\n                      case 0:\n                        C();\n                        break;\n                      case 1:\n                        C(S[0]);\n                        break;\n                      case 2:\n                        C(S[0], S[1]);\n                        break;\n                      case 3:\n                        C(S[0], S[1], S[2]);\n                        break;\n                      default:\n                        C.apply(b, S);\n                    }\n                  })(k);\n                } finally {\n                  g(h), e = !1;\n                }\n              }\n            }\n          }\n        })(typeof self > \"u\" ? n === void 0 ? this : n : self);\n      }).call(this, r(0), r(7));\n    }, function(i, c) {\n      var r, n, o = i.exports = {};\n      function d() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function b() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      function u(s) {\n        if (r === setTimeout)\n          return setTimeout(s, 0);\n        if ((r === d || !r) && setTimeout)\n          return r = setTimeout, setTimeout(s, 0);\n        try {\n          return r(s, 0);\n        } catch {\n          try {\n            return r.call(null, s, 0);\n          } catch {\n            return r.call(this, s, 0);\n          }\n        }\n      }\n      (function() {\n        try {\n          r = typeof setTimeout == \"function\" ? setTimeout : d;\n        } catch {\n          r = d;\n        }\n        try {\n          n = typeof clearTimeout == \"function\" ? clearTimeout : b;\n        } catch {\n          n = b;\n        }\n      })();\n      var f, p = [], y = !1, w = -1;\n      function v() {\n        y && f && (y = !1, f.length ? p = f.concat(p) : w = -1, p.length && t());\n      }\n      function t() {\n        if (!y) {\n          var s = u(v);\n          y = !0;\n          for (var g = p.length; g; ) {\n            for (f = p, p = []; ++w < g; )\n              f && f[w].run();\n            w = -1, g = p.length;\n          }\n          f = null, y = !1, function(m) {\n            if (n === clearTimeout)\n              return clearTimeout(m);\n            if ((n === b || !n) && clearTimeout)\n              return n = clearTimeout, clearTimeout(m);\n            try {\n              n(m);\n            } catch {\n              try {\n                return n.call(null, m);\n              } catch {\n                return n.call(this, m);\n              }\n            }\n          }(s);\n        }\n      }\n      function e(s, g) {\n        this.fun = s, this.array = g;\n      }\n      function l() {\n      }\n      o.nextTick = function(s) {\n        var g = new Array(arguments.length - 1);\n        if (arguments.length > 1)\n          for (var m = 1; m < arguments.length; m++)\n            g[m - 1] = arguments[m];\n        p.push(new e(s, g)), p.length !== 1 || y || u(t);\n      }, e.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      }, o.title = \"browser\", o.browser = !0, o.env = {}, o.argv = [], o.version = \"\", o.versions = {}, o.on = l, o.addListener = l, o.once = l, o.off = l, o.removeListener = l, o.removeAllListeners = l, o.emit = l, o.prependListener = l, o.prependOnceListener = l, o.listeners = function(s) {\n        return [];\n      }, o.binding = function(s) {\n        throw new Error(\"process.binding is not supported\");\n      }, o.cwd = function() {\n        return \"/\";\n      }, o.chdir = function(s) {\n        throw new Error(\"process.chdir is not supported\");\n      }, o.umask = function() {\n        return 0;\n      };\n    }, function(i, c, r) {\n      function n(d, b) {\n        for (var u = 0; u < b.length; u++) {\n          var f = b[u];\n          f.enumerable = f.enumerable || !1, f.configurable = !0, \"value\" in f && (f.writable = !0), Object.defineProperty(d, f.key, f);\n        }\n      }\n      var o = r(9);\n      i.exports = function() {\n        function d() {\n          (function(p, y) {\n            if (!(p instanceof y))\n              throw new TypeError(\"Cannot call a class as a function\");\n          })(this, d);\n        }\n        var b, u, f;\n        return b = d, f = [{ key: \"urlEncode\", value: function(p) {\n          return o(p);\n        } }, { key: \"jsonEncode\", value: function(p) {\n          return JSON.stringify(p);\n        } }, { key: \"formEncode\", value: function(p) {\n          if (this.isFormData(p))\n            return p;\n          if (this.isFormElement(p))\n            return new FormData(p);\n          if (this.isObject(p)) {\n            var y = new FormData();\n            return Object.keys(p).forEach(function(w) {\n              var v = p[w];\n              y.append(w, v);\n            }), y;\n          }\n          throw new Error(\"`data` must be an instance of Object, FormData or <FORM> HTMLElement\");\n        } }, { key: \"isObject\", value: function(p) {\n          return Object.prototype.toString.call(p) === \"[object Object]\";\n        } }, { key: \"isFormData\", value: function(p) {\n          return p instanceof FormData;\n        } }, { key: \"isFormElement\", value: function(p) {\n          return p instanceof HTMLFormElement;\n        } }, { key: \"selectFiles\", value: function() {\n          var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n          return new Promise(function(y, w) {\n            var v = document.createElement(\"INPUT\");\n            v.type = \"file\", p.multiple && v.setAttribute(\"multiple\", \"multiple\"), p.accept && v.setAttribute(\"accept\", p.accept), v.style.display = \"none\", document.body.appendChild(v), v.addEventListener(\"change\", function(t) {\n              var e = t.target.files;\n              y(e), document.body.removeChild(v);\n            }, !1), v.click();\n          });\n        } }, { key: \"parseHeaders\", value: function(p) {\n          var y = p.trim().split(/[\\r\\n]+/), w = {};\n          return y.forEach(function(v) {\n            var t = v.split(\": \"), e = t.shift(), l = t.join(\": \");\n            e && (w[e] = l);\n          }), w;\n        } }], (u = null) && n(b.prototype, u), f && n(b, f), d;\n      }();\n    }, function(i, c) {\n      var r = function(o) {\n        return encodeURIComponent(o).replace(/[!'()*]/g, escape).replace(/%20/g, \"+\");\n      }, n = function(o, d, b, u) {\n        return d = d || null, b = b || \"&\", u = u || null, o ? function(f) {\n          for (var p = new Array(), y = 0; y < f.length; y++)\n            f[y] && p.push(f[y]);\n          return p;\n        }(Object.keys(o).map(function(f) {\n          var p, y, w = f;\n          if (u && (w = u + \"[\" + w + \"]\"), typeof o[f] == \"object\" && o[f] !== null)\n            p = n(o[f], null, b, w);\n          else {\n            d && (y = w, w = !isNaN(parseFloat(y)) && isFinite(y) ? d + Number(w) : w);\n            var v = o[f];\n            v = (v = (v = (v = v === !0 ? \"1\" : v) === !1 ? \"0\" : v) === 0 ? \"0\" : v) || \"\", p = r(w) + \"=\" + r(v);\n          }\n          return p;\n        })).join(b).replace(/[!'()*]/g, \"\") : \"\";\n      };\n      i.exports = n;\n    }]);\n  });\n})(I);\nvar U = I.exports;\nconst F = /* @__PURE__ */ x(U);\nfunction _(E) {\n  return E && typeof E.then == \"function\";\n}\nclass B {\n  /**\n   * @param {object} params - uploader module params\n   * @param {ImageConfig} params.config - image tool config\n   * @param {Function} params.onUpload - one callback for all uploading (file, url, d-n-d, pasting)\n   * @param {Function} params.onError - callback for uploading errors\n   */\n  constructor({ config: a, onUpload: i, onError: c }) {\n    this.config = a, this.onUpload = i, this.onError = c;\n  }\n  /**\n   * Handle clicks on the upload file button\n   * Fires ajax.transport()\n   *\n   * @param {Function} onPreview - callback fired when preview is ready\n   */\n  uploadSelectedFile({ onPreview: a }) {\n    const i = function(r) {\n      const n = new FileReader();\n      n.readAsDataURL(r), n.onload = (o) => {\n        a(o.target.result);\n      };\n    };\n    let c;\n    this.config.uploader && typeof this.config.uploader.uploadByFile == \"function\" ? c = F.selectFiles({ accept: this.config.types }).then((r) => {\n      i(r[0]);\n      const n = this.config.uploader.uploadByFile(r[0]);\n      return _(n) || console.warn(\"Custom uploader method uploadByFile should return a Promise\"), n;\n    }) : c = F.transport({\n      url: this.config.endpoints.byFile,\n      data: this.config.additionalRequestData,\n      accept: this.config.types,\n      headers: this.config.additionalRequestHeaders,\n      beforeSend: (r) => {\n        i(r[0]);\n      },\n      fieldName: this.config.field\n    }).then((r) => r.body), c.then((r) => {\n      this.onUpload(r);\n    }).catch((r) => {\n      this.onError(r);\n    });\n  }\n  /**\n   * Handle clicks on the upload file button\n   * Fires ajax.post()\n   *\n   * @param {string} url - image source url\n   */\n  uploadByUrl(a) {\n    let i;\n    this.config.uploader && typeof this.config.uploader.uploadByUrl == \"function\" ? (i = this.config.uploader.uploadByUrl(a), _(i) || console.warn(\"Custom uploader method uploadByUrl should return a Promise\")) : i = F.post({\n      url: this.config.endpoints.byUrl,\n      data: Object.assign({\n        url: a\n      }, this.config.additionalRequestData),\n      type: F.contentType.JSON,\n      headers: this.config.additionalRequestHeaders\n    }).then((c) => c.body), i.then((c) => {\n      this.onUpload(c);\n    }).catch((c) => {\n      this.onError(c);\n    });\n  }\n  /**\n   * Handle clicks on the upload file button\n   * Fires ajax.post()\n   *\n   * @param {File} file - file pasted by drag-n-drop\n   * @param {Function} onPreview - file pasted by drag-n-drop\n   */\n  uploadByFile(a, { onPreview: i }) {\n    const c = new FileReader();\n    c.readAsDataURL(a), c.onload = (n) => {\n      i(n.target.result);\n    };\n    let r;\n    if (this.config.uploader && typeof this.config.uploader.uploadByFile == \"function\")\n      r = this.config.uploader.uploadByFile(a), _(r) || console.warn(\"Custom uploader method uploadByFile should return a Promise\");\n    else {\n      const n = new FormData();\n      n.append(this.config.field, a), this.config.additionalRequestData && Object.keys(this.config.additionalRequestData).length && Object.entries(this.config.additionalRequestData).forEach(([o, d]) => {\n        n.append(o, d);\n      }), r = F.post({\n        url: this.config.endpoints.byFile,\n        data: n,\n        type: F.contentType.JSON,\n        headers: this.config.additionalRequestHeaders\n      }).then((o) => o.body);\n    }\n    r.then((n) => {\n      this.onUpload(n);\n    }).catch((n) => {\n      this.onError(n);\n    });\n  }\n}\n/**\n * Image Tool for the Editor.js\n *\n * @author CodeX <team@codex.so>\n * @license MIT\n * @see {@link https://github.com/editor-js/image}\n *\n * To developers.\n * To simplify Tool structure, we split it to 4 parts:\n *  1) index.js — main Tool's interface, public API and methods for working with data\n *  2) uploader.js — module that has methods for sending files via AJAX: from device, by URL or File pasting\n *  3) ui.js — module for UI manipulations: render, showing preloader, etc\n *  4) tunes.js — working with Block Tunes: render buttons, handle clicks\n *\n * For debug purposes there is a testing server\n * that can save uploaded files and return a Response {@link UploadResponseFormat}\n *\n *       $ node dev/server.js\n *\n * It will expose 8008 port, so you can pass http://localhost:8008 with the Tools config:\n *\n * image: {\n *   class: ImageTool,\n *   config: {\n *     endpoints: {\n *       byFile: 'http://localhost:8008/uploadFile',\n *       byUrl: 'http://localhost:8008/fetchUrl',\n *     }\n *   },\n * },\n */\nclass P {\n  /**\n   * Notify core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: L,\n      title: \"Image\"\n    };\n  }\n  /**\n   * Available image tools\n   *\n   * @returns {Array}\n   */\n  static get tunes() {\n    return [\n      {\n        name: \"withBorder\",\n        icon: H,\n        title: \"With border\",\n        toggle: !0\n      },\n      {\n        name: \"stretched\",\n        icon: D,\n        title: \"Stretch image\",\n        toggle: !0\n      },\n      {\n        name: \"withBackground\",\n        icon: R,\n        title: \"With background\",\n        toggle: !0\n      }\n    ];\n  }\n  /**\n   * @param {object} tool - tool properties got from editor.js\n   * @param {ImageToolData} tool.data - previously saved data\n   * @param {ImageConfig} tool.config - user config for Tool\n   * @param {object} tool.api - Editor.js API\n   * @param {boolean} tool.readOnly - read-only mode flag\n   * @param {BlockAPI|{}} tool.block - current Block API\n   */\n  constructor({ data: a, config: i, api: c, readOnly: r, block: n }) {\n    this.api = c, this.readOnly = r, this.block = n, this.config = {\n      endpoints: i.endpoints || \"\",\n      additionalRequestData: i.additionalRequestData || {},\n      additionalRequestHeaders: i.additionalRequestHeaders || {},\n      field: i.field || \"image\",\n      types: i.types || \"image/*\",\n      captionPlaceholder: this.api.i18n.t(i.captionPlaceholder || \"Caption\"),\n      buttonContent: i.buttonContent || \"\",\n      uploader: i.uploader || void 0,\n      actions: i.actions || []\n    }, this.uploader = new B({\n      config: this.config,\n      onUpload: (o) => this.onUpload(o),\n      onError: (o) => this.uploadingFailed(o)\n    }), this.ui = new j({\n      api: c,\n      config: this.config,\n      onSelectFile: () => {\n        this.uploader.uploadSelectedFile({\n          onPreview: (o) => {\n            this.ui.showPreloader(o);\n          }\n        });\n      },\n      readOnly: r\n    }), this._data = {}, this.data = a;\n  }\n  /**\n   * Renders Block content\n   *\n   * @public\n   *\n   * @returns {HTMLDivElement}\n   */\n  render() {\n    return this.ui.render(this.data);\n  }\n  /**\n   * Validate data: check if Image exists\n   *\n   * @param {ImageToolData} savedData — data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(a) {\n    return a.file && a.file.url;\n  }\n  /**\n   * Return Block data\n   *\n   * @public\n   *\n   * @returns {ImageToolData}\n   */\n  save() {\n    const a = this.ui.nodes.caption;\n    return this._data.caption = a.innerHTML, this.data;\n  }\n  /**\n   * Returns configuration for block tunes: add background, add border, stretch image\n   *\n   * @public\n   *\n   * @returns {Array}\n   */\n  renderSettings() {\n    return P.tunes.concat(this.config.actions).map((i) => ({\n      icon: i.icon,\n      label: this.api.i18n.t(i.title),\n      name: i.name,\n      toggle: i.toggle,\n      isActive: this.data[i.name],\n      onActivate: () => {\n        if (typeof i.action == \"function\") {\n          i.action(i.name);\n          return;\n        }\n        this.tuneToggled(i.name);\n      }\n    }));\n  }\n  /**\n   * Fires after clicks on the Toolbox Image Icon\n   * Initiates click on the Select File button\n   *\n   * @public\n   */\n  appendCallback() {\n    this.ui.nodes.fileButton.click();\n  }\n  /**\n   * Specify paste substitutes\n   *\n   * @see {@link https://github.com/codex-team/editor.js/blob/master/docs/tools.md#paste-handling}\n   * @returns {{tags: string[], patterns: object<string, RegExp>, files: {extensions: string[], mimeTypes: string[]}}}\n   */\n  static get pasteConfig() {\n    return {\n      /**\n       * Paste HTML into Editor\n       */\n      tags: [\n        {\n          img: { src: !0 }\n        }\n      ],\n      /**\n       * Paste URL of image into the Editor\n       */\n      patterns: {\n        image: /https?:\\/\\/\\S+\\.(gif|jpe?g|tiff|png|svg|webp)(\\?[a-z0-9=]*)?$/i\n      },\n      /**\n       * Drag n drop file from into the Editor\n       */\n      files: {\n        mimeTypes: [\"image/*\"]\n      }\n    };\n  }\n  /**\n   * Specify paste handlers\n   *\n   * @public\n   * @see {@link https://github.com/codex-team/editor.js/blob/master/docs/tools.md#paste-handling}\n   * @param {CustomEvent} event - editor.js custom paste event\n   *                              {@link https://github.com/codex-team/editor.js/blob/master/types/tools/paste-events.d.ts}\n   * @returns {void}\n   */\n  async onPaste(a) {\n    switch (a.type) {\n      case \"tag\": {\n        const i = a.detail.data;\n        if (/^blob:/.test(i.src)) {\n          const r = await (await fetch(i.src)).blob();\n          this.uploadFile(r);\n          break;\n        }\n        this.uploadUrl(i.src);\n        break;\n      }\n      case \"pattern\": {\n        const i = a.detail.data;\n        this.uploadUrl(i);\n        break;\n      }\n      case \"file\": {\n        const i = a.detail.file;\n        this.uploadFile(i);\n        break;\n      }\n    }\n  }\n  /**\n   * Private methods\n   * ̿̿ ̿̿ ̿̿ ̿'̿'\\̵͇̿̿\\з= ( ▀ ͜͞ʖ▀) =ε/̵͇̿̿/’̿’̿ ̿ ̿̿ ̿̿ ̿̿\n   */\n  /**\n   * Stores all Tool's data\n   *\n   * @private\n   *\n   * @param {ImageToolData} data - data in Image Tool format\n   */\n  set data(a) {\n    this.image = a.file, this._data.caption = a.caption || \"\", this.ui.fillCaption(this._data.caption), P.tunes.forEach(({ name: i }) => {\n      const c = typeof a[i] < \"u\" ? a[i] === !0 || a[i] === \"true\" : !1;\n      this.setTune(i, c);\n    });\n  }\n  /**\n   * Return Tool data\n   *\n   * @private\n   *\n   * @returns {ImageToolData}\n   */\n  get data() {\n    return this._data;\n  }\n  /**\n   * Set new image file\n   *\n   * @private\n   *\n   * @param {object} file - uploaded file data\n   */\n  set image(a) {\n    this._data.file = a || {}, a && a.url && this.ui.fillImage(a.url);\n  }\n  /**\n   * File uploading callback\n   *\n   * @private\n   *\n   * @param {UploadResponseFormat} response - uploading server response\n   * @returns {void}\n   */\n  onUpload(a) {\n    a.success && a.file ? this.image = a.file : this.uploadingFailed(\"incorrect response: \" + JSON.stringify(a));\n  }\n  /**\n   * Handle uploader errors\n   *\n   * @private\n   * @param {string} errorText - uploading error text\n   * @returns {void}\n   */\n  uploadingFailed(a) {\n    console.log(\"Image Tool: uploading failed because of\", a), this.api.notifier.show({\n      message: this.api.i18n.t(\"Couldn’t upload image. Please try another.\"),\n      style: \"error\"\n    }), this.ui.hidePreloader();\n  }\n  /**\n   * Callback fired when Block Tune is activated\n   *\n   * @private\n   *\n   * @param {string} tuneName - tune that has been clicked\n   * @returns {void}\n   */\n  tuneToggled(a) {\n    this.setTune(a, !this._data[a]);\n  }\n  /**\n   * Set one tune\n   *\n   * @param {string} tuneName - {@link Tunes.tunes}\n   * @param {boolean} value - tune state\n   * @returns {void}\n   */\n  setTune(a, i) {\n    this._data[a] = i, this.ui.applyTune(a, i), a === \"stretched\" && Promise.resolve().then(() => {\n      this.block.stretched = i;\n    }).catch((c) => {\n      console.error(c);\n    });\n  }\n  /**\n   * Show preloader and upload image file\n   *\n   * @param {File} file - file that is currently uploading (from paste)\n   * @returns {void}\n   */\n  uploadFile(a) {\n    this.uploader.uploadByFile(a, {\n      onPreview: (i) => {\n        this.ui.showPreloader(i);\n      }\n    });\n  }\n  /**\n   * Show preloader and upload image by target url\n   *\n   * @param {string} url - url pasted\n   * @returns {void}\n   */\n  uploadUrl(a) {\n    this.ui.showPreloader(a), this.uploader.uploadByUrl(a);\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2ltYWdlL2Rpc3QvaW1hZ2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSx3QkFBd0Isc0NBQXNDLG1EQUFtRCxvQkFBb0IsdUJBQXVCLHdCQUF3QixtQkFBbUIsa0JBQWtCLGdCQUFnQixtQkFBbUIsMkJBQTJCLGVBQWUsc0JBQXNCLGNBQWMsNkJBQTZCLFdBQVcsWUFBWSxrQkFBa0Isc0JBQXNCLFlBQVksa0JBQWtCLGlDQUFpQyxrQ0FBa0MsbUNBQW1DLFdBQVcsa0JBQWtCLFVBQVUsV0FBVyxZQUFZLGtCQUFrQixpQ0FBaUMsb0NBQW9DLFNBQVMsUUFBUSxpQkFBaUIsa0JBQWtCLGtEQUFrRCxzQkFBc0Isb0VBQW9FLDRCQUE0QiwrQkFBK0IsY0FBYyxnQkFBZ0IsYUFBYSwwRUFBMEUsY0FBYyxnRkFBZ0YsYUFBYSx3SEFBd0gsYUFBYSx3QkFBd0IsYUFBYSxtQkFBbUIsdUJBQXVCLDRCQUE0QixZQUFZLGlCQUFpQixpRkFBaUYsYUFBYSx3Q0FBd0MsaUJBQWlCLGFBQWEscUNBQXFDLHNCQUFzQixpRkFBaUYsYUFBYSwyQ0FBMkMscUNBQXFDLCtDQUErQyxhQUFhLDJCQUEyQix1REFBdUQsY0FBYyxjQUFjLGtEQUFrRCxXQUFXLGdDQUFnQyxHQUFHLG9CQUFvQixHQUFHLDBCQUEwQixrQ0FBa0MsU0FBUyxtREFBbUQ7QUFDMXVFO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsYUFBYTtBQUMxQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFD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QUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLFlBQVk7QUFDakMsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1lZGl0b3Jqcy1hcHAvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2ltYWdlL2Rpc3QvaW1hZ2UubWpzPzcwZjAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIil7dmFyIG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO28uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJy5pbWFnZS10b29sey0tYmctY29sb3I6ICNjZGQxZTA7LS1mcm9udC1jb2xvcjogIzM4OGFlNTstLWJvcmRlci1jb2xvcjogI2U4ZThlYn0uaW1hZ2UtdG9vbF9faW1hZ2V7Ym9yZGVyLXJhZGl1czozcHg7b3ZlcmZsb3c6aGlkZGVuO21hcmdpbi1ib3R0b206MTBweH0uaW1hZ2UtdG9vbF9faW1hZ2UtcGljdHVyZXttYXgtd2lkdGg6MTAwJTt2ZXJ0aWNhbC1hbGlnbjpib3R0b207ZGlzcGxheTpibG9ja30uaW1hZ2UtdG9vbF9faW1hZ2UtcHJlbG9hZGVye3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7Ym9yZGVyLXJhZGl1czo1MCU7YmFja2dyb3VuZC1zaXplOmNvdmVyO21hcmdpbjphdXRvO3Bvc2l0aW9uOnJlbGF0aXZlO2JhY2tncm91bmQtY29sb3I6dmFyKC0tYmctY29sb3IpO2JhY2tncm91bmQtcG9zaXRpb246Y2VudGVyIGNlbnRlcn0uaW1hZ2UtdG9vbF9faW1hZ2UtcHJlbG9hZGVyOmFmdGVye2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjM7d2lkdGg6NjBweDtoZWlnaHQ6NjBweDtib3JkZXItcmFkaXVzOjUwJTtib3JkZXI6MnB4IHNvbGlkIHZhcigtLWJnLWNvbG9yKTtib3JkZXItdG9wLWNvbG9yOnZhcigtLWZyb250LWNvbG9yKTtsZWZ0OjUwJTt0b3A6NTAlO21hcmdpbi10b3A6LTMwcHg7bWFyZ2luLWxlZnQ6LTMwcHg7YW5pbWF0aW9uOmltYWdlLXByZWxvYWRlci1zcGluIDJzIGluZmluaXRlIGxpbmVhcjtib3gtc2l6aW5nOmJvcmRlci1ib3h9LmltYWdlLXRvb2xfX2NhcHRpb25bY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZSFpbXBvcnRhbnQ7Y29udGVudDphdHRyKGRhdGEtcGxhY2Vob2xkZXIpO2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NDAwO2Rpc3BsYXk6bm9uZX0uaW1hZ2UtdG9vbF9fY2FwdGlvbltjb250ZW50RWRpdGFibGU9dHJ1ZV1bZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6YmVmb3Jle2Rpc3BsYXk6YmxvY2t9LmltYWdlLXRvb2xfX2NhcHRpb25bY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmZvY3VzOmJlZm9yZXtkaXNwbGF5Om5vbmV9LmltYWdlLXRvb2wtLWVtcHR5IC5pbWFnZS10b29sX19pbWFnZSwuaW1hZ2UtdG9vbC0tZW1wdHkgLmltYWdlLXRvb2xfX2NhcHRpb24sLmltYWdlLXRvb2wtLWxvYWRpbmcgLmltYWdlLXRvb2xfX2NhcHRpb257ZGlzcGxheTpub25lfS5pbWFnZS10b29sIC5jZHgtYnV0dG9ue2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uaW1hZ2UtdG9vbCAuY2R4LWJ1dHRvbiBzdmd7aGVpZ2h0OmF1dG87bWFyZ2luOjAgNnB4IDAgMH0uaW1hZ2UtdG9vbC0tZmlsbGVkIC5jZHgtYnV0dG9uLC5pbWFnZS10b29sLS1maWxsZWQgLmltYWdlLXRvb2xfX2ltYWdlLXByZWxvYWRlcntkaXNwbGF5Om5vbmV9LmltYWdlLXRvb2wtLWxvYWRpbmcgLmltYWdlLXRvb2xfX2ltYWdle21pbi1oZWlnaHQ6MjAwcHg7ZGlzcGxheTpmbGV4O2JvcmRlcjoxcHggc29saWQgdmFyKC0tYm9yZGVyLWNvbG9yKTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LmltYWdlLXRvb2wtLWxvYWRpbmcgLmltYWdlLXRvb2xfX2ltYWdlLXBpY3R1cmUsLmltYWdlLXRvb2wtLWxvYWRpbmcgLmNkeC1idXR0b257ZGlzcGxheTpub25lfS5pbWFnZS10b29sLS13aXRoQm9yZGVyIC5pbWFnZS10b29sX19pbWFnZXtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWJvcmRlci1jb2xvcil9LmltYWdlLXRvb2wtLXdpdGhCYWNrZ3JvdW5kIC5pbWFnZS10b29sX19pbWFnZXtwYWRkaW5nOjE1cHg7YmFja2dyb3VuZDp2YXIoLS1iZy1jb2xvcil9LmltYWdlLXRvb2wtLXdpdGhCYWNrZ3JvdW5kIC5pbWFnZS10b29sX19pbWFnZS1waWN0dXJle21heC13aWR0aDo2MCU7bWFyZ2luOjAgYXV0b30uaW1hZ2UtdG9vbC0tc3RyZXRjaGVkIC5pbWFnZS10b29sX19pbWFnZS1waWN0dXJle3dpZHRoOjEwMCV9QGtleWZyYW1lcyBpbWFnZS1wcmVsb2FkZXItc3BpbnswJXt0cmFuc2Zvcm06cm90YXRlKDApfXRve3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19JykpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobyl9fWNhdGNoKGUpe2NvbnNvbGUuZXJyb3IoXCJ2aXRlLXBsdWdpbi1jc3MtaW5qZWN0ZWQtYnktanNcIixlKX19KSgpO1xuY29uc3QgUiA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMSAxOVYxOUM5LjEzNjIzIDE5IDguMjA0MzUgMTkgNy40NjkyNyAxOC42OTU1QzYuNDg5MTUgMTguMjg5NSA1LjcxMDQ2IDE3LjUxMDggNS4zMDQ0OCAxNi41MzA3QzUgMTUuNzk1NiA1IDE0Ljg2MzggNSAxM1YxMkM1IDkuMTkxMDggNSA3Ljc4NjYxIDUuNjc0MTIgNi43Nzc3MkM1Ljk2NTk2IDYuMzQwOTYgNi4zNDA5NiA1Ljk2NTk2IDYuNzc3NzIgNS42NzQxMkM3Ljc4NjYxIDUgOS4xOTEwOCA1IDEyIDVIMTMuNUMxNC44OTU2IDUgMTUuNTkzMyA1IDE2LjE2MTEgNS4xNzIyNEMxNy40Mzk1IDUuNTYwMDQgMTguNDQgNi41NjA0NiAxOC44Mjc4IDcuODM4ODZDMTkgOC40MDY2NiAxOSA5LjEwNDQ0IDE5IDEwLjVWMTAuNVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTYgMTNWMTZNMTYgMTlWMTZNMTkgMTZIMTZNMTYgMTZIMTNcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNi41IDE3LjVMMTcuNSA2LjVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTguOTkxOSAxMC41SDE5LjAwMTVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTAuOTkxOSAxOUgxMS4wMDE1XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUgMTNMMTMgNVwiLz48L3N2Zz4nLCBIID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE4Ljk5MTkgOS41SDE5LjAwMTVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTQuNSA1SDE0LjUwOTZcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE0LjYyNSA1SDE1QzE3LjIwOTEgNSAxOSA2Ljc5MDg2IDE5IDlWOS4zNzVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOS4zNzUgNUw5IDVDNi43OTA4NiA1IDUgNi43OTA4NiA1IDlWOS4zNzVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOS4zNzI1IDVIOS4zODIwN1wiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01IDkuNUg1LjAwOTU3XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTkuMzc1IDE5SDlDNi43OTA4NiAxOSA1IDE3LjIwOTEgNSAxNVYxNC42MjVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOS4zNzI1IDE5SDkuMzgyMDdcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNSAxNC41NUg1LjAwOTU3XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNiAxM1YxNk0xNiAxOVYxNk0xOSAxNkgxNk0xNiAxNkgxM1wiLz48L3N2Zz4nLCBMID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxyZWN0IHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHg9XCI1XCIgeT1cIjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgcng9XCI0XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUuMTM5NjggMTUuMzJMOC42OTA1OCAxMS41NjYxQzkuMDI5MzQgMTEuMjAzNiA5LjQ4ODczIDExIDkuOTY3NzQgMTFDMTAuNDQ2NyAxMSAxMC45MDYxIDExLjIwMzYgMTEuMjQ0OSAxMS41NjYxTDE1LjM4NzEgMTZNMTMuNTgwNiAxNC4wNjY0TDE1LjAxMzIgMTIuNTMzQzE1LjM1MTkgMTIuMTcwNSAxNS44MTEzIDExLjk2NjggMTYuMjkwMyAxMS45NjY4QzE2Ljc2OTMgMTEuOTY2OCAxNy4yMjg3IDEyLjE3MDUgMTcuNTY3NSAxMi41MzNMMTguODQxIDEzLjk2MzRcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTMuNzc3OCA5LjMzMzMxSDEzLjc4NjdcIi8+PC9zdmc+JywgRCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNyA5TDIwIDEyTDE3IDE1XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE0IDEySDIwXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTcgOUw0IDEyTDcgMTVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNCAxMkgxMFwiLz48L3N2Zz4nO1xuZnVuY3Rpb24gTShFLCBhID0gbnVsbCwgaSA9IHt9KSB7XG4gIGNvbnN0IGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KEUpO1xuICBBcnJheS5pc0FycmF5KGEpID8gYy5jbGFzc0xpc3QuYWRkKC4uLmEpIDogYSAmJiBjLmNsYXNzTGlzdC5hZGQoYSk7XG4gIGZvciAoY29uc3QgciBpbiBpKVxuICAgIGNbcl0gPSBpW3JdO1xuICByZXR1cm4gYztcbn1cbmNsYXNzIGoge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IHVpIC0gaW1hZ2UgdG9vbCBVaSBtb2R1bGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHVpLmFwaSAtIEVkaXRvci5qcyBBUElcbiAgICogQHBhcmFtIHtJbWFnZUNvbmZpZ30gdWkuY29uZmlnIC0gdXNlciBjb25maWdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdWkub25TZWxlY3RGaWxlIC0gY2FsbGJhY2sgZm9yIGNsaWNrcyBvbiBTZWxlY3QgZmlsZSBidXR0b25cbiAgICogQHBhcmFtIHtib29sZWFufSB1aS5yZWFkT25seSAtIHJlYWQtb25seSBtb2RlIGZsYWdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpOiBhLCBjb25maWc6IGksIG9uU2VsZWN0RmlsZTogYywgcmVhZE9ubHk6IHIgfSkge1xuICAgIHRoaXMuYXBpID0gYSwgdGhpcy5jb25maWcgPSBpLCB0aGlzLm9uU2VsZWN0RmlsZSA9IGMsIHRoaXMucmVhZE9ubHkgPSByLCB0aGlzLm5vZGVzID0ge1xuICAgICAgd3JhcHBlcjogTShcImRpdlwiLCBbdGhpcy5DU1MuYmFzZUNsYXNzLCB0aGlzLkNTUy53cmFwcGVyXSksXG4gICAgICBpbWFnZUNvbnRhaW5lcjogTShcImRpdlwiLCBbdGhpcy5DU1MuaW1hZ2VDb250YWluZXJdKSxcbiAgICAgIGZpbGVCdXR0b246IHRoaXMuY3JlYXRlRmlsZUJ1dHRvbigpLFxuICAgICAgaW1hZ2VFbDogdm9pZCAwLFxuICAgICAgaW1hZ2VQcmVsb2FkZXI6IE0oXCJkaXZcIiwgdGhpcy5DU1MuaW1hZ2VQcmVsb2FkZXIpLFxuICAgICAgY2FwdGlvbjogTShcImRpdlwiLCBbdGhpcy5DU1MuaW5wdXQsIHRoaXMuQ1NTLmNhcHRpb25dLCB7XG4gICAgICAgIGNvbnRlbnRFZGl0YWJsZTogIXRoaXMucmVhZE9ubHlcbiAgICAgIH0pXG4gICAgfSwgdGhpcy5ub2Rlcy5jYXB0aW9uLmRhdGFzZXQucGxhY2Vob2xkZXIgPSB0aGlzLmNvbmZpZy5jYXB0aW9uUGxhY2Vob2xkZXIsIHRoaXMubm9kZXMuaW1hZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5pbWFnZVByZWxvYWRlciksIHRoaXMubm9kZXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLmltYWdlQ29udGFpbmVyKSwgdGhpcy5ub2Rlcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMuY2FwdGlvbiksIHRoaXMubm9kZXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLmZpbGVCdXR0b24pO1xuICB9XG4gIC8qKlxuICAgKiBDU1MgY2xhc3Nlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUNsYXNzOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICBsb2FkaW5nOiB0aGlzLmFwaS5zdHlsZXMubG9hZGVyLFxuICAgICAgaW5wdXQ6IHRoaXMuYXBpLnN0eWxlcy5pbnB1dCxcbiAgICAgIGJ1dHRvbjogdGhpcy5hcGkuc3R5bGVzLmJ1dHRvbixcbiAgICAgIC8qKlxuICAgICAgICogVG9vbCdzIGNsYXNzZXNcbiAgICAgICAqL1xuICAgICAgd3JhcHBlcjogXCJpbWFnZS10b29sXCIsXG4gICAgICBpbWFnZUNvbnRhaW5lcjogXCJpbWFnZS10b29sX19pbWFnZVwiLFxuICAgICAgaW1hZ2VQcmVsb2FkZXI6IFwiaW1hZ2UtdG9vbF9faW1hZ2UtcHJlbG9hZGVyXCIsXG4gICAgICBpbWFnZUVsOiBcImltYWdlLXRvb2xfX2ltYWdlLXBpY3R1cmVcIixcbiAgICAgIGNhcHRpb246IFwiaW1hZ2UtdG9vbF9fY2FwdGlvblwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVWkgc3RhdHVzZXM6XG4gICAqIC0gZW1wdHlcbiAgICogLSB1cGxvYWRpbmdcbiAgICogLSBmaWxsZWRcbiAgICpcbiAgICogQHJldHVybnMge3tFTVBUWTogc3RyaW5nLCBVUExPQURJTkc6IHN0cmluZywgRklMTEVEOiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVNUFRZOiBcImVtcHR5XCIsXG4gICAgICBVUExPQURJTkc6IFwibG9hZGluZ1wiLFxuICAgICAgRklMTEVEOiBcImZpbGxlZFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0b29sIFVJXG4gICAqXG4gICAqIEBwYXJhbSB7SW1hZ2VUb29sRGF0YX0gdG9vbERhdGEgLSBzYXZlZCB0b29sIGRhdGFcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICByZW5kZXIoYSkge1xuICAgIHJldHVybiAhYS5maWxlIHx8IE9iamVjdC5rZXlzKGEuZmlsZSkubGVuZ3RoID09PSAwID8gdGhpcy50b2dnbGVTdGF0dXMoai5zdGF0dXMuRU1QVFkpIDogdGhpcy50b2dnbGVTdGF0dXMoai5zdGF0dXMuVVBMT0FESU5HKSwgdGhpcy5ub2Rlcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHVwbG9hZC1maWxlIGJ1dHRvblxuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIGNyZWF0ZUZpbGVCdXR0b24oKSB7XG4gICAgY29uc3QgYSA9IE0oXCJkaXZcIiwgW3RoaXMuQ1NTLmJ1dHRvbl0pO1xuICAgIHJldHVybiBhLmlubmVySFRNTCA9IHRoaXMuY29uZmlnLmJ1dHRvbkNvbnRlbnQgfHwgYCR7TH0gJHt0aGlzLmFwaS5pMThuLnQoXCJTZWxlY3QgYW4gSW1hZ2VcIil9YCwgYS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vblNlbGVjdEZpbGUoKTtcbiAgICB9KSwgYTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgdXBsb2FkaW5nIHByZWxvYWRlclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIC0gcHJldmlldyBzb3VyY2VcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzaG93UHJlbG9hZGVyKGEpIHtcbiAgICB0aGlzLm5vZGVzLmltYWdlUHJlbG9hZGVyLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHthfSlgLCB0aGlzLnRvZ2dsZVN0YXR1cyhqLnN0YXR1cy5VUExPQURJTkcpO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlIHVwbG9hZGluZyBwcmVsb2FkZXJcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBoaWRlUHJlbG9hZGVyKCkge1xuICAgIHRoaXMubm9kZXMuaW1hZ2VQcmVsb2FkZXIuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJcIiwgdGhpcy50b2dnbGVTdGF0dXMoai5zdGF0dXMuRU1QVFkpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyBhbiBpbWFnZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gaW1hZ2Ugc291cmNlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZmlsbEltYWdlKGEpIHtcbiAgICBjb25zdCBpID0gL1xcLm1wNCQvLnRlc3QoYSkgPyBcIlZJREVPXCIgOiBcIklNR1wiLCBjID0ge1xuICAgICAgc3JjOiBhXG4gICAgfTtcbiAgICBsZXQgciA9IFwibG9hZFwiO1xuICAgIGkgPT09IFwiVklERU9cIiAmJiAoYy5hdXRvcGxheSA9ICEwLCBjLmxvb3AgPSAhMCwgYy5tdXRlZCA9ICEwLCBjLnBsYXlzaW5saW5lID0gITAsIHIgPSBcImxvYWRlZGRhdGFcIiksIHRoaXMubm9kZXMuaW1hZ2VFbCA9IE0oaSwgdGhpcy5DU1MuaW1hZ2VFbCwgYyksIHRoaXMubm9kZXMuaW1hZ2VFbC5hZGRFdmVudExpc3RlbmVyKHIsICgpID0+IHtcbiAgICAgIHRoaXMudG9nZ2xlU3RhdHVzKGouc3RhdHVzLkZJTExFRCksIHRoaXMubm9kZXMuaW1hZ2VQcmVsb2FkZXIgJiYgKHRoaXMubm9kZXMuaW1hZ2VQcmVsb2FkZXIuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJcIik7XG4gICAgfSksIHRoaXMubm9kZXMuaW1hZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5pbWFnZUVsKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgY2FwdGlvbiBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIGNhcHRpb24gdGV4dFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZpbGxDYXB0aW9uKGEpIHtcbiAgICB0aGlzLm5vZGVzLmNhcHRpb24gJiYgKHRoaXMubm9kZXMuY2FwdGlvbi5pbm5lckhUTUwgPSBhKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBVSSBzdGF0dXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1cyAtIHNlZSB7QGxpbmsgVWkuc3RhdHVzfSBjb25zdGFudHNcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICB0b2dnbGVTdGF0dXMoYSkge1xuICAgIGZvciAoY29uc3QgaSBpbiBqLnN0YXR1cylcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqLnN0YXR1cywgaSkgJiYgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC50b2dnbGUoYCR7dGhpcy5DU1Mud3JhcHBlcn0tLSR7ai5zdGF0dXNbaV19YCwgYSA9PT0gai5zdGF0dXNbaV0pO1xuICB9XG4gIC8qKlxuICAgKiBBcHBseSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgYWN0aXZhdGVkIHR1bmVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR1bmVOYW1lIC0gb25lIG9mIGF2YWlsYWJsZSB0dW5lcyB7QGxpbmsgVHVuZXMudHVuZXN9XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdHVzIC0gdHJ1ZSBmb3IgZW5hYmxlLCBmYWxzZSBmb3IgZGlzYWJsZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGFwcGx5VHVuZShhLCBpKSB7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC50b2dnbGUoYCR7dGhpcy5DU1Mud3JhcHBlcn0tLSR7YX1gLCBpKTtcbiAgfVxufVxuZnVuY3Rpb24geChFKSB7XG4gIHJldHVybiBFICYmIEUuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoRSwgXCJkZWZhdWx0XCIpID8gRS5kZWZhdWx0IDogRTtcbn1cbnZhciBJID0geyBleHBvcnRzOiB7fSB9O1xuKGZ1bmN0aW9uKEUsIGEpIHtcbiAgKGZ1bmN0aW9uKGksIGMpIHtcbiAgICBFLmV4cG9ydHMgPSBjKCk7XG4gIH0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBjID0ge307XG4gICAgICBmdW5jdGlvbiByKG4pIHtcbiAgICAgICAgaWYgKGNbbl0pXG4gICAgICAgICAgcmV0dXJuIGNbbl0uZXhwb3J0cztcbiAgICAgICAgdmFyIG8gPSBjW25dID0geyBpOiBuLCBsOiAhMSwgZXhwb3J0czoge30gfTtcbiAgICAgICAgcmV0dXJuIGlbbl0uY2FsbChvLmV4cG9ydHMsIG8sIG8uZXhwb3J0cywgciksIG8ubCA9ICEwLCBvLmV4cG9ydHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gci5tID0gaSwgci5jID0gYywgci5kID0gZnVuY3Rpb24obiwgbywgZCkge1xuICAgICAgICByLm8obiwgbykgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIG8sIHsgZW51bWVyYWJsZTogITAsIGdldDogZCB9KTtcbiAgICAgIH0sIHIuciA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgICAgfSwgci50ID0gZnVuY3Rpb24obiwgbykge1xuICAgICAgICBpZiAoMSAmIG8gJiYgKG4gPSByKG4pKSwgOCAmIG8gfHwgNCAmIG8gJiYgdHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiBuICYmIG4uX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgdmFyIGQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKHIucihkKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGQsIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6ICEwLCB2YWx1ZTogbiB9KSwgMiAmIG8gJiYgdHlwZW9mIG4gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICBmb3IgKHZhciBiIGluIG4pXG4gICAgICAgICAgICByLmQoZCwgYiwgKGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5bdV07XG4gICAgICAgICAgICB9KS5iaW5kKG51bGwsIGIpKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9LCByLm4gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBvID0gbiAmJiBuLl9fZXNNb2R1bGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbi5kZWZhdWx0O1xuICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByLmQobywgXCJhXCIsIG8pLCBvO1xuICAgICAgfSwgci5vID0gZnVuY3Rpb24obiwgbykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIG8pO1xuICAgICAgfSwgci5wID0gXCJcIiwgcihyLnMgPSAzKTtcbiAgICB9KFtmdW5jdGlvbihpLCBjKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KCk7XG4gICAgICB0cnkge1xuICAgICAgICByID0gciB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIiAmJiAociA9IHdpbmRvdyk7XG4gICAgICB9XG4gICAgICBpLmV4cG9ydHMgPSByO1xuICAgIH0sIGZ1bmN0aW9uKGksIGMsIHIpIHtcbiAgICAgIChmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBvID0gcigyKSwgZCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdShlKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ld1wiKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGUgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gMCwgdGhpcy5faGFuZGxlZCA9ICExLCB0aGlzLl92YWx1ZSA9IHZvaWQgMCwgdGhpcy5fZGVmZXJyZWRzID0gW10sIHQoZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZihlLCBsKSB7XG4gICAgICAgICAgZm9yICg7IGUuX3N0YXRlID09PSAzOyApXG4gICAgICAgICAgICBlID0gZS5fdmFsdWU7XG4gICAgICAgICAgZS5fc3RhdGUgIT09IDAgPyAoZS5faGFuZGxlZCA9ICEwLCB1Ll9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzID0gZS5fc3RhdGUgPT09IDEgPyBsLm9uRnVsZmlsbGVkIDogbC5vblJlamVjdGVkO1xuICAgICAgICAgICAgaWYgKHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGc7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZyA9IHMoZS5fdmFsdWUpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgeShsLnByb21pc2UsIG0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHAobC5wcm9taXNlLCBnKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAoZS5fc3RhdGUgPT09IDEgPyBwIDogeSkobC5wcm9taXNlLCBlLl92YWx1ZSk7XG4gICAgICAgICAgfSkpIDogZS5fZGVmZXJyZWRzLnB1c2gobCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcChlLCBsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChsID09PSBlKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi5cIik7XG4gICAgICAgICAgICBpZiAobCAmJiAodHlwZW9mIGwgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbCA9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHZhciBzID0gbC50aGVuO1xuICAgICAgICAgICAgICBpZiAobCBpbnN0YW5jZW9mIHUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuX3N0YXRlID0gMywgZS5fdmFsdWUgPSBsLCB2b2lkIHcoZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgdCgoZyA9IHMsIG0gPSBsLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGcuYXBwbHkobSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9KSwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLl9zdGF0ZSA9IDEsIGUuX3ZhbHVlID0gbCwgdyhlKTtcbiAgICAgICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgICAgICB5KGUsIGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZywgbTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB5KGUsIGwpIHtcbiAgICAgICAgICBlLl9zdGF0ZSA9IDIsIGUuX3ZhbHVlID0gbCwgdyhlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3KGUpIHtcbiAgICAgICAgICBlLl9zdGF0ZSA9PT0gMiAmJiBlLl9kZWZlcnJlZHMubGVuZ3RoID09PSAwICYmIHUuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZS5faGFuZGxlZCB8fCB1Ll91bmhhbmRsZWRSZWplY3Rpb25GbihlLl92YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yICh2YXIgbCA9IDAsIHMgPSBlLl9kZWZlcnJlZHMubGVuZ3RoOyBsIDwgczsgbCsrKVxuICAgICAgICAgICAgZihlLCBlLl9kZWZlcnJlZHNbbF0pO1xuICAgICAgICAgIGUuX2RlZmVycmVkcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdihlLCBsLCBzKSB7XG4gICAgICAgICAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUgOiBudWxsLCB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2YgbCA9PSBcImZ1bmN0aW9uXCIgPyBsIDogbnVsbCwgdGhpcy5wcm9taXNlID0gcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0KGUsIGwpIHtcbiAgICAgICAgICB2YXIgcyA9ICExO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlKGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgICAgcyB8fCAocyA9ICEwLCBwKGwsIGcpKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgICAgcyB8fCAocyA9ICEwLCB5KGwsIGcpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGcpIHtcbiAgICAgICAgICAgIGlmIChzKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzID0gITAsIHkobCwgZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHUucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgZSk7XG4gICAgICAgIH0sIHUucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihlLCBsKSB7XG4gICAgICAgICAgdmFyIHMgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihiKTtcbiAgICAgICAgICByZXR1cm4gZih0aGlzLCBuZXcgdihlLCBsLCBzKSksIHM7XG4gICAgICAgIH0sIHUucHJvdG90eXBlLmZpbmFsbHkgPSBvLmEsIHUuYWxsID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgdShmdW5jdGlvbihsLCBzKSB7XG4gICAgICAgICAgICBpZiAoIWUgfHwgZS5sZW5ndGggPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UuYWxsIGFjY2VwdHMgYW4gYXJyYXlcIik7XG4gICAgICAgICAgICB2YXIgZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUpO1xuICAgICAgICAgICAgaWYgKGcubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICByZXR1cm4gbChbXSk7XG4gICAgICAgICAgICB2YXIgbSA9IGcubGVuZ3RoO1xuICAgICAgICAgICAgZnVuY3Rpb24gaChULCBDKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKEMgJiYgKHR5cGVvZiBDID09IFwib2JqZWN0XCIgfHwgdHlwZW9mIEMgPT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIFMgPSBDLnRoZW47XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCBTLmNhbGwoQywgZnVuY3Rpb24oTykge1xuICAgICAgICAgICAgICAgICAgICAgIGgoVCwgTyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnW1RdID0gQywgLS1tID09IDAgJiYgbChnKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoTykge1xuICAgICAgICAgICAgICAgIHMoTyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZy5sZW5ndGg7IGsrKylcbiAgICAgICAgICAgICAgaChrLCBnW2tdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdS5yZXNvbHZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBlICYmIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZS5jb25zdHJ1Y3RvciA9PT0gdSA/IGUgOiBuZXcgdShmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICBsKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB1LnJlamVjdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHUoZnVuY3Rpb24obCwgcykge1xuICAgICAgICAgICAgcyhlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdS5yYWNlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgdShmdW5jdGlvbihsLCBzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBnID0gMCwgbSA9IGUubGVuZ3RoOyBnIDwgbTsgZysrKVxuICAgICAgICAgICAgICBlW2ddLnRoZW4obCwgcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHUuX2ltbWVkaWF0ZUZuID0gdHlwZW9mIG4gPT0gXCJmdW5jdGlvblwiICYmIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBuKGUpO1xuICAgICAgICB9IHx8IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBkKGUsIDApO1xuICAgICAgICB9LCB1Ll91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB0eXBlb2YgY29uc29sZSA8IFwidVwiICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKFwiUG9zc2libGUgVW5oYW5kbGVkIFByb21pc2UgUmVqZWN0aW9uOlwiLCBlKTtcbiAgICAgICAgfSwgYy5hID0gdTtcbiAgICAgIH0pLmNhbGwodGhpcywgcig1KS5zZXRJbW1lZGlhdGUpO1xuICAgIH0sIGZ1bmN0aW9uKGksIGMsIHIpIHtcbiAgICAgIGMuYSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gby5yZXNvbHZlKG4oKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIG8ucmVzb2x2ZShuKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gby5yZWplY3QoZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LCBmdW5jdGlvbihpLCBjLCByKSB7XG4gICAgICBmdW5jdGlvbiBuKHQpIHtcbiAgICAgICAgcmV0dXJuIChuID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgZTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gZSAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgZTtcbiAgICAgICAgfSkodCk7XG4gICAgICB9XG4gICAgICByKDQpO1xuICAgICAgdmFyIG8sIGQsIGIsIHUsIGYsIHAsIHksIHcgPSByKDgpLCB2ID0gKGQgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihlLCBsKSB7XG4gICAgICAgICAgdCA9IHUodCksICh0ID0gZih0KSkuYmVmb3JlU2VuZCAmJiB0LmJlZm9yZVNlbmQoKTtcbiAgICAgICAgICB2YXIgcyA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCA/IG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKSA6IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgICAgICAgIHMub3Blbih0Lm1ldGhvZCwgdC51cmwpLCBzLnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsIFwiWE1MSHR0cFJlcXVlc3RcIiksIE9iamVjdC5rZXlzKHQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICB2YXIgaCA9IHQuaGVhZGVyc1ttXTtcbiAgICAgICAgICAgIHMuc2V0UmVxdWVzdEhlYWRlcihtLCBoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZyA9IHQucmF0aW87XG4gICAgICAgICAgcy51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIHZhciBoID0gTWF0aC5yb3VuZChtLmxvYWRlZCAvIG0udG90YWwgKiAxMDApLCBrID0gTWF0aC5jZWlsKGggKiBnIC8gMTAwKTtcbiAgICAgICAgICAgIHQucHJvZ3Jlc3MoTWF0aC5taW4oaywgMTAwKSk7XG4gICAgICAgICAgfSwgITEpLCBzLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICB2YXIgaCA9IE1hdGgucm91bmQobS5sb2FkZWQgLyBtLnRvdGFsICogMTAwKSwgayA9IE1hdGguY2VpbChoICogKDEwMCAtIGcpIC8gMTAwKSArIGc7XG4gICAgICAgICAgICB0LnByb2dyZXNzKE1hdGgubWluKGssIDEwMCkpO1xuICAgICAgICAgIH0sICExKSwgcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgdmFyIG0gPSBzLnJlc3BvbnNlO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG0gPSBKU09OLnBhcnNlKG0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgaCA9IHcucGFyc2VIZWFkZXJzKHMuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLCBrID0geyBib2R5OiBtLCBjb2RlOiBzLnN0YXR1cywgaGVhZGVyczogaCB9O1xuICAgICAgICAgICAgICB5KHMuc3RhdHVzKSA/IGUoaykgOiBsKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHMuc2VuZCh0LmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGIgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0Lm1ldGhvZCA9IFwiUE9TVFwiLCBkKHQpO1xuICAgICAgfSwgdSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIGlmICh0LnVybCAmJiB0eXBlb2YgdC51cmwgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVcmwgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgaWYgKHQudXJsID0gdC51cmwgfHwgXCJcIiwgdC5tZXRob2QgJiYgdHlwZW9mIHQubWV0aG9kICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG1ldGhvZGAgbXVzdCBiZSBhIHN0cmluZyBvciBudWxsXCIpO1xuICAgICAgICBpZiAodC5tZXRob2QgPSB0Lm1ldGhvZCA/IHQubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBcIkdFVFwiLCB0LmhlYWRlcnMgJiYgbih0LmhlYWRlcnMpICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBoZWFkZXJzYCBtdXN0IGJlIGFuIG9iamVjdCBvciBudWxsXCIpO1xuICAgICAgICBpZiAodC5oZWFkZXJzID0gdC5oZWFkZXJzIHx8IHt9LCB0LnR5cGUgJiYgKHR5cGVvZiB0LnR5cGUgIT0gXCJzdHJpbmdcIiB8fCAhT2JqZWN0LnZhbHVlcyhvKS5pbmNsdWRlcyh0LnR5cGUpKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdHlwZWAgbXVzdCBiZSB0YWtlbiBmcm9tIG1vZHVsZSdzIMKrY29udGVudFR5cGXCuyBsaWJyYXJ5XCIpO1xuICAgICAgICBpZiAodC5wcm9ncmVzcyAmJiB0eXBlb2YgdC5wcm9ncmVzcyAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHByb2dyZXNzYCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgbnVsbFwiKTtcbiAgICAgICAgaWYgKHQucHJvZ3Jlc3MgPSB0LnByb2dyZXNzIHx8IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgfSwgdC5iZWZvcmVTZW5kID0gdC5iZWZvcmVTZW5kIHx8IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgfSwgdC5yYXRpbyAmJiB0eXBlb2YgdC5yYXRpbyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImByYXRpb2AgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgaWYgKHQucmF0aW8gPCAwIHx8IHQucmF0aW8gPiAxMDApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHJhdGlvYCBtdXN0IGJlIGluIGEgMC0xMDAgaW50ZXJ2YWxcIik7XG4gICAgICAgIGlmICh0LnJhdGlvID0gdC5yYXRpbyB8fCA5MCwgdC5hY2NlcHQgJiYgdHlwZW9mIHQuYWNjZXB0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGFjY2VwdGAgbXVzdCBiZSBhIHN0cmluZyB3aXRoIGEgbGlzdCBvZiBhbGxvd2VkIG1pbWUtdHlwZXNcIik7XG4gICAgICAgIGlmICh0LmFjY2VwdCA9IHQuYWNjZXB0IHx8IFwiKi8qXCIsIHQubXVsdGlwbGUgJiYgdHlwZW9mIHQubXVsdGlwbGUgIT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG11bHRpcGxlYCBtdXN0IGJlIGEgdHJ1ZSBvciBmYWxzZVwiKTtcbiAgICAgICAgaWYgKHQubXVsdGlwbGUgPSB0Lm11bHRpcGxlIHx8ICExLCB0LmZpZWxkTmFtZSAmJiB0eXBlb2YgdC5maWVsZE5hbWUgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZmllbGROYW1lYCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICByZXR1cm4gdC5maWVsZE5hbWUgPSB0LmZpZWxkTmFtZSB8fCBcImZpbGVzXCIsIHQ7XG4gICAgICB9LCBmID0gZnVuY3Rpb24odCkge1xuICAgICAgICBzd2l0Y2ggKHQubWV0aG9kKSB7XG4gICAgICAgICAgY2FzZSBcIkdFVFwiOlxuICAgICAgICAgICAgdmFyIGUgPSBwKHQuZGF0YSwgby5VUkxFTkNPREVEKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0LmRhdGEsIHQudXJsID0gL1xcPy8udGVzdCh0LnVybCkgPyB0LnVybCArIFwiJlwiICsgZSA6IHQudXJsICsgXCI/XCIgKyBlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlBPU1RcIjpcbiAgICAgICAgICBjYXNlIFwiUFVUXCI6XG4gICAgICAgICAgY2FzZSBcIkRFTEVURVwiOlxuICAgICAgICAgIGNhc2UgXCJVUERBVEVcIjpcbiAgICAgICAgICAgIHZhciBsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fSkudHlwZSB8fCBvLkpTT047XG4gICAgICAgICAgICB9KHQpO1xuICAgICAgICAgICAgKHcuaXNGb3JtRGF0YSh0LmRhdGEpIHx8IHcuaXNGb3JtRWxlbWVudCh0LmRhdGEpKSAmJiAobCA9IG8uRk9STSksIHQuZGF0YSA9IHAodC5kYXRhLCBsKSwgbCAhPT0gdi5jb250ZW50VHlwZS5GT1JNICYmICh0LmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sIHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKSB7XG4gICAgICAgICAgY2FzZSBvLlVSTEVOQ09ERUQ6XG4gICAgICAgICAgICByZXR1cm4gdy51cmxFbmNvZGUodCk7XG4gICAgICAgICAgY2FzZSBvLkpTT046XG4gICAgICAgICAgICByZXR1cm4gdy5qc29uRW5jb2RlKHQpO1xuICAgICAgICAgIGNhc2Ugby5GT1JNOlxuICAgICAgICAgICAgcmV0dXJuIHcuZm9ybUVuY29kZSh0KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH1cbiAgICAgIH0sIHkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDIwMCAmJiB0IDwgMzAwO1xuICAgICAgfSwgeyBjb250ZW50VHlwZTogbyA9IHsgVVJMRU5DT0RFRDogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9dXRmLThcIiwgRk9STTogXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsIEpTT046IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiIH0sIHJlcXVlc3Q6IGQsIGdldDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdC5tZXRob2QgPSBcIkdFVFwiLCBkKHQpO1xuICAgICAgfSwgcG9zdDogYiwgdHJhbnNwb3J0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0ID0gdSh0KSwgdy5zZWxlY3RGaWxlcyh0KS50aGVuKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBsID0gbmV3IEZvcm1EYXRhKCksIHMgPSAwOyBzIDwgZS5sZW5ndGg7IHMrKylcbiAgICAgICAgICAgIGwuYXBwZW5kKHQuZmllbGROYW1lLCBlW3NdLCBlW3NdLm5hbWUpO1xuICAgICAgICAgIHcuaXNPYmplY3QodC5kYXRhKSAmJiBPYmplY3Qua2V5cyh0LmRhdGEpLmZvckVhY2goZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgdmFyIGggPSB0LmRhdGFbbV07XG4gICAgICAgICAgICBsLmFwcGVuZChtLCBoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZyA9IHQuYmVmb3JlU2VuZDtcbiAgICAgICAgICByZXR1cm4gdC5iZWZvcmVTZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZyhlKTtcbiAgICAgICAgICB9LCB0LmRhdGEgPSBsLCBiKHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIHNlbGVjdEZpbGVzOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBkZWxldGUgKHQgPSB1KHQpKS5iZWZvcmVTZW5kLCB3LnNlbGVjdEZpbGVzKHQpO1xuICAgICAgfSB9KTtcbiAgICAgIGkuZXhwb3J0cyA9IHY7XG4gICAgfSwgZnVuY3Rpb24oaSwgYywgcikge1xuICAgICAgci5yKGMpO1xuICAgICAgdmFyIG4gPSByKDEpO1xuICAgICAgd2luZG93LlByb21pc2UgPSB3aW5kb3cuUHJvbWlzZSB8fCBuLmE7XG4gICAgfSwgZnVuY3Rpb24oaSwgYywgcikge1xuICAgICAgKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIG8gPSBuICE9PSB2b2lkIDAgJiYgbiB8fCB0eXBlb2Ygc2VsZiA8IFwidVwiICYmIHNlbGYgfHwgd2luZG93LCBkID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuICAgICAgICBmdW5jdGlvbiBiKHUsIGYpIHtcbiAgICAgICAgICB0aGlzLl9pZCA9IHUsIHRoaXMuX2NsZWFyRm4gPSBmO1xuICAgICAgICB9XG4gICAgICAgIGMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgYihkLmNhbGwoc2V0VGltZW91dCwgbywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbiAgICAgICAgfSwgYy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgYihkLmNhbGwoc2V0SW50ZXJ2YWwsIG8sIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xuICAgICAgICB9LCBjLmNsZWFyVGltZW91dCA9IGMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICB1ICYmIHUuY2xvc2UoKTtcbiAgICAgICAgfSwgYi5wcm90b3R5cGUudW5yZWYgPSBiLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgfSwgYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9jbGVhckZuLmNhbGwobywgdGhpcy5faWQpO1xuICAgICAgICB9LCBjLmVucm9sbCA9IGZ1bmN0aW9uKHUsIGYpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodS5faWRsZVRpbWVvdXRJZCksIHUuX2lkbGVUaW1lb3V0ID0gZjtcbiAgICAgICAgfSwgYy51bmVucm9sbCA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodS5faWRsZVRpbWVvdXRJZCksIHUuX2lkbGVUaW1lb3V0ID0gLTE7XG4gICAgICAgIH0sIGMuX3VucmVmQWN0aXZlID0gYy5hY3RpdmUgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHUuX2lkbGVUaW1lb3V0SWQpO1xuICAgICAgICAgIHZhciBmID0gdS5faWRsZVRpbWVvdXQ7XG4gICAgICAgICAgZiA+PSAwICYmICh1Ll9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHUuX29uVGltZW91dCAmJiB1Ll9vblRpbWVvdXQoKTtcbiAgICAgICAgICB9LCBmKSk7XG4gICAgICAgIH0sIHIoNiksIGMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNlbGYgPCBcInVcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSB8fCBuICE9PSB2b2lkIDAgJiYgbi5zZXRJbW1lZGlhdGUgfHwgdGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSwgYy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBzZWxmIDwgXCJ1XCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSB8fCBuICE9PSB2b2lkIDAgJiYgbi5jbGVhckltbWVkaWF0ZSB8fCB0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGU7XG4gICAgICB9KS5jYWxsKHRoaXMsIHIoMCkpO1xuICAgIH0sIGZ1bmN0aW9uKGksIGMsIHIpIHtcbiAgICAgIChmdW5jdGlvbihuLCBvKSB7XG4gICAgICAgIChmdW5jdGlvbihkLCBiKSB7XG4gICAgICAgICAgaWYgKCFkLnNldEltbWVkaWF0ZSkge1xuICAgICAgICAgICAgdmFyIHUsIGYsIHAsIHksIHcsIHYgPSAxLCB0ID0ge30sIGUgPSAhMSwgbCA9IGQuZG9jdW1lbnQsIHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGQpO1xuICAgICAgICAgICAgcyA9IHMgJiYgcy5zZXRUaW1lb3V0ID8gcyA6IGQsIHt9LnRvU3RyaW5nLmNhbGwoZC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgPyB1ID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICBvLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG0oaCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoZC5wb3N0TWVzc2FnZSAmJiAhZC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSAhMCwgayA9IGQub25tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHJldHVybiBkLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaCA9ICExO1xuICAgICAgICAgICAgICAgIH0sIGQucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpLCBkLm9ubWVzc2FnZSA9IGssIGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKSA/ICh5ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCIsIHcgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgIGguc291cmNlID09PSBkICYmIHR5cGVvZiBoLmRhdGEgPT0gXCJzdHJpbmdcIiAmJiBoLmRhdGEuaW5kZXhPZih5KSA9PT0gMCAmJiBtKCtoLmRhdGEuc2xpY2UoeS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH0sIGQuYWRkRXZlbnRMaXN0ZW5lciA/IGQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdywgITEpIDogZC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCB3KSwgdSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgZC5wb3N0TWVzc2FnZSh5ICsgaCwgXCIqXCIpO1xuICAgICAgICAgICAgfSkgOiBkLk1lc3NhZ2VDaGFubmVsID8gKChwID0gbmV3IE1lc3NhZ2VDaGFubmVsKCkpLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgbShoLmRhdGEpO1xuICAgICAgICAgICAgfSwgdSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgcC5wb3J0Mi5wb3N0TWVzc2FnZShoKTtcbiAgICAgICAgICAgIH0pIDogbCAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGwuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSA/IChmID0gbC5kb2N1bWVudEVsZW1lbnQsIHUgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gbC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICBrLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG0oaCksIGsub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbCwgZi5yZW1vdmVDaGlsZChrKSwgayA9IG51bGw7XG4gICAgICAgICAgICAgIH0sIGYuYXBwZW5kQ2hpbGQoayk7XG4gICAgICAgICAgICB9KSA6IHUgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQobSwgMCwgaCk7XG4gICAgICAgICAgICB9LCBzLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgdHlwZW9mIGggIT0gXCJmdW5jdGlvblwiICYmIChoID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBoKSk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGsgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLCBUID0gMDsgVCA8IGsubGVuZ3RoOyBUKyspXG4gICAgICAgICAgICAgICAga1tUXSA9IGFyZ3VtZW50c1tUICsgMV07XG4gICAgICAgICAgICAgIHZhciBDID0geyBjYWxsYmFjazogaCwgYXJnczogayB9O1xuICAgICAgICAgICAgICByZXR1cm4gdFt2XSA9IEMsIHUodiksIHYrKztcbiAgICAgICAgICAgIH0sIHMuY2xlYXJJbW1lZGlhdGUgPSBnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBnKGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0W2hdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBtKGgpIHtcbiAgICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KG0sIDAsIGgpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBrID0gdFtoXTtcbiAgICAgICAgICAgICAgaWYgKGspIHtcbiAgICAgICAgICAgICAgICBlID0gITA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIChmdW5jdGlvbihUKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBDID0gVC5jYWxsYmFjaywgUyA9IFQuYXJncztcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIEMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIEMoU1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBDKFNbMF0sIFNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgQyhTWzBdLCBTWzFdLCBTWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBDLmFwcGx5KGIsIFMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KShrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgZyhoKSwgZSA9ICExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkodHlwZW9mIHNlbGYgPiBcInVcIiA/IG4gPT09IHZvaWQgMCA/IHRoaXMgOiBuIDogc2VsZik7XG4gICAgICB9KS5jYWxsKHRoaXMsIHIoMCksIHIoNykpO1xuICAgIH0sIGZ1bmN0aW9uKGksIGMpIHtcbiAgICAgIHZhciByLCBuLCBvID0gaS5leHBvcnRzID0ge307XG4gICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdShzKSB7XG4gICAgICAgIGlmIChyID09PSBzZXRUaW1lb3V0KVxuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHMsIDApO1xuICAgICAgICBpZiAoKHIgPT09IGQgfHwgIXIpICYmIHNldFRpbWVvdXQpXG4gICAgICAgICAgcmV0dXJuIHIgPSBzZXRUaW1lb3V0LCBzZXRUaW1lb3V0KHMsIDApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByKHMsIDApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHIuY2FsbChudWxsLCBzLCAwKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiByLmNhbGwodGhpcywgcywgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgciA9IHR5cGVvZiBzZXRUaW1lb3V0ID09IFwiZnVuY3Rpb25cIiA/IHNldFRpbWVvdXQgOiBkO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByID0gZDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIG4gPSB0eXBlb2YgY2xlYXJUaW1lb3V0ID09IFwiZnVuY3Rpb25cIiA/IGNsZWFyVGltZW91dCA6IGI7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIG4gPSBiO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgICAgdmFyIGYsIHAgPSBbXSwgeSA9ICExLCB3ID0gLTE7XG4gICAgICBmdW5jdGlvbiB2KCkge1xuICAgICAgICB5ICYmIGYgJiYgKHkgPSAhMSwgZi5sZW5ndGggPyBwID0gZi5jb25jYXQocCkgOiB3ID0gLTEsIHAubGVuZ3RoICYmIHQoKSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB0KCkge1xuICAgICAgICBpZiAoIXkpIHtcbiAgICAgICAgICB2YXIgcyA9IHUodik7XG4gICAgICAgICAgeSA9ICEwO1xuICAgICAgICAgIGZvciAodmFyIGcgPSBwLmxlbmd0aDsgZzsgKSB7XG4gICAgICAgICAgICBmb3IgKGYgPSBwLCBwID0gW107ICsrdyA8IGc7IClcbiAgICAgICAgICAgICAgZiAmJiBmW3ddLnJ1bigpO1xuICAgICAgICAgICAgdyA9IC0xLCBnID0gcC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGYgPSBudWxsLCB5ID0gITEsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIGlmIChuID09PSBjbGVhclRpbWVvdXQpXG4gICAgICAgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobSk7XG4gICAgICAgICAgICBpZiAoKG4gPT09IGIgfHwgIW4pICYmIGNsZWFyVGltZW91dClcbiAgICAgICAgICAgICAgcmV0dXJuIG4gPSBjbGVhclRpbWVvdXQsIGNsZWFyVGltZW91dChtKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG4obSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi5jYWxsKG51bGwsIG0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi5jYWxsKHRoaXMsIG0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfShzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZShzLCBnKSB7XG4gICAgICAgIHRoaXMuZnVuID0gcywgdGhpcy5hcnJheSA9IGc7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsKCkge1xuICAgICAgfVxuICAgICAgby5uZXh0VGljayA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIGcgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgZm9yICh2YXIgbSA9IDE7IG0gPCBhcmd1bWVudHMubGVuZ3RoOyBtKyspXG4gICAgICAgICAgICBnW20gLSAxXSA9IGFyZ3VtZW50c1ttXTtcbiAgICAgICAgcC5wdXNoKG5ldyBlKHMsIGcpKSwgcC5sZW5ndGggIT09IDEgfHwgeSB8fCB1KHQpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xuICAgICAgfSwgby50aXRsZSA9IFwiYnJvd3NlclwiLCBvLmJyb3dzZXIgPSAhMCwgby5lbnYgPSB7fSwgby5hcmd2ID0gW10sIG8udmVyc2lvbiA9IFwiXCIsIG8udmVyc2lvbnMgPSB7fSwgby5vbiA9IGwsIG8uYWRkTGlzdGVuZXIgPSBsLCBvLm9uY2UgPSBsLCBvLm9mZiA9IGwsIG8ucmVtb3ZlTGlzdGVuZXIgPSBsLCBvLnJlbW92ZUFsbExpc3RlbmVycyA9IGwsIG8uZW1pdCA9IGwsIG8ucHJlcGVuZExpc3RlbmVyID0gbCwgby5wcmVwZW5kT25jZUxpc3RlbmVyID0gbCwgby5saXN0ZW5lcnMgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sIG8uYmluZGluZyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICB9LCBvLmN3ZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCIvXCI7XG4gICAgICB9LCBvLmNoZGlyID0gZnVuY3Rpb24ocykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICB9LCBvLnVtYXNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfTtcbiAgICB9LCBmdW5jdGlvbihpLCBjLCByKSB7XG4gICAgICBmdW5jdGlvbiBuKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBiLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgdmFyIGYgPSBiW3VdO1xuICAgICAgICAgIGYuZW51bWVyYWJsZSA9IGYuZW51bWVyYWJsZSB8fCAhMSwgZi5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIGYgJiYgKGYud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkLCBmLmtleSwgZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvID0gcig5KTtcbiAgICAgIGkuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICAgIChmdW5jdGlvbihwLCB5KSB7XG4gICAgICAgICAgICBpZiAoIShwIGluc3RhbmNlb2YgeSkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgfSkodGhpcywgZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIsIHUsIGY7XG4gICAgICAgIHJldHVybiBiID0gZCwgZiA9IFt7IGtleTogXCJ1cmxFbmNvZGVcIiwgdmFsdWU6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gbyhwKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJqc29uRW5jb2RlXCIsIHZhbHVlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHApO1xuICAgICAgICB9IH0sIHsga2V5OiBcImZvcm1FbmNvZGVcIiwgdmFsdWU6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0Zvcm1EYXRhKHApKVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgaWYgKHRoaXMuaXNGb3JtRWxlbWVudChwKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybURhdGEocCk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNPYmplY3QocCkpIHtcbiAgICAgICAgICAgIHZhciB5ID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocCkuZm9yRWFjaChmdW5jdGlvbih3KSB7XG4gICAgICAgICAgICAgIHZhciB2ID0gcFt3XTtcbiAgICAgICAgICAgICAgeS5hcHBlbmQodywgdik7XG4gICAgICAgICAgICB9KSwgeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGRhdGFgIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgT2JqZWN0LCBGb3JtRGF0YSBvciA8Rk9STT4gSFRNTEVsZW1lbnRcIik7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiaXNPYmplY3RcIiwgdmFsdWU6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHApID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICAgICAgICB9IH0sIHsga2V5OiBcImlzRm9ybURhdGFcIiwgdmFsdWU6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gcCBpbnN0YW5jZW9mIEZvcm1EYXRhO1xuICAgICAgICB9IH0sIHsga2V5OiBcImlzRm9ybUVsZW1lbnRcIiwgdmFsdWU6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gcCBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudDtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzZWxlY3RGaWxlc1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih5LCB3KSB7XG4gICAgICAgICAgICB2YXIgdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJJTlBVVFwiKTtcbiAgICAgICAgICAgIHYudHlwZSA9IFwiZmlsZVwiLCBwLm11bHRpcGxlICYmIHYuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgXCJtdWx0aXBsZVwiKSwgcC5hY2NlcHQgJiYgdi5zZXRBdHRyaWJ1dGUoXCJhY2NlcHRcIiwgcC5hY2NlcHQpLCB2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh2KSwgdi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSB0LnRhcmdldC5maWxlcztcbiAgICAgICAgICAgICAgeShlKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh2KTtcbiAgICAgICAgICAgIH0sICExKSwgdi5jbGljaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IH0sIHsga2V5OiBcInBhcnNlSGVhZGVyc1wiLCB2YWx1ZTogZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHZhciB5ID0gcC50cmltKCkuc3BsaXQoL1tcXHJcXG5dKy8pLCB3ID0ge307XG4gICAgICAgICAgcmV0dXJuIHkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICB2YXIgdCA9IHYuc3BsaXQoXCI6IFwiKSwgZSA9IHQuc2hpZnQoKSwgbCA9IHQuam9pbihcIjogXCIpO1xuICAgICAgICAgICAgZSAmJiAod1tlXSA9IGwpO1xuICAgICAgICAgIH0pLCB3O1xuICAgICAgICB9IH1dLCAodSA9IG51bGwpICYmIG4oYi5wcm90b3R5cGUsIHUpLCBmICYmIG4oYiwgZiksIGQ7XG4gICAgICB9KCk7XG4gICAgfSwgZnVuY3Rpb24oaSwgYykge1xuICAgICAgdmFyIHIgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobykucmVwbGFjZSgvWyEnKCkqXS9nLCBlc2NhcGUpLnJlcGxhY2UoLyUyMC9nLCBcIitcIik7XG4gICAgICB9LCBuID0gZnVuY3Rpb24obywgZCwgYiwgdSkge1xuICAgICAgICByZXR1cm4gZCA9IGQgfHwgbnVsbCwgYiA9IGIgfHwgXCImXCIsIHUgPSB1IHx8IG51bGwsIG8gPyBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgZm9yICh2YXIgcCA9IG5ldyBBcnJheSgpLCB5ID0gMDsgeSA8IGYubGVuZ3RoOyB5KyspXG4gICAgICAgICAgICBmW3ldICYmIHAucHVzaChmW3ldKTtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfShPYmplY3Qua2V5cyhvKS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICAgIHZhciBwLCB5LCB3ID0gZjtcbiAgICAgICAgICBpZiAodSAmJiAodyA9IHUgKyBcIltcIiArIHcgKyBcIl1cIiksIHR5cGVvZiBvW2ZdID09IFwib2JqZWN0XCIgJiYgb1tmXSAhPT0gbnVsbClcbiAgICAgICAgICAgIHAgPSBuKG9bZl0sIG51bGwsIGIsIHcpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZCAmJiAoeSA9IHcsIHcgPSAhaXNOYU4ocGFyc2VGbG9hdCh5KSkgJiYgaXNGaW5pdGUoeSkgPyBkICsgTnVtYmVyKHcpIDogdyk7XG4gICAgICAgICAgICB2YXIgdiA9IG9bZl07XG4gICAgICAgICAgICB2ID0gKHYgPSAodiA9ICh2ID0gdiA9PT0gITAgPyBcIjFcIiA6IHYpID09PSAhMSA/IFwiMFwiIDogdikgPT09IDAgPyBcIjBcIiA6IHYpIHx8IFwiXCIsIHAgPSByKHcpICsgXCI9XCIgKyByKHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSkpLmpvaW4oYikucmVwbGFjZSgvWyEnKCkqXS9nLCBcIlwiKSA6IFwiXCI7XG4gICAgICB9O1xuICAgICAgaS5leHBvcnRzID0gbjtcbiAgICB9XSk7XG4gIH0pO1xufSkoSSk7XG52YXIgVSA9IEkuZXhwb3J0cztcbmNvbnN0IEYgPSAvKiBAX19QVVJFX18gKi8geChVKTtcbmZ1bmN0aW9uIF8oRSkge1xuICByZXR1cm4gRSAmJiB0eXBlb2YgRS50aGVuID09IFwiZnVuY3Rpb25cIjtcbn1cbmNsYXNzIEIge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIHVwbG9hZGVyIG1vZHVsZSBwYXJhbXNcbiAgICogQHBhcmFtIHtJbWFnZUNvbmZpZ30gcGFyYW1zLmNvbmZpZyAtIGltYWdlIHRvb2wgY29uZmlnXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtcy5vblVwbG9hZCAtIG9uZSBjYWxsYmFjayBmb3IgYWxsIHVwbG9hZGluZyAoZmlsZSwgdXJsLCBkLW4tZCwgcGFzdGluZylcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyYW1zLm9uRXJyb3IgLSBjYWxsYmFjayBmb3IgdXBsb2FkaW5nIGVycm9yc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGEsIG9uVXBsb2FkOiBpLCBvbkVycm9yOiBjIH0pIHtcbiAgICB0aGlzLmNvbmZpZyA9IGEsIHRoaXMub25VcGxvYWQgPSBpLCB0aGlzLm9uRXJyb3IgPSBjO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2tzIG9uIHRoZSB1cGxvYWQgZmlsZSBidXR0b25cbiAgICogRmlyZXMgYWpheC50cmFuc3BvcnQoKVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblByZXZpZXcgLSBjYWxsYmFjayBmaXJlZCB3aGVuIHByZXZpZXcgaXMgcmVhZHlcbiAgICovXG4gIHVwbG9hZFNlbGVjdGVkRmlsZSh7IG9uUHJldmlldzogYSB9KSB7XG4gICAgY29uc3QgaSA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgIGNvbnN0IG4gPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgbi5yZWFkQXNEYXRhVVJMKHIpLCBuLm9ubG9hZCA9IChvKSA9PiB7XG4gICAgICAgIGEoby50YXJnZXQucmVzdWx0KTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBsZXQgYztcbiAgICB0aGlzLmNvbmZpZy51cGxvYWRlciAmJiB0eXBlb2YgdGhpcy5jb25maWcudXBsb2FkZXIudXBsb2FkQnlGaWxlID09IFwiZnVuY3Rpb25cIiA/IGMgPSBGLnNlbGVjdEZpbGVzKHsgYWNjZXB0OiB0aGlzLmNvbmZpZy50eXBlcyB9KS50aGVuKChyKSA9PiB7XG4gICAgICBpKHJbMF0pO1xuICAgICAgY29uc3QgbiA9IHRoaXMuY29uZmlnLnVwbG9hZGVyLnVwbG9hZEJ5RmlsZShyWzBdKTtcbiAgICAgIHJldHVybiBfKG4pIHx8IGNvbnNvbGUud2FybihcIkN1c3RvbSB1cGxvYWRlciBtZXRob2QgdXBsb2FkQnlGaWxlIHNob3VsZCByZXR1cm4gYSBQcm9taXNlXCIpLCBuO1xuICAgIH0pIDogYyA9IEYudHJhbnNwb3J0KHtcbiAgICAgIHVybDogdGhpcy5jb25maWcuZW5kcG9pbnRzLmJ5RmlsZSxcbiAgICAgIGRhdGE6IHRoaXMuY29uZmlnLmFkZGl0aW9uYWxSZXF1ZXN0RGF0YSxcbiAgICAgIGFjY2VwdDogdGhpcy5jb25maWcudHlwZXMsXG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5hZGRpdGlvbmFsUmVxdWVzdEhlYWRlcnMsXG4gICAgICBiZWZvcmVTZW5kOiAocikgPT4ge1xuICAgICAgICBpKHJbMF0pO1xuICAgICAgfSxcbiAgICAgIGZpZWxkTmFtZTogdGhpcy5jb25maWcuZmllbGRcbiAgICB9KS50aGVuKChyKSA9PiByLmJvZHkpLCBjLnRoZW4oKHIpID0+IHtcbiAgICAgIHRoaXMub25VcGxvYWQocik7XG4gICAgfSkuY2F0Y2goKHIpID0+IHtcbiAgICAgIHRoaXMub25FcnJvcihyKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGNsaWNrcyBvbiB0aGUgdXBsb2FkIGZpbGUgYnV0dG9uXG4gICAqIEZpcmVzIGFqYXgucG9zdCgpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBpbWFnZSBzb3VyY2UgdXJsXG4gICAqL1xuICB1cGxvYWRCeVVybChhKSB7XG4gICAgbGV0IGk7XG4gICAgdGhpcy5jb25maWcudXBsb2FkZXIgJiYgdHlwZW9mIHRoaXMuY29uZmlnLnVwbG9hZGVyLnVwbG9hZEJ5VXJsID09IFwiZnVuY3Rpb25cIiA/IChpID0gdGhpcy5jb25maWcudXBsb2FkZXIudXBsb2FkQnlVcmwoYSksIF8oaSkgfHwgY29uc29sZS53YXJuKFwiQ3VzdG9tIHVwbG9hZGVyIG1ldGhvZCB1cGxvYWRCeVVybCBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZVwiKSkgOiBpID0gRi5wb3N0KHtcbiAgICAgIHVybDogdGhpcy5jb25maWcuZW5kcG9pbnRzLmJ5VXJsLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHVybDogYVxuICAgICAgfSwgdGhpcy5jb25maWcuYWRkaXRpb25hbFJlcXVlc3REYXRhKSxcbiAgICAgIHR5cGU6IEYuY29udGVudFR5cGUuSlNPTixcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmFkZGl0aW9uYWxSZXF1ZXN0SGVhZGVyc1xuICAgIH0pLnRoZW4oKGMpID0+IGMuYm9keSksIGkudGhlbigoYykgPT4ge1xuICAgICAgdGhpcy5vblVwbG9hZChjKTtcbiAgICB9KS5jYXRjaCgoYykgPT4ge1xuICAgICAgdGhpcy5vbkVycm9yKGMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2tzIG9uIHRoZSB1cGxvYWQgZmlsZSBidXR0b25cbiAgICogRmlyZXMgYWpheC5wb3N0KClcbiAgICpcbiAgICogQHBhcmFtIHtGaWxlfSBmaWxlIC0gZmlsZSBwYXN0ZWQgYnkgZHJhZy1uLWRyb3BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25QcmV2aWV3IC0gZmlsZSBwYXN0ZWQgYnkgZHJhZy1uLWRyb3BcbiAgICovXG4gIHVwbG9hZEJ5RmlsZShhLCB7IG9uUHJldmlldzogaSB9KSB7XG4gICAgY29uc3QgYyA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgYy5yZWFkQXNEYXRhVVJMKGEpLCBjLm9ubG9hZCA9IChuKSA9PiB7XG4gICAgICBpKG4udGFyZ2V0LnJlc3VsdCk7XG4gICAgfTtcbiAgICBsZXQgcjtcbiAgICBpZiAodGhpcy5jb25maWcudXBsb2FkZXIgJiYgdHlwZW9mIHRoaXMuY29uZmlnLnVwbG9hZGVyLnVwbG9hZEJ5RmlsZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gdGhpcy5jb25maWcudXBsb2FkZXIudXBsb2FkQnlGaWxlKGEpLCBfKHIpIHx8IGNvbnNvbGUud2FybihcIkN1c3RvbSB1cGxvYWRlciBtZXRob2QgdXBsb2FkQnlGaWxlIHNob3VsZCByZXR1cm4gYSBQcm9taXNlXCIpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbiA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgbi5hcHBlbmQodGhpcy5jb25maWcuZmllbGQsIGEpLCB0aGlzLmNvbmZpZy5hZGRpdGlvbmFsUmVxdWVzdERhdGEgJiYgT2JqZWN0LmtleXModGhpcy5jb25maWcuYWRkaXRpb25hbFJlcXVlc3REYXRhKS5sZW5ndGggJiYgT2JqZWN0LmVudHJpZXModGhpcy5jb25maWcuYWRkaXRpb25hbFJlcXVlc3REYXRhKS5mb3JFYWNoKChbbywgZF0pID0+IHtcbiAgICAgICAgbi5hcHBlbmQobywgZCk7XG4gICAgICB9KSwgciA9IEYucG9zdCh7XG4gICAgICAgIHVybDogdGhpcy5jb25maWcuZW5kcG9pbnRzLmJ5RmlsZSxcbiAgICAgICAgZGF0YTogbixcbiAgICAgICAgdHlwZTogRi5jb250ZW50VHlwZS5KU09OLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5hZGRpdGlvbmFsUmVxdWVzdEhlYWRlcnNcbiAgICAgIH0pLnRoZW4oKG8pID0+IG8uYm9keSk7XG4gICAgfVxuICAgIHIudGhlbigobikgPT4ge1xuICAgICAgdGhpcy5vblVwbG9hZChuKTtcbiAgICB9KS5jYXRjaCgobikgPT4ge1xuICAgICAgdGhpcy5vbkVycm9yKG4pO1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEltYWdlIFRvb2wgZm9yIHRoZSBFZGl0b3IuanNcbiAqXG4gKiBAYXV0aG9yIENvZGVYIDx0ZWFtQGNvZGV4LnNvPlxuICogQGxpY2Vuc2UgTUlUXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZWRpdG9yLWpzL2ltYWdlfVxuICpcbiAqIFRvIGRldmVsb3BlcnMuXG4gKiBUbyBzaW1wbGlmeSBUb29sIHN0cnVjdHVyZSwgd2Ugc3BsaXQgaXQgdG8gNCBwYXJ0czpcbiAqICAxKSBpbmRleC5qcyDigJQgbWFpbiBUb29sJ3MgaW50ZXJmYWNlLCBwdWJsaWMgQVBJIGFuZCBtZXRob2RzIGZvciB3b3JraW5nIHdpdGggZGF0YVxuICogIDIpIHVwbG9hZGVyLmpzIOKAlCBtb2R1bGUgdGhhdCBoYXMgbWV0aG9kcyBmb3Igc2VuZGluZyBmaWxlcyB2aWEgQUpBWDogZnJvbSBkZXZpY2UsIGJ5IFVSTCBvciBGaWxlIHBhc3RpbmdcbiAqICAzKSB1aS5qcyDigJQgbW9kdWxlIGZvciBVSSBtYW5pcHVsYXRpb25zOiByZW5kZXIsIHNob3dpbmcgcHJlbG9hZGVyLCBldGNcbiAqICA0KSB0dW5lcy5qcyDigJQgd29ya2luZyB3aXRoIEJsb2NrIFR1bmVzOiByZW5kZXIgYnV0dG9ucywgaGFuZGxlIGNsaWNrc1xuICpcbiAqIEZvciBkZWJ1ZyBwdXJwb3NlcyB0aGVyZSBpcyBhIHRlc3Rpbmcgc2VydmVyXG4gKiB0aGF0IGNhbiBzYXZlIHVwbG9hZGVkIGZpbGVzIGFuZCByZXR1cm4gYSBSZXNwb25zZSB7QGxpbmsgVXBsb2FkUmVzcG9uc2VGb3JtYXR9XG4gKlxuICogICAgICAgJCBub2RlIGRldi9zZXJ2ZXIuanNcbiAqXG4gKiBJdCB3aWxsIGV4cG9zZSA4MDA4IHBvcnQsIHNvIHlvdSBjYW4gcGFzcyBodHRwOi8vbG9jYWxob3N0OjgwMDggd2l0aCB0aGUgVG9vbHMgY29uZmlnOlxuICpcbiAqIGltYWdlOiB7XG4gKiAgIGNsYXNzOiBJbWFnZVRvb2wsXG4gKiAgIGNvbmZpZzoge1xuICogICAgIGVuZHBvaW50czoge1xuICogICAgICAgYnlGaWxlOiAnaHR0cDovL2xvY2FsaG9zdDo4MDA4L3VwbG9hZEZpbGUnLFxuICogICAgICAgYnlVcmw6ICdodHRwOi8vbG9jYWxob3N0OjgwMDgvZmV0Y2hVcmwnLFxuICogICAgIH1cbiAqICAgfSxcbiAqIH0sXG4gKi9cbmNsYXNzIFAge1xuICAvKipcbiAgICogTm90aWZ5IGNvcmUgdGhhdCByZWFkLW9ubHkgbW9kZSBpcyBzdXBwb3J0ZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgVG9vbCB0b29sYm94IHNldHRpbmdzXG4gICAqIGljb24gLSBUb29sIGljb24ncyBTVkdcbiAgICogdGl0bGUgLSB0aXRsZSB0byBzaG93IGluIHRvb2xib3hcbiAgICpcbiAgICogQHJldHVybnMge3tpY29uOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBMLFxuICAgICAgdGl0bGU6IFwiSW1hZ2VcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBpbWFnZSB0b29sc1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHR1bmVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwid2l0aEJvcmRlclwiLFxuICAgICAgICBpY29uOiBILFxuICAgICAgICB0aXRsZTogXCJXaXRoIGJvcmRlclwiLFxuICAgICAgICB0b2dnbGU6ICEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcInN0cmV0Y2hlZFwiLFxuICAgICAgICBpY29uOiBELFxuICAgICAgICB0aXRsZTogXCJTdHJldGNoIGltYWdlXCIsXG4gICAgICAgIHRvZ2dsZTogITBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwid2l0aEJhY2tncm91bmRcIixcbiAgICAgICAgaWNvbjogUixcbiAgICAgICAgdGl0bGU6IFwiV2l0aCBiYWNrZ3JvdW5kXCIsXG4gICAgICAgIHRvZ2dsZTogITBcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdG9vbCAtIHRvb2wgcHJvcGVydGllcyBnb3QgZnJvbSBlZGl0b3IuanNcbiAgICogQHBhcmFtIHtJbWFnZVRvb2xEYXRhfSB0b29sLmRhdGEgLSBwcmV2aW91c2x5IHNhdmVkIGRhdGFcbiAgICogQHBhcmFtIHtJbWFnZUNvbmZpZ30gdG9vbC5jb25maWcgLSB1c2VyIGNvbmZpZyBmb3IgVG9vbFxuICAgKiBAcGFyYW0ge29iamVjdH0gdG9vbC5hcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9vbC5yZWFkT25seSAtIHJlYWQtb25seSBtb2RlIGZsYWdcbiAgICogQHBhcmFtIHtCbG9ja0FQSXx7fX0gdG9vbC5ibG9jayAtIGN1cnJlbnQgQmxvY2sgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IGEsIGNvbmZpZzogaSwgYXBpOiBjLCByZWFkT25seTogciwgYmxvY2s6IG4gfSkge1xuICAgIHRoaXMuYXBpID0gYywgdGhpcy5yZWFkT25seSA9IHIsIHRoaXMuYmxvY2sgPSBuLCB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGVuZHBvaW50czogaS5lbmRwb2ludHMgfHwgXCJcIixcbiAgICAgIGFkZGl0aW9uYWxSZXF1ZXN0RGF0YTogaS5hZGRpdGlvbmFsUmVxdWVzdERhdGEgfHwge30sXG4gICAgICBhZGRpdGlvbmFsUmVxdWVzdEhlYWRlcnM6IGkuYWRkaXRpb25hbFJlcXVlc3RIZWFkZXJzIHx8IHt9LFxuICAgICAgZmllbGQ6IGkuZmllbGQgfHwgXCJpbWFnZVwiLFxuICAgICAgdHlwZXM6IGkudHlwZXMgfHwgXCJpbWFnZS8qXCIsXG4gICAgICBjYXB0aW9uUGxhY2Vob2xkZXI6IHRoaXMuYXBpLmkxOG4udChpLmNhcHRpb25QbGFjZWhvbGRlciB8fCBcIkNhcHRpb25cIiksXG4gICAgICBidXR0b25Db250ZW50OiBpLmJ1dHRvbkNvbnRlbnQgfHwgXCJcIixcbiAgICAgIHVwbG9hZGVyOiBpLnVwbG9hZGVyIHx8IHZvaWQgMCxcbiAgICAgIGFjdGlvbnM6IGkuYWN0aW9ucyB8fCBbXVxuICAgIH0sIHRoaXMudXBsb2FkZXIgPSBuZXcgQih7XG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgb25VcGxvYWQ6IChvKSA9PiB0aGlzLm9uVXBsb2FkKG8pLFxuICAgICAgb25FcnJvcjogKG8pID0+IHRoaXMudXBsb2FkaW5nRmFpbGVkKG8pXG4gICAgfSksIHRoaXMudWkgPSBuZXcgaih7XG4gICAgICBhcGk6IGMsXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgb25TZWxlY3RGaWxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudXBsb2FkZXIudXBsb2FkU2VsZWN0ZWRGaWxlKHtcbiAgICAgICAgICBvblByZXZpZXc6IChvKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVpLnNob3dQcmVsb2FkZXIobyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZWFkT25seTogclxuICAgIH0pLCB0aGlzLl9kYXRhID0ge30sIHRoaXMuZGF0YSA9IGE7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgQmxvY2sgY29udGVudFxuICAgKlxuICAgKiBAcHVibGljXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy51aS5yZW5kZXIodGhpcy5kYXRhKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgZGF0YTogY2hlY2sgaWYgSW1hZ2UgZXhpc3RzXG4gICAqXG4gICAqIEBwYXJhbSB7SW1hZ2VUb29sRGF0YX0gc2F2ZWREYXRhIOKAlCBkYXRhIHJlY2VpdmVkIGFmdGVyIHNhdmluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgc2F2ZWQgZGF0YSBpcyBub3QgY29ycmVjdCwgb3RoZXJ3aXNlIHRydWVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdmFsaWRhdGUoYSkge1xuICAgIHJldHVybiBhLmZpbGUgJiYgYS5maWxlLnVybDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIEJsb2NrIGRhdGFcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKlxuICAgKiBAcmV0dXJucyB7SW1hZ2VUb29sRGF0YX1cbiAgICovXG4gIHNhdmUoKSB7XG4gICAgY29uc3QgYSA9IHRoaXMudWkubm9kZXMuY2FwdGlvbjtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5jYXB0aW9uID0gYS5pbm5lckhUTUwsIHRoaXMuZGF0YTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjb25maWd1cmF0aW9uIGZvciBibG9jayB0dW5lczogYWRkIGJhY2tncm91bmQsIGFkZCBib3JkZXIsIHN0cmV0Y2ggaW1hZ2VcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICByZW5kZXJTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gUC50dW5lcy5jb25jYXQodGhpcy5jb25maWcuYWN0aW9ucykubWFwKChpKSA9PiAoe1xuICAgICAgaWNvbjogaS5pY29uLFxuICAgICAgbGFiZWw6IHRoaXMuYXBpLmkxOG4udChpLnRpdGxlKSxcbiAgICAgIG5hbWU6IGkubmFtZSxcbiAgICAgIHRvZ2dsZTogaS50b2dnbGUsXG4gICAgICBpc0FjdGl2ZTogdGhpcy5kYXRhW2kubmFtZV0sXG4gICAgICBvbkFjdGl2YXRlOiAoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaS5hY3Rpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaS5hY3Rpb24oaS5uYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50dW5lVG9nZ2xlZChpLm5hbWUpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogRmlyZXMgYWZ0ZXIgY2xpY2tzIG9uIHRoZSBUb29sYm94IEltYWdlIEljb25cbiAgICogSW5pdGlhdGVzIGNsaWNrIG9uIHRoZSBTZWxlY3QgRmlsZSBidXR0b25cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYXBwZW5kQ2FsbGJhY2soKSB7XG4gICAgdGhpcy51aS5ub2Rlcy5maWxlQnV0dG9uLmNsaWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZnkgcGFzdGUgc3Vic3RpdHV0ZXNcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2NvZGV4LXRlYW0vZWRpdG9yLmpzL2Jsb2IvbWFzdGVyL2RvY3MvdG9vbHMubWQjcGFzdGUtaGFuZGxpbmd9XG4gICAqIEByZXR1cm5zIHt7dGFnczogc3RyaW5nW10sIHBhdHRlcm5zOiBvYmplY3Q8c3RyaW5nLCBSZWdFeHA+LCBmaWxlczoge2V4dGVuc2lvbnM6IHN0cmluZ1tdLCBtaW1lVHlwZXM6IHN0cmluZ1tdfX19XG4gICAqL1xuICBzdGF0aWMgZ2V0IHBhc3RlQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFBhc3RlIEhUTUwgaW50byBFZGl0b3JcbiAgICAgICAqL1xuICAgICAgdGFnczogW1xuICAgICAgICB7XG4gICAgICAgICAgaW1nOiB7IHNyYzogITAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgLyoqXG4gICAgICAgKiBQYXN0ZSBVUkwgb2YgaW1hZ2UgaW50byB0aGUgRWRpdG9yXG4gICAgICAgKi9cbiAgICAgIHBhdHRlcm5zOiB7XG4gICAgICAgIGltYWdlOiAvaHR0cHM/OlxcL1xcL1xcUytcXC4oZ2lmfGpwZT9nfHRpZmZ8cG5nfHN2Z3x3ZWJwKShcXD9bYS16MC05PV0qKT8kL2lcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIERyYWcgbiBkcm9wIGZpbGUgZnJvbSBpbnRvIHRoZSBFZGl0b3JcbiAgICAgICAqL1xuICAgICAgZmlsZXM6IHtcbiAgICAgICAgbWltZVR5cGVzOiBbXCJpbWFnZS8qXCJdXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmeSBwYXN0ZSBoYW5kbGVyc1xuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RleC10ZWFtL2VkaXRvci5qcy9ibG9iL21hc3Rlci9kb2NzL3Rvb2xzLm1kI3Bhc3RlLWhhbmRsaW5nfVxuICAgKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudCAtIGVkaXRvci5qcyBjdXN0b20gcGFzdGUgZXZlbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2NvZGV4LXRlYW0vZWRpdG9yLmpzL2Jsb2IvbWFzdGVyL3R5cGVzL3Rvb2xzL3Bhc3RlLWV2ZW50cy5kLnRzfVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGFzeW5jIG9uUGFzdGUoYSkge1xuICAgIHN3aXRjaCAoYS50eXBlKSB7XG4gICAgICBjYXNlIFwidGFnXCI6IHtcbiAgICAgICAgY29uc3QgaSA9IGEuZGV0YWlsLmRhdGE7XG4gICAgICAgIGlmICgvXmJsb2I6Ly50ZXN0KGkuc3JjKSkge1xuICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCAoYXdhaXQgZmV0Y2goaS5zcmMpKS5ibG9iKCk7XG4gICAgICAgICAgdGhpcy51cGxvYWRGaWxlKHIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBsb2FkVXJsKGkuc3JjKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwicGF0dGVyblwiOiB7XG4gICAgICAgIGNvbnN0IGkgPSBhLmRldGFpbC5kYXRhO1xuICAgICAgICB0aGlzLnVwbG9hZFVybChpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgIGNvbnN0IGkgPSBhLmRldGFpbC5maWxlO1xuICAgICAgICB0aGlzLnVwbG9hZEZpbGUoaSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUHJpdmF0ZSBtZXRob2RzXG4gICAqIMy/zL8gzL/MvyDMv8y/IMy/J8y/J1xczLXNh8y/zL9cXNC3PSAoIOKWgCDNnM2eypbiloApID3OtS/Mtc2HzL/Mvy/igJnMv+KAmcy/IMy/IMy/zL8gzL/MvyDMv8y/XG4gICAqL1xuICAvKipcbiAgICogU3RvcmVzIGFsbCBUb29sJ3MgZGF0YVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0ltYWdlVG9vbERhdGF9IGRhdGEgLSBkYXRhIGluIEltYWdlIFRvb2wgZm9ybWF0XG4gICAqL1xuICBzZXQgZGF0YShhKSB7XG4gICAgdGhpcy5pbWFnZSA9IGEuZmlsZSwgdGhpcy5fZGF0YS5jYXB0aW9uID0gYS5jYXB0aW9uIHx8IFwiXCIsIHRoaXMudWkuZmlsbENhcHRpb24odGhpcy5fZGF0YS5jYXB0aW9uKSwgUC50dW5lcy5mb3JFYWNoKCh7IG5hbWU6IGkgfSkgPT4ge1xuICAgICAgY29uc3QgYyA9IHR5cGVvZiBhW2ldIDwgXCJ1XCIgPyBhW2ldID09PSAhMCB8fCBhW2ldID09PSBcInRydWVcIiA6ICExO1xuICAgICAgdGhpcy5zZXRUdW5lKGksIGMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbCBkYXRhXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtJbWFnZVRvb2xEYXRhfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBuZXcgaW1hZ2UgZmlsZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZmlsZSAtIHVwbG9hZGVkIGZpbGUgZGF0YVxuICAgKi9cbiAgc2V0IGltYWdlKGEpIHtcbiAgICB0aGlzLl9kYXRhLmZpbGUgPSBhIHx8IHt9LCBhICYmIGEudXJsICYmIHRoaXMudWkuZmlsbEltYWdlKGEudXJsKTtcbiAgfVxuICAvKipcbiAgICogRmlsZSB1cGxvYWRpbmcgY2FsbGJhY2tcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtVcGxvYWRSZXNwb25zZUZvcm1hdH0gcmVzcG9uc2UgLSB1cGxvYWRpbmcgc2VydmVyIHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgb25VcGxvYWQoYSkge1xuICAgIGEuc3VjY2VzcyAmJiBhLmZpbGUgPyB0aGlzLmltYWdlID0gYS5maWxlIDogdGhpcy51cGxvYWRpbmdGYWlsZWQoXCJpbmNvcnJlY3QgcmVzcG9uc2U6IFwiICsgSlNPTi5zdHJpbmdpZnkoYSkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgdXBsb2FkZXIgZXJyb3JzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvclRleHQgLSB1cGxvYWRpbmcgZXJyb3IgdGV4dFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHVwbG9hZGluZ0ZhaWxlZChhKSB7XG4gICAgY29uc29sZS5sb2coXCJJbWFnZSBUb29sOiB1cGxvYWRpbmcgZmFpbGVkIGJlY2F1c2Ugb2ZcIiwgYSksIHRoaXMuYXBpLm5vdGlmaWVyLnNob3coe1xuICAgICAgbWVzc2FnZTogdGhpcy5hcGkuaTE4bi50KFwiQ291bGRu4oCZdCB1cGxvYWQgaW1hZ2UuIFBsZWFzZSB0cnkgYW5vdGhlci5cIiksXG4gICAgICBzdHlsZTogXCJlcnJvclwiXG4gICAgfSksIHRoaXMudWkuaGlkZVByZWxvYWRlcigpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIEJsb2NrIFR1bmUgaXMgYWN0aXZhdGVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0dW5lTmFtZSAtIHR1bmUgdGhhdCBoYXMgYmVlbiBjbGlja2VkXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgdHVuZVRvZ2dsZWQoYSkge1xuICAgIHRoaXMuc2V0VHVuZShhLCAhdGhpcy5fZGF0YVthXSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBvbmUgdHVuZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHVuZU5hbWUgLSB7QGxpbmsgVHVuZXMudHVuZXN9XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSB0dW5lIHN0YXRlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc2V0VHVuZShhLCBpKSB7XG4gICAgdGhpcy5fZGF0YVthXSA9IGksIHRoaXMudWkuYXBwbHlUdW5lKGEsIGkpLCBhID09PSBcInN0cmV0Y2hlZFwiICYmIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5ibG9jay5zdHJldGNoZWQgPSBpO1xuICAgIH0pLmNhdGNoKChjKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTaG93IHByZWxvYWRlciBhbmQgdXBsb2FkIGltYWdlIGZpbGVcbiAgICpcbiAgICogQHBhcmFtIHtGaWxlfSBmaWxlIC0gZmlsZSB0aGF0IGlzIGN1cnJlbnRseSB1cGxvYWRpbmcgKGZyb20gcGFzdGUpXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgdXBsb2FkRmlsZShhKSB7XG4gICAgdGhpcy51cGxvYWRlci51cGxvYWRCeUZpbGUoYSwge1xuICAgICAgb25QcmV2aWV3OiAoaSkgPT4ge1xuICAgICAgICB0aGlzLnVpLnNob3dQcmVsb2FkZXIoaSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNob3cgcHJlbG9hZGVyIGFuZCB1cGxvYWQgaW1hZ2UgYnkgdGFyZ2V0IHVybFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gdXJsIHBhc3RlZFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHVwbG9hZFVybChhKSB7XG4gICAgdGhpcy51aS5zaG93UHJlbG9hZGVyKGEpLCB0aGlzLnVwbG9hZGVyLnVwbG9hZEJ5VXJsKGEpO1xuICB9XG59XG5leHBvcnQge1xuICBQIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/image/dist/image.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/nested-list/dist/nested-list.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@editorjs/nested-list/dist/nested-list.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ u)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode('.cdx-nested-list{margin:0;padding:0;outline:none;counter-reset:item;list-style:none}.cdx-nested-list__item{line-height:1.6em;display:flex;margin:2px 0}.cdx-nested-list__item [contenteditable]{outline:none}.cdx-nested-list__item-body{flex-grow:2}.cdx-nested-list__item-content,.cdx-nested-list__item-children{flex-basis:100%}.cdx-nested-list__item-content{word-break:break-word;white-space:pre-wrap}.cdx-nested-list__item:before{counter-increment:item;margin-right:5px;white-space:nowrap}.cdx-nested-list--ordered>.cdx-nested-list__item:before{content:counters(item,\".\") \". \"}.cdx-nested-list--unordered>.cdx-nested-list__item:before{content:\"•\"}.cdx-nested-list__settings{display:flex}.cdx-nested-list__settings .cdx-settings-button{width:50%}')),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nfunction p(d, e = null, t = {}) {\n  const r = document.createElement(d);\n  Array.isArray(e) ? r.classList.add(...e) : e && r.classList.add(e);\n  for (const s in t)\n    r[s] = t[s];\n  return r;\n}\nfunction g(d) {\n  const e = p(\"div\");\n  return e.appendChild(d), e.innerHTML;\n}\nfunction C(d) {\n  let e;\n  return d.nodeType !== Node.ELEMENT_NODE ? e = d.textContent : (e = d.innerHTML, e = e.replaceAll(\"<br>\", \"\")), e.trim().length === 0;\n}\nclass c {\n  /**\n   * Store internal properties\n   */\n  constructor() {\n    this.savedFakeCaret = void 0;\n  }\n  /**\n   * Saves caret position using hidden <span>\n   *\n   * @returns {void}\n   */\n  save() {\n    const e = c.range, t = p(\"span\");\n    t.hidden = !0, e.insertNode(t), this.savedFakeCaret = t;\n  }\n  /**\n   * Restores the caret position saved by the save() method\n   *\n   * @returns {void}\n   */\n  restore() {\n    if (!this.savedFakeCaret)\n      return;\n    const e = window.getSelection(), t = new Range();\n    t.setStartAfter(this.savedFakeCaret), t.setEndAfter(this.savedFakeCaret), e.removeAllRanges(), e.addRange(t), setTimeout(() => {\n      this.savedFakeCaret.remove();\n    }, 150);\n  }\n  /**\n   * Returns the first range\n   *\n   * @returns {Range|null}\n   */\n  static get range() {\n    const e = window.getSelection();\n    return e && e.rangeCount ? e.getRangeAt(0) : null;\n  }\n  /**\n   * Extract content fragment from Caret position to the end of contenteditable element\n   *\n   * @returns {DocumentFragment|void}\n   */\n  static extractFragmentFromCaretPositionTillTheEnd() {\n    const e = window.getSelection();\n    if (!e.rangeCount)\n      return;\n    const t = e.getRangeAt(0);\n    let r = t.startContainer;\n    r.nodeType !== Node.ELEMENT_NODE && (r = r.parentNode);\n    const s = r.closest(\"[contenteditable]\");\n    t.deleteContents();\n    const n = t.cloneRange();\n    return n.selectNodeContents(s), n.setStart(t.endContainer, t.endOffset), n.extractContents();\n  }\n  /**\n   * Set focus to contenteditable or native input element\n   *\n   * @param {HTMLElement} element - element where to set focus\n   * @param {boolean} atStart - where to set focus: at the start or at the end\n   * @returns {void}\n   */\n  static focus(e, t = !0) {\n    const r = document.createRange(), s = window.getSelection();\n    r.selectNodeContents(e), r.collapse(t), s.removeAllRanges(), s.addRange(r);\n  }\n  /**\n   * Check if the caret placed at the start of the contenteditable element\n   *\n   * @returns {void}\n   */\n  static isAtStart() {\n    const e = window.getSelection();\n    if (e.focusOffset > 0)\n      return !1;\n    const t = e.focusNode;\n    return c.getHigherLevelSiblings(t, \"left\").every((n) => C(n));\n  }\n  /**\n   * Get all first-level (first child of [contenteditabel]) siblings from passed node\n   * Then you can check it for emptiness\n   *\n   * @example\n   * <div contenteditable>\n   * <p></p>                            |\n   * <p></p>                            | left first-level siblings\n   * <p></p>                            |\n   * <blockquote><a><b>adaddad</b><a><blockquote>       <-- passed node for example <b>\n   * <p></p>                            |\n   * <p></p>                            | right first-level siblings\n   * <p></p>                            |\n   * </div>\n   * @param {HTMLElement} from - element from which siblings should be searched\n   * @param {'left' | 'right'} direction - direction of search\n   * @returns {HTMLElement[]}\n   */\n  static getHigherLevelSiblings(e, t = \"left\") {\n    let r = e;\n    const s = [];\n    for (; r.parentNode && r.parentNode.contentEditable !== \"true\"; )\n      r = r.parentNode;\n    const n = t === \"left\" ? \"previousSibling\" : \"nextSibling\";\n    for (; r[n]; )\n      r = r[n], s.push(r);\n    return s;\n  }\n}\nconst y = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"9\" x2=\"19\" y1=\"7\" y2=\"7\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"9\" x2=\"19\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"9\" x2=\"19\" y1=\"17\" y2=\"17\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 17H4.99002\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 12H4.99002\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 7H4.99002\"/></svg>', S = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"12\" x2=\"19\" y1=\"7\" y2=\"7\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"12\" x2=\"19\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"12\" x2=\"19\" y1=\"17\" y2=\"17\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7.79999 14L7.79999 7.2135C7.79999 7.12872 7.7011 7.0824 7.63597 7.13668L4.79999 9.5\"/></svg>';\nclass u {\n  /**\n   * Notify core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Allow to use native Enter behaviour\n   *\n   * @returns {boolean}\n   * @public\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: S,\n      title: \"List\"\n    };\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} params - tool constructor options\n   * @param {ListData} params.data - previously saved data\n   * @param {object} params.config - user config for Tool\n   * @param {object} params.api - Editor.js API\n   * @param {boolean} params.readOnly - read-only mode flag\n   */\n  constructor({ data: e, config: t, api: r, readOnly: s }) {\n    this.nodes = {\n      wrapper: null\n    }, this.api = r, this.readOnly = s, this.config = t, this.defaultListStyle = this.config.defaultStyle === \"ordered\" ? \"ordered\" : \"unordered\";\n    const n = {\n      style: this.defaultListStyle,\n      items: []\n    };\n    this.data = e && Object.keys(e).length ? e : n, this.caret = new c();\n  }\n  /**\n   * Returns list tag with items\n   *\n   * @returns {Element}\n   * @public\n   */\n  render() {\n    return this.nodes.wrapper = this.makeListWrapper(this.data.style, [this.CSS.baseBlock]), this.data.items.length ? this.appendItems(this.data.items, this.nodes.wrapper) : this.appendItems([{\n      content: \"\",\n      items: []\n    }], this.nodes.wrapper), this.readOnly || this.nodes.wrapper.addEventListener(\"keydown\", (e) => {\n      switch (e.key) {\n        case \"Enter\":\n          this.enterPressed(e);\n          break;\n        case \"Backspace\":\n          this.backspace(e);\n          break;\n        case \"Tab\":\n          e.shiftKey ? this.shiftTab(e) : this.addTab(e);\n          break;\n      }\n    }, !1), this.nodes.wrapper;\n  }\n  /**\n   * Creates Block Tune allowing to change the list style\n   *\n   * @public\n   * @returns {Array}\n   */\n  renderSettings() {\n    return [\n      {\n        name: \"unordered\",\n        label: this.api.i18n.t(\"Unordered\"),\n        icon: y\n      },\n      {\n        name: \"ordered\",\n        label: this.api.i18n.t(\"Ordered\"),\n        icon: S\n      }\n    ].map((t) => ({\n      name: t.name,\n      icon: t.icon,\n      label: t.label,\n      isActive: this.data.style === t.name,\n      closeOnActivate: !0,\n      onActivate: () => {\n        this.listStyle = t.name;\n      }\n    }));\n  }\n  /**\n   * On paste sanitzation config. Allow only tags that are allowed in the Tool.\n   *\n   * @returns {PasteConfig} - paste config.\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"OL\", \"UL\", \"LI\"]\n    };\n  }\n  /**\n   * On paste callback that is fired from Editor.\n   *\n   * @param {PasteEvent} event - event with pasted data\n   */\n  onPaste(e) {\n    const t = e.detail.data;\n    this.data = this.pasteHandler(t);\n    const r = this.nodes.wrapper;\n    r && r.parentNode.replaceChild(this.render(), r);\n  }\n  /**\n   * Handle UL, OL and LI tags paste and returns List data\n   *\n   * @param {HTMLUListElement|HTMLOListElement|HTMLLIElement} element\n   * @returns {ListData}\n   */\n  pasteHandler(e) {\n    const { tagName: t } = e;\n    let r, s;\n    switch (t) {\n      case \"OL\":\n        r = \"ordered\", s = \"ol\";\n        break;\n      case \"UL\":\n      case \"LI\":\n        r = \"unordered\", s = \"ul\";\n    }\n    const n = {\n      style: r,\n      items: []\n    }, o = (l) => Array.from(l.querySelectorAll(\":scope > li\")).map((i) => {\n      var m;\n      const a = i.querySelector(`:scope > ${s}`), f = a ? o(a) : [];\n      return {\n        content: ((m = i == null ? void 0 : i.firstChild) == null ? void 0 : m.textContent) || \"\",\n        items: f\n      };\n    });\n    return n.items = o(e), n;\n  }\n  /**\n   * Renders children list\n   *\n   * @param {ListItem[]} items - items data to append\n   * @param {Element} parentItem - where to append\n   * @returns {void}\n   */\n  appendItems(e, t) {\n    e.forEach((r) => {\n      const s = this.createItem(r.content, r.items);\n      t.appendChild(s);\n    });\n  }\n  /**\n   * Renders the single item\n   *\n   * @param {string} content - item content to render\n   * @param {ListItem[]} [items] - children\n   * @returns {Element}\n   */\n  createItem(e, t = []) {\n    const r = p(\"li\", this.CSS.item), s = p(\"div\", this.CSS.itemBody), n = p(\"div\", this.CSS.itemContent, {\n      innerHTML: e,\n      contentEditable: !this.readOnly\n    });\n    return s.appendChild(n), r.appendChild(s), t && t.length > 0 && this.addChildrenList(r, t), r;\n  }\n  /**\n   * Extracts tool's data from the DOM\n   *\n   * @returns {ListData}\n   */\n  save() {\n    const e = (t) => Array.from(t.querySelectorAll(`:scope > .${this.CSS.item}`)).map((s) => {\n      const n = s.querySelector(`.${this.CSS.itemChildren}`), o = this.getItemContent(s), l = n ? e(n) : [];\n      return {\n        content: o,\n        items: l\n      };\n    });\n    return {\n      style: this.data.style,\n      items: e(this.nodes.wrapper)\n    };\n  }\n  /**\n   * Append children list to passed item\n   *\n   * @param {Element} parentItem - item that should contain passed sub-items\n   * @param {ListItem[]} items - sub items to append\n   */\n  addChildrenList(e, t) {\n    const r = e.querySelector(`.${this.CSS.itemBody}`), s = this.makeListWrapper(void 0, [this.CSS.itemChildren]);\n    this.appendItems(t, s), r.appendChild(s);\n  }\n  /**\n   * Creates main <ul> or <ol> tag depended on style\n   *\n   * @param {string} [style] - 'ordered' or 'unordered'\n   * @param {string[]} [classes] - additional classes to append\n   * @returns {HTMLOListElement|HTMLUListElement}\n   */\n  makeListWrapper(e = this.listStyle, t = []) {\n    const r = e === \"ordered\" ? \"ol\" : \"ul\", s = e === \"ordered\" ? this.CSS.wrapperOrdered : this.CSS.wrapperUnordered;\n    return t.push(s), p(r, [this.CSS.wrapper, ...t]);\n  }\n  /**\n   * Styles\n   *\n   * @returns {object} - CSS classes names by keys\n   * @private\n   */\n  get CSS() {\n    return {\n      baseBlock: this.api.styles.block,\n      wrapper: \"cdx-nested-list\",\n      wrapperOrdered: \"cdx-nested-list--ordered\",\n      wrapperUnordered: \"cdx-nested-list--unordered\",\n      item: \"cdx-nested-list__item\",\n      itemBody: \"cdx-nested-list__item-body\",\n      itemContent: \"cdx-nested-list__item-content\",\n      itemChildren: \"cdx-nested-list__item-children\",\n      settingsWrapper: \"cdx-nested-list__settings\",\n      settingsButton: this.api.styles.settingsButton,\n      settingsButtonActive: this.api.styles.settingsButtonActive\n    };\n  }\n  /**\n   * Get list style name\n   *\n   * @returns {string}\n   */\n  get listStyle() {\n    return this.data.style || this.defaultListStyle;\n  }\n  /**\n   * Set list style\n   *\n   * @param {string} style - new style to set\n   */\n  set listStyle(e) {\n    const t = Array.from(this.nodes.wrapper.querySelectorAll(`.${this.CSS.wrapper}`));\n    t.push(this.nodes.wrapper), t.forEach((r) => {\n      r.classList.toggle(this.CSS.wrapperUnordered, e === \"unordered\"), r.classList.toggle(this.CSS.wrapperOrdered, e === \"ordered\");\n    }), this.data.style = e;\n  }\n  /**\n   * Returns current List item by the caret position\n   *\n   * @returns {Element}\n   */\n  get currentItem() {\n    let e = window.getSelection().anchorNode;\n    return e.nodeType !== Node.ELEMENT_NODE && (e = e.parentNode), e.closest(`.${this.CSS.item}`);\n  }\n  /**\n   * Handles Enter keypress\n   *\n   * @param {KeyboardEvent} event - keydown\n   * @returns {void}\n   */\n  enterPressed(e) {\n    const t = this.currentItem;\n    if (e.stopPropagation(), e.preventDefault(), e.isComposing)\n      return;\n    const r = this.getItemContent(t).trim().length === 0, s = t.parentNode === this.nodes.wrapper, n = t.nextElementSibling === null;\n    if (s && n && r) {\n      this.getOutOfList();\n      return;\n    } else if (n && r) {\n      this.unshiftItem();\n      return;\n    }\n    const o = c.extractFragmentFromCaretPositionTillTheEnd(), l = g(o), h = t.querySelector(`.${this.CSS.itemChildren}`), i = this.createItem(l, void 0);\n    h && Array.from(h.querySelectorAll(`.${this.CSS.item}`)).length > 0 ? h.prepend(i) : t.after(i), this.focusItem(i);\n  }\n  /**\n   * Decrease indentation of the current item\n   *\n   * @returns {void}\n   */\n  unshiftItem() {\n    const e = this.currentItem, t = e.parentNode.closest(`.${this.CSS.item}`);\n    if (!t)\n      return;\n    this.caret.save(), t.after(e), this.caret.restore();\n    const r = t.querySelector(`.${this.CSS.itemChildren}`);\n    r.children.length === 0 && r.remove();\n  }\n  /**\n   * Return the item content\n   *\n   * @param {Element} item - item wrapper (<li>)\n   * @returns {string}\n   */\n  getItemContent(e) {\n    const t = e.querySelector(`.${this.CSS.itemContent}`);\n    return C(t) ? \"\" : t.innerHTML;\n  }\n  /**\n   * Sets focus to the item's content\n   *\n   * @param {Element} item - item (<li>) to select\n   * @param {boolean} atStart - where to set focus: at the start or at the end\n   * @returns {void}\n   */\n  focusItem(e, t = !0) {\n    const r = e.querySelector(`.${this.CSS.itemContent}`);\n    c.focus(r, t);\n  }\n  /**\n   * Get out from List Tool by Enter on the empty last item\n   *\n   * @returns {void}\n   */\n  getOutOfList() {\n    this.currentItem.remove(), this.api.blocks.insert(), this.api.caret.setToBlock(this.api.blocks.getCurrentBlockIndex());\n  }\n  /**\n   * Handle backspace\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  backspace(e) {\n    if (!c.isAtStart())\n      return;\n    e.preventDefault();\n    const t = this.currentItem, r = t.previousSibling, s = t.parentNode.closest(`.${this.CSS.item}`);\n    if (!r && !s)\n      return;\n    e.stopPropagation();\n    let n;\n    if (r) {\n      const a = r.querySelectorAll(`.${this.CSS.item}`);\n      n = Array.from(a).pop() || r;\n    } else\n      n = s;\n    const o = c.extractFragmentFromCaretPositionTillTheEnd(), l = g(o), h = n.querySelector(`.${this.CSS.itemContent}`);\n    c.focus(h, !1), this.caret.save(), h.insertAdjacentHTML(\"beforeend\", l);\n    let i = t.querySelectorAll(`.${this.CSS.itemChildren} > .${this.CSS.item}`);\n    i = Array.from(i), i = i.filter((a) => a.parentNode.closest(`.${this.CSS.item}`) === t), i.reverse().forEach((a) => {\n      r ? n.after(a) : t.after(a);\n    }), t.remove(), this.caret.restore();\n  }\n  /**\n   * Add indentation to current item\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  addTab(e) {\n    e.stopPropagation(), e.preventDefault();\n    const t = this.currentItem, r = t.previousSibling;\n    if (!r)\n      return;\n    const n = r.querySelector(`.${this.CSS.itemChildren}`);\n    if (this.caret.save(), n)\n      n.appendChild(t);\n    else {\n      const o = this.makeListWrapper(void 0, [this.CSS.itemChildren]), l = r.querySelector(`.${this.CSS.itemBody}`);\n      o.appendChild(t), l.appendChild(o);\n    }\n    this.caret.restore();\n  }\n  /**\n   * Reduce indentation for current item\n   *\n   * @param {KeyboardEvent} event - keydown\n   * @returns {void}\n   */\n  shiftTab(e) {\n    e.stopPropagation(), e.preventDefault(), this.unshiftItem();\n  }\n  /**\n   * Convert from list to text for conversionConfig\n   *\n   * @param {ListData} data\n   * @returns {string}\n   */\n  static joinRecursive(e) {\n    return e.items.map((t) => `${t.content} ${u.joinRecursive(t)}`).join(\"\");\n  }\n  /**\n   * Convert from text to list with import and export list to text\n   */\n  static get conversionConfig() {\n    return {\n      export: (e) => u.joinRecursive(e),\n      import: (e) => ({\n        items: [{\n          content: e,\n          items: []\n        }],\n        style: \"unordered\"\n      })\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL25lc3RlZC1saXN0L2Rpc3QvbmVzdGVkLWxpc3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSx3QkFBd0Isc0NBQXNDLHdEQUF3RCxTQUFTLFVBQVUsYUFBYSxtQkFBbUIsZ0JBQWdCLHVCQUF1QixrQkFBa0IsYUFBYSxhQUFhLHlDQUF5QyxhQUFhLDRCQUE0QixZQUFZLCtEQUErRCxnQkFBZ0IsK0JBQStCLHNCQUFzQixxQkFBcUIsOEJBQThCLHVCQUF1QixpQkFBaUIsbUJBQW1CLHdEQUF3RCxnQ0FBZ0MsMERBQTBELFlBQVksMkJBQTJCLGFBQWEsZ0RBQWdELFVBQVUsa0NBQWtDLFNBQVMsbURBQW1EO0FBQ3Y4Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGtCQUFrQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVyxFQUFFLG1CQUFtQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZWRpdG9yanMtYXBwLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy9uZXN0ZWQtbGlzdC9kaXN0L25lc3RlZC1saXN0Lm1qcz9hODY1Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3RyeXtpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcuY2R4LW5lc3RlZC1saXN0e21hcmdpbjowO3BhZGRpbmc6MDtvdXRsaW5lOm5vbmU7Y291bnRlci1yZXNldDppdGVtO2xpc3Qtc3R5bGU6bm9uZX0uY2R4LW5lc3RlZC1saXN0X19pdGVte2xpbmUtaGVpZ2h0OjEuNmVtO2Rpc3BsYXk6ZmxleDttYXJnaW46MnB4IDB9LmNkeC1uZXN0ZWQtbGlzdF9faXRlbSBbY29udGVudGVkaXRhYmxlXXtvdXRsaW5lOm5vbmV9LmNkeC1uZXN0ZWQtbGlzdF9faXRlbS1ib2R5e2ZsZXgtZ3JvdzoyfS5jZHgtbmVzdGVkLWxpc3RfX2l0ZW0tY29udGVudCwuY2R4LW5lc3RlZC1saXN0X19pdGVtLWNoaWxkcmVue2ZsZXgtYmFzaXM6MTAwJX0uY2R4LW5lc3RlZC1saXN0X19pdGVtLWNvbnRlbnR7d29yZC1icmVhazpicmVhay13b3JkO3doaXRlLXNwYWNlOnByZS13cmFwfS5jZHgtbmVzdGVkLWxpc3RfX2l0ZW06YmVmb3Jle2NvdW50ZXItaW5jcmVtZW50Oml0ZW07bWFyZ2luLXJpZ2h0OjVweDt3aGl0ZS1zcGFjZTpub3dyYXB9LmNkeC1uZXN0ZWQtbGlzdC0tb3JkZXJlZD4uY2R4LW5lc3RlZC1saXN0X19pdGVtOmJlZm9yZXtjb250ZW50OmNvdW50ZXJzKGl0ZW0sXCIuXCIpIFwiLiBcIn0uY2R4LW5lc3RlZC1saXN0LS11bm9yZGVyZWQ+LmNkeC1uZXN0ZWQtbGlzdF9faXRlbTpiZWZvcmV7Y29udGVudDpcIuKAolwifS5jZHgtbmVzdGVkLWxpc3RfX3NldHRpbmdze2Rpc3BsYXk6ZmxleH0uY2R4LW5lc3RlZC1saXN0X19zZXR0aW5ncyAuY2R4LXNldHRpbmdzLWJ1dHRvbnt3aWR0aDo1MCV9JykpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZSl9fWNhdGNoKHQpe2NvbnNvbGUuZXJyb3IoXCJ2aXRlLXBsdWdpbi1jc3MtaW5qZWN0ZWQtYnktanNcIix0KX19KSgpO1xuZnVuY3Rpb24gcChkLCBlID0gbnVsbCwgdCA9IHt9KSB7XG4gIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGQpO1xuICBBcnJheS5pc0FycmF5KGUpID8gci5jbGFzc0xpc3QuYWRkKC4uLmUpIDogZSAmJiByLmNsYXNzTGlzdC5hZGQoZSk7XG4gIGZvciAoY29uc3QgcyBpbiB0KVxuICAgIHJbc10gPSB0W3NdO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIGcoZCkge1xuICBjb25zdCBlID0gcChcImRpdlwiKTtcbiAgcmV0dXJuIGUuYXBwZW5kQ2hpbGQoZCksIGUuaW5uZXJIVE1MO1xufVxuZnVuY3Rpb24gQyhkKSB7XG4gIGxldCBlO1xuICByZXR1cm4gZC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgPyBlID0gZC50ZXh0Q29udGVudCA6IChlID0gZC5pbm5lckhUTUwsIGUgPSBlLnJlcGxhY2VBbGwoXCI8YnI+XCIsIFwiXCIpKSwgZS50cmltKCkubGVuZ3RoID09PSAwO1xufVxuY2xhc3MgYyB7XG4gIC8qKlxuICAgKiBTdG9yZSBpbnRlcm5hbCBwcm9wZXJ0aWVzXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNhdmVkRmFrZUNhcmV0ID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTYXZlcyBjYXJldCBwb3NpdGlvbiB1c2luZyBoaWRkZW4gPHNwYW4+XG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICBjb25zdCBlID0gYy5yYW5nZSwgdCA9IHAoXCJzcGFuXCIpO1xuICAgIHQuaGlkZGVuID0gITAsIGUuaW5zZXJ0Tm9kZSh0KSwgdGhpcy5zYXZlZEZha2VDYXJldCA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3RvcmVzIHRoZSBjYXJldCBwb3NpdGlvbiBzYXZlZCBieSB0aGUgc2F2ZSgpIG1ldGhvZFxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHJlc3RvcmUoKSB7XG4gICAgaWYgKCF0aGlzLnNhdmVkRmFrZUNhcmV0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHQgPSBuZXcgUmFuZ2UoKTtcbiAgICB0LnNldFN0YXJ0QWZ0ZXIodGhpcy5zYXZlZEZha2VDYXJldCksIHQuc2V0RW5kQWZ0ZXIodGhpcy5zYXZlZEZha2VDYXJldCksIGUucmVtb3ZlQWxsUmFuZ2VzKCksIGUuYWRkUmFuZ2UodCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zYXZlZEZha2VDYXJldC5yZW1vdmUoKTtcbiAgICB9LCAxNTApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCByYW5nZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UmFuZ2V8bnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQgcmFuZ2UoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gZSAmJiBlLnJhbmdlQ291bnQgPyBlLmdldFJhbmdlQXQoMCkgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0IGNvbnRlbnQgZnJhZ21lbnQgZnJvbSBDYXJldCBwb3NpdGlvbiB0byB0aGUgZW5kIG9mIGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtEb2N1bWVudEZyYWdtZW50fHZvaWR9XG4gICAqL1xuICBzdGF0aWMgZXh0cmFjdEZyYWdtZW50RnJvbUNhcmV0UG9zaXRpb25UaWxsVGhlRW5kKCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFlLnJhbmdlQ291bnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGUuZ2V0UmFuZ2VBdCgwKTtcbiAgICBsZXQgciA9IHQuc3RhcnRDb250YWluZXI7XG4gICAgci5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgJiYgKHIgPSByLnBhcmVudE5vZGUpO1xuICAgIGNvbnN0IHMgPSByLmNsb3Nlc3QoXCJbY29udGVudGVkaXRhYmxlXVwiKTtcbiAgICB0LmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgY29uc3QgbiA9IHQuY2xvbmVSYW5nZSgpO1xuICAgIHJldHVybiBuLnNlbGVjdE5vZGVDb250ZW50cyhzKSwgbi5zZXRTdGFydCh0LmVuZENvbnRhaW5lciwgdC5lbmRPZmZzZXQpLCBuLmV4dHJhY3RDb250ZW50cygpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgZm9jdXMgdG8gY29udGVudGVkaXRhYmxlIG9yIG5hdGl2ZSBpbnB1dCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHdoZXJlIHRvIHNldCBmb2N1c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGF0U3RhcnQgLSB3aGVyZSB0byBzZXQgZm9jdXM6IGF0IHRoZSBzdGFydCBvciBhdCB0aGUgZW5kXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIGZvY3VzKGUsIHQgPSAhMCkge1xuICAgIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLCBzID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHIuc2VsZWN0Tm9kZUNvbnRlbnRzKGUpLCByLmNvbGxhcHNlKHQpLCBzLnJlbW92ZUFsbFJhbmdlcygpLCBzLmFkZFJhbmdlKHIpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgY2FyZXQgcGxhY2VkIGF0IHRoZSBzdGFydCBvZiB0aGUgY29udGVudGVkaXRhYmxlIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgaXNBdFN0YXJ0KCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKGUuZm9jdXNPZmZzZXQgPiAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHQgPSBlLmZvY3VzTm9kZTtcbiAgICByZXR1cm4gYy5nZXRIaWdoZXJMZXZlbFNpYmxpbmdzKHQsIFwibGVmdFwiKS5ldmVyeSgobikgPT4gQyhuKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgZmlyc3QtbGV2ZWwgKGZpcnN0IGNoaWxkIG9mIFtjb250ZW50ZWRpdGFiZWxdKSBzaWJsaW5ncyBmcm9tIHBhc3NlZCBub2RlXG4gICAqIFRoZW4geW91IGNhbiBjaGVjayBpdCBmb3IgZW1wdGluZXNzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxkaXYgY29udGVudGVkaXRhYmxlPlxuICAgKiA8cD48L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGxlZnQgZmlyc3QtbGV2ZWwgc2libGluZ3NcbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIDxibG9ja3F1b3RlPjxhPjxiPmFkYWRkYWQ8L2I+PGE+PGJsb2NrcXVvdGU+ICAgICAgIDwtLSBwYXNzZWQgbm9kZSBmb3IgZXhhbXBsZSA8Yj5cbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIDxwPjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCByaWdodCBmaXJzdC1sZXZlbCBzaWJsaW5nc1xuICAgKiA8cD48L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogPC9kaXY+XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZyb20gLSBlbGVtZW50IGZyb20gd2hpY2ggc2libGluZ3Mgc2hvdWxkIGJlIHNlYXJjaGVkXG4gICAqIEBwYXJhbSB7J2xlZnQnIHwgJ3JpZ2h0J30gZGlyZWN0aW9uIC0gZGlyZWN0aW9uIG9mIHNlYXJjaFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRbXX1cbiAgICovXG4gIHN0YXRpYyBnZXRIaWdoZXJMZXZlbFNpYmxpbmdzKGUsIHQgPSBcImxlZnRcIikge1xuICAgIGxldCByID0gZTtcbiAgICBjb25zdCBzID0gW107XG4gICAgZm9yICg7IHIucGFyZW50Tm9kZSAmJiByLnBhcmVudE5vZGUuY29udGVudEVkaXRhYmxlICE9PSBcInRydWVcIjsgKVxuICAgICAgciA9IHIucGFyZW50Tm9kZTtcbiAgICBjb25zdCBuID0gdCA9PT0gXCJsZWZ0XCIgPyBcInByZXZpb3VzU2libGluZ1wiIDogXCJuZXh0U2libGluZ1wiO1xuICAgIGZvciAoOyByW25dOyApXG4gICAgICByID0gcltuXSwgcy5wdXNoKHIpO1xuICAgIHJldHVybiBzO1xuICB9XG59XG5jb25zdCB5ID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxsaW5lIHgxPVwiOVwiIHgyPVwiMTlcIiB5MT1cIjdcIiB5Mj1cIjdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjlcIiB4Mj1cIjE5XCIgeTE9XCIxMlwiIHkyPVwiMTJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjlcIiB4Mj1cIjE5XCIgeTE9XCIxN1wiIHkyPVwiMTdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNS4wMDAwMSAxN0g0Ljk5MDAyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01LjAwMDAxIDEySDQuOTkwMDJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUuMDAwMDEgN0g0Ljk5MDAyXCIvPjwvc3ZnPicsIFMgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTlcIiB5MT1cIjdcIiB5Mj1cIjdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjEyXCIgeDI9XCIxOVwiIHkxPVwiMTJcIiB5Mj1cIjEyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTlcIiB5MT1cIjE3XCIgeTI9XCIxN1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk03Ljc5OTk5IDE0TDcuNzk5OTkgNy4yMTM1QzcuNzk5OTkgNy4xMjg3MiA3LjcwMTEgNy4wODI0IDcuNjM1OTcgNy4xMzY2OEw0Ljc5OTk5IDkuNVwiLz48L3N2Zz4nO1xuY2xhc3MgdSB7XG4gIC8qKlxuICAgKiBOb3RpZnkgY29yZSB0aGF0IHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IHRvIHVzZSBuYXRpdmUgRW50ZXIgYmVoYXZpb3VyXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZ2V0IGVuYWJsZUxpbmVCcmVha3MoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgVG9vbCB0b29sYm94IHNldHRpbmdzXG4gICAqIGljb24gLSBUb29sIGljb24ncyBTVkdcbiAgICogdGl0bGUgLSB0aXRsZSB0byBzaG93IGluIHRvb2xib3hcbiAgICpcbiAgICogQHJldHVybnMge3tpY29uOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBTLFxuICAgICAgdGl0bGU6IFwiTGlzdFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHBsdWdpbmBzIG1haW4gRWxlbWVudCBhbmQgZmlsbCBpdCB3aXRoIHNhdmVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIHRvb2wgY29uc3RydWN0b3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge0xpc3REYXRhfSBwYXJhbXMuZGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZWFkT25seSAtIHJlYWQtb25seSBtb2RlIGZsYWdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogZSwgY29uZmlnOiB0LCBhcGk6IHIsIHJlYWRPbmx5OiBzIH0pIHtcbiAgICB0aGlzLm5vZGVzID0ge1xuICAgICAgd3JhcHBlcjogbnVsbFxuICAgIH0sIHRoaXMuYXBpID0gciwgdGhpcy5yZWFkT25seSA9IHMsIHRoaXMuY29uZmlnID0gdCwgdGhpcy5kZWZhdWx0TGlzdFN0eWxlID0gdGhpcy5jb25maWcuZGVmYXVsdFN0eWxlID09PSBcIm9yZGVyZWRcIiA/IFwib3JkZXJlZFwiIDogXCJ1bm9yZGVyZWRcIjtcbiAgICBjb25zdCBuID0ge1xuICAgICAgc3R5bGU6IHRoaXMuZGVmYXVsdExpc3RTdHlsZSxcbiAgICAgIGl0ZW1zOiBbXVxuICAgIH07XG4gICAgdGhpcy5kYXRhID0gZSAmJiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPyBlIDogbiwgdGhpcy5jYXJldCA9IG5ldyBjKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCB0YWcgd2l0aCBpdGVtc1xuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLndyYXBwZXIgPSB0aGlzLm1ha2VMaXN0V3JhcHBlcih0aGlzLmRhdGEuc3R5bGUsIFt0aGlzLkNTUy5iYXNlQmxvY2tdKSwgdGhpcy5kYXRhLml0ZW1zLmxlbmd0aCA/IHRoaXMuYXBwZW5kSXRlbXModGhpcy5kYXRhLml0ZW1zLCB0aGlzLm5vZGVzLndyYXBwZXIpIDogdGhpcy5hcHBlbmRJdGVtcyhbe1xuICAgICAgY29udGVudDogXCJcIixcbiAgICAgIGl0ZW1zOiBbXVxuICAgIH1dLCB0aGlzLm5vZGVzLndyYXBwZXIpLCB0aGlzLnJlYWRPbmx5IHx8IHRoaXMubm9kZXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICB0aGlzLmVudGVyUHJlc3NlZChlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkJhY2tzcGFjZVwiOlxuICAgICAgICAgIHRoaXMuYmFja3NwYWNlKGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVGFiXCI6XG4gICAgICAgICAgZS5zaGlmdEtleSA/IHRoaXMuc2hpZnRUYWIoZSkgOiB0aGlzLmFkZFRhYihlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAhMSksIHRoaXMubm9kZXMud3JhcHBlcjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBCbG9jayBUdW5lIGFsbG93aW5nIHRvIGNoYW5nZSB0aGUgbGlzdCBzdHlsZVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIHJlbmRlclNldHRpbmdzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwidW5vcmRlcmVkXCIsXG4gICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJVbm9yZGVyZWRcIiksXG4gICAgICAgIGljb246IHlcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwib3JkZXJlZFwiLFxuICAgICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KFwiT3JkZXJlZFwiKSxcbiAgICAgICAgaWNvbjogU1xuICAgICAgfVxuICAgIF0ubWFwKCh0KSA9PiAoe1xuICAgICAgbmFtZTogdC5uYW1lLFxuICAgICAgaWNvbjogdC5pY29uLFxuICAgICAgbGFiZWw6IHQubGFiZWwsXG4gICAgICBpc0FjdGl2ZTogdGhpcy5kYXRhLnN0eWxlID09PSB0Lm5hbWUsXG4gICAgICBjbG9zZU9uQWN0aXZhdGU6ICEwLFxuICAgICAgb25BY3RpdmF0ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmxpc3RTdHlsZSA9IHQubmFtZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIHNhbml0emF0aW9uIGNvbmZpZy4gQWxsb3cgb25seSB0YWdzIHRoYXQgYXJlIGFsbG93ZWQgaW4gdGhlIFRvb2wuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQYXN0ZUNvbmZpZ30gLSBwYXN0ZSBjb25maWcuXG4gICAqL1xuICBzdGF0aWMgZ2V0IHBhc3RlQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWdzOiBbXCJPTFwiLCBcIlVMXCIsIFwiTElcIl1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPbiBwYXN0ZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIGZyb20gRWRpdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRXZlbnR9IGV2ZW50IC0gZXZlbnQgd2l0aCBwYXN0ZWQgZGF0YVxuICAgKi9cbiAgb25QYXN0ZShlKSB7XG4gICAgY29uc3QgdCA9IGUuZGV0YWlsLmRhdGE7XG4gICAgdGhpcy5kYXRhID0gdGhpcy5wYXN0ZUhhbmRsZXIodCk7XG4gICAgY29uc3QgciA9IHRoaXMubm9kZXMud3JhcHBlcjtcbiAgICByICYmIHIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgcik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBVTCwgT0wgYW5kIExJIHRhZ3MgcGFzdGUgYW5kIHJldHVybnMgTGlzdCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTFVMaXN0RWxlbWVudHxIVE1MT0xpc3RFbGVtZW50fEhUTUxMSUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybnMge0xpc3REYXRhfVxuICAgKi9cbiAgcGFzdGVIYW5kbGVyKGUpIHtcbiAgICBjb25zdCB7IHRhZ05hbWU6IHQgfSA9IGU7XG4gICAgbGV0IHIsIHM7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIFwiT0xcIjpcbiAgICAgICAgciA9IFwib3JkZXJlZFwiLCBzID0gXCJvbFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVTFwiOlxuICAgICAgY2FzZSBcIkxJXCI6XG4gICAgICAgIHIgPSBcInVub3JkZXJlZFwiLCBzID0gXCJ1bFwiO1xuICAgIH1cbiAgICBjb25zdCBuID0ge1xuICAgICAgc3R5bGU6IHIsXG4gICAgICBpdGVtczogW11cbiAgICB9LCBvID0gKGwpID0+IEFycmF5LmZyb20obC5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlID4gbGlcIikpLm1hcCgoaSkgPT4ge1xuICAgICAgdmFyIG07XG4gICAgICBjb25zdCBhID0gaS5xdWVyeVNlbGVjdG9yKGA6c2NvcGUgPiAke3N9YCksIGYgPSBhID8gbyhhKSA6IFtdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogKChtID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS5maXJzdENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogbS50ZXh0Q29udGVudCkgfHwgXCJcIixcbiAgICAgICAgaXRlbXM6IGZcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG4uaXRlbXMgPSBvKGUpLCBuO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIGNoaWxkcmVuIGxpc3RcbiAgICpcbiAgICogQHBhcmFtIHtMaXN0SXRlbVtdfSBpdGVtcyAtIGl0ZW1zIGRhdGEgdG8gYXBwZW5kXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50SXRlbSAtIHdoZXJlIHRvIGFwcGVuZFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGFwcGVuZEl0ZW1zKGUsIHQpIHtcbiAgICBlLmZvckVhY2goKHIpID0+IHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmNyZWF0ZUl0ZW0oci5jb250ZW50LCByLml0ZW1zKTtcbiAgICAgIHQuYXBwZW5kQ2hpbGQocyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNpbmdsZSBpdGVtXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IC0gaXRlbSBjb250ZW50IHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0xpc3RJdGVtW119IFtpdGVtc10gLSBjaGlsZHJlblxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIGNyZWF0ZUl0ZW0oZSwgdCA9IFtdKSB7XG4gICAgY29uc3QgciA9IHAoXCJsaVwiLCB0aGlzLkNTUy5pdGVtKSwgcyA9IHAoXCJkaXZcIiwgdGhpcy5DU1MuaXRlbUJvZHkpLCBuID0gcChcImRpdlwiLCB0aGlzLkNTUy5pdGVtQ29udGVudCwge1xuICAgICAgaW5uZXJIVE1MOiBlLFxuICAgICAgY29udGVudEVkaXRhYmxlOiAhdGhpcy5yZWFkT25seVxuICAgIH0pO1xuICAgIHJldHVybiBzLmFwcGVuZENoaWxkKG4pLCByLmFwcGVuZENoaWxkKHMpLCB0ICYmIHQubGVuZ3RoID4gMCAmJiB0aGlzLmFkZENoaWxkcmVuTGlzdChyLCB0KSwgcjtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdHMgdG9vbCdzIGRhdGEgZnJvbSB0aGUgRE9NXG4gICAqXG4gICAqIEByZXR1cm5zIHtMaXN0RGF0YX1cbiAgICovXG4gIHNhdmUoKSB7XG4gICAgY29uc3QgZSA9ICh0KSA9PiBBcnJheS5mcm9tKHQucXVlcnlTZWxlY3RvckFsbChgOnNjb3BlID4gLiR7dGhpcy5DU1MuaXRlbX1gKSkubWFwKChzKSA9PiB7XG4gICAgICBjb25zdCBuID0gcy5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy5pdGVtQ2hpbGRyZW59YCksIG8gPSB0aGlzLmdldEl0ZW1Db250ZW50KHMpLCBsID0gbiA/IGUobikgOiBbXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IG8sXG4gICAgICAgIGl0ZW1zOiBsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZTogdGhpcy5kYXRhLnN0eWxlLFxuICAgICAgaXRlbXM6IGUodGhpcy5ub2Rlcy53cmFwcGVyKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCBjaGlsZHJlbiBsaXN0IHRvIHBhc3NlZCBpdGVtXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50SXRlbSAtIGl0ZW0gdGhhdCBzaG91bGQgY29udGFpbiBwYXNzZWQgc3ViLWl0ZW1zXG4gICAqIEBwYXJhbSB7TGlzdEl0ZW1bXX0gaXRlbXMgLSBzdWIgaXRlbXMgdG8gYXBwZW5kXG4gICAqL1xuICBhZGRDaGlsZHJlbkxpc3QoZSwgdCkge1xuICAgIGNvbnN0IHIgPSBlLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuQ1NTLml0ZW1Cb2R5fWApLCBzID0gdGhpcy5tYWtlTGlzdFdyYXBwZXIodm9pZCAwLCBbdGhpcy5DU1MuaXRlbUNoaWxkcmVuXSk7XG4gICAgdGhpcy5hcHBlbmRJdGVtcyh0LCBzKSwgci5hcHBlbmRDaGlsZChzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBtYWluIDx1bD4gb3IgPG9sPiB0YWcgZGVwZW5kZWQgb24gc3R5bGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHlsZV0gLSAnb3JkZXJlZCcgb3IgJ3Vub3JkZXJlZCdcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW2NsYXNzZXNdIC0gYWRkaXRpb25hbCBjbGFzc2VzIHRvIGFwcGVuZFxuICAgKiBAcmV0dXJucyB7SFRNTE9MaXN0RWxlbWVudHxIVE1MVUxpc3RFbGVtZW50fVxuICAgKi9cbiAgbWFrZUxpc3RXcmFwcGVyKGUgPSB0aGlzLmxpc3RTdHlsZSwgdCA9IFtdKSB7XG4gICAgY29uc3QgciA9IGUgPT09IFwib3JkZXJlZFwiID8gXCJvbFwiIDogXCJ1bFwiLCBzID0gZSA9PT0gXCJvcmRlcmVkXCIgPyB0aGlzLkNTUy53cmFwcGVyT3JkZXJlZCA6IHRoaXMuQ1NTLndyYXBwZXJVbm9yZGVyZWQ7XG4gICAgcmV0dXJuIHQucHVzaChzKSwgcChyLCBbdGhpcy5DU1Mud3JhcHBlciwgLi4udF0pO1xuICB9XG4gIC8qKlxuICAgKiBTdHlsZXNcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gLSBDU1MgY2xhc3NlcyBuYW1lcyBieSBrZXlzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlQmxvY2s6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcbiAgICAgIHdyYXBwZXI6IFwiY2R4LW5lc3RlZC1saXN0XCIsXG4gICAgICB3cmFwcGVyT3JkZXJlZDogXCJjZHgtbmVzdGVkLWxpc3QtLW9yZGVyZWRcIixcbiAgICAgIHdyYXBwZXJVbm9yZGVyZWQ6IFwiY2R4LW5lc3RlZC1saXN0LS11bm9yZGVyZWRcIixcbiAgICAgIGl0ZW06IFwiY2R4LW5lc3RlZC1saXN0X19pdGVtXCIsXG4gICAgICBpdGVtQm9keTogXCJjZHgtbmVzdGVkLWxpc3RfX2l0ZW0tYm9keVwiLFxuICAgICAgaXRlbUNvbnRlbnQ6IFwiY2R4LW5lc3RlZC1saXN0X19pdGVtLWNvbnRlbnRcIixcbiAgICAgIGl0ZW1DaGlsZHJlbjogXCJjZHgtbmVzdGVkLWxpc3RfX2l0ZW0tY2hpbGRyZW5cIixcbiAgICAgIHNldHRpbmdzV3JhcHBlcjogXCJjZHgtbmVzdGVkLWxpc3RfX3NldHRpbmdzXCIsXG4gICAgICBzZXR0aW5nc0J1dHRvbjogdGhpcy5hcGkuc3R5bGVzLnNldHRpbmdzQnV0dG9uLFxuICAgICAgc2V0dGluZ3NCdXR0b25BY3RpdmU6IHRoaXMuYXBpLnN0eWxlcy5zZXR0aW5nc0J1dHRvbkFjdGl2ZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBsaXN0IHN0eWxlIG5hbWVcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldCBsaXN0U3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zdHlsZSB8fCB0aGlzLmRlZmF1bHRMaXN0U3R5bGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBsaXN0IHN0eWxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSAtIG5ldyBzdHlsZSB0byBzZXRcbiAgICovXG4gIHNldCBsaXN0U3R5bGUoZSkge1xuICAgIGNvbnN0IHQgPSBBcnJheS5mcm9tKHRoaXMubm9kZXMud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0aGlzLkNTUy53cmFwcGVyfWApKTtcbiAgICB0LnB1c2godGhpcy5ub2Rlcy53cmFwcGVyKSwgdC5mb3JFYWNoKChyKSA9PiB7XG4gICAgICByLmNsYXNzTGlzdC50b2dnbGUodGhpcy5DU1Mud3JhcHBlclVub3JkZXJlZCwgZSA9PT0gXCJ1bm9yZGVyZWRcIiksIHIuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLkNTUy53cmFwcGVyT3JkZXJlZCwgZSA9PT0gXCJvcmRlcmVkXCIpO1xuICAgIH0pLCB0aGlzLmRhdGEuc3R5bGUgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgTGlzdCBpdGVtIGJ5IHRoZSBjYXJldCBwb3NpdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIGdldCBjdXJyZW50SXRlbSgpIHtcbiAgICBsZXQgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5hbmNob3JOb2RlO1xuICAgIHJldHVybiBlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiAoZSA9IGUucGFyZW50Tm9kZSksIGUuY2xvc2VzdChgLiR7dGhpcy5DU1MuaXRlbX1gKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBFbnRlciBrZXlwcmVzc1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGVudGVyUHJlc3NlZChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY3VycmVudEl0ZW07XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKCksIGUucHJldmVudERlZmF1bHQoKSwgZS5pc0NvbXBvc2luZylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gdGhpcy5nZXRJdGVtQ29udGVudCh0KS50cmltKCkubGVuZ3RoID09PSAwLCBzID0gdC5wYXJlbnROb2RlID09PSB0aGlzLm5vZGVzLndyYXBwZXIsIG4gPSB0Lm5leHRFbGVtZW50U2libGluZyA9PT0gbnVsbDtcbiAgICBpZiAocyAmJiBuICYmIHIpIHtcbiAgICAgIHRoaXMuZ2V0T3V0T2ZMaXN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChuICYmIHIpIHtcbiAgICAgIHRoaXMudW5zaGlmdEl0ZW0oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbyA9IGMuZXh0cmFjdEZyYWdtZW50RnJvbUNhcmV0UG9zaXRpb25UaWxsVGhlRW5kKCksIGwgPSBnKG8pLCBoID0gdC5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy5pdGVtQ2hpbGRyZW59YCksIGkgPSB0aGlzLmNyZWF0ZUl0ZW0obCwgdm9pZCAwKTtcbiAgICBoICYmIEFycmF5LmZyb20oaC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0aGlzLkNTUy5pdGVtfWApKS5sZW5ndGggPiAwID8gaC5wcmVwZW5kKGkpIDogdC5hZnRlcihpKSwgdGhpcy5mb2N1c0l0ZW0oaSk7XG4gIH1cbiAgLyoqXG4gICAqIERlY3JlYXNlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW1cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICB1bnNoaWZ0SXRlbSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jdXJyZW50SXRlbSwgdCA9IGUucGFyZW50Tm9kZS5jbG9zZXN0KGAuJHt0aGlzLkNTUy5pdGVtfWApO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmNhcmV0LnNhdmUoKSwgdC5hZnRlcihlKSwgdGhpcy5jYXJldC5yZXN0b3JlKCk7XG4gICAgY29uc3QgciA9IHQucXVlcnlTZWxlY3RvcihgLiR7dGhpcy5DU1MuaXRlbUNoaWxkcmVufWApO1xuICAgIHIuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmIHIucmVtb3ZlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaXRlbSBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gaXRlbSAtIGl0ZW0gd3JhcHBlciAoPGxpPilcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldEl0ZW1Db250ZW50KGUpIHtcbiAgICBjb25zdCB0ID0gZS5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy5pdGVtQ29udGVudH1gKTtcbiAgICByZXR1cm4gQyh0KSA/IFwiXCIgOiB0LmlubmVySFRNTDtcbiAgfVxuICAvKipcbiAgICogU2V0cyBmb2N1cyB0byB0aGUgaXRlbSdzIGNvbnRlbnRcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBpdGVtIC0gaXRlbSAoPGxpPikgdG8gc2VsZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXRTdGFydCAtIHdoZXJlIHRvIHNldCBmb2N1czogYXQgdGhlIHN0YXJ0IG9yIGF0IHRoZSBlbmRcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb2N1c0l0ZW0oZSwgdCA9ICEwKSB7XG4gICAgY29uc3QgciA9IGUucXVlcnlTZWxlY3RvcihgLiR7dGhpcy5DU1MuaXRlbUNvbnRlbnR9YCk7XG4gICAgYy5mb2N1cyhyLCB0KTtcbiAgfVxuICAvKipcbiAgICogR2V0IG91dCBmcm9tIExpc3QgVG9vbCBieSBFbnRlciBvbiB0aGUgZW1wdHkgbGFzdCBpdGVtXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZ2V0T3V0T2ZMaXN0KCkge1xuICAgIHRoaXMuY3VycmVudEl0ZW0ucmVtb3ZlKCksIHRoaXMuYXBpLmJsb2Nrcy5pbnNlcnQoKSwgdGhpcy5hcGkuY2FyZXQuc2V0VG9CbG9jayh0aGlzLmFwaS5ibG9ja3MuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBiYWNrc3BhY2VcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGJhY2tzcGFjZShlKSB7XG4gICAgaWYgKCFjLmlzQXRTdGFydCgpKVxuICAgICAgcmV0dXJuO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5jdXJyZW50SXRlbSwgciA9IHQucHJldmlvdXNTaWJsaW5nLCBzID0gdC5wYXJlbnROb2RlLmNsb3Nlc3QoYC4ke3RoaXMuQ1NTLml0ZW19YCk7XG4gICAgaWYgKCFyICYmICFzKVxuICAgICAgcmV0dXJuO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgbGV0IG47XG4gICAgaWYgKHIpIHtcbiAgICAgIGNvbnN0IGEgPSByLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3RoaXMuQ1NTLml0ZW19YCk7XG4gICAgICBuID0gQXJyYXkuZnJvbShhKS5wb3AoKSB8fCByO1xuICAgIH0gZWxzZVxuICAgICAgbiA9IHM7XG4gICAgY29uc3QgbyA9IGMuZXh0cmFjdEZyYWdtZW50RnJvbUNhcmV0UG9zaXRpb25UaWxsVGhlRW5kKCksIGwgPSBnKG8pLCBoID0gbi5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy5pdGVtQ29udGVudH1gKTtcbiAgICBjLmZvY3VzKGgsICExKSwgdGhpcy5jYXJldC5zYXZlKCksIGguaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGwpO1xuICAgIGxldCBpID0gdC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0aGlzLkNTUy5pdGVtQ2hpbGRyZW59ID4gLiR7dGhpcy5DU1MuaXRlbX1gKTtcbiAgICBpID0gQXJyYXkuZnJvbShpKSwgaSA9IGkuZmlsdGVyKChhKSA9PiBhLnBhcmVudE5vZGUuY2xvc2VzdChgLiR7dGhpcy5DU1MuaXRlbX1gKSA9PT0gdCksIGkucmV2ZXJzZSgpLmZvckVhY2goKGEpID0+IHtcbiAgICAgIHIgPyBuLmFmdGVyKGEpIDogdC5hZnRlcihhKTtcbiAgICB9KSwgdC5yZW1vdmUoKSwgdGhpcy5jYXJldC5yZXN0b3JlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBpbmRlbnRhdGlvbiB0byBjdXJyZW50IGl0ZW1cbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGFkZFRhYihlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKSwgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHQgPSB0aGlzLmN1cnJlbnRJdGVtLCByID0gdC5wcmV2aW91c1NpYmxpbmc7XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSByLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuQ1NTLml0ZW1DaGlsZHJlbn1gKTtcbiAgICBpZiAodGhpcy5jYXJldC5zYXZlKCksIG4pXG4gICAgICBuLmFwcGVuZENoaWxkKHQpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbyA9IHRoaXMubWFrZUxpc3RXcmFwcGVyKHZvaWQgMCwgW3RoaXMuQ1NTLml0ZW1DaGlsZHJlbl0pLCBsID0gci5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy5pdGVtQm9keX1gKTtcbiAgICAgIG8uYXBwZW5kQ2hpbGQodCksIGwuYXBwZW5kQ2hpbGQobyk7XG4gICAgfVxuICAgIHRoaXMuY2FyZXQucmVzdG9yZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWR1Y2UgaW5kZW50YXRpb24gZm9yIGN1cnJlbnQgaXRlbVxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHNoaWZ0VGFiKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpLCBlLnByZXZlbnREZWZhdWx0KCksIHRoaXMudW5zaGlmdEl0ZW0oKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBmcm9tIGxpc3QgdG8gdGV4dCBmb3IgY29udmVyc2lvbkNvbmZpZ1xuICAgKlxuICAgKiBAcGFyYW0ge0xpc3REYXRhfSBkYXRhXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgam9pblJlY3Vyc2l2ZShlKSB7XG4gICAgcmV0dXJuIGUuaXRlbXMubWFwKCh0KSA9PiBgJHt0LmNvbnRlbnR9ICR7dS5qb2luUmVjdXJzaXZlKHQpfWApLmpvaW4oXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgZnJvbSB0ZXh0IHRvIGxpc3Qgd2l0aCBpbXBvcnQgYW5kIGV4cG9ydCBsaXN0IHRvIHRleHRcbiAgICovXG4gIHN0YXRpYyBnZXQgY29udmVyc2lvbkNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwb3J0OiAoZSkgPT4gdS5qb2luUmVjdXJzaXZlKGUpLFxuICAgICAgaW1wb3J0OiAoZSkgPT4gKHtcbiAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgY29udGVudDogZSxcbiAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgfV0sXG4gICAgICAgIHN0eWxlOiBcInVub3JkZXJlZFwiXG4gICAgICB9KVxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCB7XG4gIHUgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/nested-list/dist/nested-list.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/paragraph/dist/paragraph.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@editorjs/paragraph/dist/paragraph.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ a)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-paragraph{line-height:1.6em;outline:none}.ce-paragraph[data-placeholder]:empty:before{content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before{opacity:1}.codex-editor--toolbox-opened .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before,.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:focus:before{opacity:0}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}\")),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nconst s = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>';\n/**\n * Base Paragraph Block for the Editor.js.\n * Represents a regular text block\n *\n * @author CodeX (team@codex.so)\n * @copyright CodeX 2018\n * @license The MIT License (MIT)\n */\nclass a {\n  /**\n   * Default placeholder for Paragraph Tool\n   *\n   * @returns {string}\n   * @class\n   */\n  static get DEFAULT_PLACEHOLDER() {\n    return \"\";\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} params - constructor params\n   * @param {ParagraphData} params.data - previously saved data\n   * @param {ParagraphConfig} params.config - user config for Tool\n   * @param {object} params.api - editor.js api\n   * @param {boolean} readOnly - read only mode flag\n   */\n  constructor({ data: t, config: e, api: i, readOnly: n }) {\n    this.api = i, this.readOnly = n, this._CSS = {\n      block: this.api.styles.block,\n      wrapper: \"ce-paragraph\"\n    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = e.placeholder ? e.placeholder : a.DEFAULT_PLACEHOLDER, this._data = {}, this._element = null, this._preserveBlank = e.preserveBlank !== void 0 ? e.preserveBlank : !1, this.data = t;\n  }\n  /**\n   * Check if text content is empty and set empty string to inner html.\n   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements\n   *\n   * @param {KeyboardEvent} e - key up event\n   */\n  onKeyUp(t) {\n    if (t.code !== \"Backspace\" && t.code !== \"Delete\")\n      return;\n    const { textContent: e } = this._element;\n    e === \"\" && (this._element.innerHTML = \"\");\n  }\n  /**\n   * Create Tool's view\n   *\n   * @returns {HTMLElement}\n   * @private\n   */\n  drawView() {\n    const t = document.createElement(\"DIV\");\n    return t.classList.add(this._CSS.wrapper, this._CSS.block), t.contentEditable = !1, t.dataset.placeholder = this.api.i18n.t(this._placeholder), this._data.text && (t.innerHTML = this._data.text), this.readOnly || (t.contentEditable = !0, t.addEventListener(\"keyup\", this.onKeyUp)), t;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement}\n   */\n  render() {\n    return this._element = this.drawView(), this._element;\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {ParagraphData} data\n   * @public\n   */\n  merge(t) {\n    const e = {\n      text: this.data.text + t.text\n    };\n    this.data = e;\n  }\n  /**\n   * Validate Paragraph block data:\n   * - check for emptiness\n   *\n   * @param {ParagraphData} savedData — data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(t) {\n    return !(t.text.trim() === \"\" && !this._preserveBlank);\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view\n   * @returns {ParagraphData} - saved data\n   * @public\n   */\n  save(t) {\n    return {\n      text: t.innerHTML\n    };\n  }\n  /**\n   * On paste callback fired from Editor.\n   *\n   * @param {PasteEvent} event - event with pasted data\n   */\n  onPaste(t) {\n    const e = {\n      text: t.detail.data.innerHTML\n    };\n    this.data = e;\n  }\n  /**\n   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // to convert Paragraph to other block, use 'text' property of saved data\n      import: \"text\"\n      // to covert other block's exported string to Paragraph, fill 'text' property of tool data\n    };\n  }\n  /**\n   * Sanitizer rules\n   */\n  static get sanitize() {\n    return {\n      text: {\n        br: !0\n      }\n    };\n  }\n  /**\n   * Returns true to notify the core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get current Tools`s data\n   *\n   * @returns {ParagraphData} Current data\n   * @private\n   */\n  get data() {\n    if (this._element !== null) {\n      const t = this._element.innerHTML;\n      this._data.text = t;\n    }\n    return this._data;\n  }\n  /**\n   * Store data in plugin:\n   * - at the this._data property\n   * - at the HTML\n   *\n   * @param {ParagraphData} data — data to set\n   * @private\n   */\n  set data(t) {\n    this._data = t || {}, this._element !== null && this.hydrate();\n  }\n  /**\n   * Fill tool's view with data\n   */\n  hydrate() {\n    window.requestAnimationFrame(() => {\n      this._element.innerHTML = this._data.text || \"\";\n    });\n  }\n  /**\n   * Used by Editor paste handling API.\n   * Provides configuration to handle P tags.\n   *\n   * @returns {{tags: string[]}}\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"P\"]\n    };\n  }\n  /**\n   * Icon and title for displaying at the Toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: s,\n      title: \"Text\"\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL3BhcmFncmFwaC9kaXN0L3BhcmFncmFwaC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFlBQVksYUFBYSxJQUFJLHdCQUF3QixzQ0FBc0MscURBQXFELGtCQUFrQixhQUFhLDZDQUE2QywrQkFBK0IsY0FBYyxnQkFBZ0IsVUFBVSx3RkFBd0YsVUFBVSwrTEFBK0wsVUFBVSw4QkFBOEIsYUFBYSw2QkFBNkIsZ0JBQWdCLGtDQUFrQyxTQUFTLG1EQUFtRDtBQUNwd0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1SkFBdUo7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVkaXRvcmpzLWFwcC8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvcGFyYWdyYXBoL2Rpc3QvcGFyYWdyYXBoLm1qcz9lOWNlIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3RyeXtpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiLmNlLXBhcmFncmFwaHtsaW5lLWhlaWdodDoxLjZlbTtvdXRsaW5lOm5vbmV9LmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpiZWZvcmV7Y29udGVudDphdHRyKGRhdGEtcGxhY2Vob2xkZXIpO2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NDAwO29wYWNpdHk6MH0uY29kZXgtZWRpdG9yLS1lbXB0eSAuY2UtYmxvY2s6Zmlyc3QtY2hpbGQgLmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpiZWZvcmV7b3BhY2l0eToxfS5jb2RleC1lZGl0b3ItLXRvb2xib3gtb3BlbmVkIC5jZS1ibG9jazpmaXJzdC1jaGlsZCAuY2UtcGFyYWdyYXBoW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmJlZm9yZSwuY29kZXgtZWRpdG9yLS1lbXB0eSAuY2UtYmxvY2s6Zmlyc3QtY2hpbGQgLmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpmb2N1czpiZWZvcmV7b3BhY2l0eTowfS5jZS1wYXJhZ3JhcGggcDpmaXJzdC1vZi10eXBle21hcmdpbi10b3A6MH0uY2UtcGFyYWdyYXBoIHA6bGFzdC1vZi10eXBle21hcmdpbi1ib3R0b206MH1cIikpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZSl9fWNhdGNoKHQpe2NvbnNvbGUuZXJyb3IoXCJ2aXRlLXBsdWdpbi1jc3MtaW5qZWN0ZWQtYnktanNcIix0KX19KSgpO1xuY29uc3QgcyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOCA5VjcuMkM4IDcuMDg5NTQgOC4wODk1NCA3IDguMiA3TDEyIDdNMTYgOVY3LjJDMTYgNy4wODk1NCAxNS45MTA1IDcgMTUuOCA3TDEyIDdNMTIgN0wxMiAxN00xMiAxN0gxME0xMiAxN0gxNFwiLz48L3N2Zz4nO1xuLyoqXG4gKiBCYXNlIFBhcmFncmFwaCBCbG9jayBmb3IgdGhlIEVkaXRvci5qcy5cbiAqIFJlcHJlc2VudHMgYSByZWd1bGFyIHRleHQgYmxvY2tcbiAqXG4gKiBAYXV0aG9yIENvZGVYICh0ZWFtQGNvZGV4LnNvKVxuICogQGNvcHlyaWdodCBDb2RlWCAyMDE4XG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqL1xuY2xhc3MgYSB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHBsYWNlaG9sZGVyIGZvciBQYXJhZ3JhcGggVG9vbFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAY2xhc3NcbiAgICovXG4gIHN0YXRpYyBnZXQgREVGQVVMVF9QTEFDRUhPTERFUigpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHBsdWdpbmBzIG1haW4gRWxlbWVudCBhbmQgZmlsbCBpdCB3aXRoIHNhdmVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIGNvbnN0cnVjdG9yIHBhcmFtc1xuICAgKiBAcGFyYW0ge1BhcmFncmFwaERhdGF9IHBhcmFtcy5kYXRhIC0gcHJldmlvdXNseSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoQ29uZmlnfSBwYXJhbXMuY29uZmlnIC0gdXNlciBjb25maWcgZm9yIFRvb2xcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5hcGkgLSBlZGl0b3IuanMgYXBpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHkgLSByZWFkIG9ubHkgbW9kZSBmbGFnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IHQsIGNvbmZpZzogZSwgYXBpOiBpLCByZWFkT25seTogbiB9KSB7XG4gICAgdGhpcy5hcGkgPSBpLCB0aGlzLnJlYWRPbmx5ID0gbiwgdGhpcy5fQ1NTID0ge1xuICAgICAgYmxvY2s6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcbiAgICAgIHdyYXBwZXI6IFwiY2UtcGFyYWdyYXBoXCJcbiAgICB9LCB0aGlzLnJlYWRPbmx5IHx8ICh0aGlzLm9uS2V5VXAgPSB0aGlzLm9uS2V5VXAuYmluZCh0aGlzKSksIHRoaXMuX3BsYWNlaG9sZGVyID0gZS5wbGFjZWhvbGRlciA/IGUucGxhY2Vob2xkZXIgOiBhLkRFRkFVTFRfUExBQ0VIT0xERVIsIHRoaXMuX2RhdGEgPSB7fSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX3ByZXNlcnZlQmxhbmsgPSBlLnByZXNlcnZlQmxhbmsgIT09IHZvaWQgMCA/IGUucHJlc2VydmVCbGFuayA6ICExLCB0aGlzLmRhdGEgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0ZXh0IGNvbnRlbnQgaXMgZW1wdHkgYW5kIHNldCBlbXB0eSBzdHJpbmcgdG8gaW5uZXIgaHRtbC5cbiAgICogV2UgbmVlZCB0aGlzIGJlY2F1c2Ugc29tZSBicm93c2VycyAoZS5nLiBTYWZhcmkpIGluc2VydCA8YnI+IGludG8gZW1wdHkgY29udGVudGVkaXRhbmxlIGVsZW1lbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZSAtIGtleSB1cCBldmVudFxuICAgKi9cbiAgb25LZXlVcCh0KSB7XG4gICAgaWYgKHQuY29kZSAhPT0gXCJCYWNrc3BhY2VcIiAmJiB0LmNvZGUgIT09IFwiRGVsZXRlXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyB0ZXh0Q29udGVudDogZSB9ID0gdGhpcy5fZWxlbWVudDtcbiAgICBlID09PSBcIlwiICYmICh0aGlzLl9lbGVtZW50LmlubmVySFRNTCA9IFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgVG9vbCdzIHZpZXdcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHJhd1ZpZXcoKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gICAgcmV0dXJuIHQuY2xhc3NMaXN0LmFkZCh0aGlzLl9DU1Mud3JhcHBlciwgdGhpcy5fQ1NTLmJsb2NrKSwgdC5jb250ZW50RWRpdGFibGUgPSAhMSwgdC5kYXRhc2V0LnBsYWNlaG9sZGVyID0gdGhpcy5hcGkuaTE4bi50KHRoaXMuX3BsYWNlaG9sZGVyKSwgdGhpcy5fZGF0YS50ZXh0ICYmICh0LmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCksIHRoaXMucmVhZE9ubHkgfHwgKHQuY29udGVudEVkaXRhYmxlID0gITAsIHQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMub25LZXlVcCkpLCB0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbCdzIHZpZXdcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50ID0gdGhpcy5kcmF3VmlldygpLCB0aGlzLl9lbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBzcGVjaWZpZWQgaG93IHRvIG1lcmdlIHR3byBUZXh0IGJsb2Nrcy5cbiAgICogQ2FsbGVkIGJ5IEVkaXRvci5qcyBieSBiYWNrc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG1lcmdlKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgdGV4dDogdGhpcy5kYXRhLnRleHQgKyB0LnRleHRcbiAgICB9O1xuICAgIHRoaXMuZGF0YSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIFBhcmFncmFwaCBibG9jayBkYXRhOlxuICAgKiAtIGNoZWNrIGZvciBlbXB0aW5lc3NcbiAgICpcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBzYXZlZERhdGEg4oCUIGRhdGEgcmVjZWl2ZWQgYWZ0ZXIgc2F2aW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBzYXZlZCBkYXRhIGlzIG5vdCBjb3JyZWN0LCBvdGhlcndpc2UgdHJ1ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICB2YWxpZGF0ZSh0KSB7XG4gICAgcmV0dXJuICEodC50ZXh0LnRyaW0oKSA9PT0gXCJcIiAmJiAhdGhpcy5fcHJlc2VydmVCbGFuayk7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgVG9vbCdzIGRhdGEgZnJvbSB0aGUgdmlld1xuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSB0b29sc0NvbnRlbnQgLSBQYXJhZ3JhcGggdG9vbHMgcmVuZGVyZWQgdmlld1xuICAgKiBAcmV0dXJucyB7UGFyYWdyYXBoRGF0YX0gLSBzYXZlZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNhdmUodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB0LmlubmVySFRNTFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIGNhbGxiYWNrIGZpcmVkIGZyb20gRWRpdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRXZlbnR9IGV2ZW50IC0gZXZlbnQgd2l0aCBwYXN0ZWQgZGF0YVxuICAgKi9cbiAgb25QYXN0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIHRleHQ6IHQuZGV0YWlsLmRhdGEuaW5uZXJIVE1MXG4gICAgfTtcbiAgICB0aGlzLmRhdGEgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgQ29udmVyc2lvbiBUb29sYmFyLiBQYXJhZ3JhcGggY2FuIGJlIGNvbnZlcnRlZCB0by9mcm9tIG90aGVyIHRvb2xzXG4gICAqL1xuICBzdGF0aWMgZ2V0IGNvbnZlcnNpb25Db25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cG9ydDogXCJ0ZXh0XCIsXG4gICAgICAvLyB0byBjb252ZXJ0IFBhcmFncmFwaCB0byBvdGhlciBibG9jaywgdXNlICd0ZXh0JyBwcm9wZXJ0eSBvZiBzYXZlZCBkYXRhXG4gICAgICBpbXBvcnQ6IFwidGV4dFwiXG4gICAgICAvLyB0byBjb3ZlcnQgb3RoZXIgYmxvY2sncyBleHBvcnRlZCBzdHJpbmcgdG8gUGFyYWdyYXBoLCBmaWxsICd0ZXh0JyBwcm9wZXJ0eSBvZiB0b29sIGRhdGFcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgcnVsZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgYnI6ICEwXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHRvIG5vdGlmeSB0aGUgY29yZSB0aGF0IHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IFRvb2xzYHMgZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7UGFyYWdyYXBoRGF0YX0gQ3VycmVudCBkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgdGhpcy5fZGF0YS50ZXh0ID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlIGRhdGEgaW4gcGx1Z2luOlxuICAgKiAtIGF0IHRoZSB0aGlzLl9kYXRhIHByb3BlcnR5XG4gICAqIC0gYXQgdGhlIEhUTUxcbiAgICpcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBkYXRhIOKAlCBkYXRhIHRvIHNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0IGRhdGEodCkge1xuICAgIHRoaXMuX2RhdGEgPSB0IHx8IHt9LCB0aGlzLl9lbGVtZW50ICE9PSBudWxsICYmIHRoaXMuaHlkcmF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBGaWxsIHRvb2wncyB2aWV3IHdpdGggZGF0YVxuICAgKi9cbiAgaHlkcmF0ZSgpIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fZGF0YS50ZXh0IHx8IFwiXCI7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgYnkgRWRpdG9yIHBhc3RlIGhhbmRsaW5nIEFQSS5cbiAgICogUHJvdmlkZXMgY29uZmlndXJhdGlvbiB0byBoYW5kbGUgUCB0YWdzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7e3RhZ3M6IHN0cmluZ1tdfX1cbiAgICovXG4gIHN0YXRpYyBnZXQgcGFzdGVDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ3M6IFtcIlBcIl1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJY29uIGFuZCB0aXRsZSBmb3IgZGlzcGxheWluZyBhdCB0aGUgVG9vbGJveFxuICAgKlxuICAgKiBAcmV0dXJucyB7e2ljb246IHN0cmluZywgdGl0bGU6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IHMsXG4gICAgICB0aXRsZTogXCJUZXh0XCJcbiAgICB9O1xuICB9XG59XG5leHBvcnQge1xuICBhIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/paragraph/dist/paragraph.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/quote/dist/quote.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@editorjs/quote/dist/quote.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ i)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var t=document.createElement(\"style\");t.appendChild(document.createTextNode(\".cdx-quote-icon svg{transform:rotate(180deg)}.cdx-quote{margin:0}.cdx-quote__text{min-height:158px;margin-bottom:10px}.cdx-quote [contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.cdx-quote [contentEditable=true][data-placeholder]:empty:before{opacity:1}.cdx-quote [contentEditable=true][data-placeholder]:empty:focus:before{opacity:0}.cdx-quote-settings{display:flex}.cdx-quote-settings .cdx-settings-button{width:50%}\")),document.head.appendChild(t)}}catch(e){console.error(\"vite-plugin-css-injected-by-js\",e)}})();\nconst a = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M18 7L6 7\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M18 17H6\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 12L8 12\"/></svg>', c = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M17 7L5 7\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M17 17H5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M13 12L5 12\"/></svg>', l = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10 10.8182L9 10.8182C8.80222 10.8182 8.60888 10.7649 8.44443 10.665C8.27998 10.5651 8.15181 10.4231 8.07612 10.257C8.00043 10.0909 7.98063 9.90808 8.01922 9.73174C8.0578 9.55539 8.15304 9.39341 8.29289 9.26627C8.43275 9.13913 8.61093 9.05255 8.80491 9.01747C8.99889 8.98239 9.19996 9.00039 9.38268 9.0692C9.56541 9.13801 9.72159 9.25453 9.83147 9.40403C9.94135 9.55353 10 9.72929 10 9.90909L10 12.1818C10 12.664 9.78929 13.1265 9.41421 13.4675C9.03914 13.8084 8.53043 14 8 14\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M16 10.8182L15 10.8182C14.8022 10.8182 14.6089 10.7649 14.4444 10.665C14.28 10.5651 14.1518 10.4231 14.0761 10.257C14.0004 10.0909 13.9806 9.90808 14.0192 9.73174C14.0578 9.55539 14.153 9.39341 14.2929 9.26627C14.4327 9.13913 14.6109 9.05255 14.8049 9.01747C14.9989 8.98239 15.2 9.00039 15.3827 9.0692C15.5654 9.13801 15.7216 9.25453 15.8315 9.40403C15.9414 9.55353 16 9.72929 16 9.90909L16 12.1818C16 12.664 15.7893 13.1265 15.4142 13.4675C15.0391 13.8084 14.5304 14 14 14\"/></svg>';\nclass i {\n  /**\n   * Notify core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: l,\n      title: \"Quote\"\n    };\n  }\n  /**\n   * Empty Quote is not empty Block\n   *\n   * @public\n   * @returns {boolean}\n   */\n  static get contentless() {\n    return !0;\n  }\n  /**\n   * Allow to press Enter inside the Quote\n   *\n   * @public\n   * @returns {boolean}\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Default placeholder for quote text\n   *\n   * @public\n   * @returns {string}\n   */\n  static get DEFAULT_QUOTE_PLACEHOLDER() {\n    return \"Enter a quote\";\n  }\n  /**\n   * Default placeholder for quote caption\n   *\n   * @public\n   * @returns {string}\n   */\n  static get DEFAULT_CAPTION_PLACEHOLDER() {\n    return \"Enter a caption\";\n  }\n  /**\n   * Allowed quote alignments\n   *\n   * @public\n   * @returns {{left: string, center: string}}\n   */\n  static get ALIGNMENTS() {\n    return {\n      left: \"left\",\n      center: \"center\"\n    };\n  }\n  /**\n   * Default quote alignment\n   *\n   * @public\n   * @returns {string}\n   */\n  static get DEFAULT_ALIGNMENT() {\n    return i.ALIGNMENTS.left;\n  }\n  /**\n   * Allow Quote to be converted to/from other blocks\n   */\n  static get conversionConfig() {\n    return {\n      /**\n       * To create Quote data from string, simple fill 'text' property\n       */\n      import: \"text\",\n      /**\n       * To create string from Quote data, concatenate text and caption\n       *\n       * @param {QuoteData} quoteData\n       * @returns {string}\n       */\n      export: function(t) {\n        return t.caption ? `${t.text} — ${t.caption}` : t.text;\n      }\n    };\n  }\n  /**\n   * Tool`s styles\n   *\n   * @returns {{baseClass: string, wrapper: string, quote: string, input: string, caption: string}}\n   */\n  get CSS() {\n    return {\n      baseClass: this.api.styles.block,\n      wrapper: \"cdx-quote\",\n      text: \"cdx-quote__text\",\n      input: this.api.styles.input,\n      caption: \"cdx-quote__caption\"\n    };\n  }\n  /**\n   * Tool`s settings properties\n   *\n   * @returns {*[]}\n   */\n  get settings() {\n    return [\n      {\n        name: \"left\",\n        icon: c\n      },\n      {\n        name: \"center\",\n        icon: a\n      }\n    ];\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {{data: QuoteData, config: QuoteConfig, api: object}}\n   *   data — previously saved data\n   *   config - user config for Tool\n   *   api - Editor.js API\n   *   readOnly - read-only mode flag\n   */\n  constructor({ data: t, config: e, api: n, readOnly: r }) {\n    const { ALIGNMENTS: o, DEFAULT_ALIGNMENT: s } = i;\n    this.api = n, this.readOnly = r, this.quotePlaceholder = e.quotePlaceholder || i.DEFAULT_QUOTE_PLACEHOLDER, this.captionPlaceholder = e.captionPlaceholder || i.DEFAULT_CAPTION_PLACEHOLDER, this.data = {\n      text: t.text || \"\",\n      caption: t.caption || \"\",\n      alignment: Object.values(o).includes(t.alignment) && t.alignment || e.defaultAlignment || s\n    };\n  }\n  /**\n   * Create Quote Tool container with inputs\n   *\n   * @returns {Element}\n   */\n  render() {\n    const t = this._make(\"blockquote\", [this.CSS.baseClass, this.CSS.wrapper]), e = this._make(\"div\", [this.CSS.input, this.CSS.text], {\n      contentEditable: !this.readOnly,\n      innerHTML: this.data.text\n    }), n = this._make(\"div\", [this.CSS.input, this.CSS.caption], {\n      contentEditable: !this.readOnly,\n      innerHTML: this.data.caption\n    });\n    return e.dataset.placeholder = this.quotePlaceholder, n.dataset.placeholder = this.captionPlaceholder, t.appendChild(e), t.appendChild(n), t;\n  }\n  /**\n   * Extract Quote data from Quote Tool element\n   *\n   * @param {HTMLDivElement} quoteElement - element to save\n   * @returns {QuoteData}\n   */\n  save(t) {\n    const e = t.querySelector(`.${this.CSS.text}`), n = t.querySelector(`.${this.CSS.caption}`);\n    return Object.assign(this.data, {\n      text: e.innerHTML,\n      caption: n.innerHTML\n    });\n  }\n  /**\n   * Sanitizer rules\n   */\n  static get sanitize() {\n    return {\n      text: {\n        br: !0\n      },\n      caption: {\n        br: !0\n      },\n      alignment: {}\n    };\n  }\n  /**\n   * Create wrapper for Tool`s settings buttons:\n   * 1. Left alignment\n   * 2. Center alignment\n   *\n   * @returns {TunesMenuConfig}\n   *\n   */\n  renderSettings() {\n    const t = (e) => e[0].toUpperCase() + e.substr(1);\n    return this.settings.map((e) => ({\n      icon: e.icon,\n      label: this.api.i18n.t(`Align ${t(e.name)}`),\n      onActivate: () => this._toggleTune(e.name),\n      isActive: this.data.alignment === e.name,\n      closeOnActivate: !0\n    }));\n  }\n  /**\n   * Toggle quote`s alignment\n   *\n   * @param {string} tune - alignment\n   * @private\n   */\n  _toggleTune(t) {\n    this.data.alignment = t;\n  }\n  /**\n   * Helper for making Elements with attributes\n   *\n   * @param  {string} tagName           - new Element tag name\n   * @param  {Array|string} classNames  - list or name of CSS classname(s)\n   * @param  {object} attributes        - any attributes\n   * @returns {Element}\n   */\n  _make(t, e = null, n = {}) {\n    const r = document.createElement(t);\n    Array.isArray(e) ? r.classList.add(...e) : e && r.classList.add(e);\n    for (const o in n)\n      r[o] = n[o];\n    return r;\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL3F1b3RlL2Rpc3QvcXVvdGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSx3QkFBd0Isc0NBQXNDLDJEQUEyRCx5QkFBeUIsV0FBVyxTQUFTLGlCQUFpQixpQkFBaUIsbUJBQW1CLDJEQUEyRCxrQkFBa0IsK0JBQStCLGNBQWMsZ0JBQWdCLFVBQVUsaUVBQWlFLFVBQVUsdUVBQXVFLFVBQVUsb0JBQW9CLGFBQWEseUNBQXlDLFVBQVUsa0NBQWtDLFNBQVMsbURBQW1EO0FBQzF0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsOEJBQThCLFFBQVEsSUFBSSxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pELFlBQVksc0NBQXNDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWU7QUFDZjtBQUNBO0FBQ0Esa0NBQWtDLGNBQWMsNEJBQTRCLGlCQUFpQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVkaXRvcmpzLWFwcC8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvcXVvdGUvZGlzdC9xdW90ZS5tanM/YzAxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt0cnl7aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIi5jZHgtcXVvdGUtaWNvbiBzdmd7dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfS5jZHgtcXVvdGV7bWFyZ2luOjB9LmNkeC1xdW90ZV9fdGV4dHttaW4taGVpZ2h0OjE1OHB4O21hcmdpbi1ib3R0b206MTBweH0uY2R4LXF1b3RlIFtjb250ZW50RWRpdGFibGU9dHJ1ZV1bZGF0YS1wbGFjZWhvbGRlcl06YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO2NvbnRlbnQ6YXR0cihkYXRhLXBsYWNlaG9sZGVyKTtjb2xvcjojNzA3Njg0O2ZvbnQtd2VpZ2h0OjQwMDtvcGFjaXR5OjB9LmNkeC1xdW90ZSBbY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmJlZm9yZXtvcGFjaXR5OjF9LmNkeC1xdW90ZSBbY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmZvY3VzOmJlZm9yZXtvcGFjaXR5OjB9LmNkeC1xdW90ZS1zZXR0aW5nc3tkaXNwbGF5OmZsZXh9LmNkeC1xdW90ZS1zZXR0aW5ncyAuY2R4LXNldHRpbmdzLWJ1dHRvbnt3aWR0aDo1MCV9XCIpKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHQpfX1jYXRjaChlKXtjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsZSl9fSkoKTtcbmNvbnN0IGEgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE4IDdMNiA3XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xOCAxN0g2XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNiAxMkw4IDEyXCIvPjwvc3ZnPicsIGMgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE3IDdMNSA3XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNyAxN0g1XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMyAxMkw1IDEyXCIvPjwvc3ZnPicsIGwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTAgMTAuODE4Mkw5IDEwLjgxODJDOC44MDIyMiAxMC44MTgyIDguNjA4ODggMTAuNzY0OSA4LjQ0NDQzIDEwLjY2NUM4LjI3OTk4IDEwLjU2NTEgOC4xNTE4MSAxMC40MjMxIDguMDc2MTIgMTAuMjU3QzguMDAwNDMgMTAuMDkwOSA3Ljk4MDYzIDkuOTA4MDggOC4wMTkyMiA5LjczMTc0QzguMDU3OCA5LjU1NTM5IDguMTUzMDQgOS4zOTM0MSA4LjI5Mjg5IDkuMjY2MjdDOC40MzI3NSA5LjEzOTEzIDguNjEwOTMgOS4wNTI1NSA4LjgwNDkxIDkuMDE3NDdDOC45OTg4OSA4Ljk4MjM5IDkuMTk5OTYgOS4wMDAzOSA5LjM4MjY4IDkuMDY5MkM5LjU2NTQxIDkuMTM4MDEgOS43MjE1OSA5LjI1NDUzIDkuODMxNDcgOS40MDQwM0M5Ljk0MTM1IDkuNTUzNTMgMTAgOS43MjkyOSAxMCA5LjkwOTA5TDEwIDEyLjE4MThDMTAgMTIuNjY0IDkuNzg5MjkgMTMuMTI2NSA5LjQxNDIxIDEzLjQ2NzVDOS4wMzkxNCAxMy44MDg0IDguNTMwNDMgMTQgOCAxNFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNiAxMC44MTgyTDE1IDEwLjgxODJDMTQuODAyMiAxMC44MTgyIDE0LjYwODkgMTAuNzY0OSAxNC40NDQ0IDEwLjY2NUMxNC4yOCAxMC41NjUxIDE0LjE1MTggMTAuNDIzMSAxNC4wNzYxIDEwLjI1N0MxNC4wMDA0IDEwLjA5MDkgMTMuOTgwNiA5LjkwODA4IDE0LjAxOTIgOS43MzE3NEMxNC4wNTc4IDkuNTU1MzkgMTQuMTUzIDkuMzkzNDEgMTQuMjkyOSA5LjI2NjI3QzE0LjQzMjcgOS4xMzkxMyAxNC42MTA5IDkuMDUyNTUgMTQuODA0OSA5LjAxNzQ3QzE0Ljk5ODkgOC45ODIzOSAxNS4yIDkuMDAwMzkgMTUuMzgyNyA5LjA2OTJDMTUuNTY1NCA5LjEzODAxIDE1LjcyMTYgOS4yNTQ1MyAxNS44MzE1IDkuNDA0MDNDMTUuOTQxNCA5LjU1MzUzIDE2IDkuNzI5MjkgMTYgOS45MDkwOUwxNiAxMi4xODE4QzE2IDEyLjY2NCAxNS43ODkzIDEzLjEyNjUgMTUuNDE0MiAxMy40Njc1QzE1LjAzOTEgMTMuODA4NCAxNC41MzA0IDE0IDE0IDE0XCIvPjwvc3ZnPic7XG5jbGFzcyBpIHtcbiAgLyoqXG4gICAqIE5vdGlmeSBjb3JlIHRoYXQgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCBpc1JlYWRPbmx5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogR2V0IFRvb2wgdG9vbGJveCBzZXR0aW5nc1xuICAgKiBpY29uIC0gVG9vbCBpY29uJ3MgU1ZHXG4gICAqIHRpdGxlIC0gdGl0bGUgdG8gc2hvdyBpbiB0b29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHt7aWNvbjogc3RyaW5nLCB0aXRsZTogc3RyaW5nfX1cbiAgICovXG4gIHN0YXRpYyBnZXQgdG9vbGJveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogbCxcbiAgICAgIHRpdGxlOiBcIlF1b3RlXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFbXB0eSBRdW90ZSBpcyBub3QgZW1wdHkgQmxvY2tcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgY29udGVudGxlc3MoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvdyB0byBwcmVzcyBFbnRlciBpbnNpZGUgdGhlIFF1b3RlXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGVuYWJsZUxpbmVCcmVha3MoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBEZWZhdWx0IHBsYWNlaG9sZGVyIGZvciBxdW90ZSB0ZXh0XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgREVGQVVMVF9RVU9URV9QTEFDRUhPTERFUigpIHtcbiAgICByZXR1cm4gXCJFbnRlciBhIHF1b3RlXCI7XG4gIH1cbiAgLyoqXG4gICAqIERlZmF1bHQgcGxhY2Vob2xkZXIgZm9yIHF1b3RlIGNhcHRpb25cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBERUZBVUxUX0NBUFRJT05fUExBQ0VIT0xERVIoKSB7XG4gICAgcmV0dXJuIFwiRW50ZXIgYSBjYXB0aW9uXCI7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93ZWQgcXVvdGUgYWxpZ25tZW50c1xuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHt7bGVmdDogc3RyaW5nLCBjZW50ZXI6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgZ2V0IEFMSUdOTUVOVFMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IFwibGVmdFwiLFxuICAgICAgY2VudGVyOiBcImNlbnRlclwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGVmYXVsdCBxdW90ZSBhbGlnbm1lbnRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBERUZBVUxUX0FMSUdOTUVOVCgpIHtcbiAgICByZXR1cm4gaS5BTElHTk1FTlRTLmxlZnQ7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IFF1b3RlIHRvIGJlIGNvbnZlcnRlZCB0by9mcm9tIG90aGVyIGJsb2Nrc1xuICAgKi9cbiAgc3RhdGljIGdldCBjb252ZXJzaW9uQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvIGNyZWF0ZSBRdW90ZSBkYXRhIGZyb20gc3RyaW5nLCBzaW1wbGUgZmlsbCAndGV4dCcgcHJvcGVydHlcbiAgICAgICAqL1xuICAgICAgaW1wb3J0OiBcInRleHRcIixcbiAgICAgIC8qKlxuICAgICAgICogVG8gY3JlYXRlIHN0cmluZyBmcm9tIFF1b3RlIGRhdGEsIGNvbmNhdGVuYXRlIHRleHQgYW5kIGNhcHRpb25cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1F1b3RlRGF0YX0gcXVvdGVEYXRhXG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICBleHBvcnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuY2FwdGlvbiA/IGAke3QudGV4dH0g4oCUICR7dC5jYXB0aW9ufWAgOiB0LnRleHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVG9vbGBzIHN0eWxlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7e2Jhc2VDbGFzczogc3RyaW5nLCB3cmFwcGVyOiBzdHJpbmcsIHF1b3RlOiBzdHJpbmcsIGlucHV0OiBzdHJpbmcsIGNhcHRpb246IHN0cmluZ319XG4gICAqL1xuICBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlQ2xhc3M6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcbiAgICAgIHdyYXBwZXI6IFwiY2R4LXF1b3RlXCIsXG4gICAgICB0ZXh0OiBcImNkeC1xdW90ZV9fdGV4dFwiLFxuICAgICAgaW5wdXQ6IHRoaXMuYXBpLnN0eWxlcy5pbnB1dCxcbiAgICAgIGNhcHRpb246IFwiY2R4LXF1b3RlX19jYXB0aW9uXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBUb29sYHMgc2V0dGluZ3MgcHJvcGVydGllc1xuICAgKlxuICAgKiBAcmV0dXJucyB7KltdfVxuICAgKi9cbiAgZ2V0IHNldHRpbmdzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwibGVmdFwiLFxuICAgICAgICBpY29uOiBjXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcImNlbnRlclwiLFxuICAgICAgICBpY29uOiBhXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHBsdWdpbmBzIG1haW4gRWxlbWVudCBhbmQgZmlsbCBpdCB3aXRoIHNhdmVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHt7ZGF0YTogUXVvdGVEYXRhLCBjb25maWc6IFF1b3RlQ29uZmlnLCBhcGk6IG9iamVjdH19XG4gICAqICAgZGF0YSDigJQgcHJldmlvdXNseSBzYXZlZCBkYXRhXG4gICAqICAgY29uZmlnIC0gdXNlciBjb25maWcgZm9yIFRvb2xcbiAgICogICBhcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqICAgcmVhZE9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IHQsIGNvbmZpZzogZSwgYXBpOiBuLCByZWFkT25seTogciB9KSB7XG4gICAgY29uc3QgeyBBTElHTk1FTlRTOiBvLCBERUZBVUxUX0FMSUdOTUVOVDogcyB9ID0gaTtcbiAgICB0aGlzLmFwaSA9IG4sIHRoaXMucmVhZE9ubHkgPSByLCB0aGlzLnF1b3RlUGxhY2Vob2xkZXIgPSBlLnF1b3RlUGxhY2Vob2xkZXIgfHwgaS5ERUZBVUxUX1FVT1RFX1BMQUNFSE9MREVSLCB0aGlzLmNhcHRpb25QbGFjZWhvbGRlciA9IGUuY2FwdGlvblBsYWNlaG9sZGVyIHx8IGkuREVGQVVMVF9DQVBUSU9OX1BMQUNFSE9MREVSLCB0aGlzLmRhdGEgPSB7XG4gICAgICB0ZXh0OiB0LnRleHQgfHwgXCJcIixcbiAgICAgIGNhcHRpb246IHQuY2FwdGlvbiB8fCBcIlwiLFxuICAgICAgYWxpZ25tZW50OiBPYmplY3QudmFsdWVzKG8pLmluY2x1ZGVzKHQuYWxpZ25tZW50KSAmJiB0LmFsaWdubWVudCB8fCBlLmRlZmF1bHRBbGlnbm1lbnQgfHwgc1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBRdW90ZSBUb29sIGNvbnRhaW5lciB3aXRoIGlucHV0c1xuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fbWFrZShcImJsb2NrcXVvdGVcIiwgW3RoaXMuQ1NTLmJhc2VDbGFzcywgdGhpcy5DU1Mud3JhcHBlcl0pLCBlID0gdGhpcy5fbWFrZShcImRpdlwiLCBbdGhpcy5DU1MuaW5wdXQsIHRoaXMuQ1NTLnRleHRdLCB7XG4gICAgICBjb250ZW50RWRpdGFibGU6ICF0aGlzLnJlYWRPbmx5LFxuICAgICAgaW5uZXJIVE1MOiB0aGlzLmRhdGEudGV4dFxuICAgIH0pLCBuID0gdGhpcy5fbWFrZShcImRpdlwiLCBbdGhpcy5DU1MuaW5wdXQsIHRoaXMuQ1NTLmNhcHRpb25dLCB7XG4gICAgICBjb250ZW50RWRpdGFibGU6ICF0aGlzLnJlYWRPbmx5LFxuICAgICAgaW5uZXJIVE1MOiB0aGlzLmRhdGEuY2FwdGlvblxuICAgIH0pO1xuICAgIHJldHVybiBlLmRhdGFzZXQucGxhY2Vob2xkZXIgPSB0aGlzLnF1b3RlUGxhY2Vob2xkZXIsIG4uZGF0YXNldC5wbGFjZWhvbGRlciA9IHRoaXMuY2FwdGlvblBsYWNlaG9sZGVyLCB0LmFwcGVuZENoaWxkKGUpLCB0LmFwcGVuZENoaWxkKG4pLCB0O1xuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0IFF1b3RlIGRhdGEgZnJvbSBRdW90ZSBUb29sIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gcXVvdGVFbGVtZW50IC0gZWxlbWVudCB0byBzYXZlXG4gICAqIEByZXR1cm5zIHtRdW90ZURhdGF9XG4gICAqL1xuICBzYXZlKHQpIHtcbiAgICBjb25zdCBlID0gdC5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy50ZXh0fWApLCBuID0gdC5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLkNTUy5jYXB0aW9ufWApO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMuZGF0YSwge1xuICAgICAgdGV4dDogZS5pbm5lckhUTUwsXG4gICAgICBjYXB0aW9uOiBuLmlubmVySFRNTFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgcnVsZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgYnI6ICEwXG4gICAgICB9LFxuICAgICAgY2FwdGlvbjoge1xuICAgICAgICBicjogITBcbiAgICAgIH0sXG4gICAgICBhbGlnbm1lbnQ6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIHdyYXBwZXIgZm9yIFRvb2xgcyBzZXR0aW5ncyBidXR0b25zOlxuICAgKiAxLiBMZWZ0IGFsaWdubWVudFxuICAgKiAyLiBDZW50ZXIgYWxpZ25tZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtUdW5lc01lbnVDb25maWd9XG4gICAqXG4gICAqL1xuICByZW5kZXJTZXR0aW5ncygpIHtcbiAgICBjb25zdCB0ID0gKGUpID0+IGVbMF0udG9VcHBlckNhc2UoKSArIGUuc3Vic3RyKDEpO1xuICAgIHJldHVybiB0aGlzLnNldHRpbmdzLm1hcCgoZSkgPT4gKHtcbiAgICAgIGljb246IGUuaWNvbixcbiAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoYEFsaWduICR7dChlLm5hbWUpfWApLFxuICAgICAgb25BY3RpdmF0ZTogKCkgPT4gdGhpcy5fdG9nZ2xlVHVuZShlLm5hbWUpLFxuICAgICAgaXNBY3RpdmU6IHRoaXMuZGF0YS5hbGlnbm1lbnQgPT09IGUubmFtZSxcbiAgICAgIGNsb3NlT25BY3RpdmF0ZTogITBcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSBxdW90ZWBzIGFsaWdubWVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHVuZSAtIGFsaWdubWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RvZ2dsZVR1bmUodCkge1xuICAgIHRoaXMuZGF0YS5hbGlnbm1lbnQgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIG1ha2luZyBFbGVtZW50cyB3aXRoIGF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWdOYW1lICAgICAgICAgICAtIG5ldyBFbGVtZW50IHRhZyBuYW1lXG4gICAqIEBwYXJhbSAge0FycmF5fHN0cmluZ30gY2xhc3NOYW1lcyAgLSBsaXN0IG9yIG5hbWUgb2YgQ1NTIGNsYXNzbmFtZShzKVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZXMgICAgICAgIC0gYW55IGF0dHJpYnV0ZXNcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICBfbWFrZSh0LCBlID0gbnVsbCwgbiA9IHt9KSB7XG4gICAgY29uc3QgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodCk7XG4gICAgQXJyYXkuaXNBcnJheShlKSA/IHIuY2xhc3NMaXN0LmFkZCguLi5lKSA6IGUgJiYgci5jbGFzc0xpc3QuYWRkKGUpO1xuICAgIGZvciAoY29uc3QgbyBpbiBuKVxuICAgICAgcltvXSA9IG5bb107XG4gICAgcmV0dXJuIHI7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIGkgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/quote/dist/quote.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/table/dist/table.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@editorjs/table/dist/table.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ I)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var o=document.createElement(\"style\");o.appendChild(document.createTextNode('.tc-wrap{--color-background:#f9f9fb;--color-text-secondary:#7b7e89;--color-border:#e8e8eb;--cell-size:34px;--toolbox-icon-size:18px;--toolbox-padding:6px;--toolbox-aiming-field-size:calc(var(--toolbox-icon-size) + var(--toolbox-padding)*2);border-left:0;position:relative;height:100%;width:100%;margin-top:var(--toolbox-icon-size);box-sizing:border-box;display:grid;grid-template-columns:calc(100% - var(--cell-size)) var(--cell-size)}.tc-wrap--readonly{grid-template-columns:100% var(--cell-size)}.tc-wrap svg{vertical-align:top}@media print{.tc-wrap{border-left-color:var(--color-border);border-left-style:solid;border-left-width:1px;grid-template-columns:100% var(--cell-size)}}@media print{.tc-wrap .tc-row:after{display:none}}.tc-table{position:relative;width:100%;height:100%;display:grid;font-size:14px;border-top:1px solid var(--color-border);line-height:1.4}.tc-table:after{width:calc(var(--cell-size));height:100%;left:calc(var(--cell-size)*-1);top:0}.tc-table:after,.tc-table:before{position:absolute;content:\"\"}.tc-table:before{width:100%;height:var(--toolbox-aiming-field-size);top:calc(var(--toolbox-aiming-field-size)*-1);left:0}.tc-table--heading .tc-row:first-child{font-weight:600;border-bottom:2px solid var(--color-border)}.tc-table--heading .tc-row:first-child [contenteditable]:empty:before{content:attr(heading);color:var(--color-text-secondary)}.tc-table--heading .tc-row:first-child:after{bottom:-2px;border-bottom:2px solid var(--color-border)}.tc-add-column,.tc-add-row{display:flex;color:var(--color-text-secondary)}@media print{.tc-add{display:none}}.tc-add-column{padding:4px 0;justify-content:center;border-top:1px solid var(--color-border)}@media print{.tc-add-column{display:none}}.tc-add-row{height:var(--cell-size);align-items:center;padding-left:4px;position:relative}.tc-add-row:before{content:\"\";position:absolute;right:calc(var(--cell-size)*-1);width:var(--cell-size);height:100%}@media print{.tc-add-row{display:none}}.tc-add-column,.tc-add-row{transition:0s;cursor:pointer;will-change:background-color}.tc-add-column:hover,.tc-add-row:hover{transition:background-color .1s ease;background-color:var(--color-background)}.tc-add-row{margin-top:1px}.tc-add-row:hover:before{transition:.1s;background-color:var(--color-background)}.tc-row{display:grid;grid-template-columns:repeat(auto-fit,minmax(10px,1fr));position:relative;border-bottom:1px solid var(--color-border)}.tc-row:after{content:\"\";pointer-events:none;position:absolute;width:var(--cell-size);height:100%;bottom:-1px;right:calc(var(--cell-size)*-1);border-bottom:1px solid var(--color-border)}.tc-row--selected{background:var(--color-background)}.tc-row--selected:after{background:var(--color-background)}.tc-cell{border-right:1px solid var(--color-border);padding:6px 12px;overflow:hidden;outline:none;line-break:normal}.tc-cell--selected{background:var(--color-background)}.tc-wrap--readonly .tc-row:after{display:none}.tc-toolbox{--toolbox-padding:6px;--popover-margin:30px;--toggler-click-zone-size:30px;--toggler-dots-color:#7b7e89;--toggler-dots-color-hovered:#1d202b;position:absolute;cursor:pointer;z-index:1;opacity:0;transition:opacity .1s;will-change:left,opacity}.tc-toolbox--column{top:calc(var(--toggler-click-zone-size)*-1);transform:translate(calc(var(--toggler-click-zone-size)*-1/2));will-change:left,opacity}.tc-toolbox--row{left:calc(var(--popover-margin)*-1);transform:translateY(calc(var(--toggler-click-zone-size)*-1/2));margin-top:-1px;will-change:top,opacity}.tc-toolbox--showed{opacity:1}.tc-toolbox .tc-popover{position:absolute;top:0;left:var(--popover-margin)}.tc-toolbox__toggler{display:flex;align-items:center;justify-content:center;width:var(--toggler-click-zone-size);height:var(--toggler-click-zone-size);color:var(--toggler-dots-color);opacity:0;transition:opacity .15s ease;will-change:opacity}.tc-toolbox__toggler:hover{color:var(--toggler-dots-color-hovered)}.tc-toolbox__toggler svg{fill:currentColor}.tc-wrap:hover .tc-toolbox__toggler{opacity:1}.tc-settings .cdx-settings-button{width:50%;margin:0}.tc-popover{--color-border:#eaeaea;--color-background:#fff;--color-background-hover:rgba(232,232,235,.49);--color-background-confirm:#e24a4a;--color-background-confirm-hover:#d54040;--color-text-confirm:#fff;background:var(--color-background);border:1px solid var(--color-border);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;padding:6px;display:none;will-change:opacity,transform}.tc-popover--opened{display:block;animation:menuShowing .1s cubic-bezier(.215,.61,.355,1) forwards}.tc-popover__item{display:flex;align-items:center;padding:2px 14px 2px 2px;border-radius:5px;cursor:pointer;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;user-select:none}.tc-popover__item:hover{background:var(--color-background-hover)}.tc-popover__item:not(:last-of-type){margin-bottom:2px}.tc-popover__item-icon{display:inline-flex;width:26px;height:26px;align-items:center;justify-content:center;background:var(--color-background);border-radius:5px;border:1px solid var(--color-border);margin-right:8px}.tc-popover__item-label{line-height:22px;font-size:14px;font-weight:500}.tc-popover__item--confirm{background:var(--color-background-confirm);color:var(--color-text-confirm)}.tc-popover__item--confirm:hover{background-color:var(--color-background-confirm-hover)}.tc-popover__item--confirm .tc-popover__item-icon{background:var(--color-background-confirm);border-color:#0000001a}.tc-popover__item--confirm .tc-popover__item-icon svg{transition:transform .2s ease-in;transform:rotate(90deg) scale(1.2)}.tc-popover__item--hidden{display:none}@keyframes menuShowing{0%{opacity:0;transform:translateY(-8px) scale(.9)}70%{opacity:1;transform:translateY(2px)}to{transform:translateY(0)}}')),document.head.appendChild(o)}}catch(r){console.error(\"vite-plugin-css-injected-by-js\",r)}})();\nfunction c(d, t, e = {}) {\n  const o = document.createElement(d);\n  Array.isArray(t) ? o.classList.add(...t) : t && o.classList.add(t);\n  for (const i in e)\n    Object.prototype.hasOwnProperty.call(e, i) && (o[i] = e[i]);\n  return o;\n}\nfunction f(d) {\n  const t = d.getBoundingClientRect();\n  return {\n    y1: Math.floor(t.top + window.pageYOffset),\n    x1: Math.floor(t.left + window.pageXOffset),\n    x2: Math.floor(t.right + window.pageXOffset),\n    y2: Math.floor(t.bottom + window.pageYOffset)\n  };\n}\nfunction g(d, t) {\n  const e = f(d), o = f(t);\n  return {\n    fromTopBorder: o.y1 - e.y1,\n    fromLeftBorder: o.x1 - e.x1,\n    fromRightBorder: e.x2 - o.x2,\n    fromBottomBorder: e.y2 - o.y2\n  };\n}\nfunction R(d, t) {\n  const e = d.getBoundingClientRect(), { width: o, height: i, x: s, y: n } = e, { clientX: h, clientY: l } = t;\n  return {\n    width: o,\n    height: i,\n    x: h - s,\n    y: l - n\n  };\n}\nfunction C(d, t) {\n  return t.parentNode.insertBefore(d, t);\n}\nfunction m(d, t = !0) {\n  const e = document.createRange(), o = window.getSelection();\n  e.selectNodeContents(d), e.collapse(t), o.removeAllRanges(), o.addRange(e);\n}\nclass a {\n  /**\n   * @param {object} options - constructor options\n   * @param {PopoverItem[]} options.items - constructor options\n   */\n  constructor({ items: t }) {\n    this.items = t, this.wrapper = void 0, this.itemEls = [];\n  }\n  /**\n   * Set of CSS classnames used in popover\n   *\n   * @returns {object}\n   */\n  static get CSS() {\n    return {\n      popover: \"tc-popover\",\n      popoverOpened: \"tc-popover--opened\",\n      item: \"tc-popover__item\",\n      itemHidden: \"tc-popover__item--hidden\",\n      itemConfirmState: \"tc-popover__item--confirm\",\n      itemIcon: \"tc-popover__item-icon\",\n      itemLabel: \"tc-popover__item-label\"\n    };\n  }\n  /**\n   * Returns the popover element\n   *\n   * @returns {Element}\n   */\n  render() {\n    return this.wrapper = c(\"div\", a.CSS.popover), this.items.forEach((t, e) => {\n      const o = c(\"div\", a.CSS.item), i = c(\"div\", a.CSS.itemIcon, {\n        innerHTML: t.icon\n      }), s = c(\"div\", a.CSS.itemLabel, {\n        textContent: t.label\n      });\n      o.dataset.index = e, o.appendChild(i), o.appendChild(s), this.wrapper.appendChild(o), this.itemEls.push(o);\n    }), this.wrapper.addEventListener(\"click\", (t) => {\n      this.popoverClicked(t);\n    }), this.wrapper;\n  }\n  /**\n   * Popover wrapper click listener\n   * Used to delegate clicks in items\n   *\n   * @returns {void}\n   */\n  popoverClicked(t) {\n    const e = t.target.closest(`.${a.CSS.item}`);\n    if (!e)\n      return;\n    const o = e.dataset.index, i = this.items[o];\n    if (i.confirmationRequired && !this.hasConfirmationState(e)) {\n      this.setConfirmationState(e);\n      return;\n    }\n    i.onClick();\n  }\n  /**\n   * Enable the confirmation state on passed item\n   *\n   * @returns {void}\n   */\n  setConfirmationState(t) {\n    t.classList.add(a.CSS.itemConfirmState);\n  }\n  /**\n   * Disable the confirmation state on passed item\n   *\n   * @returns {void}\n   */\n  clearConfirmationState(t) {\n    t.classList.remove(a.CSS.itemConfirmState);\n  }\n  /**\n   * Check if passed item has the confirmation state\n   *\n   * @returns {boolean}\n   */\n  hasConfirmationState(t) {\n    return t.classList.contains(a.CSS.itemConfirmState);\n  }\n  /**\n   * Return an opening state\n   *\n   * @returns {boolean}\n   */\n  get opened() {\n    return this.wrapper.classList.contains(a.CSS.popoverOpened);\n  }\n  /**\n   * Opens the popover\n   *\n   * @returns {void}\n   */\n  open() {\n    this.items.forEach((t, e) => {\n      typeof t.hideIf == \"function\" && this.itemEls[e].classList.toggle(a.CSS.itemHidden, t.hideIf());\n    }), this.wrapper.classList.add(a.CSS.popoverOpened);\n  }\n  /**\n   * Closes the popover\n   *\n   * @returns {void}\n   */\n  close() {\n    this.wrapper.classList.remove(a.CSS.popoverOpened), this.itemEls.forEach((t) => {\n      this.clearConfirmationState(t);\n    });\n  }\n}\nconst b = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16\"/></svg>', k = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14.8833 9.16666L18.2167 12.5M18.2167 12.5L14.8833 15.8333M18.2167 12.5H10.05C9.16594 12.5 8.31809 12.1488 7.69297 11.5237C7.06785 10.8986 6.71666 10.0507 6.71666 9.16666\"/></svg>', S = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14.9167 14.9167L11.5833 18.25M11.5833 18.25L8.25 14.9167M11.5833 18.25L11.5833 10.0833C11.5833 9.19928 11.9345 8.35143 12.5596 7.72631C13.1848 7.10119 14.0326 6.75 14.9167 6.75\"/></svg>', x = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.13333 14.9167L12.4667 18.25M12.4667 18.25L15.8 14.9167M12.4667 18.25L12.4667 10.0833C12.4667 9.19928 12.1155 8.35143 11.4904 7.72631C10.8652 7.10119 10.0174 6.75 9.13333 6.75\"/></svg>', y = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14.8833 15.8333L18.2167 12.5M18.2167 12.5L14.8833 9.16667M18.2167 12.5L10.05 12.5C9.16595 12.5 8.31811 12.8512 7.69299 13.4763C7.06787 14.1014 6.71667 14.9493 6.71667 15.8333\"/></svg>', T = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.41 9.66H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 9.66H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.31 14.36H9.3\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 14.36H14.59\"/></svg>', v = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 7V12M12 17V12M17 12H12M12 12H7\"/></svg>', L = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M5 10H19\"/><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/></svg>', M = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M10 5V18.5\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M14 5V18.5\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M5 10H19\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M5 14H19\"/><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/></svg>', O = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M10 5V18.5\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M5 10H19\"/><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/></svg>';\nclass u {\n  /**\n   * Creates toolbox buttons and toolbox menus\n   *\n   * @param {object} api - Editor.js api\n   * @param {PopoverItem[]} items - Editor.js api\n   * @param {function} onOpen - callback fired when the Popover is opening\n   * @param {function} onClose - callback fired when the Popover is closing\n   * @param {string} [cssModifier] - the modifier for the Toolbox. Allows to add some specific styles.\n   */\n  constructor({ api: t, items: e, onOpen: o, onClose: i, cssModifier: s = \"\" }) {\n    this.api = t, this.items = e, this.onOpen = o, this.onClose = i, this.cssModifier = s, this.popover = null, this.wrapper = this.createToolbox();\n  }\n  /**\n   * Style classes\n   */\n  static get CSS() {\n    return {\n      toolbox: \"tc-toolbox\",\n      toolboxShowed: \"tc-toolbox--showed\",\n      toggler: \"tc-toolbox__toggler\"\n    };\n  }\n  /**\n   * Returns rendered Toolbox element\n   */\n  get element() {\n    return this.wrapper;\n  }\n  /**\n   * Creating a toolbox to open menu for a manipulating columns\n   *\n   * @returns {Element}\n   */\n  createToolbox() {\n    const t = c(\"div\", [\n      u.CSS.toolbox,\n      this.cssModifier ? `${u.CSS.toolbox}--${this.cssModifier}` : \"\"\n    ]);\n    t.dataset.mutationFree = \"true\";\n    const e = this.createPopover(), o = this.createToggler();\n    return t.appendChild(o), t.appendChild(e), t;\n  }\n  /**\n   * Creates the Toggler\n   *\n   * @returns {Element}\n   */\n  createToggler() {\n    const t = c(\"div\", u.CSS.toggler, {\n      innerHTML: T\n    });\n    return t.addEventListener(\"click\", () => {\n      this.togglerClicked();\n    }), t;\n  }\n  /**\n   * Creates the Popover instance and render it\n   *\n   * @returns {Element}\n   */\n  createPopover() {\n    return this.popover = new a({\n      items: this.items\n    }), this.popover.render();\n  }\n  /**\n   * Toggler click handler. Opens/Closes the popover\n   *\n   * @returns {void}\n   */\n  togglerClicked() {\n    this.popover.opened ? (this.popover.close(), this.onClose()) : (this.popover.open(), this.onOpen());\n  }\n  /**\n   * Shows the Toolbox\n   *\n   * @param {function} computePositionMethod - method that returns the position coordinate\n   * @returns {void}\n   */\n  show(t) {\n    const e = t();\n    Object.entries(e).forEach(([o, i]) => {\n      this.wrapper.style[o] = i;\n    }), this.wrapper.classList.add(u.CSS.toolboxShowed);\n  }\n  /**\n   * Hides the Toolbox\n   *\n   * @returns {void}\n   */\n  hide() {\n    this.popover.close(), this.wrapper.classList.remove(u.CSS.toolboxShowed);\n  }\n}\nfunction H(d, t) {\n  let e = 0;\n  return function(...o) {\n    const i = (/* @__PURE__ */ new Date()).getTime();\n    if (!(i - e < d))\n      return e = i, t(...o);\n  };\n}\nconst r = {\n  wrapper: \"tc-wrap\",\n  wrapperReadOnly: \"tc-wrap--readonly\",\n  table: \"tc-table\",\n  row: \"tc-row\",\n  withHeadings: \"tc-table--heading\",\n  rowSelected: \"tc-row--selected\",\n  cell: \"tc-cell\",\n  cellSelected: \"tc-cell--selected\",\n  addRow: \"tc-add-row\",\n  addColumn: \"tc-add-column\"\n};\nclass A {\n  /**\n   * Creates\n   *\n   * @constructor\n   * @param {boolean} readOnly - read-only mode flag\n   * @param {object} api - Editor.js API\n   * @param {TableData} data - Editor.js API\n   * @param {TableConfig} config - Editor.js API\n   */\n  constructor(t, e, o, i) {\n    this.readOnly = t, this.api = e, this.data = o, this.config = i, this.wrapper = null, this.table = null, this.toolboxColumn = this.createColumnToolbox(), this.toolboxRow = this.createRowToolbox(), this.createTableWrapper(), this.hoveredRow = 0, this.hoveredColumn = 0, this.selectedRow = 0, this.selectedColumn = 0, this.tunes = {\n      withHeadings: !1\n    }, this.resize(), this.fill(), this.focusedCell = {\n      row: 0,\n      column: 0\n    }, this.documentClicked = (s) => {\n      const n = s.target.closest(`.${r.table}`) !== null, h = s.target.closest(`.${r.wrapper}`) === null;\n      (n || h) && this.hideToolboxes();\n      const w = s.target.closest(`.${r.addRow}`), p = s.target.closest(`.${r.addColumn}`);\n      w && w.parentNode === this.wrapper ? (this.addRow(void 0, !0), this.hideToolboxes()) : p && p.parentNode === this.wrapper && (this.addColumn(void 0, !0), this.hideToolboxes());\n    }, this.readOnly || this.bindEvents();\n  }\n  /**\n   * Returns the rendered table wrapper\n   *\n   * @returns {Element}\n   */\n  getWrapper() {\n    return this.wrapper;\n  }\n  /**\n   * Hangs the necessary handlers to events\n   */\n  bindEvents() {\n    document.addEventListener(\"click\", this.documentClicked), this.table.addEventListener(\"mousemove\", H(150, (t) => this.onMouseMoveInTable(t)), { passive: !0 }), this.table.onkeypress = (t) => this.onKeyPressListener(t), this.table.addEventListener(\"keydown\", (t) => this.onKeyDownListener(t)), this.table.addEventListener(\"focusin\", (t) => this.focusInTableListener(t));\n  }\n  /**\n   * Configures and creates the toolbox for manipulating with columns\n   *\n   * @returns {Toolbox}\n   */\n  createColumnToolbox() {\n    return new u({\n      api: this.api,\n      cssModifier: \"column\",\n      items: [\n        {\n          label: this.api.i18n.t(\"Add column to left\"),\n          icon: S,\n          onClick: () => {\n            this.addColumn(this.selectedColumn, !0), this.hideToolboxes();\n          }\n        },\n        {\n          label: this.api.i18n.t(\"Add column to right\"),\n          icon: x,\n          onClick: () => {\n            this.addColumn(this.selectedColumn + 1, !0), this.hideToolboxes();\n          }\n        },\n        {\n          label: this.api.i18n.t(\"Delete column\"),\n          icon: b,\n          hideIf: () => this.numberOfColumns === 1,\n          confirmationRequired: !0,\n          onClick: () => {\n            this.deleteColumn(this.selectedColumn), this.hideToolboxes();\n          }\n        }\n      ],\n      onOpen: () => {\n        this.selectColumn(this.hoveredColumn), this.hideRowToolbox();\n      },\n      onClose: () => {\n        this.unselectColumn();\n      }\n    });\n  }\n  /**\n   * Configures and creates the toolbox for manipulating with rows\n   *\n   * @returns {Toolbox}\n   */\n  createRowToolbox() {\n    return new u({\n      api: this.api,\n      cssModifier: \"row\",\n      items: [\n        {\n          label: this.api.i18n.t(\"Add row above\"),\n          icon: y,\n          onClick: () => {\n            this.addRow(this.selectedRow, !0), this.hideToolboxes();\n          }\n        },\n        {\n          label: this.api.i18n.t(\"Add row below\"),\n          icon: k,\n          onClick: () => {\n            this.addRow(this.selectedRow + 1, !0), this.hideToolboxes();\n          }\n        },\n        {\n          label: this.api.i18n.t(\"Delete row\"),\n          icon: b,\n          hideIf: () => this.numberOfRows === 1,\n          confirmationRequired: !0,\n          onClick: () => {\n            this.deleteRow(this.selectedRow), this.hideToolboxes();\n          }\n        }\n      ],\n      onOpen: () => {\n        this.selectRow(this.hoveredRow), this.hideColumnToolbox();\n      },\n      onClose: () => {\n        this.unselectRow();\n      }\n    });\n  }\n  /**\n   * When you press enter it moves the cursor down to the next row\n   * or creates it if the click occurred on the last one\n   */\n  moveCursorToNextRow() {\n    this.focusedCell.row !== this.numberOfRows ? (this.focusedCell.row += 1, this.focusCell(this.focusedCell)) : (this.addRow(), this.focusedCell.row += 1, this.focusCell(this.focusedCell), this.updateToolboxesPosition(0, 0));\n  }\n  /**\n   * Get table cell by row and col index\n   *\n   * @param {number} row - cell row coordinate\n   * @param {number} column - cell column coordinate\n   * @returns {HTMLElement}\n   */\n  getCell(t, e) {\n    return this.table.querySelectorAll(`.${r.row}:nth-child(${t}) .${r.cell}`)[e - 1];\n  }\n  /**\n   * Get table row by index\n   *\n   * @param {number} row - row coordinate\n   * @returns {HTMLElement}\n   */\n  getRow(t) {\n    return this.table.querySelector(`.${r.row}:nth-child(${t})`);\n  }\n  /**\n   * The parent of the cell which is the row\n   *\n   * @param {HTMLElement} cell - cell element\n   * @returns {HTMLElement}\n   */\n  getRowByCell(t) {\n    return t.parentElement;\n  }\n  /**\n   * Ger row's first cell\n   *\n   * @param {Element} row - row to find its first cell\n   * @returns {Element}\n   */\n  getRowFirstCell(t) {\n    return t.querySelector(`.${r.cell}:first-child`);\n  }\n  /**\n   * Set the sell's content by row and column numbers\n   *\n   * @param {number} row - cell row coordinate\n   * @param {number} column - cell column coordinate\n   * @param {string} content - cell HTML content\n   */\n  setCellContent(t, e, o) {\n    const i = this.getCell(t, e);\n    i.innerHTML = o;\n  }\n  /**\n   * Add column in table on index place\n   * Add cells in each row\n   *\n   * @param {number} columnIndex - number in the array of columns, where new column to insert, -1 if insert at the end\n   * @param {boolean} [setFocus] - pass true to focus the first cell\n   */\n  addColumn(t = -1, e = !1) {\n    let o = this.numberOfColumns;\n    for (let i = 1; i <= this.numberOfRows; i++) {\n      let s;\n      const n = this.createCell();\n      if (t > 0 && t <= o ? (s = this.getCell(i, t), C(n, s)) : s = this.getRow(i).appendChild(n), i === 1) {\n        const h = this.getCell(i, t > 0 ? t : o + 1);\n        h && e && m(h);\n      }\n    }\n    this.addHeadingAttrToFirstRow();\n  }\n  /**\n   * Add row in table on index place\n   *\n   * @param {number} index - number in the array of rows, where new column to insert, -1 if insert at the end\n   * @param {boolean} [setFocus] - pass true to focus the inserted row\n   * @returns {HTMLElement} row\n   */\n  addRow(t = -1, e = !1) {\n    let o, i = c(\"div\", r.row);\n    this.tunes.withHeadings && this.removeHeadingAttrFromFirstRow();\n    let s = this.numberOfColumns;\n    if (t > 0 && t <= this.numberOfRows) {\n      let h = this.getRow(t);\n      o = C(i, h);\n    } else\n      o = this.table.appendChild(i);\n    this.fillRow(o, s), this.tunes.withHeadings && this.addHeadingAttrToFirstRow();\n    const n = this.getRowFirstCell(o);\n    return n && e && m(n), o;\n  }\n  /**\n   * Delete a column by index\n   *\n   * @param {number} index\n   */\n  deleteColumn(t) {\n    for (let e = 1; e <= this.numberOfRows; e++) {\n      const o = this.getCell(e, t);\n      if (!o)\n        return;\n      o.remove();\n    }\n  }\n  /**\n   * Delete a row by index\n   *\n   * @param {number} index\n   */\n  deleteRow(t) {\n    this.getRow(t).remove(), this.addHeadingAttrToFirstRow();\n  }\n  /**\n   * Create a wrapper containing a table, toolboxes\n   * and buttons for adding rows and columns\n   *\n   * @returns {HTMLElement} wrapper - where all buttons for a table and the table itself will be\n   */\n  createTableWrapper() {\n    if (this.wrapper = c(\"div\", r.wrapper), this.table = c(\"div\", r.table), this.readOnly && this.wrapper.classList.add(r.wrapperReadOnly), this.wrapper.appendChild(this.toolboxRow.element), this.wrapper.appendChild(this.toolboxColumn.element), this.wrapper.appendChild(this.table), !this.readOnly) {\n      const t = c(\"div\", r.addColumn, {\n        innerHTML: v\n      }), e = c(\"div\", r.addRow, {\n        innerHTML: v\n      });\n      this.wrapper.appendChild(t), this.wrapper.appendChild(e);\n    }\n  }\n  /**\n   * Returns the size of the table based on initial data or config \"size\" property\n   *\n   * @return {{rows: number, cols: number}} - number of cols and rows\n   */\n  computeInitialSize() {\n    const t = this.data && this.data.content, e = Array.isArray(t), o = e ? t.length : !1, i = e ? t.length : void 0, s = o ? t[0].length : void 0, n = Number.parseInt(this.config && this.config.rows), h = Number.parseInt(this.config && this.config.cols), l = !isNaN(n) && n > 0 ? n : void 0, w = !isNaN(h) && h > 0 ? h : void 0;\n    return {\n      rows: i || l || 2,\n      cols: s || w || 2\n    };\n  }\n  /**\n   * Resize table to match config size or transmitted data size\n   *\n   * @return {{rows: number, cols: number}} - number of cols and rows\n   */\n  resize() {\n    const { rows: t, cols: e } = this.computeInitialSize();\n    for (let o = 0; o < t; o++)\n      this.addRow();\n    for (let o = 0; o < e; o++)\n      this.addColumn();\n  }\n  /**\n   * Fills the table with data passed to the constructor\n   *\n   * @returns {void}\n   */\n  fill() {\n    const t = this.data;\n    if (t && t.content)\n      for (let e = 0; e < t.content.length; e++)\n        for (let o = 0; o < t.content[e].length; o++)\n          this.setCellContent(e + 1, o + 1, t.content[e][o]);\n  }\n  /**\n   * Fills a row with cells\n   *\n   * @param {HTMLElement} row - row to fill\n   * @param {number} numberOfColumns - how many cells should be in a row\n   */\n  fillRow(t, e) {\n    for (let o = 1; o <= e; o++) {\n      const i = this.createCell();\n      t.appendChild(i);\n    }\n  }\n  /**\n   * Creating a cell element\n   *\n   * @return {Element}\n   */\n  createCell() {\n    return c(\"div\", r.cell, {\n      contentEditable: !this.readOnly\n    });\n  }\n  /**\n   * Get number of rows in the table\n   */\n  get numberOfRows() {\n    return this.table.childElementCount;\n  }\n  /**\n   * Get number of columns in the table\n   */\n  get numberOfColumns() {\n    return this.numberOfRows ? this.table.querySelectorAll(`.${r.row}:first-child .${r.cell}`).length : 0;\n  }\n  /**\n   * Is the column toolbox menu displayed or not\n   *\n   * @returns {boolean}\n   */\n  get isColumnMenuShowing() {\n    return this.selectedColumn !== 0;\n  }\n  /**\n   * Is the row toolbox menu displayed or not\n   *\n   * @returns {boolean}\n   */\n  get isRowMenuShowing() {\n    return this.selectedRow !== 0;\n  }\n  /**\n   * Recalculate position of toolbox icons\n   *\n   * @param {Event} event - mouse move event\n   */\n  onMouseMoveInTable(t) {\n    const { row: e, column: o } = this.getHoveredCell(t);\n    this.hoveredColumn = o, this.hoveredRow = e, this.updateToolboxesPosition();\n  }\n  /**\n   * Prevents default Enter behaviors\n   * Adds Shift+Enter processing\n   *\n   * @param {KeyboardEvent} event - keypress event\n   */\n  onKeyPressListener(t) {\n    if (t.key === \"Enter\") {\n      if (t.shiftKey)\n        return !0;\n      this.moveCursorToNextRow();\n    }\n    return t.key !== \"Enter\";\n  }\n  /**\n   * Prevents tab keydown event from bubbling\n   * so that it only works inside the table\n   *\n   * @param {KeyboardEvent} event - keydown event\n   */\n  onKeyDownListener(t) {\n    t.key === \"Tab\" && t.stopPropagation();\n  }\n  /**\n   * Set the coordinates of the cell that the focus has moved to\n   *\n   * @param {FocusEvent} event - focusin event\n   */\n  focusInTableListener(t) {\n    const e = t.target, o = this.getRowByCell(e);\n    this.focusedCell = {\n      row: Array.from(this.table.querySelectorAll(`.${r.row}`)).indexOf(o) + 1,\n      column: Array.from(o.querySelectorAll(`.${r.cell}`)).indexOf(e) + 1\n    };\n  }\n  /**\n   * Unselect row/column\n   * Close toolbox menu\n   * Hide toolboxes\n   *\n   * @returns {void}\n   */\n  hideToolboxes() {\n    this.hideRowToolbox(), this.hideColumnToolbox(), this.updateToolboxesPosition();\n  }\n  /**\n   * Unselect row, close toolbox\n   *\n   * @returns {void}\n   */\n  hideRowToolbox() {\n    this.unselectRow(), this.toolboxRow.hide();\n  }\n  /**\n   * Unselect column, close toolbox\n   *\n   * @returns {void}\n   */\n  hideColumnToolbox() {\n    this.unselectColumn(), this.toolboxColumn.hide();\n  }\n  /**\n   * Set the cursor focus to the focused cell\n   *\n   * @returns {void}\n   */\n  focusCell() {\n    this.focusedCellElem.focus();\n  }\n  /**\n   * Get current focused element\n   *\n   * @returns {HTMLElement} - focused cell\n   */\n  get focusedCellElem() {\n    const { row: t, column: e } = this.focusedCell;\n    return this.getCell(t, e);\n  }\n  /**\n   * Update toolboxes position\n   *\n   * @param {number} row - hovered row\n   * @param {number} column - hovered column\n   */\n  updateToolboxesPosition(t = this.hoveredRow, e = this.hoveredColumn) {\n    this.isColumnMenuShowing || e > 0 && e <= this.numberOfColumns && this.toolboxColumn.show(() => ({\n      left: `calc((100% - var(--cell-size)) / (${this.numberOfColumns} * 2) * (1 + (${e} - 1) * 2))`\n    })), this.isRowMenuShowing || t > 0 && t <= this.numberOfRows && this.toolboxRow.show(() => {\n      const o = this.getRow(t), { fromTopBorder: i } = g(this.table, o), { height: s } = o.getBoundingClientRect();\n      return {\n        top: `${Math.ceil(i + s / 2)}px`\n      };\n    });\n  }\n  /**\n   * Makes the first row headings\n   *\n   * @param {boolean} withHeadings - use headings row or not\n   */\n  setHeadingsSetting(t) {\n    this.tunes.withHeadings = t, t ? (this.table.classList.add(r.withHeadings), this.addHeadingAttrToFirstRow()) : (this.table.classList.remove(r.withHeadings), this.removeHeadingAttrFromFirstRow());\n  }\n  /**\n   * Adds an attribute for displaying the placeholder in the cell\n   */\n  addHeadingAttrToFirstRow() {\n    for (let t = 1; t <= this.numberOfColumns; t++) {\n      let e = this.getCell(1, t);\n      e && e.setAttribute(\"heading\", this.api.i18n.t(\"Heading\"));\n    }\n  }\n  /**\n   * Removes an attribute for displaying the placeholder in the cell\n   */\n  removeHeadingAttrFromFirstRow() {\n    for (let t = 1; t <= this.numberOfColumns; t++) {\n      let e = this.getCell(1, t);\n      e && e.removeAttribute(\"heading\");\n    }\n  }\n  /**\n   * Add effect of a selected row\n   *\n   * @param {number} index\n   */\n  selectRow(t) {\n    const e = this.getRow(t);\n    e && (this.selectedRow = t, e.classList.add(r.rowSelected));\n  }\n  /**\n   * Remove effect of a selected row\n   */\n  unselectRow() {\n    if (this.selectedRow <= 0)\n      return;\n    const t = this.table.querySelector(`.${r.rowSelected}`);\n    t && t.classList.remove(r.rowSelected), this.selectedRow = 0;\n  }\n  /**\n   * Add effect of a selected column\n   *\n   * @param {number} index\n   */\n  selectColumn(t) {\n    for (let e = 1; e <= this.numberOfRows; e++) {\n      const o = this.getCell(e, t);\n      o && o.classList.add(r.cellSelected);\n    }\n    this.selectedColumn = t;\n  }\n  /**\n   * Remove effect of a selected column\n   */\n  unselectColumn() {\n    if (this.selectedColumn <= 0)\n      return;\n    let t = this.table.querySelectorAll(`.${r.cellSelected}`);\n    Array.from(t).forEach((e) => {\n      e.classList.remove(r.cellSelected);\n    }), this.selectedColumn = 0;\n  }\n  /**\n   * Calculates the row and column that the cursor is currently hovering over\n   * The search was optimized from O(n) to O (log n) via bin search to reduce the number of calculations\n   *\n   * @param {Event} event - mousemove event\n   * @returns hovered cell coordinates as an integer row and column\n   */\n  getHoveredCell(t) {\n    let e = this.hoveredRow, o = this.hoveredColumn;\n    const { width: i, height: s, x: n, y: h } = R(this.table, t);\n    return n >= 0 && (o = this.binSearch(\n      this.numberOfColumns,\n      (l) => this.getCell(1, l),\n      ({ fromLeftBorder: l }) => n < l,\n      ({ fromRightBorder: l }) => n > i - l\n    )), h >= 0 && (e = this.binSearch(\n      this.numberOfRows,\n      (l) => this.getCell(l, 1),\n      ({ fromTopBorder: l }) => h < l,\n      ({ fromBottomBorder: l }) => h > s - l\n    )), {\n      row: e || this.hoveredRow,\n      column: o || this.hoveredColumn\n    };\n  }\n  /**\n   * Looks for the index of the cell the mouse is hovering over.\n   * Cells can be represented as ordered intervals with left and\n   * right (upper and lower for rows) borders inside the table, if the mouse enters it, then this is our index\n   *\n   * @param {number} numberOfCells - upper bound of binary search\n   * @param {function} getCell - function to take the currently viewed cell\n   * @param {function} beforeTheLeftBorder - determines the cursor position, to the left of the cell or not\n   * @param {function} afterTheRightBorder - determines the cursor position, to the right of the cell or not\n   * @returns {number}\n   */\n  binSearch(t, e, o, i) {\n    let s = 0, n = t + 1, h = 0, l;\n    for (; s < n - 1 && h < 10; ) {\n      l = Math.ceil((s + n) / 2);\n      const w = e(l), p = g(this.table, w);\n      if (o(p))\n        n = l;\n      else if (i(p))\n        s = l;\n      else\n        break;\n      h++;\n    }\n    return l;\n  }\n  /**\n   * Collects data from cells into a two-dimensional array\n   *\n   * @returns {string[][]}\n   */\n  getData() {\n    const t = [];\n    for (let e = 1; e <= this.numberOfRows; e++) {\n      const o = this.table.querySelector(`.${r.row}:nth-child(${e})`), i = Array.from(o.querySelectorAll(`.${r.cell}`));\n      i.every((n) => !n.textContent.trim()) || t.push(i.map((n) => n.innerHTML));\n    }\n    return t;\n  }\n  /**\n   * Remove listeners on the document\n   */\n  destroy() {\n    document.removeEventListener(\"click\", this.documentClicked);\n  }\n}\nclass I {\n  /**\n   * Notify core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Allow to press Enter inside the CodeTool textarea\n   *\n   * @returns {boolean}\n   * @public\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {TableData} data — previously saved data\n   * @param {TableConfig} config - user config for Tool\n   * @param {object} api - Editor.js API\n   * @param {boolean} readOnly - read-only mode flag\n   */\n  constructor({ data: t, config: e, api: o, readOnly: i }) {\n    this.api = o, this.readOnly = i, this.config = e, this.data = {\n      withHeadings: this.getConfig(\"withHeadings\", !1, t),\n      content: t && t.content ? t.content : []\n    }, this.table = null;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: O,\n      title: \"Table\"\n    };\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement}\n   */\n  render() {\n    return this.table = new A(this.readOnly, this.api, this.data, this.config), this.container = c(\"div\", this.api.styles.block), this.container.appendChild(this.table.getWrapper()), this.table.setHeadingsSetting(this.data.withHeadings), this.container;\n  }\n  /**\n   * Returns plugin settings\n   *\n   * @returns {Array}\n   */\n  renderSettings() {\n    return [\n      {\n        label: this.api.i18n.t(\"With headings\"),\n        icon: L,\n        isActive: this.data.withHeadings,\n        closeOnActivate: !0,\n        toggle: !0,\n        onActivate: () => {\n          this.data.withHeadings = !0, this.table.setHeadingsSetting(this.data.withHeadings);\n        }\n      },\n      {\n        label: this.api.i18n.t(\"Without headings\"),\n        icon: M,\n        isActive: !this.data.withHeadings,\n        closeOnActivate: !0,\n        toggle: !0,\n        onActivate: () => {\n          this.data.withHeadings = !1, this.table.setHeadingsSetting(this.data.withHeadings);\n        }\n      }\n    ];\n  }\n  /**\n   * Extract table data from the view\n   *\n   * @returns {TableData} - saved data\n   */\n  save() {\n    const t = this.table.getData();\n    return {\n      withHeadings: this.data.withHeadings,\n      content: t\n    };\n  }\n  /**\n   * Plugin destroyer\n   *\n   * @returns {void}\n   */\n  destroy() {\n    this.table.destroy();\n  }\n  /**\n   * A helper to get config value.\n   * \n   * @param {string} configName - the key to get from the config. \n   * @param {any} defaultValue - default value if config doesn't have passed key\n   * @param {object} savedData - previously saved data. If passed, the key will be got from there, otherwise from the config\n   * @returns {any} - config value.\n   */\n  getConfig(t, e = void 0, o = void 0) {\n    const i = this.data || o;\n    return i ? i[t] ? i[t] : e : this.config && this.config[t] ? this.config[t] : e;\n  }\n  /**  \n   * Table onPaste configuration\n   *\n   * @public\n   */\n  static get pasteConfig() {\n    return { tags: [\"TABLE\", \"TR\", \"TH\", \"TD\"] };\n  }\n  /**\n   * On paste callback that is fired from Editor\n   *\n   * @param {PasteEvent} event - event with pasted data\n   */\n  onPaste(t) {\n    const e = t.detail.data, o = e.querySelector(\":scope > thead, tr:first-of-type th\"), s = Array.from(e.querySelectorAll(\"tr\")).map((n) => Array.from(n.querySelectorAll(\"th, td\")).map((l) => l.innerHTML));\n    this.data = {\n      withHeadings: o !== null,\n      content: s\n    }, this.table.wrapper && this.table.wrapper.replaceWith(this.render());\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL3RhYmxlL2Rpc3QvdGFibGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSx3QkFBd0Isc0NBQXNDLGdEQUFnRCwyQkFBMkIsK0JBQStCLHVCQUF1QixpQkFBaUIseUJBQXlCLHNCQUFzQixzRkFBc0YsY0FBYyxrQkFBa0IsWUFBWSxXQUFXLG9DQUFvQyxzQkFBc0IsYUFBYSxxRUFBcUUsbUJBQW1CLDRDQUE0QyxhQUFhLG1CQUFtQixhQUFhLFNBQVMsc0NBQXNDLHdCQUF3QixzQkFBc0IsNkNBQTZDLGFBQWEsdUJBQXVCLGNBQWMsVUFBVSxrQkFBa0IsV0FBVyxZQUFZLGFBQWEsZUFBZSx5Q0FBeUMsZ0JBQWdCLGdCQUFnQiw2QkFBNkIsWUFBWSwrQkFBK0IsTUFBTSxpQ0FBaUMsa0JBQWtCLFdBQVcsaUJBQWlCLFdBQVcsd0NBQXdDLDhDQUE4QyxPQUFPLHVDQUF1QyxnQkFBZ0IsNENBQTRDLHNFQUFzRSxzQkFBc0Isa0NBQWtDLDZDQUE2QyxZQUFZLDRDQUE0QywyQkFBMkIsYUFBYSxrQ0FBa0MsYUFBYSxRQUFRLGNBQWMsZUFBZSxjQUFjLHVCQUF1Qix5Q0FBeUMsYUFBYSxlQUFlLGNBQWMsWUFBWSx3QkFBd0IsbUJBQW1CLGlCQUFpQixrQkFBa0IsbUJBQW1CLFdBQVcsa0JBQWtCLGdDQUFnQyx1QkFBdUIsWUFBWSxhQUFhLFlBQVksY0FBYywyQkFBMkIsY0FBYyxlQUFlLDZCQUE2Qix1Q0FBdUMscUNBQXFDLHlDQUF5QyxZQUFZLGVBQWUseUJBQXlCLGVBQWUseUNBQXlDLFFBQVEsYUFBYSx3REFBd0Qsa0JBQWtCLDRDQUE0QyxjQUFjLFdBQVcsb0JBQW9CLGtCQUFrQix1QkFBdUIsWUFBWSxZQUFZLGdDQUFnQyw0Q0FBNEMsa0JBQWtCLG1DQUFtQyx3QkFBd0IsbUNBQW1DLFNBQVMsMkNBQTJDLGlCQUFpQixnQkFBZ0IsYUFBYSxrQkFBa0IsbUJBQW1CLG1DQUFtQyxpQ0FB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ckIsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWVkaXRvcmpzLWFwcC8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvdGFibGUvZGlzdC90YWJsZS5tanM/NWIzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt0cnl7aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXt2YXIgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7by5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLnRjLXdyYXB7LS1jb2xvci1iYWNrZ3JvdW5kOiNmOWY5ZmI7LS1jb2xvci10ZXh0LXNlY29uZGFyeTojN2I3ZTg5Oy0tY29sb3ItYm9yZGVyOiNlOGU4ZWI7LS1jZWxsLXNpemU6MzRweDstLXRvb2xib3gtaWNvbi1zaXplOjE4cHg7LS10b29sYm94LXBhZGRpbmc6NnB4Oy0tdG9vbGJveC1haW1pbmctZmllbGQtc2l6ZTpjYWxjKHZhcigtLXRvb2xib3gtaWNvbi1zaXplKSArIHZhcigtLXRvb2xib3gtcGFkZGluZykqMik7Ym9yZGVyLWxlZnQ6MDtwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO21hcmdpbi10b3A6dmFyKC0tdG9vbGJveC1pY29uLXNpemUpO2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOmNhbGMoMTAwJSAtIHZhcigtLWNlbGwtc2l6ZSkpIHZhcigtLWNlbGwtc2l6ZSl9LnRjLXdyYXAtLXJlYWRvbmx5e2dyaWQtdGVtcGxhdGUtY29sdW1uczoxMDAlIHZhcigtLWNlbGwtc2l6ZSl9LnRjLXdyYXAgc3Zne3ZlcnRpY2FsLWFsaWduOnRvcH1AbWVkaWEgcHJpbnR7LnRjLXdyYXB7Ym9yZGVyLWxlZnQtY29sb3I6dmFyKC0tY29sb3ItYm9yZGVyKTtib3JkZXItbGVmdC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDoxcHg7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOjEwMCUgdmFyKC0tY2VsbC1zaXplKX19QG1lZGlhIHByaW50ey50Yy13cmFwIC50Yy1yb3c6YWZ0ZXJ7ZGlzcGxheTpub25lfX0udGMtdGFibGV7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtkaXNwbGF5OmdyaWQ7Zm9udC1zaXplOjE0cHg7Ym9yZGVyLXRvcDoxcHggc29saWQgdmFyKC0tY29sb3ItYm9yZGVyKTtsaW5lLWhlaWdodDoxLjR9LnRjLXRhYmxlOmFmdGVye3dpZHRoOmNhbGModmFyKC0tY2VsbC1zaXplKSk7aGVpZ2h0OjEwMCU7bGVmdDpjYWxjKHZhcigtLWNlbGwtc2l6ZSkqLTEpO3RvcDowfS50Yy10YWJsZTphZnRlciwudGMtdGFibGU6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO2NvbnRlbnQ6XCJcIn0udGMtdGFibGU6YmVmb3Jle3dpZHRoOjEwMCU7aGVpZ2h0OnZhcigtLXRvb2xib3gtYWltaW5nLWZpZWxkLXNpemUpO3RvcDpjYWxjKHZhcigtLXRvb2xib3gtYWltaW5nLWZpZWxkLXNpemUpKi0xKTtsZWZ0OjB9LnRjLXRhYmxlLS1oZWFkaW5nIC50Yy1yb3c6Zmlyc3QtY2hpbGR7Zm9udC13ZWlnaHQ6NjAwO2JvcmRlci1ib3R0b206MnB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlcil9LnRjLXRhYmxlLS1oZWFkaW5nIC50Yy1yb3c6Zmlyc3QtY2hpbGQgW2NvbnRlbnRlZGl0YWJsZV06ZW1wdHk6YmVmb3Jle2NvbnRlbnQ6YXR0cihoZWFkaW5nKTtjb2xvcjp2YXIoLS1jb2xvci10ZXh0LXNlY29uZGFyeSl9LnRjLXRhYmxlLS1oZWFkaW5nIC50Yy1yb3c6Zmlyc3QtY2hpbGQ6YWZ0ZXJ7Ym90dG9tOi0ycHg7Ym9yZGVyLWJvdHRvbToycHggc29saWQgdmFyKC0tY29sb3ItYm9yZGVyKX0udGMtYWRkLWNvbHVtbiwudGMtYWRkLXJvd3tkaXNwbGF5OmZsZXg7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpfUBtZWRpYSBwcmludHsudGMtYWRke2Rpc3BsYXk6bm9uZX19LnRjLWFkZC1jb2x1bW57cGFkZGluZzo0cHggMDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JvcmRlci10b3A6MXB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlcil9QG1lZGlhIHByaW50ey50Yy1hZGQtY29sdW1ue2Rpc3BsYXk6bm9uZX19LnRjLWFkZC1yb3d7aGVpZ2h0OnZhcigtLWNlbGwtc2l6ZSk7YWxpZ24taXRlbXM6Y2VudGVyO3BhZGRpbmctbGVmdDo0cHg7cG9zaXRpb246cmVsYXRpdmV9LnRjLWFkZC1yb3c6YmVmb3Jle2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDpjYWxjKHZhcigtLWNlbGwtc2l6ZSkqLTEpO3dpZHRoOnZhcigtLWNlbGwtc2l6ZSk7aGVpZ2h0OjEwMCV9QG1lZGlhIHByaW50ey50Yy1hZGQtcm93e2Rpc3BsYXk6bm9uZX19LnRjLWFkZC1jb2x1bW4sLnRjLWFkZC1yb3d7dHJhbnNpdGlvbjowcztjdXJzb3I6cG9pbnRlcjt3aWxsLWNoYW5nZTpiYWNrZ3JvdW5kLWNvbG9yfS50Yy1hZGQtY29sdW1uOmhvdmVyLC50Yy1hZGQtcm93OmhvdmVye3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuMXMgZWFzZTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yLWJhY2tncm91bmQpfS50Yy1hZGQtcm93e21hcmdpbi10b3A6MXB4fS50Yy1hZGQtcm93OmhvdmVyOmJlZm9yZXt0cmFuc2l0aW9uOi4xcztiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yLWJhY2tncm91bmQpfS50Yy1yb3d7ZGlzcGxheTpncmlkO2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoYXV0by1maXQsbWlubWF4KDEwcHgsMWZyKSk7cG9zaXRpb246cmVsYXRpdmU7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgdmFyKC0tY29sb3ItYm9yZGVyKX0udGMtcm93OmFmdGVye2NvbnRlbnQ6XCJcIjtwb2ludGVyLWV2ZW50czpub25lO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOnZhcigtLWNlbGwtc2l6ZSk7aGVpZ2h0OjEwMCU7Ym90dG9tOi0xcHg7cmlnaHQ6Y2FsYyh2YXIoLS1jZWxsLXNpemUpKi0xKTtib3JkZXItYm90dG9tOjFweCBzb2xpZCB2YXIoLS1jb2xvci1ib3JkZXIpfS50Yy1yb3ctLXNlbGVjdGVke2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZCl9LnRjLXJvdy0tc2VsZWN0ZWQ6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kKX0udGMtY2VsbHtib3JkZXItcmlnaHQ6MXB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlcik7cGFkZGluZzo2cHggMTJweDtvdmVyZmxvdzpoaWRkZW47b3V0bGluZTpub25lO2xpbmUtYnJlYWs6bm9ybWFsfS50Yy1jZWxsLS1zZWxlY3RlZHtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQpfS50Yy13cmFwLS1yZWFkb25seSAudGMtcm93OmFmdGVye2Rpc3BsYXk6bm9uZX0udGMtdG9vbGJveHstLXRvb2xib3gtcGFkZGluZzo2cHg7LS1wb3BvdmVyLW1hcmdpbjozMHB4Oy0tdG9nZ2xlci1jbGljay16b25lLXNpemU6MzBweDstLXRvZ2dsZXItZG90cy1jb2xvcjojN2I3ZTg5Oy0tdG9nZ2xlci1kb3RzLWNvbG9yLWhvdmVyZWQ6IzFkMjAyYjtwb3NpdGlvbjphYnNvbHV0ZTtjdXJzb3I6cG9pbnRlcjt6LWluZGV4OjE7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuMXM7d2lsbC1jaGFuZ2U6bGVmdCxvcGFjaXR5fS50Yy10b29sYm94LS1jb2x1bW57dG9wOmNhbGModmFyKC0tdG9nZ2xlci1jbGljay16b25lLXNpemUpKi0xKTt0cmFuc2Zvcm06dHJhbnNsYXRlKGNhbGModmFyKC0tdG9nZ2xlci1jbGljay16b25lLXNpemUpKi0xLzIpKTt3aWxsLWNoYW5nZTpsZWZ0LG9wYWNpdHl9LnRjLXRvb2xib3gtLXJvd3tsZWZ0OmNhbGModmFyKC0tcG9wb3Zlci1tYXJnaW4pKi0xKTt0cmFuc2Zvcm06dHJhbnNsYXRlWShjYWxjKHZhcigtLXRvZ2dsZXItY2xpY2stem9uZS1zaXplKSotMS8yKSk7bWFyZ2luLXRvcDotMXB4O3dpbGwtY2hhbmdlOnRvcCxvcGFjaXR5fS50Yy10b29sYm94LS1zaG93ZWR7b3BhY2l0eToxfS50Yy10b29sYm94IC50Yy1wb3BvdmVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6dmFyKC0tcG9wb3Zlci1tYXJnaW4pfS50Yy10b29sYm94X190b2dnbGVye2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDp2YXIoLS10b2dnbGVyLWNsaWNrLXpvbmUtc2l6ZSk7aGVpZ2h0OnZhcigtLXRvZ2dsZXItY2xpY2stem9uZS1zaXplKTtjb2xvcjp2YXIoLS10b2dnbGVyLWRvdHMtY29sb3IpO29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjE1cyBlYXNlO3dpbGwtY2hhbmdlOm9wYWNpdHl9LnRjLXRvb2xib3hfX3RvZ2dsZXI6aG92ZXJ7Y29sb3I6dmFyKC0tdG9nZ2xlci1kb3RzLWNvbG9yLWhvdmVyZWQpfS50Yy10b29sYm94X190b2dnbGVyIHN2Z3tmaWxsOmN1cnJlbnRDb2xvcn0udGMtd3JhcDpob3ZlciAudGMtdG9vbGJveF9fdG9nZ2xlcntvcGFjaXR5OjF9LnRjLXNldHRpbmdzIC5jZHgtc2V0dGluZ3MtYnV0dG9ue3dpZHRoOjUwJTttYXJnaW46MH0udGMtcG9wb3ZlcnstLWNvbG9yLWJvcmRlcjojZWFlYWVhOy0tY29sb3ItYmFja2dyb3VuZDojZmZmOy0tY29sb3ItYmFja2dyb3VuZC1ob3ZlcjpyZ2JhKDIzMiwyMzIsMjM1LC40OSk7LS1jb2xvci1iYWNrZ3JvdW5kLWNvbmZpcm06I2UyNGE0YTstLWNvbG9yLWJhY2tncm91bmQtY29uZmlybS1ob3ZlcjojZDU0MDQwOy0tY29sb3ItdGV4dC1jb25maXJtOiNmZmY7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlcik7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggIzBkMTQyMTIxO2JvcmRlci1yYWRpdXM6NnB4O3BhZGRpbmc6NnB4O2Rpc3BsYXk6bm9uZTt3aWxsLWNoYW5nZTpvcGFjaXR5LHRyYW5zZm9ybX0udGMtcG9wb3Zlci0tb3BlbmVke2Rpc3BsYXk6YmxvY2s7YW5pbWF0aW9uOm1lbnVTaG93aW5nIC4xcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKSBmb3J3YXJkc30udGMtcG9wb3Zlcl9faXRlbXtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO3BhZGRpbmc6MnB4IDE0cHggMnB4IDJweDtib3JkZXItcmFkaXVzOjVweDtjdXJzb3I6cG9pbnRlcjt3aGl0ZS1zcGFjZTpub3dyYXA7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS50Yy1wb3BvdmVyX19pdGVtOmhvdmVye2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1ob3Zlcil9LnRjLXBvcG92ZXJfX2l0ZW06bm90KDpsYXN0LW9mLXR5cGUpe21hcmdpbi1ib3R0b206MnB4fS50Yy1wb3BvdmVyX19pdGVtLWljb257ZGlzcGxheTppbmxpbmUtZmxleDt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZCk7Ym9yZGVyLXJhZGl1czo1cHg7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1jb2xvci1ib3JkZXIpO21hcmdpbi1yaWdodDo4cHh9LnRjLXBvcG92ZXJfX2l0ZW0tbGFiZWx7bGluZS1oZWlnaHQ6MjJweDtmb250LXNpemU6MTRweDtmb250LXdlaWdodDo1MDB9LnRjLXBvcG92ZXJfX2l0ZW0tLWNvbmZpcm17YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWNvbmZpcm0pO2NvbG9yOnZhcigtLWNvbG9yLXRleHQtY29uZmlybSl9LnRjLXBvcG92ZXJfX2l0ZW0tLWNvbmZpcm06aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWNvbmZpcm0taG92ZXIpfS50Yy1wb3BvdmVyX19pdGVtLS1jb25maXJtIC50Yy1wb3BvdmVyX19pdGVtLWljb257YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWNvbmZpcm0pO2JvcmRlci1jb2xvcjojMDAwMDAwMWF9LnRjLXBvcG92ZXJfX2l0ZW0tLWNvbmZpcm0gLnRjLXBvcG92ZXJfX2l0ZW0taWNvbiBzdmd7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjJzIGVhc2UtaW47dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZykgc2NhbGUoMS4yKX0udGMtcG9wb3Zlcl9faXRlbS0taGlkZGVue2Rpc3BsYXk6bm9uZX1Aa2V5ZnJhbWVzIG1lbnVTaG93aW5nezAle29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KSBzY2FsZSguOSl9NzAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgycHgpfXRve3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfX0nKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChvKX19Y2F0Y2gocil7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLHIpfX0pKCk7XG5mdW5jdGlvbiBjKGQsIHQsIGUgPSB7fSkge1xuICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkKTtcbiAgQXJyYXkuaXNBcnJheSh0KSA/IG8uY2xhc3NMaXN0LmFkZCguLi50KSA6IHQgJiYgby5jbGFzc0xpc3QuYWRkKHQpO1xuICBmb3IgKGNvbnN0IGkgaW4gZSlcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgaSkgJiYgKG9baV0gPSBlW2ldKTtcbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBmKGQpIHtcbiAgY29uc3QgdCA9IGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeTE6IE1hdGguZmxvb3IodC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQpLFxuICAgIHgxOiBNYXRoLmZsb29yKHQubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCksXG4gICAgeDI6IE1hdGguZmxvb3IodC5yaWdodCArIHdpbmRvdy5wYWdlWE9mZnNldCksXG4gICAgeTI6IE1hdGguZmxvb3IodC5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQpXG4gIH07XG59XG5mdW5jdGlvbiBnKGQsIHQpIHtcbiAgY29uc3QgZSA9IGYoZCksIG8gPSBmKHQpO1xuICByZXR1cm4ge1xuICAgIGZyb21Ub3BCb3JkZXI6IG8ueTEgLSBlLnkxLFxuICAgIGZyb21MZWZ0Qm9yZGVyOiBvLngxIC0gZS54MSxcbiAgICBmcm9tUmlnaHRCb3JkZXI6IGUueDIgLSBvLngyLFxuICAgIGZyb21Cb3R0b21Cb3JkZXI6IGUueTIgLSBvLnkyXG4gIH07XG59XG5mdW5jdGlvbiBSKGQsIHQpIHtcbiAgY29uc3QgZSA9IGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHsgd2lkdGg6IG8sIGhlaWdodDogaSwgeDogcywgeTogbiB9ID0gZSwgeyBjbGllbnRYOiBoLCBjbGllbnRZOiBsIH0gPSB0O1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBvLFxuICAgIGhlaWdodDogaSxcbiAgICB4OiBoIC0gcyxcbiAgICB5OiBsIC0gblxuICB9O1xufVxuZnVuY3Rpb24gQyhkLCB0KSB7XG4gIHJldHVybiB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGQsIHQpO1xufVxuZnVuY3Rpb24gbShkLCB0ID0gITApIHtcbiAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksIG8gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIGUuc2VsZWN0Tm9kZUNvbnRlbnRzKGQpLCBlLmNvbGxhcHNlKHQpLCBvLnJlbW92ZUFsbFJhbmdlcygpLCBvLmFkZFJhbmdlKGUpO1xufVxuY2xhc3MgYSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHtQb3BvdmVySXRlbVtdfSBvcHRpb25zLml0ZW1zIC0gY29uc3RydWN0b3Igb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBpdGVtczogdCB9KSB7XG4gICAgdGhpcy5pdGVtcyA9IHQsIHRoaXMud3JhcHBlciA9IHZvaWQgMCwgdGhpcy5pdGVtRWxzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFNldCBvZiBDU1MgY2xhc3NuYW1lcyB1c2VkIGluIHBvcG92ZXJcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3BvdmVyOiBcInRjLXBvcG92ZXJcIixcbiAgICAgIHBvcG92ZXJPcGVuZWQ6IFwidGMtcG9wb3Zlci0tb3BlbmVkXCIsXG4gICAgICBpdGVtOiBcInRjLXBvcG92ZXJfX2l0ZW1cIixcbiAgICAgIGl0ZW1IaWRkZW46IFwidGMtcG9wb3Zlcl9faXRlbS0taGlkZGVuXCIsXG4gICAgICBpdGVtQ29uZmlybVN0YXRlOiBcInRjLXBvcG92ZXJfX2l0ZW0tLWNvbmZpcm1cIixcbiAgICAgIGl0ZW1JY29uOiBcInRjLXBvcG92ZXJfX2l0ZW0taWNvblwiLFxuICAgICAgaXRlbUxhYmVsOiBcInRjLXBvcG92ZXJfX2l0ZW0tbGFiZWxcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvcG92ZXIgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVyID0gYyhcImRpdlwiLCBhLkNTUy5wb3BvdmVyKSwgdGhpcy5pdGVtcy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBjb25zdCBvID0gYyhcImRpdlwiLCBhLkNTUy5pdGVtKSwgaSA9IGMoXCJkaXZcIiwgYS5DU1MuaXRlbUljb24sIHtcbiAgICAgICAgaW5uZXJIVE1MOiB0Lmljb25cbiAgICAgIH0pLCBzID0gYyhcImRpdlwiLCBhLkNTUy5pdGVtTGFiZWwsIHtcbiAgICAgICAgdGV4dENvbnRlbnQ6IHQubGFiZWxcbiAgICAgIH0pO1xuICAgICAgby5kYXRhc2V0LmluZGV4ID0gZSwgby5hcHBlbmRDaGlsZChpKSwgby5hcHBlbmRDaGlsZChzKSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKG8pLCB0aGlzLml0ZW1FbHMucHVzaChvKTtcbiAgICB9KSwgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgdGhpcy5wb3BvdmVyQ2xpY2tlZCh0KTtcbiAgICB9KSwgdGhpcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBQb3BvdmVyIHdyYXBwZXIgY2xpY2sgbGlzdGVuZXJcbiAgICogVXNlZCB0byBkZWxlZ2F0ZSBjbGlja3MgaW4gaXRlbXNcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwb3BvdmVyQ2xpY2tlZCh0KSB7XG4gICAgY29uc3QgZSA9IHQudGFyZ2V0LmNsb3Nlc3QoYC4ke2EuQ1NTLml0ZW19YCk7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSBlLmRhdGFzZXQuaW5kZXgsIGkgPSB0aGlzLml0ZW1zW29dO1xuICAgIGlmIChpLmNvbmZpcm1hdGlvblJlcXVpcmVkICYmICF0aGlzLmhhc0NvbmZpcm1hdGlvblN0YXRlKGUpKSB7XG4gICAgICB0aGlzLnNldENvbmZpcm1hdGlvblN0YXRlKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpLm9uQ2xpY2soKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIHRoZSBjb25maXJtYXRpb24gc3RhdGUgb24gcGFzc2VkIGl0ZW1cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzZXRDb25maXJtYXRpb25TdGF0ZSh0KSB7XG4gICAgdC5jbGFzc0xpc3QuYWRkKGEuQ1NTLml0ZW1Db25maXJtU3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBjb25maXJtYXRpb24gc3RhdGUgb24gcGFzc2VkIGl0ZW1cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhckNvbmZpcm1hdGlvblN0YXRlKHQpIHtcbiAgICB0LmNsYXNzTGlzdC5yZW1vdmUoYS5DU1MuaXRlbUNvbmZpcm1TdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBpdGVtIGhhcyB0aGUgY29uZmlybWF0aW9uIHN0YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ29uZmlybWF0aW9uU3RhdGUodCkge1xuICAgIHJldHVybiB0LmNsYXNzTGlzdC5jb250YWlucyhhLkNTUy5pdGVtQ29uZmlybVN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIG9wZW5pbmcgc3RhdGVcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgb3BlbmVkKCkge1xuICAgIHJldHVybiB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LmNvbnRhaW5zKGEuQ1NTLnBvcG92ZXJPcGVuZWQpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgcG9wb3ZlclxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICB0eXBlb2YgdC5oaWRlSWYgPT0gXCJmdW5jdGlvblwiICYmIHRoaXMuaXRlbUVsc1tlXS5jbGFzc0xpc3QudG9nZ2xlKGEuQ1NTLml0ZW1IaWRkZW4sIHQuaGlkZUlmKCkpO1xuICAgIH0pLCB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LmFkZChhLkNTUy5wb3BvdmVyT3BlbmVkKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBwb3BvdmVyXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoYS5DU1MucG9wb3Zlck9wZW5lZCksIHRoaXMuaXRlbUVscy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0aGlzLmNsZWFyQ29uZmlybWF0aW9uU3RhdGUodCk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGIgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTggOEwxMiAxMk0xMiAxMkwxNiAxNk0xMiAxMkwxNiA4TTEyIDEyTDggMTZcIi8+PC9zdmc+JywgayA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNC44ODMzIDkuMTY2NjZMMTguMjE2NyAxMi41TTE4LjIxNjcgMTIuNUwxNC44ODMzIDE1LjgzMzNNMTguMjE2NyAxMi41SDEwLjA1QzkuMTY1OTQgMTIuNSA4LjMxODA5IDEyLjE0ODggNy42OTI5NyAxMS41MjM3QzcuMDY3ODUgMTAuODk4NiA2LjcxNjY2IDEwLjA1MDcgNi43MTY2NiA5LjE2NjY2XCIvPjwvc3ZnPicsIFMgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTQuOTE2NyAxNC45MTY3TDExLjU4MzMgMTguMjVNMTEuNTgzMyAxOC4yNUw4LjI1IDE0LjkxNjdNMTEuNTgzMyAxOC4yNUwxMS41ODMzIDEwLjA4MzNDMTEuNTgzMyA5LjE5OTI4IDExLjkzNDUgOC4zNTE0MyAxMi41NTk2IDcuNzI2MzFDMTMuMTg0OCA3LjEwMTE5IDE0LjAzMjYgNi43NSAxNC45MTY3IDYuNzVcIi8+PC9zdmc+JywgeCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05LjEzMzMzIDE0LjkxNjdMMTIuNDY2NyAxOC4yNU0xMi40NjY3IDE4LjI1TDE1LjggMTQuOTE2N00xMi40NjY3IDE4LjI1TDEyLjQ2NjcgMTAuMDgzM0MxMi40NjY3IDkuMTk5MjggMTIuMTE1NSA4LjM1MTQzIDExLjQ5MDQgNy43MjYzMUMxMC44NjUyIDcuMTAxMTkgMTAuMDE3NCA2Ljc1IDkuMTMzMzMgNi43NVwiLz48L3N2Zz4nLCB5ID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE0Ljg4MzMgMTUuODMzM0wxOC4yMTY3IDEyLjVNMTguMjE2NyAxMi41TDE0Ljg4MzMgOS4xNjY2N00xOC4yMTY3IDEyLjVMMTAuMDUgMTIuNUM5LjE2NTk1IDEyLjUgOC4zMTgxMSAxMi44NTEyIDcuNjkyOTkgMTMuNDc2M0M3LjA2Nzg3IDE0LjEwMTQgNi43MTY2NyAxNC45NDkzIDYuNzE2NjcgMTUuODMzM1wiLz48L3N2Zz4nLCBUID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTkuNDEgOS42Nkg5LjRcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNMTQuNiA5LjY2SDE0LjU5XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTkuMzEgMTQuMzZIOS4zXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTE0LjYgMTQuMzZIMTQuNTlcIi8+PC9zdmc+JywgdiA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTIgN1YxMk0xMiAxN1YxMk0xNyAxMkgxMk0xMiAxMkg3XCIvPjwvc3ZnPicsIEwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNSAxMEgxOVwiLz48cmVjdCB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIiB4PVwiNVwiIHk9XCI1XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHJ4PVwiNFwiLz48L3N2Zz4nLCBNID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEwIDVWMTguNVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNCA1VjE4LjVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNSAxMEgxOVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01IDE0SDE5XCIvPjxyZWN0IHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHg9XCI1XCIgeT1cIjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgcng9XCI0XCIvPjwvc3ZnPicsIE8gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTAgNVYxOC41XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUgMTBIMTlcIi8+PHJlY3Qgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgeD1cIjVcIiB5PVwiNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiByeD1cIjRcIi8+PC9zdmc+JztcbmNsYXNzIHUge1xuICAvKipcbiAgICogQ3JlYXRlcyB0b29sYm94IGJ1dHRvbnMgYW5kIHRvb2xib3ggbWVudXNcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGFwaSAtIEVkaXRvci5qcyBhcGlcbiAgICogQHBhcmFtIHtQb3BvdmVySXRlbVtdfSBpdGVtcyAtIEVkaXRvci5qcyBhcGlcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25PcGVuIC0gY2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgUG9wb3ZlciBpcyBvcGVuaW5nXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uQ2xvc2UgLSBjYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBQb3BvdmVyIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjc3NNb2RpZmllcl0gLSB0aGUgbW9kaWZpZXIgZm9yIHRoZSBUb29sYm94LiBBbGxvd3MgdG8gYWRkIHNvbWUgc3BlY2lmaWMgc3R5bGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGk6IHQsIGl0ZW1zOiBlLCBvbk9wZW46IG8sIG9uQ2xvc2U6IGksIGNzc01vZGlmaWVyOiBzID0gXCJcIiB9KSB7XG4gICAgdGhpcy5hcGkgPSB0LCB0aGlzLml0ZW1zID0gZSwgdGhpcy5vbk9wZW4gPSBvLCB0aGlzLm9uQ2xvc2UgPSBpLCB0aGlzLmNzc01vZGlmaWVyID0gcywgdGhpcy5wb3BvdmVyID0gbnVsbCwgdGhpcy53cmFwcGVyID0gdGhpcy5jcmVhdGVUb29sYm94KCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0eWxlIGNsYXNzZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sYm94OiBcInRjLXRvb2xib3hcIixcbiAgICAgIHRvb2xib3hTaG93ZWQ6IFwidGMtdG9vbGJveC0tc2hvd2VkXCIsXG4gICAgICB0b2dnbGVyOiBcInRjLXRvb2xib3hfX3RvZ2dsZXJcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcmVuZGVyZWQgVG9vbGJveCBlbGVtZW50XG4gICAqL1xuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGluZyBhIHRvb2xib3ggdG8gb3BlbiBtZW51IGZvciBhIG1hbmlwdWxhdGluZyBjb2x1bW5zXG4gICAqXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgKi9cbiAgY3JlYXRlVG9vbGJveCgpIHtcbiAgICBjb25zdCB0ID0gYyhcImRpdlwiLCBbXG4gICAgICB1LkNTUy50b29sYm94LFxuICAgICAgdGhpcy5jc3NNb2RpZmllciA/IGAke3UuQ1NTLnRvb2xib3h9LS0ke3RoaXMuY3NzTW9kaWZpZXJ9YCA6IFwiXCJcbiAgICBdKTtcbiAgICB0LmRhdGFzZXQubXV0YXRpb25GcmVlID0gXCJ0cnVlXCI7XG4gICAgY29uc3QgZSA9IHRoaXMuY3JlYXRlUG9wb3ZlcigpLCBvID0gdGhpcy5jcmVhdGVUb2dnbGVyKCk7XG4gICAgcmV0dXJuIHQuYXBwZW5kQ2hpbGQobyksIHQuYXBwZW5kQ2hpbGQoZSksIHQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIFRvZ2dsZXJcbiAgICpcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICBjcmVhdGVUb2dnbGVyKCkge1xuICAgIGNvbnN0IHQgPSBjKFwiZGl2XCIsIHUuQ1NTLnRvZ2dsZXIsIHtcbiAgICAgIGlubmVySFRNTDogVFxuICAgIH0pO1xuICAgIHJldHVybiB0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnRvZ2dsZXJDbGlja2VkKCk7XG4gICAgfSksIHQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIFBvcG92ZXIgaW5zdGFuY2UgYW5kIHJlbmRlciBpdFxuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIGNyZWF0ZVBvcG92ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9wb3ZlciA9IG5ldyBhKHtcbiAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zXG4gICAgfSksIHRoaXMucG9wb3Zlci5yZW5kZXIoKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlciBjbGljayBoYW5kbGVyLiBPcGVucy9DbG9zZXMgdGhlIHBvcG92ZXJcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICB0b2dnbGVyQ2xpY2tlZCgpIHtcbiAgICB0aGlzLnBvcG92ZXIub3BlbmVkID8gKHRoaXMucG9wb3Zlci5jbG9zZSgpLCB0aGlzLm9uQ2xvc2UoKSkgOiAodGhpcy5wb3BvdmVyLm9wZW4oKSwgdGhpcy5vbk9wZW4oKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBUb29sYm94XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXB1dGVQb3NpdGlvbk1ldGhvZCAtIG1ldGhvZCB0aGF0IHJldHVybnMgdGhlIHBvc2l0aW9uIGNvb3JkaW5hdGVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzaG93KHQpIHtcbiAgICBjb25zdCBlID0gdCgpO1xuICAgIE9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtvLCBpXSkgPT4ge1xuICAgICAgdGhpcy53cmFwcGVyLnN0eWxlW29dID0gaTtcbiAgICB9KSwgdGhpcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQodS5DU1MudG9vbGJveFNob3dlZCk7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBUb29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnBvcG92ZXIuY2xvc2UoKSwgdGhpcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUodS5DU1MudG9vbGJveFNob3dlZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEgoZCwgdCkge1xuICBsZXQgZSA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiguLi5vKSB7XG4gICAgY29uc3QgaSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIGlmICghKGkgLSBlIDwgZCkpXG4gICAgICByZXR1cm4gZSA9IGksIHQoLi4ubyk7XG4gIH07XG59XG5jb25zdCByID0ge1xuICB3cmFwcGVyOiBcInRjLXdyYXBcIixcbiAgd3JhcHBlclJlYWRPbmx5OiBcInRjLXdyYXAtLXJlYWRvbmx5XCIsXG4gIHRhYmxlOiBcInRjLXRhYmxlXCIsXG4gIHJvdzogXCJ0Yy1yb3dcIixcbiAgd2l0aEhlYWRpbmdzOiBcInRjLXRhYmxlLS1oZWFkaW5nXCIsXG4gIHJvd1NlbGVjdGVkOiBcInRjLXJvdy0tc2VsZWN0ZWRcIixcbiAgY2VsbDogXCJ0Yy1jZWxsXCIsXG4gIGNlbGxTZWxlY3RlZDogXCJ0Yy1jZWxsLS1zZWxlY3RlZFwiLFxuICBhZGRSb3c6IFwidGMtYWRkLXJvd1wiLFxuICBhZGRDb2x1bW46IFwidGMtYWRkLWNvbHVtblwiXG59O1xuY2xhc3MgQSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5IC0gcmVhZC1vbmx5IG1vZGUgZmxhZ1xuICAgKiBAcGFyYW0ge29iamVjdH0gYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKiBAcGFyYW0ge1RhYmxlRGF0YX0gZGF0YSAtIEVkaXRvci5qcyBBUElcbiAgICogQHBhcmFtIHtUYWJsZUNvbmZpZ30gY29uZmlnIC0gRWRpdG9yLmpzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IodCwgZSwgbywgaSkge1xuICAgIHRoaXMucmVhZE9ubHkgPSB0LCB0aGlzLmFwaSA9IGUsIHRoaXMuZGF0YSA9IG8sIHRoaXMuY29uZmlnID0gaSwgdGhpcy53cmFwcGVyID0gbnVsbCwgdGhpcy50YWJsZSA9IG51bGwsIHRoaXMudG9vbGJveENvbHVtbiA9IHRoaXMuY3JlYXRlQ29sdW1uVG9vbGJveCgpLCB0aGlzLnRvb2xib3hSb3cgPSB0aGlzLmNyZWF0ZVJvd1Rvb2xib3goKSwgdGhpcy5jcmVhdGVUYWJsZVdyYXBwZXIoKSwgdGhpcy5ob3ZlcmVkUm93ID0gMCwgdGhpcy5ob3ZlcmVkQ29sdW1uID0gMCwgdGhpcy5zZWxlY3RlZFJvdyA9IDAsIHRoaXMuc2VsZWN0ZWRDb2x1bW4gPSAwLCB0aGlzLnR1bmVzID0ge1xuICAgICAgd2l0aEhlYWRpbmdzOiAhMVxuICAgIH0sIHRoaXMucmVzaXplKCksIHRoaXMuZmlsbCgpLCB0aGlzLmZvY3VzZWRDZWxsID0ge1xuICAgICAgcm93OiAwLFxuICAgICAgY29sdW1uOiAwXG4gICAgfSwgdGhpcy5kb2N1bWVudENsaWNrZWQgPSAocykgPT4ge1xuICAgICAgY29uc3QgbiA9IHMudGFyZ2V0LmNsb3Nlc3QoYC4ke3IudGFibGV9YCkgIT09IG51bGwsIGggPSBzLnRhcmdldC5jbG9zZXN0KGAuJHtyLndyYXBwZXJ9YCkgPT09IG51bGw7XG4gICAgICAobiB8fCBoKSAmJiB0aGlzLmhpZGVUb29sYm94ZXMoKTtcbiAgICAgIGNvbnN0IHcgPSBzLnRhcmdldC5jbG9zZXN0KGAuJHtyLmFkZFJvd31gKSwgcCA9IHMudGFyZ2V0LmNsb3Nlc3QoYC4ke3IuYWRkQ29sdW1ufWApO1xuICAgICAgdyAmJiB3LnBhcmVudE5vZGUgPT09IHRoaXMud3JhcHBlciA/ICh0aGlzLmFkZFJvdyh2b2lkIDAsICEwKSwgdGhpcy5oaWRlVG9vbGJveGVzKCkpIDogcCAmJiBwLnBhcmVudE5vZGUgPT09IHRoaXMud3JhcHBlciAmJiAodGhpcy5hZGRDb2x1bW4odm9pZCAwLCAhMCksIHRoaXMuaGlkZVRvb2xib3hlcygpKTtcbiAgICB9LCB0aGlzLnJlYWRPbmx5IHx8IHRoaXMuYmluZEV2ZW50cygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZW5kZXJlZCB0YWJsZSB3cmFwcGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0V3JhcHBlcigpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBIYW5ncyB0aGUgbmVjZXNzYXJ5IGhhbmRsZXJzIHRvIGV2ZW50c1xuICAgKi9cbiAgYmluZEV2ZW50cygpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5kb2N1bWVudENsaWNrZWQpLCB0aGlzLnRhYmxlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgSCgxNTAsICh0KSA9PiB0aGlzLm9uTW91c2VNb3ZlSW5UYWJsZSh0KSksIHsgcGFzc2l2ZTogITAgfSksIHRoaXMudGFibGUub25rZXlwcmVzcyA9ICh0KSA9PiB0aGlzLm9uS2V5UHJlc3NMaXN0ZW5lcih0KSwgdGhpcy50YWJsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAodCkgPT4gdGhpcy5vbktleURvd25MaXN0ZW5lcih0KSksIHRoaXMudGFibGUuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKHQpID0+IHRoaXMuZm9jdXNJblRhYmxlTGlzdGVuZXIodCkpO1xuICB9XG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGFuZCBjcmVhdGVzIHRoZSB0b29sYm94IGZvciBtYW5pcHVsYXRpbmcgd2l0aCBjb2x1bW5zXG4gICAqXG4gICAqIEByZXR1cm5zIHtUb29sYm94fVxuICAgKi9cbiAgY3JlYXRlQ29sdW1uVG9vbGJveCgpIHtcbiAgICByZXR1cm4gbmV3IHUoe1xuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIGNzc01vZGlmaWVyOiBcImNvbHVtblwiLFxuICAgICAgaXRlbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJBZGQgY29sdW1uIHRvIGxlZnRcIiksXG4gICAgICAgICAgaWNvbjogUyxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZENvbHVtbih0aGlzLnNlbGVjdGVkQ29sdW1uLCAhMCksIHRoaXMuaGlkZVRvb2xib3hlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJBZGQgY29sdW1uIHRvIHJpZ2h0XCIpLFxuICAgICAgICAgIGljb246IHgsXG4gICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRDb2x1bW4odGhpcy5zZWxlY3RlZENvbHVtbiArIDEsICEwKSwgdGhpcy5oaWRlVG9vbGJveGVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6IHRoaXMuYXBpLmkxOG4udChcIkRlbGV0ZSBjb2x1bW5cIiksXG4gICAgICAgICAgaWNvbjogYixcbiAgICAgICAgICBoaWRlSWY6ICgpID0+IHRoaXMubnVtYmVyT2ZDb2x1bW5zID09PSAxLFxuICAgICAgICAgIGNvbmZpcm1hdGlvblJlcXVpcmVkOiAhMCxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZUNvbHVtbih0aGlzLnNlbGVjdGVkQ29sdW1uKSwgdGhpcy5oaWRlVG9vbGJveGVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb25PcGVuOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0Q29sdW1uKHRoaXMuaG92ZXJlZENvbHVtbiksIHRoaXMuaGlkZVJvd1Rvb2xib3goKTtcbiAgICAgIH0sXG4gICAgICBvbkNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudW5zZWxlY3RDb2x1bW4oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29uZmlndXJlcyBhbmQgY3JlYXRlcyB0aGUgdG9vbGJveCBmb3IgbWFuaXB1bGF0aW5nIHdpdGggcm93c1xuICAgKlxuICAgKiBAcmV0dXJucyB7VG9vbGJveH1cbiAgICovXG4gIGNyZWF0ZVJvd1Rvb2xib3goKSB7XG4gICAgcmV0dXJuIG5ldyB1KHtcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBjc3NNb2RpZmllcjogXCJyb3dcIixcbiAgICAgIGl0ZW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KFwiQWRkIHJvdyBhYm92ZVwiKSxcbiAgICAgICAgICBpY29uOiB5LFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkUm93KHRoaXMuc2VsZWN0ZWRSb3csICEwKSwgdGhpcy5oaWRlVG9vbGJveGVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6IHRoaXMuYXBpLmkxOG4udChcIkFkZCByb3cgYmVsb3dcIiksXG4gICAgICAgICAgaWNvbjogayxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZFJvdyh0aGlzLnNlbGVjdGVkUm93ICsgMSwgITApLCB0aGlzLmhpZGVUb29sYm94ZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KFwiRGVsZXRlIHJvd1wiKSxcbiAgICAgICAgICBpY29uOiBiLFxuICAgICAgICAgIGhpZGVJZjogKCkgPT4gdGhpcy5udW1iZXJPZlJvd3MgPT09IDEsXG4gICAgICAgICAgY29uZmlybWF0aW9uUmVxdWlyZWQ6ICEwLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlUm93KHRoaXMuc2VsZWN0ZWRSb3cpLCB0aGlzLmhpZGVUb29sYm94ZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBvbk9wZW46ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3RSb3codGhpcy5ob3ZlcmVkUm93KSwgdGhpcy5oaWRlQ29sdW1uVG9vbGJveCgpO1xuICAgICAgfSxcbiAgICAgIG9uQ2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy51bnNlbGVjdFJvdygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBXaGVuIHlvdSBwcmVzcyBlbnRlciBpdCBtb3ZlcyB0aGUgY3Vyc29yIGRvd24gdG8gdGhlIG5leHQgcm93XG4gICAqIG9yIGNyZWF0ZXMgaXQgaWYgdGhlIGNsaWNrIG9jY3VycmVkIG9uIHRoZSBsYXN0IG9uZVxuICAgKi9cbiAgbW92ZUN1cnNvclRvTmV4dFJvdygpIHtcbiAgICB0aGlzLmZvY3VzZWRDZWxsLnJvdyAhPT0gdGhpcy5udW1iZXJPZlJvd3MgPyAodGhpcy5mb2N1c2VkQ2VsbC5yb3cgKz0gMSwgdGhpcy5mb2N1c0NlbGwodGhpcy5mb2N1c2VkQ2VsbCkpIDogKHRoaXMuYWRkUm93KCksIHRoaXMuZm9jdXNlZENlbGwucm93ICs9IDEsIHRoaXMuZm9jdXNDZWxsKHRoaXMuZm9jdXNlZENlbGwpLCB0aGlzLnVwZGF0ZVRvb2xib3hlc1Bvc2l0aW9uKDAsIDApKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRhYmxlIGNlbGwgYnkgcm93IGFuZCBjb2wgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyAtIGNlbGwgcm93IGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiAtIGNlbGwgY29sdW1uIGNvb3JkaW5hdGVcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0Q2VsbCh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGUucXVlcnlTZWxlY3RvckFsbChgLiR7ci5yb3d9Om50aC1jaGlsZCgke3R9KSAuJHtyLmNlbGx9YClbZSAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGFibGUgcm93IGJ5IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSByb3cgY29vcmRpbmF0ZVxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBnZXRSb3codCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlLnF1ZXJ5U2VsZWN0b3IoYC4ke3Iucm93fTpudGgtY2hpbGQoJHt0fSlgKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBhcmVudCBvZiB0aGUgY2VsbCB3aGljaCBpcyB0aGUgcm93XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNlbGwgLSBjZWxsIGVsZW1lbnRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0Um93QnlDZWxsKHQpIHtcbiAgICByZXR1cm4gdC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBHZXIgcm93J3MgZmlyc3QgY2VsbFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvdyAtIHJvdyB0byBmaW5kIGl0cyBmaXJzdCBjZWxsXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0Um93Rmlyc3RDZWxsKHQpIHtcbiAgICByZXR1cm4gdC5xdWVyeVNlbGVjdG9yKGAuJHtyLmNlbGx9OmZpcnN0LWNoaWxkYCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgc2VsbCdzIGNvbnRlbnQgYnkgcm93IGFuZCBjb2x1bW4gbnVtYmVyc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm93IC0gY2VsbCByb3cgY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIC0gY2VsbCBjb2x1bW4gY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIGNlbGwgSFRNTCBjb250ZW50XG4gICAqL1xuICBzZXRDZWxsQ29udGVudCh0LCBlLCBvKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0Q2VsbCh0LCBlKTtcbiAgICBpLmlubmVySFRNTCA9IG87XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjb2x1bW4gaW4gdGFibGUgb24gaW5kZXggcGxhY2VcbiAgICogQWRkIGNlbGxzIGluIGVhY2ggcm93XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIG51bWJlciBpbiB0aGUgYXJyYXkgb2YgY29sdW1ucywgd2hlcmUgbmV3IGNvbHVtbiB0byBpbnNlcnQsIC0xIGlmIGluc2VydCBhdCB0aGUgZW5kXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldEZvY3VzXSAtIHBhc3MgdHJ1ZSB0byBmb2N1cyB0aGUgZmlyc3QgY2VsbFxuICAgKi9cbiAgYWRkQ29sdW1uKHQgPSAtMSwgZSA9ICExKSB7XG4gICAgbGV0IG8gPSB0aGlzLm51bWJlck9mQ29sdW1ucztcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLm51bWJlck9mUm93czsgaSsrKSB7XG4gICAgICBsZXQgcztcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmNyZWF0ZUNlbGwoKTtcbiAgICAgIGlmICh0ID4gMCAmJiB0IDw9IG8gPyAocyA9IHRoaXMuZ2V0Q2VsbChpLCB0KSwgQyhuLCBzKSkgOiBzID0gdGhpcy5nZXRSb3coaSkuYXBwZW5kQ2hpbGQobiksIGkgPT09IDEpIHtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuZ2V0Q2VsbChpLCB0ID4gMCA/IHQgOiBvICsgMSk7XG4gICAgICAgIGggJiYgZSAmJiBtKGgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZEhlYWRpbmdBdHRyVG9GaXJzdFJvdygpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgcm93IGluIHRhYmxlIG9uIGluZGV4IHBsYWNlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIG51bWJlciBpbiB0aGUgYXJyYXkgb2Ygcm93cywgd2hlcmUgbmV3IGNvbHVtbiB0byBpbnNlcnQsIC0xIGlmIGluc2VydCBhdCB0aGUgZW5kXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldEZvY3VzXSAtIHBhc3MgdHJ1ZSB0byBmb2N1cyB0aGUgaW5zZXJ0ZWQgcm93XG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gcm93XG4gICAqL1xuICBhZGRSb3codCA9IC0xLCBlID0gITEpIHtcbiAgICBsZXQgbywgaSA9IGMoXCJkaXZcIiwgci5yb3cpO1xuICAgIHRoaXMudHVuZXMud2l0aEhlYWRpbmdzICYmIHRoaXMucmVtb3ZlSGVhZGluZ0F0dHJGcm9tRmlyc3RSb3coKTtcbiAgICBsZXQgcyA9IHRoaXMubnVtYmVyT2ZDb2x1bW5zO1xuICAgIGlmICh0ID4gMCAmJiB0IDw9IHRoaXMubnVtYmVyT2ZSb3dzKSB7XG4gICAgICBsZXQgaCA9IHRoaXMuZ2V0Um93KHQpO1xuICAgICAgbyA9IEMoaSwgaCk7XG4gICAgfSBlbHNlXG4gICAgICBvID0gdGhpcy50YWJsZS5hcHBlbmRDaGlsZChpKTtcbiAgICB0aGlzLmZpbGxSb3cobywgcyksIHRoaXMudHVuZXMud2l0aEhlYWRpbmdzICYmIHRoaXMuYWRkSGVhZGluZ0F0dHJUb0ZpcnN0Um93KCk7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0Um93Rmlyc3RDZWxsKG8pO1xuICAgIHJldHVybiBuICYmIGUgJiYgbShuKSwgbztcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgY29sdW1uIGJ5IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgZGVsZXRlQ29sdW1uKHQpIHtcbiAgICBmb3IgKGxldCBlID0gMTsgZSA8PSB0aGlzLm51bWJlck9mUm93czsgZSsrKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5nZXRDZWxsKGUsIHQpO1xuICAgICAgaWYgKCFvKVxuICAgICAgICByZXR1cm47XG4gICAgICBvLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcm93IGJ5IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgZGVsZXRlUm93KHQpIHtcbiAgICB0aGlzLmdldFJvdyh0KS5yZW1vdmUoKSwgdGhpcy5hZGRIZWFkaW5nQXR0clRvRmlyc3RSb3coKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgd3JhcHBlciBjb250YWluaW5nIGEgdGFibGUsIHRvb2xib3hlc1xuICAgKiBhbmQgYnV0dG9ucyBmb3IgYWRkaW5nIHJvd3MgYW5kIGNvbHVtbnNcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB3cmFwcGVyIC0gd2hlcmUgYWxsIGJ1dHRvbnMgZm9yIGEgdGFibGUgYW5kIHRoZSB0YWJsZSBpdHNlbGYgd2lsbCBiZVxuICAgKi9cbiAgY3JlYXRlVGFibGVXcmFwcGVyKCkge1xuICAgIGlmICh0aGlzLndyYXBwZXIgPSBjKFwiZGl2XCIsIHIud3JhcHBlciksIHRoaXMudGFibGUgPSBjKFwiZGl2XCIsIHIudGFibGUpLCB0aGlzLnJlYWRPbmx5ICYmIHRoaXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHIud3JhcHBlclJlYWRPbmx5KSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMudG9vbGJveFJvdy5lbGVtZW50KSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMudG9vbGJveENvbHVtbi5lbGVtZW50KSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMudGFibGUpLCAhdGhpcy5yZWFkT25seSkge1xuICAgICAgY29uc3QgdCA9IGMoXCJkaXZcIiwgci5hZGRDb2x1bW4sIHtcbiAgICAgICAgaW5uZXJIVE1MOiB2XG4gICAgICB9KSwgZSA9IGMoXCJkaXZcIiwgci5hZGRSb3csIHtcbiAgICAgICAgaW5uZXJIVE1MOiB2XG4gICAgICB9KTtcbiAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0KSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgdGFibGUgYmFzZWQgb24gaW5pdGlhbCBkYXRhIG9yIGNvbmZpZyBcInNpemVcIiBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcmV0dXJuIHt7cm93czogbnVtYmVyLCBjb2xzOiBudW1iZXJ9fSAtIG51bWJlciBvZiBjb2xzIGFuZCByb3dzXG4gICAqL1xuICBjb21wdXRlSW5pdGlhbFNpemUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuY29udGVudCwgZSA9IEFycmF5LmlzQXJyYXkodCksIG8gPSBlID8gdC5sZW5ndGggOiAhMSwgaSA9IGUgPyB0Lmxlbmd0aCA6IHZvaWQgMCwgcyA9IG8gPyB0WzBdLmxlbmd0aCA6IHZvaWQgMCwgbiA9IE51bWJlci5wYXJzZUludCh0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5yb3dzKSwgaCA9IE51bWJlci5wYXJzZUludCh0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5jb2xzKSwgbCA9ICFpc05hTihuKSAmJiBuID4gMCA/IG4gOiB2b2lkIDAsIHcgPSAhaXNOYU4oaCkgJiYgaCA+IDAgPyBoIDogdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICByb3dzOiBpIHx8IGwgfHwgMixcbiAgICAgIGNvbHM6IHMgfHwgdyB8fCAyXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplIHRhYmxlIHRvIG1hdGNoIGNvbmZpZyBzaXplIG9yIHRyYW5zbWl0dGVkIGRhdGEgc2l6ZVxuICAgKlxuICAgKiBAcmV0dXJuIHt7cm93czogbnVtYmVyLCBjb2xzOiBudW1iZXJ9fSAtIG51bWJlciBvZiBjb2xzIGFuZCByb3dzXG4gICAqL1xuICByZXNpemUoKSB7XG4gICAgY29uc3QgeyByb3dzOiB0LCBjb2xzOiBlIH0gPSB0aGlzLmNvbXB1dGVJbml0aWFsU2l6ZSgpO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgdDsgbysrKVxuICAgICAgdGhpcy5hZGRSb3coKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGU7IG8rKylcbiAgICAgIHRoaXMuYWRkQ29sdW1uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbGxzIHRoZSB0YWJsZSB3aXRoIGRhdGEgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZpbGwoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZGF0YTtcbiAgICBpZiAodCAmJiB0LmNvbnRlbnQpXG4gICAgICBmb3IgKGxldCBlID0gMDsgZSA8IHQuY29udGVudC5sZW5ndGg7IGUrKylcbiAgICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCB0LmNvbnRlbnRbZV0ubGVuZ3RoOyBvKyspXG4gICAgICAgICAgdGhpcy5zZXRDZWxsQ29udGVudChlICsgMSwgbyArIDEsIHQuY29udGVudFtlXVtvXSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbGxzIGEgcm93IHdpdGggY2VsbHNcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm93IC0gcm93IHRvIGZpbGxcbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mQ29sdW1ucyAtIGhvdyBtYW55IGNlbGxzIHNob3VsZCBiZSBpbiBhIHJvd1xuICAgKi9cbiAgZmlsbFJvdyh0LCBlKSB7XG4gICAgZm9yIChsZXQgbyA9IDE7IG8gPD0gZTsgbysrKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5jcmVhdGVDZWxsKCk7XG4gICAgICB0LmFwcGVuZENoaWxkKGkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRpbmcgYSBjZWxsIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGNyZWF0ZUNlbGwoKSB7XG4gICAgcmV0dXJuIGMoXCJkaXZcIiwgci5jZWxsLCB7XG4gICAgICBjb250ZW50RWRpdGFibGU6ICF0aGlzLnJlYWRPbmx5XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGFibGVcbiAgICovXG4gIGdldCBudW1iZXJPZlJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGUuY2hpbGRFbGVtZW50Q291bnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGFibGVcbiAgICovXG4gIGdldCBudW1iZXJPZkNvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyT2ZSb3dzID8gdGhpcy50YWJsZS5xdWVyeVNlbGVjdG9yQWxsKGAuJHtyLnJvd306Zmlyc3QtY2hpbGQgLiR7ci5jZWxsfWApLmxlbmd0aCA6IDA7XG4gIH1cbiAgLyoqXG4gICAqIElzIHRoZSBjb2x1bW4gdG9vbGJveCBtZW51IGRpc3BsYXllZCBvciBub3RcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNDb2x1bW5NZW51U2hvd2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZENvbHVtbiAhPT0gMDtcbiAgfVxuICAvKipcbiAgICogSXMgdGhlIHJvdyB0b29sYm94IG1lbnUgZGlzcGxheWVkIG9yIG5vdFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1Jvd01lbnVTaG93aW5nKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkUm93ICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZWNhbGN1bGF0ZSBwb3NpdGlvbiBvZiB0b29sYm94IGljb25zXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gbW91c2UgbW92ZSBldmVudFxuICAgKi9cbiAgb25Nb3VzZU1vdmVJblRhYmxlKHQpIHtcbiAgICBjb25zdCB7IHJvdzogZSwgY29sdW1uOiBvIH0gPSB0aGlzLmdldEhvdmVyZWRDZWxsKHQpO1xuICAgIHRoaXMuaG92ZXJlZENvbHVtbiA9IG8sIHRoaXMuaG92ZXJlZFJvdyA9IGUsIHRoaXMudXBkYXRlVG9vbGJveGVzUG9zaXRpb24oKTtcbiAgfVxuICAvKipcbiAgICogUHJldmVudHMgZGVmYXVsdCBFbnRlciBiZWhhdmlvcnNcbiAgICogQWRkcyBTaGlmdCtFbnRlciBwcm9jZXNzaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlwcmVzcyBldmVudFxuICAgKi9cbiAgb25LZXlQcmVzc0xpc3RlbmVyKHQpIHtcbiAgICBpZiAodC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgaWYgKHQuc2hpZnRLZXkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHRoaXMubW92ZUN1cnNvclRvTmV4dFJvdygpO1xuICAgIH1cbiAgICByZXR1cm4gdC5rZXkgIT09IFwiRW50ZXJcIjtcbiAgfVxuICAvKipcbiAgICogUHJldmVudHMgdGFiIGtleWRvd24gZXZlbnQgZnJvbSBidWJibGluZ1xuICAgKiBzbyB0aGF0IGl0IG9ubHkgd29ya3MgaW5zaWRlIHRoZSB0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93biBldmVudFxuICAgKi9cbiAgb25LZXlEb3duTGlzdGVuZXIodCkge1xuICAgIHQua2V5ID09PSBcIlRhYlwiICYmIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbGwgdGhhdCB0aGUgZm9jdXMgaGFzIG1vdmVkIHRvXG4gICAqXG4gICAqIEBwYXJhbSB7Rm9jdXNFdmVudH0gZXZlbnQgLSBmb2N1c2luIGV2ZW50XG4gICAqL1xuICBmb2N1c0luVGFibGVMaXN0ZW5lcih0KSB7XG4gICAgY29uc3QgZSA9IHQudGFyZ2V0LCBvID0gdGhpcy5nZXRSb3dCeUNlbGwoZSk7XG4gICAgdGhpcy5mb2N1c2VkQ2VsbCA9IHtcbiAgICAgIHJvdzogQXJyYXkuZnJvbSh0aGlzLnRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3Iucm93fWApKS5pbmRleE9mKG8pICsgMSxcbiAgICAgIGNvbHVtbjogQXJyYXkuZnJvbShvLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3IuY2VsbH1gKSkuaW5kZXhPZihlKSArIDFcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVbnNlbGVjdCByb3cvY29sdW1uXG4gICAqIENsb3NlIHRvb2xib3ggbWVudVxuICAgKiBIaWRlIHRvb2xib3hlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGhpZGVUb29sYm94ZXMoKSB7XG4gICAgdGhpcy5oaWRlUm93VG9vbGJveCgpLCB0aGlzLmhpZGVDb2x1bW5Ub29sYm94KCksIHRoaXMudXBkYXRlVG9vbGJveGVzUG9zaXRpb24oKTtcbiAgfVxuICAvKipcbiAgICogVW5zZWxlY3Qgcm93LCBjbG9zZSB0b29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgaGlkZVJvd1Rvb2xib3goKSB7XG4gICAgdGhpcy51bnNlbGVjdFJvdygpLCB0aGlzLnRvb2xib3hSb3cuaGlkZSgpO1xuICB9XG4gIC8qKlxuICAgKiBVbnNlbGVjdCBjb2x1bW4sIGNsb3NlIHRvb2xib3hcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBoaWRlQ29sdW1uVG9vbGJveCgpIHtcbiAgICB0aGlzLnVuc2VsZWN0Q29sdW1uKCksIHRoaXMudG9vbGJveENvbHVtbi5oaWRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY3Vyc29yIGZvY3VzIHRvIHRoZSBmb2N1c2VkIGNlbGxcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb2N1c0NlbGwoKSB7XG4gICAgdGhpcy5mb2N1c2VkQ2VsbEVsZW0uZm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgZm9jdXNlZCBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBmb2N1c2VkIGNlbGxcbiAgICovXG4gIGdldCBmb2N1c2VkQ2VsbEVsZW0oKSB7XG4gICAgY29uc3QgeyByb3c6IHQsIGNvbHVtbjogZSB9ID0gdGhpcy5mb2N1c2VkQ2VsbDtcbiAgICByZXR1cm4gdGhpcy5nZXRDZWxsKHQsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdG9vbGJveGVzIHBvc2l0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSBob3ZlcmVkIHJvd1xuICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIC0gaG92ZXJlZCBjb2x1bW5cbiAgICovXG4gIHVwZGF0ZVRvb2xib3hlc1Bvc2l0aW9uKHQgPSB0aGlzLmhvdmVyZWRSb3csIGUgPSB0aGlzLmhvdmVyZWRDb2x1bW4pIHtcbiAgICB0aGlzLmlzQ29sdW1uTWVudVNob3dpbmcgfHwgZSA+IDAgJiYgZSA8PSB0aGlzLm51bWJlck9mQ29sdW1ucyAmJiB0aGlzLnRvb2xib3hDb2x1bW4uc2hvdygoKSA9PiAoe1xuICAgICAgbGVmdDogYGNhbGMoKDEwMCUgLSB2YXIoLS1jZWxsLXNpemUpKSAvICgke3RoaXMubnVtYmVyT2ZDb2x1bW5zfSAqIDIpICogKDEgKyAoJHtlfSAtIDEpICogMikpYFxuICAgIH0pKSwgdGhpcy5pc1Jvd01lbnVTaG93aW5nIHx8IHQgPiAwICYmIHQgPD0gdGhpcy5udW1iZXJPZlJvd3MgJiYgdGhpcy50b29sYm94Um93LnNob3coKCkgPT4ge1xuICAgICAgY29uc3QgbyA9IHRoaXMuZ2V0Um93KHQpLCB7IGZyb21Ub3BCb3JkZXI6IGkgfSA9IGcodGhpcy50YWJsZSwgbyksIHsgaGVpZ2h0OiBzIH0gPSBvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBgJHtNYXRoLmNlaWwoaSArIHMgLyAyKX1weGBcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIHRoZSBmaXJzdCByb3cgaGVhZGluZ3NcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSB3aXRoSGVhZGluZ3MgLSB1c2UgaGVhZGluZ3Mgcm93IG9yIG5vdFxuICAgKi9cbiAgc2V0SGVhZGluZ3NTZXR0aW5nKHQpIHtcbiAgICB0aGlzLnR1bmVzLndpdGhIZWFkaW5ncyA9IHQsIHQgPyAodGhpcy50YWJsZS5jbGFzc0xpc3QuYWRkKHIud2l0aEhlYWRpbmdzKSwgdGhpcy5hZGRIZWFkaW5nQXR0clRvRmlyc3RSb3coKSkgOiAodGhpcy50YWJsZS5jbGFzc0xpc3QucmVtb3ZlKHIud2l0aEhlYWRpbmdzKSwgdGhpcy5yZW1vdmVIZWFkaW5nQXR0ckZyb21GaXJzdFJvdygpKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBhdHRyaWJ1dGUgZm9yIGRpc3BsYXlpbmcgdGhlIHBsYWNlaG9sZGVyIGluIHRoZSBjZWxsXG4gICAqL1xuICBhZGRIZWFkaW5nQXR0clRvRmlyc3RSb3coKSB7XG4gICAgZm9yIChsZXQgdCA9IDE7IHQgPD0gdGhpcy5udW1iZXJPZkNvbHVtbnM7IHQrKykge1xuICAgICAgbGV0IGUgPSB0aGlzLmdldENlbGwoMSwgdCk7XG4gICAgICBlICYmIGUuc2V0QXR0cmlidXRlKFwiaGVhZGluZ1wiLCB0aGlzLmFwaS5pMThuLnQoXCJIZWFkaW5nXCIpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZvciBkaXNwbGF5aW5nIHRoZSBwbGFjZWhvbGRlciBpbiB0aGUgY2VsbFxuICAgKi9cbiAgcmVtb3ZlSGVhZGluZ0F0dHJGcm9tRmlyc3RSb3coKSB7XG4gICAgZm9yIChsZXQgdCA9IDE7IHQgPD0gdGhpcy5udW1iZXJPZkNvbHVtbnM7IHQrKykge1xuICAgICAgbGV0IGUgPSB0aGlzLmdldENlbGwoMSwgdCk7XG4gICAgICBlICYmIGUucmVtb3ZlQXR0cmlidXRlKFwiaGVhZGluZ1wiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBlZmZlY3Qgb2YgYSBzZWxlY3RlZCByb3dcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqL1xuICBzZWxlY3RSb3codCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmdldFJvdyh0KTtcbiAgICBlICYmICh0aGlzLnNlbGVjdGVkUm93ID0gdCwgZS5jbGFzc0xpc3QuYWRkKHIucm93U2VsZWN0ZWQpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGVmZmVjdCBvZiBhIHNlbGVjdGVkIHJvd1xuICAgKi9cbiAgdW5zZWxlY3RSb3coKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRSb3cgPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy50YWJsZS5xdWVyeVNlbGVjdG9yKGAuJHtyLnJvd1NlbGVjdGVkfWApO1xuICAgIHQgJiYgdC5jbGFzc0xpc3QucmVtb3ZlKHIucm93U2VsZWN0ZWQpLCB0aGlzLnNlbGVjdGVkUm93ID0gMDtcbiAgfVxuICAvKipcbiAgICogQWRkIGVmZmVjdCBvZiBhIHNlbGVjdGVkIGNvbHVtblxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG4gIHNlbGVjdENvbHVtbih0KSB7XG4gICAgZm9yIChsZXQgZSA9IDE7IGUgPD0gdGhpcy5udW1iZXJPZlJvd3M7IGUrKykge1xuICAgICAgY29uc3QgbyA9IHRoaXMuZ2V0Q2VsbChlLCB0KTtcbiAgICAgIG8gJiYgby5jbGFzc0xpc3QuYWRkKHIuY2VsbFNlbGVjdGVkKTtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RlZENvbHVtbiA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBlZmZlY3Qgb2YgYSBzZWxlY3RlZCBjb2x1bW5cbiAgICovXG4gIHVuc2VsZWN0Q29sdW1uKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkQ29sdW1uIDw9IDApXG4gICAgICByZXR1cm47XG4gICAgbGV0IHQgPSB0aGlzLnRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3IuY2VsbFNlbGVjdGVkfWApO1xuICAgIEFycmF5LmZyb20odCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5jbGFzc0xpc3QucmVtb3ZlKHIuY2VsbFNlbGVjdGVkKTtcbiAgICB9KSwgdGhpcy5zZWxlY3RlZENvbHVtbiA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHJvdyBhbmQgY29sdW1uIHRoYXQgdGhlIGN1cnNvciBpcyBjdXJyZW50bHkgaG92ZXJpbmcgb3ZlclxuICAgKiBUaGUgc2VhcmNoIHdhcyBvcHRpbWl6ZWQgZnJvbSBPKG4pIHRvIE8gKGxvZyBuKSB2aWEgYmluIHNlYXJjaCB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBjYWxjdWxhdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBtb3VzZW1vdmUgZXZlbnRcbiAgICogQHJldHVybnMgaG92ZXJlZCBjZWxsIGNvb3JkaW5hdGVzIGFzIGFuIGludGVnZXIgcm93IGFuZCBjb2x1bW5cbiAgICovXG4gIGdldEhvdmVyZWRDZWxsKHQpIHtcbiAgICBsZXQgZSA9IHRoaXMuaG92ZXJlZFJvdywgbyA9IHRoaXMuaG92ZXJlZENvbHVtbjtcbiAgICBjb25zdCB7IHdpZHRoOiBpLCBoZWlnaHQ6IHMsIHg6IG4sIHk6IGggfSA9IFIodGhpcy50YWJsZSwgdCk7XG4gICAgcmV0dXJuIG4gPj0gMCAmJiAobyA9IHRoaXMuYmluU2VhcmNoKFxuICAgICAgdGhpcy5udW1iZXJPZkNvbHVtbnMsXG4gICAgICAobCkgPT4gdGhpcy5nZXRDZWxsKDEsIGwpLFxuICAgICAgKHsgZnJvbUxlZnRCb3JkZXI6IGwgfSkgPT4gbiA8IGwsXG4gICAgICAoeyBmcm9tUmlnaHRCb3JkZXI6IGwgfSkgPT4gbiA+IGkgLSBsXG4gICAgKSksIGggPj0gMCAmJiAoZSA9IHRoaXMuYmluU2VhcmNoKFxuICAgICAgdGhpcy5udW1iZXJPZlJvd3MsXG4gICAgICAobCkgPT4gdGhpcy5nZXRDZWxsKGwsIDEpLFxuICAgICAgKHsgZnJvbVRvcEJvcmRlcjogbCB9KSA9PiBoIDwgbCxcbiAgICAgICh7IGZyb21Cb3R0b21Cb3JkZXI6IGwgfSkgPT4gaCA+IHMgLSBsXG4gICAgKSksIHtcbiAgICAgIHJvdzogZSB8fCB0aGlzLmhvdmVyZWRSb3csXG4gICAgICBjb2x1bW46IG8gfHwgdGhpcy5ob3ZlcmVkQ29sdW1uXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTG9va3MgZm9yIHRoZSBpbmRleCBvZiB0aGUgY2VsbCB0aGUgbW91c2UgaXMgaG92ZXJpbmcgb3Zlci5cbiAgICogQ2VsbHMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIG9yZGVyZWQgaW50ZXJ2YWxzIHdpdGggbGVmdCBhbmRcbiAgICogcmlnaHQgKHVwcGVyIGFuZCBsb3dlciBmb3Igcm93cykgYm9yZGVycyBpbnNpZGUgdGhlIHRhYmxlLCBpZiB0aGUgbW91c2UgZW50ZXJzIGl0LCB0aGVuIHRoaXMgaXMgb3VyIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkNlbGxzIC0gdXBwZXIgYm91bmQgb2YgYmluYXJ5IHNlYXJjaFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRDZWxsIC0gZnVuY3Rpb24gdG8gdGFrZSB0aGUgY3VycmVudGx5IHZpZXdlZCBjZWxsXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGJlZm9yZVRoZUxlZnRCb3JkZXIgLSBkZXRlcm1pbmVzIHRoZSBjdXJzb3IgcG9zaXRpb24sIHRvIHRoZSBsZWZ0IG9mIHRoZSBjZWxsIG9yIG5vdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBhZnRlclRoZVJpZ2h0Qm9yZGVyIC0gZGV0ZXJtaW5lcyB0aGUgY3Vyc29yIHBvc2l0aW9uLCB0byB0aGUgcmlnaHQgb2YgdGhlIGNlbGwgb3Igbm90XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBiaW5TZWFyY2godCwgZSwgbywgaSkge1xuICAgIGxldCBzID0gMCwgbiA9IHQgKyAxLCBoID0gMCwgbDtcbiAgICBmb3IgKDsgcyA8IG4gLSAxICYmIGggPCAxMDsgKSB7XG4gICAgICBsID0gTWF0aC5jZWlsKChzICsgbikgLyAyKTtcbiAgICAgIGNvbnN0IHcgPSBlKGwpLCBwID0gZyh0aGlzLnRhYmxlLCB3KTtcbiAgICAgIGlmIChvKHApKVxuICAgICAgICBuID0gbDtcbiAgICAgIGVsc2UgaWYgKGkocCkpXG4gICAgICAgIHMgPSBsO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICAgIGgrKztcbiAgICB9XG4gICAgcmV0dXJuIGw7XG4gIH1cbiAgLyoqXG4gICAqIENvbGxlY3RzIGRhdGEgZnJvbSBjZWxscyBpbnRvIGEgdHdvLWRpbWVuc2lvbmFsIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZ2V0RGF0YSgpIHtcbiAgICBjb25zdCB0ID0gW107XG4gICAgZm9yIChsZXQgZSA9IDE7IGUgPD0gdGhpcy5udW1iZXJPZlJvd3M7IGUrKykge1xuICAgICAgY29uc3QgbyA9IHRoaXMudGFibGUucXVlcnlTZWxlY3RvcihgLiR7ci5yb3d9Om50aC1jaGlsZCgke2V9KWApLCBpID0gQXJyYXkuZnJvbShvLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3IuY2VsbH1gKSk7XG4gICAgICBpLmV2ZXJ5KChuKSA9PiAhbi50ZXh0Q29udGVudC50cmltKCkpIHx8IHQucHVzaChpLm1hcCgobikgPT4gbi5pbm5lckhUTUwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgb24gdGhlIGRvY3VtZW50XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmRvY3VtZW50Q2xpY2tlZCk7XG4gIH1cbn1cbmNsYXNzIEkge1xuICAvKipcbiAgICogTm90aWZ5IGNvcmUgdGhhdCByZWFkLW9ubHkgbW9kZSBpcyBzdXBwb3J0ZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvdyB0byBwcmVzcyBFbnRlciBpbnNpZGUgdGhlIENvZGVUb29sIHRleHRhcmVhXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZ2V0IGVuYWJsZUxpbmVCcmVha3MoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGx1Z2luYHMgbWFpbiBFbGVtZW50IGFuZCBmaWxsIGl0IHdpdGggc2F2ZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge1RhYmxlRGF0YX0gZGF0YSDigJQgcHJldmlvdXNseSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSB7VGFibGVDb25maWd9IGNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IHQsIGNvbmZpZzogZSwgYXBpOiBvLCByZWFkT25seTogaSB9KSB7XG4gICAgdGhpcy5hcGkgPSBvLCB0aGlzLnJlYWRPbmx5ID0gaSwgdGhpcy5jb25maWcgPSBlLCB0aGlzLmRhdGEgPSB7XG4gICAgICB3aXRoSGVhZGluZ3M6IHRoaXMuZ2V0Q29uZmlnKFwid2l0aEhlYWRpbmdzXCIsICExLCB0KSxcbiAgICAgIGNvbnRlbnQ6IHQgJiYgdC5jb250ZW50ID8gdC5jb250ZW50IDogW11cbiAgICB9LCB0aGlzLnRhYmxlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogR2V0IFRvb2wgdG9vbGJveCBzZXR0aW5nc1xuICAgKiBpY29uIC0gVG9vbCBpY29uJ3MgU1ZHXG4gICAqIHRpdGxlIC0gdGl0bGUgdG8gc2hvdyBpbiB0b29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHt7aWNvbjogc3RyaW5nLCB0aXRsZTogc3RyaW5nfX1cbiAgICovXG4gIHN0YXRpYyBnZXQgdG9vbGJveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogTyxcbiAgICAgIHRpdGxlOiBcIlRhYmxlXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbCdzIHZpZXdcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlID0gbmV3IEEodGhpcy5yZWFkT25seSwgdGhpcy5hcGksIHRoaXMuZGF0YSwgdGhpcy5jb25maWcpLCB0aGlzLmNvbnRhaW5lciA9IGMoXCJkaXZcIiwgdGhpcy5hcGkuc3R5bGVzLmJsb2NrKSwgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50YWJsZS5nZXRXcmFwcGVyKCkpLCB0aGlzLnRhYmxlLnNldEhlYWRpbmdzU2V0dGluZyh0aGlzLmRhdGEud2l0aEhlYWRpbmdzKSwgdGhpcy5jb250YWluZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcGx1Z2luIHNldHRpbmdzXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIHJlbmRlclNldHRpbmdzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJXaXRoIGhlYWRpbmdzXCIpLFxuICAgICAgICBpY29uOiBMLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5kYXRhLndpdGhIZWFkaW5ncyxcbiAgICAgICAgY2xvc2VPbkFjdGl2YXRlOiAhMCxcbiAgICAgICAgdG9nZ2xlOiAhMCxcbiAgICAgICAgb25BY3RpdmF0ZTogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGF0YS53aXRoSGVhZGluZ3MgPSAhMCwgdGhpcy50YWJsZS5zZXRIZWFkaW5nc1NldHRpbmcodGhpcy5kYXRhLndpdGhIZWFkaW5ncyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJXaXRob3V0IGhlYWRpbmdzXCIpLFxuICAgICAgICBpY29uOiBNLFxuICAgICAgICBpc0FjdGl2ZTogIXRoaXMuZGF0YS53aXRoSGVhZGluZ3MsXG4gICAgICAgIGNsb3NlT25BY3RpdmF0ZTogITAsXG4gICAgICAgIHRvZ2dsZTogITAsXG4gICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmRhdGEud2l0aEhlYWRpbmdzID0gITEsIHRoaXMudGFibGUuc2V0SGVhZGluZ3NTZXR0aW5nKHRoaXMuZGF0YS53aXRoSGVhZGluZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCB0YWJsZSBkYXRhIGZyb20gdGhlIHZpZXdcbiAgICpcbiAgICogQHJldHVybnMge1RhYmxlRGF0YX0gLSBzYXZlZCBkYXRhXG4gICAqL1xuICBzYXZlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnRhYmxlLmdldERhdGEoKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2l0aEhlYWRpbmdzOiB0aGlzLmRhdGEud2l0aEhlYWRpbmdzLFxuICAgICAgY29udGVudDogdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFBsdWdpbiBkZXN0cm95ZXJcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMudGFibGUuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBBIGhlbHBlciB0byBnZXQgY29uZmlnIHZhbHVlLlxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZ05hbWUgLSB0aGUga2V5IHRvIGdldCBmcm9tIHRoZSBjb25maWcuIFxuICAgKiBAcGFyYW0ge2FueX0gZGVmYXVsdFZhbHVlIC0gZGVmYXVsdCB2YWx1ZSBpZiBjb25maWcgZG9lc24ndCBoYXZlIHBhc3NlZCBrZXlcbiAgICogQHBhcmFtIHtvYmplY3R9IHNhdmVkRGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YS4gSWYgcGFzc2VkLCB0aGUga2V5IHdpbGwgYmUgZ290IGZyb20gdGhlcmUsIG90aGVyd2lzZSBmcm9tIHRoZSBjb25maWdcbiAgICogQHJldHVybnMge2FueX0gLSBjb25maWcgdmFsdWUuXG4gICAqL1xuICBnZXRDb25maWcodCwgZSA9IHZvaWQgMCwgbyA9IHZvaWQgMCkge1xuICAgIGNvbnN0IGkgPSB0aGlzLmRhdGEgfHwgbztcbiAgICByZXR1cm4gaSA/IGlbdF0gPyBpW3RdIDogZSA6IHRoaXMuY29uZmlnICYmIHRoaXMuY29uZmlnW3RdID8gdGhpcy5jb25maWdbdF0gOiBlO1xuICB9XG4gIC8qKiAgXG4gICAqIFRhYmxlIG9uUGFzdGUgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZ2V0IHBhc3RlQ29uZmlnKCkge1xuICAgIHJldHVybiB7IHRhZ3M6IFtcIlRBQkxFXCIsIFwiVFJcIiwgXCJUSFwiLCBcIlREXCJdIH07XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgZnJvbSBFZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIHtQYXN0ZUV2ZW50fSBldmVudCAtIGV2ZW50IHdpdGggcGFzdGVkIGRhdGFcbiAgICovXG4gIG9uUGFzdGUodCkge1xuICAgIGNvbnN0IGUgPSB0LmRldGFpbC5kYXRhLCBvID0gZS5xdWVyeVNlbGVjdG9yKFwiOnNjb3BlID4gdGhlYWQsIHRyOmZpcnN0LW9mLXR5cGUgdGhcIiksIHMgPSBBcnJheS5mcm9tKGUucXVlcnlTZWxlY3RvckFsbChcInRyXCIpKS5tYXAoKG4pID0+IEFycmF5LmZyb20obi5xdWVyeVNlbGVjdG9yQWxsKFwidGgsIHRkXCIpKS5tYXAoKGwpID0+IGwuaW5uZXJIVE1MKSk7XG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgd2l0aEhlYWRpbmdzOiBvICE9PSBudWxsLFxuICAgICAgY29udGVudDogc1xuICAgIH0sIHRoaXMudGFibGUud3JhcHBlciAmJiB0aGlzLnRhYmxlLndyYXBwZXIucmVwbGFjZVdpdGgodGhpcy5yZW5kZXIoKSk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEkgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/table/dist/table.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/warning/dist/warning.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@editorjs/warning/dist/warning.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(`.cdx-warning{position:relative}@media all and (min-width: 736px){.cdx-warning{padding-left:36px}}.cdx-warning [contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.cdx-warning [contentEditable=true][data-placeholder]:empty:before{opacity:1}.cdx-warning [contentEditable=true][data-placeholder]:empty:focus:before{opacity:0}.cdx-warning:before{content:\"\";background-image:url(\"data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='5' y='5' width='14' height='14' rx='4' stroke='black' stroke-width='2'/%3E%3Cline x1='12' y1='9' x2='12' y2='12' stroke='black' stroke-width='2' stroke-linecap='round'/%3E%3Cpath d='M12 15.02V15.01' stroke='black' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E\");width:24px;height:24px;background-size:24px 24px;position:absolute;margin-top:8px;left:0}@media all and (max-width: 735px){.cdx-warning:before{display:none}}.cdx-warning__message{min-height:85px}.cdx-warning__title{margin-bottom:6px}`)),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nconst n = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/><line x1=\"12\" x2=\"12\" y1=\"9\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 15.02V15.01\"/></svg>';\nclass r {\n  /**\n   * Notify core that read-only mode is supported\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get Toolbox settings\n   *\n   * @public\n   * @returns {string}\n   */\n  static get toolbox() {\n    return {\n      icon: n,\n      title: \"Warning\"\n    };\n  }\n  /**\n   * Allow to press Enter inside the Warning\n   *\n   * @public\n   * @returns {boolean}\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Default placeholder for warning title\n   *\n   * @public\n   * @returns {string}\n   */\n  static get DEFAULT_TITLE_PLACEHOLDER() {\n    return \"Title\";\n  }\n  /**\n   * Default placeholder for warning message\n   *\n   * @public\n   * @returns {string}\n   */\n  static get DEFAULT_MESSAGE_PLACEHOLDER() {\n    return \"Message\";\n  }\n  /**\n   * Warning Tool`s styles\n   *\n   * @returns {object}\n   */\n  get CSS() {\n    return {\n      baseClass: this.api.styles.block,\n      wrapper: \"cdx-warning\",\n      title: \"cdx-warning__title\",\n      input: this.api.styles.input,\n      message: \"cdx-warning__message\"\n    };\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {WarningData} data — previously saved data\n   * @param {WarningConfig} config — user config for Tool\n   * @param {object} api - Editor.js API\n   * @param {boolean} readOnly - read-only mode flag\n   */\n  constructor({ data: e, config: t, api: s, readOnly: i }) {\n    this.api = s, this.readOnly = i, this.titlePlaceholder = t.titlePlaceholder || r.DEFAULT_TITLE_PLACEHOLDER, this.messagePlaceholder = t.messagePlaceholder || r.DEFAULT_MESSAGE_PLACEHOLDER, this.data = {\n      title: e.title || \"\",\n      message: e.message || \"\"\n    };\n  }\n  /**\n   * Create Warning Tool container with inputs\n   *\n   * @returns {Element}\n   */\n  render() {\n    const e = this._make(\"div\", [this.CSS.baseClass, this.CSS.wrapper]), t = this._make(\"div\", [this.CSS.input, this.CSS.title], {\n      contentEditable: !this.readOnly,\n      innerHTML: this.data.title\n    }), s = this._make(\"div\", [this.CSS.input, this.CSS.message], {\n      contentEditable: !this.readOnly,\n      innerHTML: this.data.message\n    });\n    return t.dataset.placeholder = this.titlePlaceholder, s.dataset.placeholder = this.messagePlaceholder, e.appendChild(t), e.appendChild(s), e;\n  }\n  /**\n   * Extract Warning data from Warning Tool element\n   *\n   * @param {HTMLDivElement} warningElement - element to save\n   * @returns {WarningData}\n   */\n  save(e) {\n    const t = e.querySelector(`.${this.CSS.title}`), s = e.querySelector(`.${this.CSS.message}`);\n    return Object.assign(this.data, {\n      title: t.innerHTML,\n      message: s.innerHTML\n    });\n  }\n  /**\n   * Helper for making Elements with attributes\n   *\n   * @param  {string} tagName           - new Element tag name\n   * @param  {Array|string} classNames  - list or name of CSS classname(s)\n   * @param  {object} attributes        - any attributes\n   * @returns {Element}\n   */\n  _make(e, t = null, s = {}) {\n    const i = document.createElement(e);\n    Array.isArray(t) ? i.classList.add(...t) : t && i.classList.add(t);\n    for (const a in s)\n      i[a] = s[a];\n    return i;\n  }\n  /**\n   * Sanitizer config for Warning Tool saved data\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      title: {},\n      message: {}\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL3dhcm5pbmcvZGlzdC93YXJuaW5nLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsWUFBWSxhQUFhLElBQUksd0JBQXdCLHNDQUFzQyxvREFBb0Qsa0JBQWtCLGtDQUFrQyxhQUFhLG1CQUFtQiw2REFBNkQsa0JBQWtCLCtCQUErQixjQUFjLGdCQUFnQixVQUFVLG1FQUFtRSxVQUFVLHlFQUF5RSxVQUFVLG9CQUFvQixXQUFXLHFhQUFxYSxXQUFXLFlBQVksMEJBQTBCLGtCQUFrQixlQUFlLE9BQU8sa0NBQWtDLG9CQUFvQixjQUFjLHNCQUFzQixnQkFBZ0Isb0JBQW9CLGtCQUFrQixrQ0FBa0MsU0FBUyxtREFBbUQ7QUFDcHlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWU7QUFDZjtBQUNBO0FBQ0Esa0NBQWtDLGVBQWUsNEJBQTRCLGlCQUFpQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZWRpdG9yanMtYXBwLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy93YXJuaW5nL2Rpc3Qvd2FybmluZy5tanM/OGRiZSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt0cnl7aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgLmNkeC13YXJuaW5ne3Bvc2l0aW9uOnJlbGF0aXZlfUBtZWRpYSBhbGwgYW5kIChtaW4td2lkdGg6IDczNnB4KXsuY2R4LXdhcm5pbmd7cGFkZGluZy1sZWZ0OjM2cHh9fS5jZHgtd2FybmluZyBbY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTtjb250ZW50OmF0dHIoZGF0YS1wbGFjZWhvbGRlcik7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo0MDA7b3BhY2l0eTowfS5jZHgtd2FybmluZyBbY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmJlZm9yZXtvcGFjaXR5OjF9LmNkeC13YXJuaW5nIFtjb250ZW50RWRpdGFibGU9dHJ1ZV1bZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6Zm9jdXM6YmVmb3Jle29wYWNpdHk6MH0uY2R4LXdhcm5pbmc6YmVmb3Jle2NvbnRlbnQ6XCJcIjtiYWNrZ3JvdW5kLWltYWdlOnVybChcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0Nzdmcgd2lkdGg9JzI0JyBoZWlnaHQ9JzI0JyB2aWV3Qm94PScwIDAgMjQgMjQnIGZpbGw9J25vbmUnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyclM0UlM0NyZWN0IHg9JzUnIHk9JzUnIHdpZHRoPScxNCcgaGVpZ2h0PScxNCcgcng9JzQnIHN0cm9rZT0nYmxhY2snIHN0cm9rZS13aWR0aD0nMicvJTNFJTNDbGluZSB4MT0nMTInIHkxPSc5JyB4Mj0nMTInIHkyPScxMicgc3Ryb2tlPSdibGFjaycgc3Ryb2tlLXdpZHRoPScyJyBzdHJva2UtbGluZWNhcD0ncm91bmQnLyUzRSUzQ3BhdGggZD0nTTEyIDE1LjAyVjE1LjAxJyBzdHJva2U9J2JsYWNrJyBzdHJva2Utd2lkdGg9JzInIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcvJTNFJTNDL3N2ZyUzRVwiKTt3aWR0aDoyNHB4O2hlaWdodDoyNHB4O2JhY2tncm91bmQtc2l6ZToyNHB4IDI0cHg7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luLXRvcDo4cHg7bGVmdDowfUBtZWRpYSBhbGwgYW5kIChtYXgtd2lkdGg6IDczNXB4KXsuY2R4LXdhcm5pbmc6YmVmb3Jle2Rpc3BsYXk6bm9uZX19LmNkeC13YXJuaW5nX19tZXNzYWdle21pbi1oZWlnaHQ6ODVweH0uY2R4LXdhcm5pbmdfX3RpdGxle21hcmdpbi1ib3R0b206NnB4fWApKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGUpfX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsdCl9fSkoKTtcbmNvbnN0IG4gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHJlY3Qgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgeD1cIjVcIiB5PVwiNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiByeD1cIjRcIi8+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTJcIiB5MT1cIjlcIiB5Mj1cIjEyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEyIDE1LjAyVjE1LjAxXCIvPjwvc3ZnPic7XG5jbGFzcyByIHtcbiAgLyoqXG4gICAqIE5vdGlmeSBjb3JlIHRoYXQgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgVG9vbGJveCBzZXR0aW5nc1xuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IG4sXG4gICAgICB0aXRsZTogXCJXYXJuaW5nXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBbGxvdyB0byBwcmVzcyBFbnRlciBpbnNpZGUgdGhlIFdhcm5pbmdcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZW5hYmxlTGluZUJyZWFrcygpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIERlZmF1bHQgcGxhY2Vob2xkZXIgZm9yIHdhcm5pbmcgdGl0bGVcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBERUZBVUxUX1RJVExFX1BMQUNFSE9MREVSKCkge1xuICAgIHJldHVybiBcIlRpdGxlXCI7XG4gIH1cbiAgLyoqXG4gICAqIERlZmF1bHQgcGxhY2Vob2xkZXIgZm9yIHdhcm5pbmcgbWVzc2FnZVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERFRkFVTFRfTUVTU0FHRV9QTEFDRUhPTERFUigpIHtcbiAgICByZXR1cm4gXCJNZXNzYWdlXCI7XG4gIH1cbiAgLyoqXG4gICAqIFdhcm5pbmcgVG9vbGBzIHN0eWxlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUNsYXNzOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICB3cmFwcGVyOiBcImNkeC13YXJuaW5nXCIsXG4gICAgICB0aXRsZTogXCJjZHgtd2FybmluZ19fdGl0bGVcIixcbiAgICAgIGlucHV0OiB0aGlzLmFwaS5zdHlsZXMuaW5wdXQsXG4gICAgICBtZXNzYWdlOiBcImNkeC13YXJuaW5nX19tZXNzYWdlXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGx1Z2luYHMgbWFpbiBFbGVtZW50IGFuZCBmaWxsIGl0IHdpdGggc2F2ZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge1dhcm5pbmdEYXRhfSBkYXRhIOKAlCBwcmV2aW91c2x5IHNhdmVkIGRhdGFcbiAgICogQHBhcmFtIHtXYXJuaW5nQ29uZmlnfSBjb25maWcg4oCUIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IGUsIGNvbmZpZzogdCwgYXBpOiBzLCByZWFkT25seTogaSB9KSB7XG4gICAgdGhpcy5hcGkgPSBzLCB0aGlzLnJlYWRPbmx5ID0gaSwgdGhpcy50aXRsZVBsYWNlaG9sZGVyID0gdC50aXRsZVBsYWNlaG9sZGVyIHx8IHIuREVGQVVMVF9USVRMRV9QTEFDRUhPTERFUiwgdGhpcy5tZXNzYWdlUGxhY2Vob2xkZXIgPSB0Lm1lc3NhZ2VQbGFjZWhvbGRlciB8fCByLkRFRkFVTFRfTUVTU0FHRV9QTEFDRUhPTERFUiwgdGhpcy5kYXRhID0ge1xuICAgICAgdGl0bGU6IGUudGl0bGUgfHwgXCJcIixcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSB8fCBcIlwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIFdhcm5pbmcgVG9vbCBjb250YWluZXIgd2l0aCBpbnB1dHNcbiAgICpcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX21ha2UoXCJkaXZcIiwgW3RoaXMuQ1NTLmJhc2VDbGFzcywgdGhpcy5DU1Mud3JhcHBlcl0pLCB0ID0gdGhpcy5fbWFrZShcImRpdlwiLCBbdGhpcy5DU1MuaW5wdXQsIHRoaXMuQ1NTLnRpdGxlXSwge1xuICAgICAgY29udGVudEVkaXRhYmxlOiAhdGhpcy5yZWFkT25seSxcbiAgICAgIGlubmVySFRNTDogdGhpcy5kYXRhLnRpdGxlXG4gICAgfSksIHMgPSB0aGlzLl9tYWtlKFwiZGl2XCIsIFt0aGlzLkNTUy5pbnB1dCwgdGhpcy5DU1MubWVzc2FnZV0sIHtcbiAgICAgIGNvbnRlbnRFZGl0YWJsZTogIXRoaXMucmVhZE9ubHksXG4gICAgICBpbm5lckhUTUw6IHRoaXMuZGF0YS5tZXNzYWdlXG4gICAgfSk7XG4gICAgcmV0dXJuIHQuZGF0YXNldC5wbGFjZWhvbGRlciA9IHRoaXMudGl0bGVQbGFjZWhvbGRlciwgcy5kYXRhc2V0LnBsYWNlaG9sZGVyID0gdGhpcy5tZXNzYWdlUGxhY2Vob2xkZXIsIGUuYXBwZW5kQ2hpbGQodCksIGUuYXBwZW5kQ2hpbGQocyksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgV2FybmluZyBkYXRhIGZyb20gV2FybmluZyBUb29sIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gd2FybmluZ0VsZW1lbnQgLSBlbGVtZW50IHRvIHNhdmVcbiAgICogQHJldHVybnMge1dhcm5pbmdEYXRhfVxuICAgKi9cbiAgc2F2ZShlKSB7XG4gICAgY29uc3QgdCA9IGUucXVlcnlTZWxlY3RvcihgLiR7dGhpcy5DU1MudGl0bGV9YCksIHMgPSBlLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuQ1NTLm1lc3NhZ2V9YCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcy5kYXRhLCB7XG4gICAgICB0aXRsZTogdC5pbm5lckhUTUwsXG4gICAgICBtZXNzYWdlOiBzLmlubmVySFRNTFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIG1ha2luZyBFbGVtZW50cyB3aXRoIGF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWdOYW1lICAgICAgICAgICAtIG5ldyBFbGVtZW50IHRhZyBuYW1lXG4gICAqIEBwYXJhbSAge0FycmF5fHN0cmluZ30gY2xhc3NOYW1lcyAgLSBsaXN0IG9yIG5hbWUgb2YgQ1NTIGNsYXNzbmFtZShzKVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZXMgICAgICAgIC0gYW55IGF0dHJpYnV0ZXNcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICBfbWFrZShlLCB0ID0gbnVsbCwgcyA9IHt9KSB7XG4gICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSk7XG4gICAgQXJyYXkuaXNBcnJheSh0KSA/IGkuY2xhc3NMaXN0LmFkZCguLi50KSA6IHQgJiYgaS5jbGFzc0xpc3QuYWRkKHQpO1xuICAgIGZvciAoY29uc3QgYSBpbiBzKVxuICAgICAgaVthXSA9IHNbYV07XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBjb25maWcgZm9yIFdhcm5pbmcgVG9vbCBzYXZlZCBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHNhbml0aXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0aXRsZToge30sXG4gICAgICBtZXNzYWdlOiB7fVxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCB7XG4gIHIgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/warning/dist/warning.mjs\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@alkhipce";
exports.ids = ["vendor-chunks/@alkhipce"];
exports.modules = {

/***/ "(ssr)/./node_modules/@alkhipce/editorjs-aitext/dist/aitext.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@alkhipce/editorjs-aitext/dist/aitext.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Un)\n/* harmony export */ });\nvar zt = Object.defineProperty;\nvar Qt = (n, e, t) => e in n ? zt(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;\nvar Be = (n, e, t) => (Qt(n, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nconst D = \"4.17.3\";\nlet dt = !1, J, xt, Pt, qe, Rt, St, At, Et, $t;\nfunction Yt(n, e = { auto: !1 }) {\n  if (dt)\n    throw new Error(`you must \\`import 'openai/shims/${n.kind}'\\` before importing anything else from openai`);\n  if (J)\n    throw new Error(`can't \\`import 'openai/shims/${n.kind}'\\` after \\`import 'openai/shims/${J}'\\``);\n  dt = e.auto, J = n.kind, xt = n.fetch, n.Request, n.Response, n.Headers, Pt = n.FormData, n.Blob, qe = n.File, Rt = n.ReadableStream, St = n.getMultipartRequestOptions, At = n.getDefaultAgent, Et = n.fileFromPath, $t = n.isFsReadStream;\n}\nclass Zt {\n  constructor(e) {\n    this.body = e;\n  }\n  get [Symbol.toStringTag]() {\n    return \"MultipartBody\";\n  }\n}\nfunction en({ manuallyImported: n } = {}) {\n  const e = n ? \"You may need to use polyfills\" : \"Add one of these imports before your first `import â€¦ from 'openai'`:\\n- `import 'openai/shims/node'` (if you're running on Node)\\n- `import 'openai/shims/web'` (otherwise)\\n\";\n  let t, s, r, i;\n  try {\n    t = fetch, s = Request, r = Response, i = Headers;\n  } catch (a) {\n    throw new Error(`this environment is missing the following Web Fetch API type: ${a.message}. ${e}`);\n  }\n  return {\n    kind: \"web\",\n    fetch: t,\n    Request: s,\n    Response: r,\n    Headers: i,\n    FormData: (\n      // @ts-ignore\n      typeof FormData < \"u\" ? FormData : class {\n        // @ts-ignore\n        constructor() {\n          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`);\n        }\n      }\n    ),\n    Blob: typeof Blob < \"u\" ? Blob : class {\n      constructor() {\n        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`);\n      }\n    },\n    File: (\n      // @ts-ignore\n      typeof File < \"u\" ? File : class {\n        // @ts-ignore\n        constructor() {\n          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`);\n        }\n      }\n    ),\n    ReadableStream: (\n      // @ts-ignore\n      typeof ReadableStream < \"u\" ? ReadableStream : class {\n        // @ts-ignore\n        constructor() {\n          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`);\n        }\n      }\n    ),\n    getMultipartRequestOptions: async (a, o) => ({\n      ...o,\n      body: new Zt(a)\n    }),\n    getDefaultAgent: (a) => {\n    },\n    fileFromPath: () => {\n      throw new Error(\"The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads\");\n    },\n    isFsReadStream: (a) => !1\n  };\n}\nJ || Yt(en(), { auto: !0 });\nclass m extends Error {\n}\nclass _ extends m {\n  constructor(e, t, s, r) {\n    super(`${_.makeMessage(e, t, s)}`), this.status = e, this.headers = r;\n    const i = t;\n    this.error = i, this.code = i == null ? void 0 : i.code, this.param = i == null ? void 0 : i.param, this.type = i == null ? void 0 : i.type;\n  }\n  static makeMessage(e, t, s) {\n    const r = t != null && t.message ? typeof t.message == \"string\" ? t.message : JSON.stringify(t.message) : t ? JSON.stringify(t) : s;\n    return e && r ? `${e} ${r}` : e ? `${e} status code (no body)` : r || \"(no status code or body)\";\n  }\n  static generate(e, t, s, r) {\n    if (!e)\n      return new Ie({ cause: Xe(t) });\n    const i = t == null ? void 0 : t.error;\n    return e === 400 ? new Tt(e, i, s, r) : e === 401 ? new vt(e, i, s, r) : e === 403 ? new Ft(e, i, s, r) : e === 404 ? new It(e, i, s, r) : e === 409 ? new Mt(e, i, s, r) : e === 422 ? new kt(e, i, s, r) : e === 429 ? new Ot(e, i, s, r) : e >= 500 ? new Lt(e, i, s, r) : new _(e, i, s, r);\n  }\n}\nclass j extends _ {\n  constructor({ message: e } = {}) {\n    super(void 0, void 0, e || \"Request was aborted.\", void 0), this.status = void 0;\n  }\n}\nclass Ie extends _ {\n  constructor({ message: e, cause: t }) {\n    super(void 0, void 0, e || \"Connection error.\", void 0), this.status = void 0, t && (this.cause = t);\n  }\n}\nclass Ze extends Ie {\n  constructor({ message: e } = {}) {\n    super({ message: e ?? \"Request timed out.\" });\n  }\n}\nclass Tt extends _ {\n  constructor() {\n    super(...arguments), this.status = 400;\n  }\n}\nclass vt extends _ {\n  constructor() {\n    super(...arguments), this.status = 401;\n  }\n}\nclass Ft extends _ {\n  constructor() {\n    super(...arguments), this.status = 403;\n  }\n}\nclass It extends _ {\n  constructor() {\n    super(...arguments), this.status = 404;\n  }\n}\nclass Mt extends _ {\n  constructor() {\n    super(...arguments), this.status = 409;\n  }\n}\nclass kt extends _ {\n  constructor() {\n    super(...arguments), this.status = 422;\n  }\n}\nclass Ot extends _ {\n  constructor() {\n    super(...arguments), this.status = 429;\n  }\n}\nclass Lt extends _ {\n}\nclass L {\n  constructor(e, t) {\n    this.iterator = e, this.controller = t;\n  }\n  static fromSSEResponse(e, t) {\n    let s = !1;\n    const r = new tn();\n    async function* i() {\n      if (!e.body)\n        throw t.abort(), new m(\"Attempted to iterate over a response with no body\");\n      const o = new N(), c = ft(e.body);\n      for await (const p of c)\n        for (const f of o.decode(p)) {\n          const w = r.decode(f);\n          w && (yield w);\n        }\n      for (const p of o.flush()) {\n        const f = r.decode(p);\n        f && (yield f);\n      }\n    }\n    async function* a() {\n      if (s)\n        throw new Error(\"Cannot iterate over a consumed stream, use `.tee()` to split the stream.\");\n      s = !0;\n      let o = !1;\n      try {\n        for await (const c of i())\n          if (!o) {\n            if (c.data.startsWith(\"[DONE]\")) {\n              o = !0;\n              continue;\n            }\n            if (c.event === null) {\n              let p;\n              try {\n                p = JSON.parse(c.data);\n              } catch (f) {\n                throw console.error(\"Could not parse message into JSON:\", c.data), console.error(\"From chunk:\", c.raw), f;\n              }\n              if (p && p.error)\n                throw new _(void 0, p.error, void 0, void 0);\n              yield p;\n            }\n          }\n        o = !0;\n      } catch (c) {\n        if (c instanceof Error && c.name === \"AbortError\")\n          return;\n        throw c;\n      } finally {\n        o || t.abort();\n      }\n    }\n    return new L(a, t);\n  }\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n  static fromReadableStream(e, t) {\n    let s = !1;\n    async function* r() {\n      const a = new N(), o = ft(e);\n      for await (const c of o)\n        for (const p of a.decode(c))\n          yield p;\n      for (const c of a.flush())\n        yield c;\n    }\n    async function* i() {\n      if (s)\n        throw new Error(\"Cannot iterate over a consumed stream, use `.tee()` to split the stream.\");\n      s = !0;\n      let a = !1;\n      try {\n        for await (const o of r())\n          a || o && (yield JSON.parse(o));\n        a = !0;\n      } catch (o) {\n        if (o instanceof Error && o.name === \"AbortError\")\n          return;\n        throw o;\n      } finally {\n        a || t.abort();\n      }\n    }\n    return new L(i, t);\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterator();\n  }\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n  tee() {\n    const e = [], t = [], s = this.iterator(), r = (i) => ({\n      next: () => {\n        if (i.length === 0) {\n          const a = s.next();\n          e.push(a), t.push(a);\n        }\n        return i.shift();\n      }\n    });\n    return [\n      new L(() => r(e), this.controller),\n      new L(() => r(t), this.controller)\n    ];\n  }\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n  toReadableStream() {\n    const e = this;\n    let t;\n    const s = new TextEncoder();\n    return new Rt({\n      async start() {\n        t = e[Symbol.asyncIterator]();\n      },\n      async pull(r) {\n        try {\n          const { value: i, done: a } = await t.next();\n          if (a)\n            return r.close();\n          const o = s.encode(JSON.stringify(i) + `\n`);\n          r.enqueue(o);\n        } catch (i) {\n          r.error(i);\n        }\n      },\n      async cancel() {\n        var r;\n        await ((r = t.return) == null ? void 0 : r.call(t));\n      }\n    });\n  }\n}\nclass tn {\n  constructor() {\n    this.event = null, this.data = [], this.chunks = [];\n  }\n  decode(e) {\n    if (e.endsWith(\"\\r\") && (e = e.substring(0, e.length - 1)), !e) {\n      if (!this.event && !this.data.length)\n        return null;\n      const i = {\n        event: this.event,\n        data: this.data.join(`\n`),\n        raw: this.chunks\n      };\n      return this.event = null, this.data = [], this.chunks = [], i;\n    }\n    if (this.chunks.push(e), e.startsWith(\":\"))\n      return null;\n    let [t, s, r] = nn(e, \":\");\n    return r.startsWith(\" \") && (r = r.substring(1)), t === \"event\" ? this.event = r : t === \"data\" && this.data.push(r), null;\n  }\n}\nclass N {\n  constructor() {\n    this.buffer = [], this.trailingCR = !1;\n  }\n  decode(e) {\n    let t = this.decodeText(e);\n    if (this.trailingCR && (t = \"\\r\" + t, this.trailingCR = !1), t.endsWith(\"\\r\") && (this.trailingCR = !0, t = t.slice(0, -1)), !t)\n      return [];\n    const s = N.NEWLINE_CHARS.has(t[t.length - 1] || \"\");\n    let r = t.split(N.NEWLINE_REGEXP);\n    return r.length === 1 && !s ? (this.buffer.push(r[0]), []) : (this.buffer.length > 0 && (r = [this.buffer.join(\"\") + r[0], ...r.slice(1)], this.buffer = []), s || (this.buffer = [r.pop() || \"\"]), r);\n  }\n  decodeText(e) {\n    if (e == null)\n      return \"\";\n    if (typeof e == \"string\")\n      return e;\n    if (typeof Buffer < \"u\") {\n      if (e instanceof Buffer)\n        return e.toString();\n      if (e instanceof Uint8Array)\n        return Buffer.from(e).toString();\n      throw new m(`Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n    }\n    if (typeof TextDecoder < \"u\") {\n      if (e instanceof Uint8Array || e instanceof ArrayBuffer)\n        return this.textDecoder ?? (this.textDecoder = new TextDecoder(\"utf8\")), this.textDecoder.decode(e);\n      throw new m(`Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`);\n    }\n    throw new m(\"Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.\");\n  }\n  flush() {\n    if (!this.buffer.length && !this.trailingCR)\n      return [];\n    const e = [this.buffer.join(\"\")];\n    return this.buffer = [], this.trailingCR = !1, e;\n  }\n}\nN.NEWLINE_CHARS = /* @__PURE__ */ new Set([`\n`, \"\\r\", \"\\v\", \"\\f\", \"\u001c\", \"\u001d\", \"\u001e\", \"Â…\", \"\\u2028\", \"\\u2029\"]);\nN.NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\nfunction nn(n, e) {\n  const t = n.indexOf(e);\n  return t !== -1 ? [n.substring(0, t), e, n.substring(t + e.length)] : [n, \"\", \"\"];\n}\nfunction ft(n) {\n  if (n[Symbol.asyncIterator])\n    return n;\n  const e = n.getReader();\n  return {\n    async next() {\n      try {\n        const t = await e.read();\n        return t != null && t.done && e.releaseLock(), t;\n      } catch (t) {\n        throw e.releaseLock(), t;\n      }\n    },\n    async return() {\n      const t = e.cancel();\n      return e.releaseLock(), await t, { done: !0, value: void 0 };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}\nconst Bt = (n) => n != null && typeof n == \"object\" && typeof n.url == \"string\" && typeof n.blob == \"function\", sn = (n) => n != null && typeof n == \"object\" && typeof n.name == \"string\" && typeof n.lastModified == \"number\" && jt(n), jt = (n) => n != null && typeof n == \"object\" && typeof n.size == \"number\" && typeof n.type == \"string\" && typeof n.text == \"function\" && typeof n.slice == \"function\" && typeof n.arrayBuffer == \"function\", rn = (n) => sn(n) || Bt(n) || $t(n);\nasync function Nt(n, e, t = {}) {\n  var r;\n  if (n = await n, Bt(n)) {\n    const i = await n.blob();\n    return e || (e = new URL(n.url).pathname.split(/[\\\\/]/).pop() ?? \"unknown_file\"), new qe([i], e, t);\n  }\n  const s = await an(n);\n  if (e || (e = cn(n) ?? \"unknown_file\"), !t.type) {\n    const i = (r = s[0]) == null ? void 0 : r.type;\n    typeof i == \"string\" && (t = { ...t, type: i });\n  }\n  return new qe(s, e, t);\n}\nasync function an(n) {\n  var t;\n  let e = [];\n  if (typeof n == \"string\" || ArrayBuffer.isView(n) || // includes Uint8Array, Buffer, etc.\n  n instanceof ArrayBuffer)\n    e.push(n);\n  else if (jt(n))\n    e.push(await n.arrayBuffer());\n  else if (ln(n))\n    for await (const s of n)\n      e.push(s);\n  else\n    throw new Error(`Unexpected data type: ${typeof n}; constructor: ${(t = n == null ? void 0 : n.constructor) == null ? void 0 : t.name}; props: ${on(n)}`);\n  return e;\n}\nfunction on(n) {\n  return `[${Object.getOwnPropertyNames(n).map((t) => `\"${t}\"`).join(\", \")}]`;\n}\nfunction cn(n) {\n  var e;\n  return je(n.name) || je(n.filename) || // For fs.ReadStream\n  ((e = je(n.path)) == null ? void 0 : e.split(/[\\\\/]/).pop());\n}\nconst je = (n) => {\n  if (typeof n == \"string\")\n    return n;\n  if (typeof Buffer < \"u\" && n instanceof Buffer)\n    return String(n);\n}, ln = (n) => n != null && typeof n == \"object\" && typeof n[Symbol.asyncIterator] == \"function\", mt = (n) => n && typeof n == \"object\" && n.body && n[Symbol.toStringTag] === \"MultipartBody\", G = async (n) => {\n  const e = await un(n.body);\n  return St(e, n);\n}, un = async (n) => {\n  const e = new Pt();\n  return await Promise.all(Object.entries(n || {}).map(([t, s]) => We(e, t, s))), e;\n}, We = async (n, e, t) => {\n  if (t !== void 0) {\n    if (t == null)\n      throw new TypeError(`Received null for \"${e}\"; to pass null in FormData, you must use the string 'null'`);\n    if (typeof t == \"string\" || typeof t == \"number\" || typeof t == \"boolean\")\n      n.append(e, String(t));\n    else if (rn(t)) {\n      const s = await Nt(t);\n      n.append(e, s);\n    } else if (Array.isArray(t))\n      await Promise.all(t.map((s) => We(n, e + \"[]\", s)));\n    else if (typeof t == \"object\")\n      await Promise.all(Object.entries(t).map(([s, r]) => We(n, `${e}[${s}]`, r)));\n    else\n      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${t} instead`);\n  }\n};\nvar hn = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, s, r) {\n  if (s === \"m\")\n    throw new TypeError(\"Private method is not writable\");\n  if (s === \"a\" && !r)\n    throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof e == \"function\" ? n !== e || !r : !e.has(n))\n    throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return s === \"a\" ? r.call(n, t) : r ? r.value = t : e.set(n, t), t;\n}, dn = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, s) {\n  if (t === \"a\" && !s)\n    throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof e == \"function\" ? n !== e || !s : !e.has(n))\n    throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return t === \"m\" ? s : t === \"a\" ? s.call(n) : s ? s.value : e.get(n);\n}, Z;\nasync function Dt(n) {\n  const { response: e } = n;\n  if (n.options.stream)\n    return K(\"response\", e.status, e.url, e.headers, e.body), L.fromSSEResponse(e, n.controller);\n  if (e.status === 204)\n    return null;\n  if (n.options.__binaryResponse)\n    return e;\n  const t = e.headers.get(\"content-type\");\n  if (t != null && t.includes(\"application/json\")) {\n    const r = await e.json();\n    return K(\"response\", e.status, e.url, e.headers, r), r;\n  }\n  const s = await e.text();\n  return K(\"response\", e.status, e.url, e.headers, s), s;\n}\nclass Me extends Promise {\n  constructor(e, t = Dt) {\n    super((s) => {\n      s(null);\n    }), this.responsePromise = e, this.parseResponse = t;\n  }\n  _thenUnwrap(e) {\n    return new Me(this.responsePromise, async (t) => e(await this.parseResponse(t)));\n  }\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   *\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import â€¦ from 'openai'`:\n   * - `import 'openai/shims/node'` (if you're running on Node)\n   * - `import 'openai/shims/web'` (otherwise)\n   */\n  asResponse() {\n    return this.responsePromise.then((e) => e.response);\n  }\n  /**\n   * Gets the parsed response data and the raw `Response` instance.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   *\n   *\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import â€¦ from 'openai'`:\n   * - `import 'openai/shims/node'` (if you're running on Node)\n   * - `import 'openai/shims/web'` (otherwise)\n   */\n  async withResponse() {\n    const [e, t] = await Promise.all([this.parse(), this.asResponse()]);\n    return { data: e, response: t };\n  }\n  parse() {\n    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)), this.parsedPromise;\n  }\n  then(e, t) {\n    return this.parse().then(e, t);\n  }\n  catch(e) {\n    return this.parse().catch(e);\n  }\n  finally(e) {\n    return this.parse().finally(e);\n  }\n}\nclass fn {\n  constructor({\n    baseURL: e,\n    maxRetries: t = 2,\n    timeout: s = 6e5,\n    // 10 minutes\n    httpAgent: r,\n    fetch: i\n  }) {\n    this.baseURL = e, this.maxRetries = Ne(\"maxRetries\", t), this.timeout = Ne(\"timeout\", s), this.httpAgent = r, this.fetch = i ?? xt;\n  }\n  authHeaders(e) {\n    return {};\n  }\n  /**\n   * Override this to add your own default headers, for example:\n   *\n   *  {\n   *    ...super.defaultHeaders(),\n   *    Authorization: 'Bearer 123',\n   *  }\n   */\n  defaultHeaders(e) {\n    return {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n      \"User-Agent\": this.getUserAgent(),\n      ...bn(),\n      ...this.authHeaders(e)\n    };\n  }\n  /**\n   * Override this to add your own headers validation:\n   */\n  validateHeaders(e, t) {\n  }\n  defaultIdempotencyKey() {\n    return `stainless-node-retry-${Rn()}`;\n  }\n  get(e, t) {\n    return this.methodRequest(\"get\", e, t);\n  }\n  post(e, t) {\n    return this.methodRequest(\"post\", e, t);\n  }\n  patch(e, t) {\n    return this.methodRequest(\"patch\", e, t);\n  }\n  put(e, t) {\n    return this.methodRequest(\"put\", e, t);\n  }\n  delete(e, t) {\n    return this.methodRequest(\"delete\", e, t);\n  }\n  methodRequest(e, t, s) {\n    return this.request(Promise.resolve(s).then((r) => ({ method: e, path: t, ...r })));\n  }\n  getAPIList(e, t, s) {\n    return this.requestAPIList(t, { method: \"get\", path: e, ...s });\n  }\n  calculateContentLength(e) {\n    if (typeof e == \"string\") {\n      if (typeof Buffer < \"u\")\n        return Buffer.byteLength(e, \"utf8\").toString();\n      if (typeof TextEncoder < \"u\")\n        return new TextEncoder().encode(e).length.toString();\n    }\n    return null;\n  }\n  buildRequest(e) {\n    var d;\n    const { method: t, path: s, query: r, headers: i = {} } = e, a = mt(e.body) ? e.body.body : e.body ? JSON.stringify(e.body, null, 2) : null, o = this.calculateContentLength(a), c = this.buildURL(s, r);\n    \"timeout\" in e && Ne(\"timeout\", e.timeout);\n    const p = e.timeout ?? this.timeout, f = e.httpAgent ?? this.httpAgent ?? At(c), w = p + 1e3;\n    typeof ((d = f == null ? void 0 : f.options) == null ? void 0 : d.timeout) == \"number\" && w > (f.options.timeout ?? 0) && (f.options.timeout = w), this.idempotencyHeader && t !== \"get\" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()), i[this.idempotencyHeader] = e.idempotencyKey);\n    const u = {\n      ...o && { \"Content-Length\": o },\n      ...this.defaultHeaders(e),\n      ...i\n    };\n    mt(e.body) && J !== \"node\" && delete u[\"Content-Type\"], Object.keys(u).forEach((P) => u[P] === null && delete u[P]);\n    const h = {\n      method: t,\n      ...a && { body: a },\n      headers: u,\n      ...f && { agent: f },\n      // @ts-ignore node-fetch uses a custom AbortSignal type that is\n      // not compatible with standard web types\n      signal: e.signal ?? null\n    };\n    return this.validateHeaders(u, i), { req: h, url: c, timeout: p };\n  }\n  /**\n   * Used as a callback for mutating the given `RequestInit` object.\n   *\n   * This is useful for cases where you want to add certain headers based off of\n   * the request properties, e.g. `method` or `url`.\n   */\n  async prepareRequest(e, { url: t, options: s }) {\n  }\n  parseHeaders(e) {\n    return e ? Symbol.iterator in e ? Object.fromEntries(Array.from(e).map((t) => [...t])) : { ...e } : {};\n  }\n  makeStatusError(e, t, s, r) {\n    return _.generate(e, t, s, r);\n  }\n  request(e, t = null) {\n    return new Me(this.makeRequest(e, t));\n  }\n  async makeRequest(e, t) {\n    var f, w;\n    const s = await e;\n    t == null && (t = s.maxRetries ?? this.maxRetries);\n    const { req: r, url: i, timeout: a } = this.buildRequest(s);\n    if (await this.prepareRequest(r, { url: i, options: s }), K(\"request\", i, s, r.headers), (f = s.signal) != null && f.aborted)\n      throw new j();\n    const o = new AbortController(), c = await this.fetchWithTimeout(i, r, a, o).catch(Xe);\n    if (c instanceof Error) {\n      if ((w = s.signal) != null && w.aborted)\n        throw new j();\n      if (t)\n        return this.retryRequest(s, t);\n      throw c.name === \"AbortError\" ? new Ze() : new Ie({ cause: c });\n    }\n    const p = pn(c.headers);\n    if (!c.ok) {\n      if (t && this.shouldRetry(c))\n        return this.retryRequest(s, t, p);\n      const u = await c.text().catch((y) => Xe(y).message), h = _n(u), d = h ? void 0 : u;\n      throw K(\"response\", c.status, i, p, d), this.makeStatusError(c.status, h, d, p);\n    }\n    return { response: c, options: s, controller: o };\n  }\n  requestAPIList(e, t) {\n    const s = this.makeRequest(t, null);\n    return new mn(this, s, e);\n  }\n  buildURL(e, t) {\n    const s = xn(e) ? new URL(e) : new URL(this.baseURL + (this.baseURL.endsWith(\"/\") && e.startsWith(\"/\") ? e.slice(1) : e)), r = this.defaultQuery();\n    return qt(r) || (t = { ...r, ...t }), t && (s.search = this.stringifyQuery(t)), s.toString();\n  }\n  stringifyQuery(e) {\n    return Object.entries(e).filter(([t, s]) => typeof s < \"u\").map(([t, s]) => {\n      if (typeof s == \"string\" || typeof s == \"number\" || typeof s == \"boolean\")\n        return `${encodeURIComponent(t)}=${encodeURIComponent(s)}`;\n      if (s === null)\n        return `${encodeURIComponent(t)}=`;\n      throw new m(`Cannot stringify type ${typeof s}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n    }).join(\"&\");\n  }\n  async fetchWithTimeout(e, t, s, r) {\n    const { signal: i, ...a } = t || {};\n    i && i.addEventListener(\"abort\", () => r.abort());\n    const o = setTimeout(() => r.abort(), s);\n    return this.getRequestClient().fetch.call(void 0, e, { signal: r.signal, ...a }).finally(() => {\n      clearTimeout(o);\n    });\n  }\n  getRequestClient() {\n    return { fetch: this.fetch };\n  }\n  shouldRetry(e) {\n    const t = e.headers.get(\"x-should-retry\");\n    return t === \"true\" ? !0 : t === \"false\" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500;\n  }\n  async retryRequest(e, t, s) {\n    let r;\n    const i = s == null ? void 0 : s[\"retry-after\"];\n    if (i) {\n      const a = parseInt(i);\n      Number.isNaN(a) ? r = Date.parse(i) - Date.now() : r = a * 1e3;\n    }\n    if (!r || !Number.isInteger(r) || r <= 0 || r > 60 * 1e3) {\n      const a = e.maxRetries ?? this.maxRetries;\n      r = this.calculateDefaultRetryTimeoutMillis(t, a);\n    }\n    return await Ht(r), this.makeRequest(e, t - 1);\n  }\n  calculateDefaultRetryTimeoutMillis(e, t) {\n    const i = t - e, a = Math.min(0.5 * Math.pow(2, i), 8), o = 1 - Math.random() * 0.25;\n    return a * o * 1e3;\n  }\n  getUserAgent() {\n    return `${this.constructor.name}/JS ${D}`;\n  }\n}\nclass Ut {\n  constructor(e, t, s, r) {\n    Z.set(this, void 0), hn(this, Z, e, \"f\"), this.options = r, this.response = t, this.body = s;\n  }\n  hasNextPage() {\n    return this.getPaginatedItems().length ? this.nextPageInfo() != null : !1;\n  }\n  async getNextPage() {\n    const e = this.nextPageInfo();\n    if (!e)\n      throw new m(\"No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.\");\n    const t = { ...this.options };\n    if (\"params\" in e)\n      t.query = { ...t.query, ...e.params };\n    else if (\"url\" in e) {\n      const s = [...Object.entries(t.query || {}), ...e.url.searchParams.entries()];\n      for (const [r, i] of s)\n        e.url.searchParams.set(r, i);\n      t.query = void 0, t.path = e.url.toString();\n    }\n    return await dn(this, Z, \"f\").requestAPIList(this.constructor, t);\n  }\n  async *iterPages() {\n    let e = this;\n    for (yield e; e.hasNextPage(); )\n      e = await e.getNextPage(), yield e;\n  }\n  async *[(Z = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {\n    for await (const e of this.iterPages())\n      for (const t of e.getPaginatedItems())\n        yield t;\n  }\n}\nclass mn extends Me {\n  constructor(e, t, s) {\n    super(t, async (r) => new s(e, r.response, await Dt(r), r.options));\n  }\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const e = await this;\n    for await (const t of e)\n      yield t;\n  }\n}\nconst pn = (n) => new Proxy(Object.fromEntries(\n  // @ts-ignore\n  n.entries()\n), {\n  get(e, t) {\n    const s = t.toString();\n    return e[s.toLowerCase()] || e[s];\n  }\n}), gn = {\n  method: !0,\n  path: !0,\n  query: !0,\n  body: !0,\n  headers: !0,\n  maxRetries: !0,\n  stream: !0,\n  timeout: !0,\n  httpAgent: !0,\n  signal: !0,\n  idempotencyKey: !0,\n  __binaryResponse: !0\n}, I = (n) => typeof n == \"object\" && n !== null && !qt(n) && Object.keys(n).every((e) => Pn(gn, e)), wn = () => {\n  if (typeof Deno < \"u\" && Deno.build != null)\n    return {\n      \"X-Stainless-Lang\": \"js\",\n      \"X-Stainless-Package-Version\": D,\n      \"X-Stainless-OS\": gt(Deno.build.os),\n      \"X-Stainless-Arch\": pt(Deno.build.arch),\n      \"X-Stainless-Runtime\": \"deno\",\n      \"X-Stainless-Runtime-Version\": Deno.version\n    };\n  if (typeof EdgeRuntime < \"u\")\n    return {\n      \"X-Stainless-Lang\": \"js\",\n      \"X-Stainless-Package-Version\": D,\n      \"X-Stainless-OS\": \"Unknown\",\n      \"X-Stainless-Arch\": `other:${EdgeRuntime}`,\n      \"X-Stainless-Runtime\": \"edge\",\n      \"X-Stainless-Runtime-Version\": process.version\n    };\n  if (Object.prototype.toString.call(typeof process < \"u\" ? process : 0) === \"[object process]\")\n    return {\n      \"X-Stainless-Lang\": \"js\",\n      \"X-Stainless-Package-Version\": D,\n      \"X-Stainless-OS\": gt(process.platform),\n      \"X-Stainless-Arch\": pt(process.arch),\n      \"X-Stainless-Runtime\": \"node\",\n      \"X-Stainless-Runtime-Version\": process.version\n    };\n  const n = yn();\n  return n ? {\n    \"X-Stainless-Lang\": \"js\",\n    \"X-Stainless-Package-Version\": D,\n    \"X-Stainless-OS\": \"Unknown\",\n    \"X-Stainless-Arch\": \"unknown\",\n    \"X-Stainless-Runtime\": `browser:${n.browser}`,\n    \"X-Stainless-Runtime-Version\": n.version\n  } : {\n    \"X-Stainless-Lang\": \"js\",\n    \"X-Stainless-Package-Version\": D,\n    \"X-Stainless-OS\": \"Unknown\",\n    \"X-Stainless-Arch\": \"unknown\",\n    \"X-Stainless-Runtime\": \"unknown\",\n    \"X-Stainless-Runtime-Version\": \"unknown\"\n  };\n};\nfunction yn() {\n  if (typeof navigator > \"u\" || !navigator)\n    return null;\n  const n = [\n    { key: \"edge\", pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: \"ie\", pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: \"ie\", pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: \"chrome\", pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: \"firefox\", pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: \"safari\", pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ }\n  ];\n  for (const { key: e, pattern: t } of n) {\n    const s = t.exec(navigator.userAgent);\n    if (s) {\n      const r = s[1] || 0, i = s[2] || 0, a = s[3] || 0;\n      return { browser: e, version: `${r}.${i}.${a}` };\n    }\n  }\n  return null;\n}\nconst pt = (n) => n === \"x32\" ? \"x32\" : n === \"x86_64\" || n === \"x64\" ? \"x64\" : n === \"arm\" ? \"arm\" : n === \"aarch64\" || n === \"arm64\" ? \"arm64\" : n ? `other:${n}` : \"unknown\", gt = (n) => (n = n.toLowerCase(), n.includes(\"ios\") ? \"iOS\" : n === \"android\" ? \"Android\" : n === \"darwin\" ? \"MacOS\" : n === \"win32\" ? \"Windows\" : n === \"freebsd\" ? \"FreeBSD\" : n === \"openbsd\" ? \"OpenBSD\" : n === \"linux\" ? \"Linux\" : n ? `Other:${n}` : \"Unknown\");\nlet wt;\nconst bn = () => wt ?? (wt = wn()), _n = (n) => {\n  try {\n    return JSON.parse(n);\n  } catch {\n    return;\n  }\n}, Cn = new RegExp(\"^(?:[a-z]+:)?//\", \"i\"), xn = (n) => Cn.test(n), Ht = (n) => new Promise((e) => setTimeout(e, n)), Ne = (n, e) => {\n  if (typeof e != \"number\" || !Number.isInteger(e))\n    throw new m(`${n} must be an integer`);\n  if (e < 0)\n    throw new m(`${n} must be a positive integer`);\n  return e;\n}, Xe = (n) => n instanceof Error ? n : new Error(n), yt = (n) => {\n  var e, t, s;\n  if (typeof process < \"u\")\n    return ((e = process.env) == null ? void 0 : e[n]) ?? void 0;\n  if (typeof Deno < \"u\")\n    return (s = (t = Deno.env) == null ? void 0 : t.get) == null ? void 0 : s.call(t, n);\n};\nfunction qt(n) {\n  if (!n)\n    return !0;\n  for (const e in n)\n    return !1;\n  return !0;\n}\nfunction Pn(n, e) {\n  return Object.prototype.hasOwnProperty.call(n, e);\n}\nfunction K(n, ...e) {\n  typeof process < \"u\" && process.env.DEBUG === \"true\" && console.log(`OpenAI:DEBUG:${n}`, ...e);\n}\nconst Rn = () => \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (n) => {\n  const e = Math.random() * 16 | 0;\n  return (n === \"x\" ? e : e & 3 | 8).toString(16);\n}), Sn = () => (\n  // @ts-ignore\n  typeof window < \"u\" && // @ts-ignore\n  typeof window.document < \"u\" && // @ts-ignore\n  typeof navigator < \"u\"\n);\nclass ke extends Ut {\n  constructor(e, t, s, r) {\n    super(e, t, s, r), this.data = s.data, this.object = s.object;\n  }\n  getPaginatedItems() {\n    return this.data;\n  }\n  // @deprecated Please use `nextPageInfo()` instead\n  /**\n   * This page represents a response that isn't actually paginated at the API level\n   * so there will never be any next page params.\n   */\n  nextPageParams() {\n    return null;\n  }\n  nextPageInfo() {\n    return null;\n  }\n}\nclass k extends Ut {\n  constructor(e, t, s, r) {\n    super(e, t, s, r), this.data = s.data;\n  }\n  getPaginatedItems() {\n    return this.data;\n  }\n  // @deprecated Please use `nextPageInfo()` instead\n  nextPageParams() {\n    const e = this.nextPageInfo();\n    if (!e)\n      return null;\n    if (\"params\" in e)\n      return e.params;\n    const t = Object.fromEntries(e.url.searchParams);\n    return Object.keys(t).length ? t : null;\n  }\n  nextPageInfo() {\n    var t, s;\n    if (!((t = this.data) != null && t.length))\n      return null;\n    const e = (s = this.data[this.data.length - 1]) == null ? void 0 : s.id;\n    return e ? { params: { after: e } } : null;\n  }\n}\nclass g {\n  constructor(e) {\n    this.client = e, this.get = e.get.bind(e), this.post = e.post.bind(e), this.patch = e.patch.bind(e), this.put = e.put.bind(e), this.delete = e.delete.bind(e), this.getAPIList = e.getAPIList.bind(e);\n  }\n}\nlet oe = class extends g {\n  create(e, t) {\n    return this.post(\"/chat/completions\", { body: e, ...t, stream: e.stream ?? !1 });\n  }\n};\noe || (oe = {});\nlet ce = class extends g {\n  constructor() {\n    super(...arguments), this.completions = new oe(this.client);\n  }\n};\n(function(n) {\n  n.Completions = oe;\n})(ce || (ce = {}));\nclass le extends g {\n  /**\n   * Generates audio from the input text.\n   */\n  create(e, t) {\n    return this.post(\"/audio/speech\", { body: e, ...t, __binaryResponse: !0 });\n  }\n}\nle || (le = {});\nclass ue extends g {\n  /**\n   * Transcribes audio into the input language.\n   */\n  create(e, t) {\n    return this.post(\"/audio/transcriptions\", G({ body: e, ...t }));\n  }\n}\nue || (ue = {});\nclass he extends g {\n  /**\n   * Translates audio into English.\n   */\n  create(e, t) {\n    return this.post(\"/audio/translations\", G({ body: e, ...t }));\n  }\n}\nhe || (he = {});\nclass de extends g {\n  constructor() {\n    super(...arguments), this.transcriptions = new ue(this.client), this.translations = new he(this.client), this.speech = new le(this.client);\n  }\n}\n(function(n) {\n  n.Transcriptions = ue, n.Translations = he, n.Speech = le;\n})(de || (de = {}));\nlet fe = class extends g {\n  /**\n   * Create an assistant file by attaching a\n   * [File](https://platform.openai.com/docs/api-reference/files) to an\n   * [assistant](https://platform.openai.com/docs/api-reference/assistants).\n   */\n  create(e, t, s) {\n    return this.post(`/assistants/${e}/files`, {\n      body: t,\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n  /**\n   * Retrieves an AssistantFile.\n   */\n  retrieve(e, t, s) {\n    return this.get(`/assistants/${e}/files/${t}`, {\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n  list(e, t = {}, s) {\n    return I(t) ? this.list(e, {}, t) : this.getAPIList(`/assistants/${e}/files`, et, {\n      query: t,\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n  /**\n   * Delete an assistant file.\n   */\n  del(e, t, s) {\n    return this.delete(`/assistants/${e}/files/${t}`, {\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n};\nclass et extends k {\n}\n(function(n) {\n  n.AssistantFilesPage = et;\n})(fe || (fe = {}));\nclass me extends g {\n  constructor() {\n    super(...arguments), this.files = new fe(this.client);\n  }\n  /**\n   * Create an assistant with a model and instructions.\n   */\n  create(e, t) {\n    return this.post(\"/assistants\", {\n      body: e,\n      ...t,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...t == null ? void 0 : t.headers }\n    });\n  }\n  /**\n   * Retrieves an assistant.\n   */\n  retrieve(e, t) {\n    return this.get(`/assistants/${e}`, {\n      ...t,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...t == null ? void 0 : t.headers }\n    });\n  }\n  /**\n   * Modifies an assistant.\n   */\n  update(e, t, s) {\n    return this.post(`/assistants/${e}`, {\n      body: t,\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n  list(e = {}, t) {\n    return I(e) ? this.list({}, e) : this.getAPIList(\"/assistants\", tt, {\n      query: e,\n      ...t,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...t == null ? void 0 : t.headers }\n    });\n  }\n  /**\n   * Delete an assistant.\n   */\n  del(e, t) {\n    return this.delete(`/assistants/${e}`, {\n      ...t,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...t == null ? void 0 : t.headers }\n    });\n  }\n}\nclass tt extends k {\n}\n(function(n) {\n  n.AssistantsPage = tt, n.Files = fe, n.AssistantFilesPage = et;\n})(me || (me = {}));\nfunction bt(n) {\n  return typeof n.parse == \"function\";\n}\nconst z = (n) => (n == null ? void 0 : n.role) === \"assistant\", Wt = (n) => (n == null ? void 0 : n.role) === \"function\", An = (n) => (n == null ? void 0 : n.role) === \"tool\";\nvar E = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, s, r) {\n  if (s === \"m\")\n    throw new TypeError(\"Private method is not writable\");\n  if (s === \"a\" && !r)\n    throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof e == \"function\" ? n !== e || !r : !e.has(n))\n    throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return s === \"a\" ? r.call(n, t) : r ? r.value = t : e.set(n, t), t;\n}, l = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, s) {\n  if (t === \"a\" && !s)\n    throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof e == \"function\" ? n !== e || !s : !e.has(n))\n    throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return t === \"m\" ? s : t === \"a\" ? s.call(n) : s ? s.value : e.get(n);\n}, x, ne, se, q, W, re, X, M, V, ie, ae, U, Ve, Je, Ke, Ge, ze, Qe, Xt, Ye;\nconst _t = 10;\nclass Vt {\n  constructor() {\n    x.add(this), this.controller = new AbortController(), ne.set(this, void 0), se.set(this, () => {\n    }), q.set(this, () => {\n    }), W.set(this, void 0), re.set(this, () => {\n    }), X.set(this, () => {\n    }), M.set(this, {}), this._chatCompletions = [], this.messages = [], V.set(this, !1), ie.set(this, !1), ae.set(this, !1), U.set(this, !1), Qe.set(this, (e) => {\n      if (E(this, ie, !0, \"f\"), e instanceof Error && e.name === \"AbortError\" && (e = new j()), e instanceof j)\n        return E(this, ae, !0, \"f\"), this._emit(\"abort\", e);\n      if (e instanceof m)\n        return this._emit(\"error\", e);\n      if (e instanceof Error) {\n        const t = new m(e.message);\n        return t.cause = e, this._emit(\"error\", t);\n      }\n      return this._emit(\"error\", new m(String(e)));\n    }), E(this, ne, new Promise((e, t) => {\n      E(this, se, e, \"f\"), E(this, q, t, \"f\");\n    }), \"f\"), E(this, W, new Promise((e, t) => {\n      E(this, re, e, \"f\"), E(this, X, t, \"f\");\n    }), \"f\"), l(this, ne, \"f\").catch(() => {\n    }), l(this, W, \"f\").catch(() => {\n    });\n  }\n  _run(e) {\n    setTimeout(() => {\n      e().then(() => {\n        this._emitFinal(), this._emit(\"end\");\n      }, l(this, Qe, \"f\"));\n    }, 0);\n  }\n  _addChatCompletion(e) {\n    var s;\n    this._chatCompletions.push(e), this._emit(\"chatCompletion\", e);\n    const t = (s = e.choices[0]) == null ? void 0 : s.message;\n    return t && this._addMessage(t), e;\n  }\n  _addMessage(e, t = !0) {\n    if (this.messages.push(e), t) {\n      if (this._emit(\"message\", e), (Wt(e) || An(e)) && e.content)\n        this._emit(\"functionCallResult\", e.content);\n      else if (z(e) && e.function_call)\n        this._emit(\"functionCall\", e.function_call);\n      else if (z(e) && e.tool_calls)\n        for (const s of e.tool_calls)\n          s.type === \"function\" && this._emit(\"functionCall\", s.function);\n    }\n  }\n  _connected() {\n    this.ended || (l(this, se, \"f\").call(this), this._emit(\"connect\"));\n  }\n  get ended() {\n    return l(this, V, \"f\");\n  }\n  get errored() {\n    return l(this, ie, \"f\");\n  }\n  get aborted() {\n    return l(this, ae, \"f\");\n  }\n  abort() {\n    this.controller.abort();\n  }\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  on(e, t) {\n    return (l(this, M, \"f\")[e] || (l(this, M, \"f\")[e] = [])).push({ listener: t }), this;\n  }\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  off(e, t) {\n    const s = l(this, M, \"f\")[e];\n    if (!s)\n      return this;\n    const r = s.findIndex((i) => i.listener === t);\n    return r >= 0 && s.splice(r, 1), this;\n  }\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  once(e, t) {\n    return (l(this, M, \"f\")[e] || (l(this, M, \"f\")[e] = [])).push({ listener: t, once: !0 }), this;\n  }\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted(e) {\n    return new Promise((t, s) => {\n      E(this, U, !0, \"f\"), e !== \"error\" && this.once(\"error\", s), this.once(e, t);\n    });\n  }\n  async done() {\n    E(this, U, !0, \"f\"), await l(this, W, \"f\");\n  }\n  /**\n   * @returns a promise that resolves with the final ChatCompletion, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n   */\n  async finalChatCompletion() {\n    await this.done();\n    const e = this._chatCompletions[this._chatCompletions.length - 1];\n    if (!e)\n      throw new m(\"stream ended without producing a ChatCompletion\");\n    return e;\n  }\n  /**\n   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalContent() {\n    return await this.done(), l(this, x, \"m\", Ve).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalMessage() {\n    return await this.done(), l(this, x, \"m\", Je).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalFunctionCall() {\n    return await this.done(), l(this, x, \"m\", Ke).call(this);\n  }\n  async finalFunctionCallResult() {\n    return await this.done(), l(this, x, \"m\", Ge).call(this);\n  }\n  async totalUsage() {\n    return await this.done(), l(this, x, \"m\", ze).call(this);\n  }\n  allChatCompletions() {\n    return [...this._chatCompletions];\n  }\n  _emit(e, ...t) {\n    if (l(this, V, \"f\"))\n      return;\n    e === \"end\" && (E(this, V, !0, \"f\"), l(this, re, \"f\").call(this));\n    const s = l(this, M, \"f\")[e];\n    if (s && (l(this, M, \"f\")[e] = s.filter((r) => !r.once), s.forEach(({ listener: r }) => r(...t))), e === \"abort\") {\n      const r = t[0];\n      !l(this, U, \"f\") && !(s != null && s.length) && Promise.reject(r), l(this, q, \"f\").call(this, r), l(this, X, \"f\").call(this, r), this._emit(\"end\");\n      return;\n    }\n    if (e === \"error\") {\n      const r = t[0];\n      !l(this, U, \"f\") && !(s != null && s.length) && Promise.reject(r), l(this, q, \"f\").call(this, r), l(this, X, \"f\").call(this, r), this._emit(\"end\");\n    }\n  }\n  _emitFinal() {\n    const e = this._chatCompletions[this._chatCompletions.length - 1];\n    e && this._emit(\"finalChatCompletion\", e);\n    const t = this.messages[this.messages.length - 1];\n    t && this._emit(\"finalMessage\", t);\n    const s = l(this, x, \"m\", Ve).call(this);\n    s && this._emit(\"finalContent\", s);\n    const r = l(this, x, \"m\", Ke).call(this);\n    r && this._emit(\"finalFunctionCall\", r);\n    const i = l(this, x, \"m\", Ge).call(this);\n    i != null && this._emit(\"finalFunctionCallResult\", i), this._chatCompletions.some((a) => a.usage) && this._emit(\"totalUsage\", l(this, x, \"m\", ze).call(this));\n  }\n  async _createChatCompletion(e, t, s) {\n    const r = s == null ? void 0 : s.signal;\n    r && (r.aborted && this.controller.abort(), r.addEventListener(\"abort\", () => this.controller.abort())), l(this, x, \"m\", Xt).call(this, t);\n    const i = await e.create({ ...t, stream: !1 }, { ...s, signal: this.controller.signal });\n    return this._connected(), this._addChatCompletion(i);\n  }\n  async _runChatCompletion(e, t, s) {\n    for (const r of t.messages)\n      this._addMessage(r, !1);\n    return await this._createChatCompletion(e, t, s);\n  }\n  async _runFunctions(e, t, s) {\n    var u;\n    const r = \"function\", { function_call: i = \"auto\", stream: a, ...o } = t, c = typeof i != \"string\" && (i == null ? void 0 : i.name), { maxChatCompletions: p = _t } = s || {}, f = {};\n    for (const h of t.functions)\n      f[h.name || h.function.name] = h;\n    const w = t.functions.map((h) => ({\n      name: h.name || h.function.name,\n      parameters: h.parameters,\n      description: h.description\n    }));\n    for (const h of t.messages)\n      this._addMessage(h, !1);\n    for (let h = 0; h < p; ++h) {\n      const P = (u = (await this._createChatCompletion(e, {\n        ...o,\n        function_call: i,\n        functions: w,\n        messages: [...this.messages]\n      }, s)).choices[0]) == null ? void 0 : u.message;\n      if (!P)\n        throw new m(\"missing message in ChatCompletion response\");\n      if (!P.function_call)\n        return;\n      const { name: y, arguments: A } = P.function_call, C = f[y];\n      if (C) {\n        if (c && c !== y) {\n          const v = `Invalid function_call: ${JSON.stringify(y)}. ${JSON.stringify(c)} requested. Please try again`;\n          this._addMessage({ role: r, name: y, content: v });\n          continue;\n        }\n      } else {\n        const v = `Invalid function_call: ${JSON.stringify(y)}. Available options are: ${w.map((Oe) => JSON.stringify(Oe.name)).join(\", \")}. Please try again`;\n        this._addMessage({ role: r, name: y, content: v });\n        continue;\n      }\n      let T;\n      try {\n        T = bt(C) ? await C.parse(A) : A;\n      } catch (v) {\n        this._addMessage({\n          role: r,\n          name: y,\n          content: v instanceof Error ? v.message : String(v)\n        });\n        continue;\n      }\n      const R = await C.function(T, this), S = l(this, x, \"m\", Ye).call(this, R);\n      if (this._addMessage({ role: r, name: y, content: S }), c)\n        return;\n    }\n  }\n  async _runTools(e, t, s) {\n    var u, h;\n    const r = \"tool\", { tool_choice: i = \"auto\", stream: a, ...o } = t, c = typeof i != \"string\" && ((u = i == null ? void 0 : i.function) == null ? void 0 : u.name), { maxChatCompletions: p = _t } = s || {}, f = {};\n    for (const d of t.tools)\n      d.type === \"function\" && (f[d.function.name || d.function.function.name] = d.function);\n    const w = \"tools\" in t ? t.tools.map((d) => d.type === \"function\" ? {\n      type: \"function\",\n      function: {\n        name: d.function.name || d.function.function.name,\n        parameters: d.function.parameters,\n        description: d.function.description\n      }\n    } : d) : void 0;\n    for (const d of t.messages)\n      this._addMessage(d, !1);\n    for (let d = 0; d < p; ++d) {\n      const y = (h = (await this._createChatCompletion(e, {\n        ...o,\n        tool_choice: i,\n        tools: w,\n        messages: [...this.messages]\n      }, s)).choices[0]) == null ? void 0 : h.message;\n      if (!y)\n        throw new m(\"missing message in ChatCompletion response\");\n      if (!y.tool_calls)\n        return;\n      for (const A of y.tool_calls) {\n        if (A.type !== \"function\")\n          continue;\n        const C = A.id, { name: T, arguments: R } = A.function, S = f[T];\n        if (S) {\n          if (c && c !== T) {\n            const B = `Invalid tool_call: ${JSON.stringify(T)}. ${JSON.stringify(c)} requested. Please try again`;\n            this._addMessage({ role: r, tool_call_id: C, content: B });\n            continue;\n          }\n        } else {\n          const B = `Invalid tool_call: ${JSON.stringify(T)}. Available options are: ${w.map((Le) => JSON.stringify(Le.function.name)).join(\", \")}. Please try again`;\n          this._addMessage({ role: r, tool_call_id: C, content: B });\n          continue;\n        }\n        let v;\n        try {\n          v = bt(S) ? await S.parse(R) : R;\n        } catch (B) {\n          const Le = B instanceof Error ? B.message : String(B);\n          this._addMessage({ role: r, tool_call_id: C, content: Le });\n          continue;\n        }\n        const Oe = await S.function(v, this), Gt = l(this, x, \"m\", Ye).call(this, Oe);\n        if (this._addMessage({ role: r, tool_call_id: C, content: Gt }), c)\n          return;\n      }\n    }\n  }\n}\nne = /* @__PURE__ */ new WeakMap(), se = /* @__PURE__ */ new WeakMap(), q = /* @__PURE__ */ new WeakMap(), W = /* @__PURE__ */ new WeakMap(), re = /* @__PURE__ */ new WeakMap(), X = /* @__PURE__ */ new WeakMap(), M = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakMap(), ie = /* @__PURE__ */ new WeakMap(), ae = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap(), Qe = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakSet(), Ve = function() {\n  return l(this, x, \"m\", Je).call(this).content;\n}, Je = function() {\n  let e = this.messages.length;\n  for (; e-- > 0; ) {\n    const t = this.messages[e];\n    if (z(t))\n      return t;\n  }\n  throw new m(\"stream ended without producing a ChatCompletionMessage with role=assistant\");\n}, Ke = function() {\n  for (let e = this.messages.length - 1; e >= 0; e--) {\n    const t = this.messages[e];\n    if (z(t) && (t != null && t.function_call))\n      return t.function_call;\n  }\n}, Ge = function() {\n  for (let e = this.messages.length - 1; e >= 0; e--) {\n    const t = this.messages[e];\n    if (Wt(t) && t.content != null)\n      return t.content;\n  }\n}, ze = function() {\n  const e = {\n    completion_tokens: 0,\n    prompt_tokens: 0,\n    total_tokens: 0\n  };\n  for (const { usage: t } of this._chatCompletions)\n    t && (e.completion_tokens += t.completion_tokens, e.prompt_tokens += t.prompt_tokens, e.total_tokens += t.total_tokens);\n  return e;\n}, Xt = function(e) {\n  if (e.n != null && e.n > 1)\n    throw new m(\"ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.\");\n}, Ye = function(e) {\n  return typeof e == \"string\" ? e : e === void 0 ? \"undefined\" : JSON.stringify(e);\n};\nclass Q extends Vt {\n  static runFunctions(e, t, s) {\n    const r = new Q();\n    return r._run(() => r._runFunctions(e, t, s)), r;\n  }\n  static runTools(e, t, s) {\n    const r = new Q();\n    return r._run(() => r._runTools(e, t, s)), r;\n  }\n  _addMessage(e) {\n    super._addMessage(e), z(e) && e.content && this._emit(\"content\", e.content);\n  }\n}\nvar $ = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, s) {\n  if (t === \"a\" && !s)\n    throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof e == \"function\" ? n !== e || !s : !e.has(n))\n    throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return t === \"m\" ? s : t === \"a\" ? s.call(n) : s ? s.value : e.get(n);\n}, De = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, s, r) {\n  if (s === \"m\")\n    throw new TypeError(\"Private method is not writable\");\n  if (s === \"a\" && !r)\n    throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof e == \"function\" ? n !== e || !r : !e.has(n))\n    throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return s === \"a\" ? r.call(n, t) : r ? r.value = t : e.set(n, t), t;\n}, F, O, Ue, He, ee, Ct;\nclass Y extends Vt {\n  constructor() {\n    super(...arguments), F.add(this), O.set(this, void 0);\n  }\n  get currentChatCompletionSnapshot() {\n    return $(this, O, \"f\");\n  }\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(e) {\n    const t = new Y();\n    return t._run(() => t._fromReadableStream(e)), t;\n  }\n  static createChatCompletion(e, t, s) {\n    const r = new Y();\n    return r._run(() => r._runChatCompletion(e, { ...t, stream: !0 }, s)), r;\n  }\n  async _createChatCompletion(e, t, s) {\n    var a;\n    const r = s == null ? void 0 : s.signal;\n    r && (r.aborted && this.controller.abort(), r.addEventListener(\"abort\", () => this.controller.abort())), $(this, F, \"m\", Ue).call(this);\n    const i = await e.create({ ...t, stream: !0 }, { ...s, signal: this.controller.signal });\n    this._connected();\n    for await (const o of i)\n      $(this, F, \"m\", He).call(this, o);\n    if ((a = i.controller.signal) != null && a.aborted)\n      throw new j();\n    return this._addChatCompletion($(this, F, \"m\", ee).call(this));\n  }\n  async _fromReadableStream(e, t) {\n    var a;\n    const s = t == null ? void 0 : t.signal;\n    s && (s.aborted && this.controller.abort(), s.addEventListener(\"abort\", () => this.controller.abort())), $(this, F, \"m\", Ue).call(this), this._connected();\n    const r = L.fromReadableStream(e, this.controller);\n    let i;\n    for await (const o of r)\n      i && i !== o.id && this._addChatCompletion($(this, F, \"m\", ee).call(this)), $(this, F, \"m\", He).call(this, o), i = o.id;\n    if ((a = r.controller.signal) != null && a.aborted)\n      throw new j();\n    return this._addChatCompletion($(this, F, \"m\", ee).call(this));\n  }\n  [(O = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakSet(), Ue = function() {\n    this.ended || De(this, O, void 0, \"f\");\n  }, He = function(t) {\n    var a, o, c;\n    if (this.ended)\n      return;\n    const s = $(this, F, \"m\", Ct).call(this, t);\n    this._emit(\"chunk\", t, s);\n    const r = (o = (a = t.choices[0]) == null ? void 0 : a.delta) == null ? void 0 : o.content, i = (c = s.choices[0]) == null ? void 0 : c.message;\n    r != null && (i == null ? void 0 : i.role) === \"assistant\" && (i != null && i.content) && this._emit(\"content\", r, i.content);\n  }, ee = function() {\n    if (this.ended)\n      throw new m(\"stream has ended, this shouldn't happen\");\n    const t = $(this, O, \"f\");\n    if (!t)\n      throw new m(\"request ended without sending any chunks\");\n    return De(this, O, void 0, \"f\"), En(t);\n  }, Ct = function(t) {\n    var s, r;\n    let i = $(this, O, \"f\");\n    const { choices: a, ...o } = t;\n    i ? Object.assign(i, o) : i = De(this, O, {\n      ...o,\n      choices: []\n    }, \"f\");\n    for (const { delta: c, finish_reason: p, index: f, ...w } of t.choices) {\n      let u = i.choices[f];\n      if (!u) {\n        i.choices[f] = { finish_reason: p, index: f, message: c, ...w };\n        continue;\n      }\n      if (p && (u.finish_reason = p), Object.assign(u, w), !c)\n        continue;\n      const { content: h, function_call: d, role: P, tool_calls: y } = c;\n      if (h && (u.message.content = (u.message.content || \"\") + h), P && (u.message.role = P), d && (u.message.function_call ? (d.name && (u.message.function_call.name = d.name), d.arguments && ((s = u.message.function_call).arguments ?? (s.arguments = \"\"), u.message.function_call.arguments += d.arguments)) : u.message.function_call = d), y) {\n        u.message.tool_calls || (u.message.tool_calls = []);\n        for (const { index: A, id: C, type: T, function: R } of y) {\n          const S = (r = u.message.tool_calls)[A] ?? (r[A] = {});\n          C && (S.id = C), T && (S.type = T), R && (S.function ?? (S.function = { arguments: \"\" })), R != null && R.name && (S.function.name = R.name), R != null && R.arguments && (S.function.arguments += R.arguments);\n        }\n      }\n    }\n    return i;\n  }, Symbol.asyncIterator)]() {\n    const e = [], t = [];\n    let s = !1;\n    return this.on(\"chunk\", (r) => {\n      const i = t.shift();\n      i ? i(r) : e.push(r);\n    }), this.on(\"end\", () => {\n      s = !0;\n      for (const r of t)\n        r(void 0);\n      t.length = 0;\n    }), {\n      next: async () => e.length ? { value: e.shift(), done: !1 } : s ? { value: void 0, done: !0 } : new Promise((i) => t.push(i)).then((i) => i ? { value: i, done: !1 } : { value: void 0, done: !0 })\n    };\n  }\n  toReadableStream() {\n    return new L(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();\n  }\n}\nfunction En(n) {\n  const { id: e, choices: t, created: s, model: r } = n;\n  return {\n    id: e,\n    choices: t.map(({ message: i, finish_reason: a, index: o }) => {\n      if (!a)\n        throw new m(`missing finish_reason for choice ${o}`);\n      const { content: c = null, function_call: p, tool_calls: f } = i, w = i.role;\n      if (!w)\n        throw new m(`missing role for choice ${o}`);\n      if (p) {\n        const { arguments: u, name: h } = p;\n        if (u == null)\n          throw new m(`missing function_call.arguments for choice ${o}`);\n        if (!h)\n          throw new m(`missing function_call.name for choice ${o}`);\n        return { message: { content: c, function_call: { arguments: u, name: h }, role: w }, finish_reason: a, index: o };\n      }\n      return f ? {\n        index: o,\n        finish_reason: a,\n        message: {\n          role: w,\n          content: c,\n          tool_calls: f.map((u, h) => {\n            const { function: d, type: P, id: y } = u, { arguments: A, name: C } = d || {};\n            if (y == null)\n              throw new m(`missing choices[${o}].tool_calls[${h}].id\n${te(n)}`);\n            if (P == null)\n              throw new m(`missing choices[${o}].tool_calls[${h}].type\n${te(n)}`);\n            if (C == null)\n              throw new m(`missing choices[${o}].tool_calls[${h}].function.name\n${te(n)}`);\n            if (A == null)\n              throw new m(`missing choices[${o}].tool_calls[${h}].function.arguments\n${te(n)}`);\n            return { id: y, type: P, function: { name: C, arguments: A } };\n          })\n        }\n      } : { message: { content: c, role: w }, finish_reason: a, index: o };\n    }),\n    created: s,\n    model: r,\n    object: \"chat.completion\"\n  };\n}\nfunction te(n) {\n  return JSON.stringify(n);\n}\nclass H extends Y {\n  static fromReadableStream(e) {\n    const t = new H();\n    return t._run(() => t._fromReadableStream(e)), t;\n  }\n  static runFunctions(e, t, s) {\n    const r = new H();\n    return r._run(() => r._runFunctions(e, t, s)), r;\n  }\n  static runTools(e, t, s) {\n    const r = new H();\n    return r._run(() => r._runTools(e, t, s)), r;\n  }\n}\nlet Jt = class extends g {\n  runFunctions(e, t) {\n    return e.stream ? H.runFunctions(this.client.chat.completions, e, t) : Q.runFunctions(this.client.chat.completions, e, t);\n  }\n  runTools(e, t) {\n    return e.stream ? H.runTools(this.client.chat.completions, e, t) : Q.runTools(this.client.chat.completions, e, t);\n  }\n  /**\n   * Creates a chat completion stream\n   */\n  stream(e, t) {\n    return Y.createChatCompletion(this.client.chat.completions, e, t);\n  }\n};\nclass pe extends g {\n  constructor() {\n    super(...arguments), this.completions = new Jt(this.client);\n  }\n}\n(function(n) {\n  n.Completions = Jt;\n})(pe || (pe = {}));\nlet ge = class extends g {\n  /**\n   * Retrieves a message file.\n   */\n  retrieve(e, t, s, r) {\n    return this.get(`/threads/${e}/messages/${t}/files/${s}`, {\n      ...r,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...r == null ? void 0 : r.headers }\n    });\n  }\n  list(e, t, s = {}, r) {\n    return I(s) ? this.list(e, t, {}, s) : this.getAPIList(`/threads/${e}/messages/${t}/files`, nt, {\n      query: s,\n      ...r,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...r == null ? void 0 : r.headers }\n    });\n  }\n};\nclass nt extends k {\n}\n(function(n) {\n  n.MessageFilesPage = nt;\n})(ge || (ge = {}));\nclass we extends g {\n  constructor() {\n    super(...arguments), this.files = new ge(this.client);\n  }\n  /**\n   * Create a message.\n   */\n  create(e, t, s) {\n    return this.post(`/threads/${e}/messages`, {\n      body: t,\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n  /**\n   * Retrieve a message.\n   */\n  retrieve(e, t, s) {\n    return this.get(`/threads/${e}/messages/${t}`, {\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n  /**\n   * Modifies a message.\n   */\n  update(e, t, s, r) {\n    return this.post(`/threads/${e}/messages/${t}`, {\n      body: s,\n      ...r,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...r == null ? void 0 : r.headers }\n    });\n  }\n  list(e, t = {}, s) {\n    return I(t) ? this.list(e, {}, t) : this.getAPIList(`/threads/${e}/messages`, st, {\n      query: t,\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n}\nclass st extends k {\n}\n(function(n) {\n  n.ThreadMessagesPage = st, n.Files = ge, n.MessageFilesPage = nt;\n})(we || (we = {}));\nclass ye extends g {\n  /**\n   * Retrieves a run step.\n   */\n  retrieve(e, t, s, r) {\n    return this.get(`/threads/${e}/runs/${t}/steps/${s}`, {\n      ...r,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...r == null ? void 0 : r.headers }\n    });\n  }\n  list(e, t, s = {}, r) {\n    return I(s) ? this.list(e, t, {}, s) : this.getAPIList(`/threads/${e}/runs/${t}/steps`, rt, {\n      query: s,\n      ...r,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...r == null ? void 0 : r.headers }\n    });\n  }\n}\nclass rt extends k {\n}\n(function(n) {\n  n.RunStepsPage = rt;\n})(ye || (ye = {}));\nclass be extends g {\n  constructor() {\n    super(...arguments), this.steps = new ye(this.client);\n  }\n  /**\n   * Create a run.\n   */\n  create(e, t, s) {\n    return this.post(`/threads/${e}/runs`, {\n      body: t,\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n  /**\n   * Retrieves a run.\n   */\n  retrieve(e, t, s) {\n    return this.get(`/threads/${e}/runs/${t}`, {\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n  /**\n   * Modifies a run.\n   */\n  update(e, t, s, r) {\n    return this.post(`/threads/${e}/runs/${t}`, {\n      body: s,\n      ...r,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...r == null ? void 0 : r.headers }\n    });\n  }\n  list(e, t = {}, s) {\n    return I(t) ? this.list(e, {}, t) : this.getAPIList(`/threads/${e}/runs`, it, {\n      query: t,\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n  /**\n   * Cancels a run that is `in_progress`.\n   */\n  cancel(e, t, s) {\n    return this.post(`/threads/${e}/runs/${t}/cancel`, {\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n  /**\n   * When a run has the `status: \"requires_action\"` and `required_action.type` is\n   * `submit_tool_outputs`, this endpoint can be used to submit the outputs from the\n   * tool calls once they're all completed. All outputs must be submitted in a single\n   * request.\n   */\n  submitToolOutputs(e, t, s, r) {\n    return this.post(`/threads/${e}/runs/${t}/submit_tool_outputs`, {\n      body: s,\n      ...r,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...r == null ? void 0 : r.headers }\n    });\n  }\n}\nclass it extends k {\n}\n(function(n) {\n  n.RunsPage = it, n.Steps = ye, n.RunStepsPage = rt;\n})(be || (be = {}));\nclass _e extends g {\n  constructor() {\n    super(...arguments), this.runs = new be(this.client), this.messages = new we(this.client);\n  }\n  create(e = {}, t) {\n    return I(e) ? this.create({}, e) : this.post(\"/threads\", {\n      body: e,\n      ...t,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...t == null ? void 0 : t.headers }\n    });\n  }\n  /**\n   * Retrieves a thread.\n   */\n  retrieve(e, t) {\n    return this.get(`/threads/${e}`, {\n      ...t,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...t == null ? void 0 : t.headers }\n    });\n  }\n  /**\n   * Modifies a thread.\n   */\n  update(e, t, s) {\n    return this.post(`/threads/${e}`, {\n      body: t,\n      ...s,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...s == null ? void 0 : s.headers }\n    });\n  }\n  /**\n   * Delete a thread.\n   */\n  del(e, t) {\n    return this.delete(`/threads/${e}`, {\n      ...t,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...t == null ? void 0 : t.headers }\n    });\n  }\n  /**\n   * Create a thread and run it in one request.\n   */\n  createAndRun(e, t) {\n    return this.post(\"/threads/runs\", {\n      body: e,\n      ...t,\n      headers: { \"OpenAI-Beta\": \"assistants=v1\", ...t == null ? void 0 : t.headers }\n    });\n  }\n}\n(function(n) {\n  n.Runs = be, n.RunsPage = it, n.Messages = we, n.ThreadMessagesPage = st;\n})(_e || (_e = {}));\nclass Ce extends g {\n  constructor() {\n    super(...arguments), this.chat = new pe(this.client), this.assistants = new me(this.client), this.threads = new _e(this.client);\n  }\n}\n(function(n) {\n  n.Chat = pe, n.Assistants = me, n.AssistantsPage = tt, n.Threads = _e;\n})(Ce || (Ce = {}));\nclass xe extends g {\n  create(e, t) {\n    return this.post(\"/completions\", { body: e, ...t, stream: e.stream ?? !1 });\n  }\n}\nxe || (xe = {});\nclass Pe extends g {\n  /**\n   * Creates an embedding vector representing the input text.\n   */\n  create(e, t) {\n    return this.post(\"/embeddings\", { body: e, ...t });\n  }\n}\nPe || (Pe = {});\nclass Re extends g {\n  /**\n   * Creates a new edit for the provided input, instruction, and parameters.\n   *\n   * @deprecated The Edits API is deprecated; please use Chat Completions instead.\n   *\n   * https://openai.com/blog/gpt-4-api-general-availability#deprecation-of-the-edits-api\n   */\n  create(e, t) {\n    return this.post(\"/edits\", { body: e, ...t });\n  }\n}\nRe || (Re = {});\nclass Se extends g {\n  /**\n   * Upload a file that can be used across various endpoints/features. The size of\n   * all the files uploaded by one organization can be up to 100 GB.\n   *\n   * The size of individual files for can be a maximum of 512MB. See the\n   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) to\n   * learn more about the types of files supported. The Fine-tuning API only supports\n   * `.jsonl` files.\n   *\n   * Please [contact us](https://help.openai.com/) if you need to increase these\n   * storage limits.\n   */\n  create(e, t) {\n    return this.post(\"/files\", G({ body: e, ...t }));\n  }\n  /**\n   * Returns information about a specific file.\n   */\n  retrieve(e, t) {\n    return this.get(`/files/${e}`, t);\n  }\n  list(e = {}, t) {\n    return I(e) ? this.list({}, e) : this.getAPIList(\"/files\", at, { query: e, ...t });\n  }\n  /**\n   * Delete a file.\n   */\n  del(e, t) {\n    return this.delete(`/files/${e}`, t);\n  }\n  /**\n   * Returns the contents of the specified file.\n   */\n  content(e, t) {\n    return this.get(`/files/${e}/content`, { ...t, __binaryResponse: !0 });\n  }\n  /**\n   * Returns the contents of the specified file.\n   *\n   * @deprecated The `.content()` method should be used instead\n   */\n  retrieveContent(e, t) {\n    return this.get(`/files/${e}/content`, {\n      ...t,\n      headers: { Accept: \"application/json\", ...t == null ? void 0 : t.headers }\n    });\n  }\n  /**\n   * Waits for the given file to be processed, default timeout is 30 mins.\n   */\n  async waitForProcessing(e, { pollInterval: t = 5e3, maxWait: s = 30 * 60 * 1e3 } = {}) {\n    const r = /* @__PURE__ */ new Set([\"processed\", \"error\", \"deleted\"]), i = Date.now();\n    let a = await this.retrieve(e);\n    for (; !a.status || !r.has(a.status); )\n      if (await Ht(t), a = await this.retrieve(e), Date.now() - i > s)\n        throw new Ze({\n          message: `Giving up on waiting for file ${e} to finish processing after ${s} milliseconds.`\n        });\n    return a;\n  }\n}\nclass at extends ke {\n}\n(function(n) {\n  n.FileObjectsPage = at;\n})(Se || (Se = {}));\nclass Ae extends g {\n  /**\n   * Creates a job that fine-tunes a specified model from a given dataset.\n   *\n   * Response includes details of the enqueued job including job status and the name\n   * of the fine-tuned models once complete.\n   *\n   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/legacy-fine-tuning)\n   */\n  create(e, t) {\n    return this.post(\"/fine-tunes\", { body: e, ...t });\n  }\n  /**\n   * Gets info about the fine-tune job.\n   *\n   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/legacy-fine-tuning)\n   */\n  retrieve(e, t) {\n    return this.get(`/fine-tunes/${e}`, t);\n  }\n  /**\n   * List your organization's fine-tuning jobs\n   */\n  list(e) {\n    return this.getAPIList(\"/fine-tunes\", ot, e);\n  }\n  /**\n   * Immediately cancel a fine-tune job.\n   */\n  cancel(e, t) {\n    return this.post(`/fine-tunes/${e}/cancel`, t);\n  }\n  listEvents(e, t, s) {\n    return this.get(`/fine-tunes/${e}/events`, {\n      query: t,\n      timeout: 864e5,\n      ...s,\n      stream: (t == null ? void 0 : t.stream) ?? !1\n    });\n  }\n}\nclass ot extends ke {\n}\n(function(n) {\n  n.FineTunesPage = ot;\n})(Ae || (Ae = {}));\nclass Ee extends g {\n  /**\n   * Creates a job that fine-tunes a specified model from a given dataset.\n   *\n   * Response includes details of the enqueued job including job status and the name\n   * of the fine-tuned models once complete.\n   *\n   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n   */\n  create(e, t) {\n    return this.post(\"/fine_tuning/jobs\", { body: e, ...t });\n  }\n  /**\n   * Get info about a fine-tuning job.\n   *\n   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)\n   */\n  retrieve(e, t) {\n    return this.get(`/fine_tuning/jobs/${e}`, t);\n  }\n  list(e = {}, t) {\n    return I(e) ? this.list({}, e) : this.getAPIList(\"/fine_tuning/jobs\", ct, { query: e, ...t });\n  }\n  /**\n   * Immediately cancel a fine-tune job.\n   */\n  cancel(e, t) {\n    return this.post(`/fine_tuning/jobs/${e}/cancel`, t);\n  }\n  listEvents(e, t = {}, s) {\n    return I(t) ? this.listEvents(e, {}, t) : this.getAPIList(`/fine_tuning/jobs/${e}/events`, lt, {\n      query: t,\n      ...s\n    });\n  }\n}\nclass ct extends k {\n}\nclass lt extends k {\n}\n(function(n) {\n  n.FineTuningJobsPage = ct, n.FineTuningJobEventsPage = lt;\n})(Ee || (Ee = {}));\nclass $e extends g {\n  constructor() {\n    super(...arguments), this.jobs = new Ee(this.client);\n  }\n}\n(function(n) {\n  n.Jobs = Ee, n.FineTuningJobsPage = ct, n.FineTuningJobEventsPage = lt;\n})($e || ($e = {}));\nclass Te extends g {\n  /**\n   * Creates a variation of a given image.\n   */\n  createVariation(e, t) {\n    return this.post(\"/images/variations\", G({ body: e, ...t }));\n  }\n  /**\n   * Creates an edited or extended image given an original image and a prompt.\n   */\n  edit(e, t) {\n    return this.post(\"/images/edits\", G({ body: e, ...t }));\n  }\n  /**\n   * Creates an image given a prompt.\n   */\n  generate(e, t) {\n    return this.post(\"/images/generations\", { body: e, ...t });\n  }\n}\nTe || (Te = {});\nclass ve extends g {\n  /**\n   * Retrieves a model instance, providing basic information about the model such as\n   * the owner and permissioning.\n   */\n  retrieve(e, t) {\n    return this.get(`/models/${e}`, t);\n  }\n  /**\n   * Lists the currently available models, and provides basic information about each\n   * one such as the owner and availability.\n   */\n  list(e) {\n    return this.getAPIList(\"/models\", ut, e);\n  }\n  /**\n   * Delete a fine-tuned model. You must have the Owner role in your organization to\n   * delete a model.\n   */\n  del(e, t) {\n    return this.delete(`/models/${e}`, t);\n  }\n}\nclass ut extends ke {\n}\n(function(n) {\n  n.ModelsPage = ut;\n})(ve || (ve = {}));\nclass Fe extends g {\n  /**\n   * Classifies if text violates OpenAI's Content Policy\n   */\n  create(e, t) {\n    return this.post(\"/moderations\", { body: e, ...t });\n  }\n}\nFe || (Fe = {});\nvar Kt;\nclass b extends fn {\n  /**\n   * API Client for interfacing with the OpenAI API.\n   *\n   * @param {string} [opts.apiKey==process.env['OPENAI_API_KEY'] ?? undefined]\n   * @param {string | null} [opts.organization==process.env['OPENAI_ORG_ID'] ?? null]\n   * @param {string} [opts.baseURL] - Override the default base URL for the API.\n   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n   */\n  constructor({ apiKey: e = yt(\"OPENAI_API_KEY\"), organization: t = yt(\"OPENAI_ORG_ID\") ?? null, ...s } = {}) {\n    if (e === void 0)\n      throw new m(\"The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).\");\n    const r = {\n      apiKey: e,\n      organization: t,\n      ...s,\n      baseURL: s.baseURL ?? \"https://api.openai.com/v1\"\n    };\n    if (!r.dangerouslyAllowBrowser && Sn())\n      throw new m(`It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the \\`dangerouslyAllowBrowser\\` option to \\`true\\`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n`);\n    super({\n      baseURL: r.baseURL,\n      timeout: r.timeout ?? 6e5,\n      httpAgent: r.httpAgent,\n      maxRetries: r.maxRetries,\n      fetch: r.fetch\n    }), this.completions = new xe(this), this.chat = new ce(this), this.edits = new Re(this), this.embeddings = new Pe(this), this.files = new Se(this), this.images = new Te(this), this.audio = new de(this), this.moderations = new Fe(this), this.models = new ve(this), this.fineTuning = new $e(this), this.fineTunes = new Ae(this), this.beta = new Ce(this), this._options = r, this.apiKey = e, this.organization = t;\n  }\n  defaultQuery() {\n    return this._options.defaultQuery;\n  }\n  defaultHeaders(e) {\n    return {\n      ...super.defaultHeaders(e),\n      \"OpenAI-Organization\": this.organization,\n      ...this._options.defaultHeaders\n    };\n  }\n  authHeaders(e) {\n    return { Authorization: `Bearer ${this.apiKey}` };\n  }\n}\nKt = b;\nb.OpenAI = Kt;\nb.OpenAIError = m;\nb.APIError = _;\nb.APIConnectionError = Ie;\nb.APIConnectionTimeoutError = Ze;\nb.APIUserAbortError = j;\nb.NotFoundError = It;\nb.ConflictError = Mt;\nb.RateLimitError = Ot;\nb.BadRequestError = Tt;\nb.AuthenticationError = vt;\nb.InternalServerError = Lt;\nb.PermissionDeniedError = Ft;\nb.UnprocessableEntityError = kt;\n(function(n) {\n  n.toFile = Nt, n.fileFromPath = Et, n.Page = ke, n.CursorPage = k, n.Completions = xe, n.Chat = ce, n.Edits = Re, n.Embeddings = Pe, n.Files = Se, n.FileObjectsPage = at, n.Images = Te, n.Audio = de, n.Moderations = Fe, n.Models = ve, n.ModelsPage = ut, n.FineTuning = $e, n.FineTunes = Ae, n.FineTunesPage = ot, n.Beta = Ce;\n})(b || (b = {}));\nconst $n = b;\n(function() {\n  try {\n    if (typeof document < \"u\") {\n      var n = document.createElement(\"style\");\n      n.appendChild(document.createTextNode(\".ce-paragraph{line-height:1.6em;outline:none}.ce-paragraph[data-placeholder]:empty:before{content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before{opacity:1}.codex-editor--toolbox-opened .ce-block:first-child .ce-paragraph[data-placeholder]:empty:before,.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:focus:before{opacity:0}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}\")), document.head.appendChild(n);\n    }\n  } catch (e) {\n    console.error(\"vite-plugin-css-injected-by-js\", e);\n  }\n})();\nconst Tn = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>';\n/**\n * Base Paragraph Block for the Editor.js.\n * Represents a regular text block\n *\n * @author CodeX (team@codex.so)\n * @copyright CodeX 2018\n * @license The MIT License (MIT)\n */\nclass ht {\n  /**\n   * Default placeholder for Paragraph Tool\n   *\n   * @returns {string}\n   * @class\n   */\n  static get DEFAULT_PLACEHOLDER() {\n    return \"\";\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} params - constructor params\n   * @param {ParagraphData} params.data - previously saved data\n   * @param {ParagraphConfig} params.config - user config for Tool\n   * @param {object} params.api - editor.js api\n   * @param {boolean} readOnly - read only mode flag\n   */\n  constructor({ data: e, config: t, api: s, readOnly: r }) {\n    this.api = s, this.readOnly = r, this._CSS = {\n      block: this.api.styles.block,\n      wrapper: \"ce-paragraph\"\n    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = t.placeholder ? t.placeholder : ht.DEFAULT_PLACEHOLDER, this._data = {}, this._element = null, this._preserveBlank = t.preserveBlank !== void 0 ? t.preserveBlank : !1, this.data = e;\n  }\n  /**\n   * Check if text content is empty and set empty string to inner html.\n   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements\n   *\n   * @param {KeyboardEvent} e - key up event\n   */\n  onKeyUp(e) {\n    if (e.code !== \"Backspace\" && e.code !== \"Delete\")\n      return;\n    const { textContent: t } = this._element;\n    t === \"\" && (this._element.innerHTML = \"\");\n  }\n  /**\n   * Create Tool's view\n   *\n   * @returns {HTMLElement}\n   * @private\n   */\n  drawView() {\n    const e = document.createElement(\"DIV\");\n    return e.classList.add(this._CSS.wrapper, this._CSS.block), e.contentEditable = !1, e.dataset.placeholder = this.api.i18n.t(this._placeholder), this._data.text && (e.innerHTML = this._data.text), this.readOnly || (e.contentEditable = !0, e.addEventListener(\"keyup\", this.onKeyUp)), e;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement}\n   */\n  render() {\n    return this._element = this.drawView(), this._element;\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {ParagraphData} data\n   * @public\n   */\n  merge(e) {\n    const t = {\n      text: this.data.text + e.text\n    };\n    this.data = t;\n  }\n  /**\n   * Validate Paragraph block data:\n   * - check for emptiness\n   *\n   * @param {ParagraphData} savedData â€” data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(e) {\n    return !(e.text.trim() === \"\" && !this._preserveBlank);\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view\n   * @returns {ParagraphData} - saved data\n   * @public\n   */\n  save(e) {\n    return {\n      text: e.innerHTML\n    };\n  }\n  /**\n   * On paste callback fired from Editor.\n   *\n   * @param {PasteEvent} event - event with pasted data\n   */\n  onPaste(e) {\n    const t = {\n      text: e.detail.data.innerHTML\n    };\n    this.data = t;\n  }\n  /**\n   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // to convert Paragraph to other block, use 'text' property of saved data\n      import: \"text\"\n      // to covert other block's exported string to Paragraph, fill 'text' property of tool data\n    };\n  }\n  /**\n   * Sanitizer rules\n   */\n  static get sanitize() {\n    return {\n      text: {\n        br: !0\n      }\n    };\n  }\n  /**\n   * Returns true to notify the core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get current Tools`s data\n   *\n   * @returns {ParagraphData} Current data\n   * @private\n   */\n  get data() {\n    if (this._element !== null) {\n      const e = this._element.innerHTML;\n      this._data.text = e;\n    }\n    return this._data;\n  }\n  /**\n   * Store data in plugin:\n   * - at the this._data property\n   * - at the HTML\n   *\n   * @param {ParagraphData} data â€” data to set\n   * @private\n   */\n  set data(e) {\n    this._data = e || {}, this._element !== null && this.hydrate();\n  }\n  /**\n   * Fill tool's view with data\n   */\n  hydrate() {\n    window.requestAnimationFrame(() => {\n      this._element.innerHTML = this._data.text || \"\";\n    });\n  }\n  /**\n   * Used by Editor paste handling API.\n   * Provides configuration to handle P tags.\n   *\n   * @returns {{tags: string[]}}\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"P\"]\n    };\n  }\n  /**\n   * Icon and title for displaying at the Toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: Tn,\n      title: \"Text\"\n    };\n  }\n}\nfunction vn(n, e = 2e3) {\n  let t;\n  return (...s) => {\n    clearTimeout(t), t = setTimeout(() => {\n      n.apply(this, s);\n    }, e);\n  };\n}\nclass Un extends ht {\n  constructor({ api: t, block: s, config: r, data: i }) {\n    console.log(r);\n    super({\n      api: t,\n      block: s,\n      config: r,\n      data: i\n    });\n    Be(this, \"openai\");\n    Be(this, \"onInput\", vn((t) => {\n      this._element.querySelector(\"#ai-suggestions\") || t.inputType === \"deleteContentBackward\" || t.inputType === \"deleteContentForward\" || t.inputType === \"insertParagraph\" || t.inputType === \"insertFromPaste\" || t.inputType === \"insertFromDrop\" || !t.target.innerHTML || this.getAICompletion(t.target.innerHTML);\n    }));\n    if (!r.openaiKey)\n      throw new Error(\"OpenAI key is required for AI Text\");\n    this.openai = new $n({\n      apiKey: r.openaiKey,\n      dangerouslyAllowBrowser: !0\n    });\n  }\n  static get toolbox() {\n    return {\n      title: \"AI TEXT (experimental)\",\n      icon: `<svg width=\"800px\" height=\"800px\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path d=\"M8 4V20M17 12V20M6 20H10M15 20H19M13 7V4H3V7M21 14V12H13V14\" stroke=\"#000000\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n      </svg>`\n    };\n  }\n  getAICompletion(t) {\n    if (!t)\n      return;\n    const s = document.createElement(\"div\");\n    s.innerHTML = `<svg width=\"800px\" height=\"800px\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M12 2.99988V5.99988M12 20.9999V17.9999M4.20577 16.4999L6.80385 14.9999M21 11.9999H18M16.5 19.7941L15 17.196M3 11.9999H6M7.5 4.20565L9 6.80373M7.5 19.7941L9 17.196M19.7942 16.4999L17.1962 14.9999M4.20577 7.49988L6.80385 8.99988\" stroke=\"#000000\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n    </svg>`, s.id = \"ai-suggestions-loader\", s.style.display = \"inline-flex\", s.style.alignItems = \"center\", s.style.width = \"24px\", s.style.height = \"24px\", s.style.paddingLeft = \"4px\", s.style.color = \"lightgray\", s.style.position = \"absolute\", s.animate(\n      [\n        {\n          transform: \"rotate(0deg)\"\n        },\n        {\n          transform: \"rotate(360deg)\"\n        }\n      ],\n      {\n        duration: 2e3,\n        iterations: 1 / 0\n      }\n    ), this._element.appendChild(s), this.openai.chat.completions.create({\n      messages: [\n        {\n          role: \"user\",\n          content: `Behave yourself as a professional journalist and finish this text in similar style: ${t.length > 100 ? t : t.slice(t.length - 100)}`\n        }\n      ],\n      max_tokens: 256,\n      model: \"gpt-3.5-turbo\"\n    }).then((r) => {\n      var a;\n      const i = document.createElement(\"span\");\n      i.innerHTML = \"\", i.id = \"ai-suggestions\", i.style.color = \"lightgray\", i.innerHTML = r.choices[0].message.content, this._element.appendChild(i), (a = this._element.querySelector(\"#ai-suggestions-loader\")) == null || a.remove();\n    });\n  }\n  onKeyUp(t) {\n    var r;\n    if (t.code === \"Escape\" || t.code === \"Backspace\") {\n      (r = this._element.querySelector(\"#ai-suggestions\")) == null || r.remove();\n      return;\n    }\n    if (t.code === \"AltLeft\" || t.code === \"AltRight\") {\n      const i = this._element.querySelector(\"#ai-suggestions\"), a = i == null ? void 0 : i.textContent;\n      if (!a)\n        return;\n      const o = document.createTextNode(\n        a\n      );\n      this._element.appendChild(o), i.remove();\n      return;\n    }\n    if (t.code !== \"Backspace\" && t.code !== \"Delete\")\n      return;\n    const { textContent: s } = this._element;\n    s === \"\" && (this._element.innerHTML = \"\");\n  }\n  drawView() {\n    const t = document.createElement(\"DIV\");\n    return t.classList.add(this._CSS.wrapper, this._CSS.block), t.contentEditable = !1, t.dataset.placeholder = this.api.i18n.t(this._placeholder), this._data.text && (t.innerHTML = this._data.text), this.readOnly || (t.contentEditable = !0, t.addEventListener(\"keyup\", this.onKeyUp), t.addEventListener(\"input\", this.onInput)), t;\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFsa2hpcGNlL2VkaXRvcmpzLWFpdGV4dC9kaXN0L2FpdGV4dC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0Esb0RBQW9ELE9BQU8sbUNBQW1DLEVBQUU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQixJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFGQUFxRixVQUFVLElBQUksRUFBRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0csRUFBRTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLEVBQUU7QUFDM0c7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyxFQUFFO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsRUFBRTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRyxFQUFFLEVBQUUsV0FBVyxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxJQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLElBQUk7QUFDakMsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTCxLQUFLO0FBQ0wsS0FBSyxpQkFBaUI7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSx1QkFBdUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsNkNBQTZDO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1lZGl0b3Jqcy1hcHAvLi9ub2RlX21vZHVsZXMvQGFsa2hpcGNlL2VkaXRvcmpzLWFpdGV4dC9kaXN0L2FpdGV4dC5tanM/NzZjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgenQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgUXQgPSAobiwgZSwgdCkgPT4gZSBpbiBuID8genQobiwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IG5bZV0gPSB0O1xudmFyIEJlID0gKG4sIGUsIHQpID0+IChRdChuLCB0eXBlb2YgZSAhPSBcInN5bWJvbFwiID8gZSArIFwiXCIgOiBlLCB0KSwgdCk7XG5jb25zdCBEID0gXCI0LjE3LjNcIjtcbmxldCBkdCA9ICExLCBKLCB4dCwgUHQsIHFlLCBSdCwgU3QsIEF0LCBFdCwgJHQ7XG5mdW5jdGlvbiBZdChuLCBlID0geyBhdXRvOiAhMSB9KSB7XG4gIGlmIChkdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHlvdSBtdXN0IFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zLyR7bi5raW5kfSdcXGAgYmVmb3JlIGltcG9ydGluZyBhbnl0aGluZyBlbHNlIGZyb20gb3BlbmFpYCk7XG4gIGlmIChKKVxuICAgIHRocm93IG5ldyBFcnJvcihgY2FuJ3QgXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvJHtuLmtpbmR9J1xcYCBhZnRlciBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy8ke0p9J1xcYGApO1xuICBkdCA9IGUuYXV0bywgSiA9IG4ua2luZCwgeHQgPSBuLmZldGNoLCBuLlJlcXVlc3QsIG4uUmVzcG9uc2UsIG4uSGVhZGVycywgUHQgPSBuLkZvcm1EYXRhLCBuLkJsb2IsIHFlID0gbi5GaWxlLCBSdCA9IG4uUmVhZGFibGVTdHJlYW0sIFN0ID0gbi5nZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucywgQXQgPSBuLmdldERlZmF1bHRBZ2VudCwgRXQgPSBuLmZpbGVGcm9tUGF0aCwgJHQgPSBuLmlzRnNSZWFkU3RyZWFtO1xufVxuY2xhc3MgWnQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5ib2R5ID0gZTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiTXVsdGlwYXJ0Qm9keVwiO1xuICB9XG59XG5mdW5jdGlvbiBlbih7IG1hbnVhbGx5SW1wb3J0ZWQ6IG4gfSA9IHt9KSB7XG4gIGNvbnN0IGUgPSBuID8gXCJZb3UgbWF5IG5lZWQgdG8gdXNlIHBvbHlmaWxsc1wiIDogXCJBZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgYGltcG9ydCDigKYgZnJvbSAnb3BlbmFpJ2A6XFxuLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvbm9kZSdgIChpZiB5b3UncmUgcnVubmluZyBvbiBOb2RlKVxcbi0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL3dlYidgIChvdGhlcndpc2UpXFxuXCI7XG4gIGxldCB0LCBzLCByLCBpO1xuICB0cnkge1xuICAgIHQgPSBmZXRjaCwgcyA9IFJlcXVlc3QsIHIgPSBSZXNwb25zZSwgaSA9IEhlYWRlcnM7XG4gIH0gY2F0Y2ggKGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHRoaXMgZW52aXJvbm1lbnQgaXMgbWlzc2luZyB0aGUgZm9sbG93aW5nIFdlYiBGZXRjaCBBUEkgdHlwZTogJHthLm1lc3NhZ2V9LiAke2V9YCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcIndlYlwiLFxuICAgIGZldGNoOiB0LFxuICAgIFJlcXVlc3Q6IHMsXG4gICAgUmVzcG9uc2U6IHIsXG4gICAgSGVhZGVyczogaSxcbiAgICBGb3JtRGF0YTogKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHlwZW9mIEZvcm1EYXRhIDwgXCJ1XCIgPyBGb3JtRGF0YSA6IGNsYXNzIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdGb3JtRGF0YScgaXMgdW5kZWZpbmVkLiAke2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApLFxuICAgIEJsb2I6IHR5cGVvZiBCbG9iIDwgXCJ1XCIgPyBCbG9iIDogY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZmlsZSB1cGxvYWRzIGFyZW4ndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCB5ZXQgYXMgJ0Jsb2InIGlzIHVuZGVmaW5lZC4gJHtlfWApO1xuICAgICAgfVxuICAgIH0sXG4gICAgRmlsZTogKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHlwZW9mIEZpbGUgPCBcInVcIiA/IEZpbGUgOiBjbGFzcyB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmaWxlIHVwbG9hZHMgYXJlbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnRmlsZScgaXMgdW5kZWZpbmVkLiAke2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApLFxuICAgIFJlYWRhYmxlU3RyZWFtOiAoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0eXBlb2YgUmVhZGFibGVTdHJlYW0gPCBcInVcIiA/IFJlYWRhYmxlU3RyZWFtIDogY2xhc3Mge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RyZWFtaW5nIGlzbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnUmVhZGFibGVTdHJlYW0nIGlzIHVuZGVmaW5lZC4gJHtlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKSxcbiAgICBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9uczogYXN5bmMgKGEsIG8pID0+ICh7XG4gICAgICAuLi5vLFxuICAgICAgYm9keTogbmV3IFp0KGEpXG4gICAgfSksXG4gICAgZ2V0RGVmYXVsdEFnZW50OiAoYSkgPT4ge1xuICAgIH0sXG4gICAgZmlsZUZyb21QYXRoOiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGZpbGVGcm9tUGF0aGAgZnVuY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gTm9kZS4gU2VlIHRoZSBSRUFETUUgZm9yIG1vcmUgZGV0YWlsczogaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUjZmlsZS11cGxvYWRzXCIpO1xuICAgIH0sXG4gICAgaXNGc1JlYWRTdHJlYW06IChhKSA9PiAhMVxuICB9O1xufVxuSiB8fCBZdChlbigpLCB7IGF1dG86ICEwIH0pO1xuY2xhc3MgbSBleHRlbmRzIEVycm9yIHtcbn1cbmNsYXNzIF8gZXh0ZW5kcyBtIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcywgcikge1xuICAgIHN1cGVyKGAke18ubWFrZU1lc3NhZ2UoZSwgdCwgcyl9YCksIHRoaXMuc3RhdHVzID0gZSwgdGhpcy5oZWFkZXJzID0gcjtcbiAgICBjb25zdCBpID0gdDtcbiAgICB0aGlzLmVycm9yID0gaSwgdGhpcy5jb2RlID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS5jb2RlLCB0aGlzLnBhcmFtID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS5wYXJhbSwgdGhpcy50eXBlID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS50eXBlO1xuICB9XG4gIHN0YXRpYyBtYWtlTWVzc2FnZShlLCB0LCBzKSB7XG4gICAgY29uc3QgciA9IHQgIT0gbnVsbCAmJiB0Lm1lc3NhZ2UgPyB0eXBlb2YgdC5tZXNzYWdlID09IFwic3RyaW5nXCIgPyB0Lm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeSh0Lm1lc3NhZ2UpIDogdCA/IEpTT04uc3RyaW5naWZ5KHQpIDogcztcbiAgICByZXR1cm4gZSAmJiByID8gYCR7ZX0gJHtyfWAgOiBlID8gYCR7ZX0gc3RhdHVzIGNvZGUgKG5vIGJvZHkpYCA6IHIgfHwgXCIobm8gc3RhdHVzIGNvZGUgb3IgYm9keSlcIjtcbiAgfVxuICBzdGF0aWMgZ2VuZXJhdGUoZSwgdCwgcywgcikge1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiBuZXcgSWUoeyBjYXVzZTogWGUodCkgfSk7XG4gICAgY29uc3QgaSA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZXJyb3I7XG4gICAgcmV0dXJuIGUgPT09IDQwMCA/IG5ldyBUdChlLCBpLCBzLCByKSA6IGUgPT09IDQwMSA/IG5ldyB2dChlLCBpLCBzLCByKSA6IGUgPT09IDQwMyA/IG5ldyBGdChlLCBpLCBzLCByKSA6IGUgPT09IDQwNCA/IG5ldyBJdChlLCBpLCBzLCByKSA6IGUgPT09IDQwOSA/IG5ldyBNdChlLCBpLCBzLCByKSA6IGUgPT09IDQyMiA/IG5ldyBrdChlLCBpLCBzLCByKSA6IGUgPT09IDQyOSA/IG5ldyBPdChlLCBpLCBzLCByKSA6IGUgPj0gNTAwID8gbmV3IEx0KGUsIGksIHMsIHIpIDogbmV3IF8oZSwgaSwgcywgcik7XG4gIH1cbn1cbmNsYXNzIGogZXh0ZW5kcyBfIHtcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlOiBlIH0gPSB7fSkge1xuICAgIHN1cGVyKHZvaWQgMCwgdm9pZCAwLCBlIHx8IFwiUmVxdWVzdCB3YXMgYWJvcnRlZC5cIiwgdm9pZCAwKSwgdGhpcy5zdGF0dXMgPSB2b2lkIDA7XG4gIH1cbn1cbmNsYXNzIEllIGV4dGVuZHMgXyB7XG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZTogZSwgY2F1c2U6IHQgfSkge1xuICAgIHN1cGVyKHZvaWQgMCwgdm9pZCAwLCBlIHx8IFwiQ29ubmVjdGlvbiBlcnJvci5cIiwgdm9pZCAwKSwgdGhpcy5zdGF0dXMgPSB2b2lkIDAsIHQgJiYgKHRoaXMuY2F1c2UgPSB0KTtcbiAgfVxufVxuY2xhc3MgWmUgZXh0ZW5kcyBJZSB7XG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZTogZSB9ID0ge30pIHtcbiAgICBzdXBlcih7IG1lc3NhZ2U6IGUgPz8gXCJSZXF1ZXN0IHRpbWVkIG91dC5cIiB9KTtcbiAgfVxufVxuY2xhc3MgVHQgZXh0ZW5kcyBfIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5zdGF0dXMgPSA0MDA7XG4gIH1cbn1cbmNsYXNzIHZ0IGV4dGVuZHMgXyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuc3RhdHVzID0gNDAxO1xuICB9XG59XG5jbGFzcyBGdCBleHRlbmRzIF8ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnN0YXR1cyA9IDQwMztcbiAgfVxufVxuY2xhc3MgSXQgZXh0ZW5kcyBfIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5zdGF0dXMgPSA0MDQ7XG4gIH1cbn1cbmNsYXNzIE10IGV4dGVuZHMgXyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuc3RhdHVzID0gNDA5O1xuICB9XG59XG5jbGFzcyBrdCBleHRlbmRzIF8ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnN0YXR1cyA9IDQyMjtcbiAgfVxufVxuY2xhc3MgT3QgZXh0ZW5kcyBfIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5zdGF0dXMgPSA0Mjk7XG4gIH1cbn1cbmNsYXNzIEx0IGV4dGVuZHMgXyB7XG59XG5jbGFzcyBMIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuaXRlcmF0b3IgPSBlLCB0aGlzLmNvbnRyb2xsZXIgPSB0O1xuICB9XG4gIHN0YXRpYyBmcm9tU1NFUmVzcG9uc2UoZSwgdCkge1xuICAgIGxldCBzID0gITE7XG4gICAgY29uc3QgciA9IG5ldyB0bigpO1xuICAgIGFzeW5jIGZ1bmN0aW9uKiBpKCkge1xuICAgICAgaWYgKCFlLmJvZHkpXG4gICAgICAgIHRocm93IHQuYWJvcnQoKSwgbmV3IG0oXCJBdHRlbXB0ZWQgdG8gaXRlcmF0ZSBvdmVyIGEgcmVzcG9uc2Ugd2l0aCBubyBib2R5XCIpO1xuICAgICAgY29uc3QgbyA9IG5ldyBOKCksIGMgPSBmdChlLmJvZHkpO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBwIG9mIGMpXG4gICAgICAgIGZvciAoY29uc3QgZiBvZiBvLmRlY29kZShwKSkge1xuICAgICAgICAgIGNvbnN0IHcgPSByLmRlY29kZShmKTtcbiAgICAgICAgICB3ICYmICh5aWVsZCB3KTtcbiAgICAgICAgfVxuICAgICAgZm9yIChjb25zdCBwIG9mIG8uZmx1c2goKSkge1xuICAgICAgICBjb25zdCBmID0gci5kZWNvZGUocCk7XG4gICAgICAgIGYgJiYgKHlpZWxkIGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiogYSgpIHtcbiAgICAgIGlmIChzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaXRlcmF0ZSBvdmVyIGEgY29uc3VtZWQgc3RyZWFtLCB1c2UgYC50ZWUoKWAgdG8gc3BsaXQgdGhlIHN0cmVhbS5cIik7XG4gICAgICBzID0gITA7XG4gICAgICBsZXQgbyA9ICExO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjIG9mIGkoKSlcbiAgICAgICAgICBpZiAoIW8pIHtcbiAgICAgICAgICAgIGlmIChjLmRhdGEuc3RhcnRzV2l0aChcIltET05FXVwiKSkge1xuICAgICAgICAgICAgICBvID0gITA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuZXZlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcCA9IEpTT04ucGFyc2UoYy5kYXRhKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgbWVzc2FnZSBpbnRvIEpTT046XCIsIGMuZGF0YSksIGNvbnNvbGUuZXJyb3IoXCJGcm9tIGNodW5rOlwiLCBjLnJhdyksIGY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHAgJiYgcC5lcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgXyh2b2lkIDAsIHAuZXJyb3IsIHZvaWQgMCwgdm9pZCAwKTtcbiAgICAgICAgICAgICAgeWllbGQgcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIG8gPSAhMDtcbiAgICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBFcnJvciAmJiBjLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhyb3cgYztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG8gfHwgdC5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEwoYSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFN0cmVhbSBmcm9tIGEgbmV3bGluZS1zZXBhcmF0ZWQgUmVhZGFibGVTdHJlYW1cbiAgICogd2hlcmUgZWFjaCBpdGVtIGlzIGEgSlNPTiB2YWx1ZS5cbiAgICovXG4gIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0oZSwgdCkge1xuICAgIGxldCBzID0gITE7XG4gICAgYXN5bmMgZnVuY3Rpb24qIHIoKSB7XG4gICAgICBjb25zdCBhID0gbmV3IE4oKSwgbyA9IGZ0KGUpO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBjIG9mIG8pXG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBhLmRlY29kZShjKSlcbiAgICAgICAgICB5aWVsZCBwO1xuICAgICAgZm9yIChjb25zdCBjIG9mIGEuZmx1c2goKSlcbiAgICAgICAgeWllbGQgYztcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24qIGkoKSB7XG4gICAgICBpZiAocylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGl0ZXJhdGUgb3ZlciBhIGNvbnN1bWVkIHN0cmVhbSwgdXNlIGAudGVlKClgIHRvIHNwbGl0IHRoZSBzdHJlYW0uXCIpO1xuICAgICAgcyA9ICEwO1xuICAgICAgbGV0IGEgPSAhMTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgbyBvZiByKCkpXG4gICAgICAgICAgYSB8fCBvICYmICh5aWVsZCBKU09OLnBhcnNlKG8pKTtcbiAgICAgICAgYSA9ICEwO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICBpZiAobyBpbnN0YW5jZW9mIEVycm9yICYmIG8ubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aHJvdyBvO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYSB8fCB0LmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTChpLCB0KTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNwbGl0cyB0aGUgc3RyZWFtIGludG8gdHdvIHN0cmVhbXMgd2hpY2ggY2FuIGJlXG4gICAqIGluZGVwZW5kZW50bHkgcmVhZCBmcm9tIGF0IGRpZmZlcmVudCBzcGVlZHMuXG4gICAqL1xuICB0ZWUoKSB7XG4gICAgY29uc3QgZSA9IFtdLCB0ID0gW10sIHMgPSB0aGlzLml0ZXJhdG9yKCksIHIgPSAoaSkgPT4gKHtcbiAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgaWYgKGkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgYSA9IHMubmV4dCgpO1xuICAgICAgICAgIGUucHVzaChhKSwgdC5wdXNoKGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBMKCgpID0+IHIoZSksIHRoaXMuY29udHJvbGxlciksXG4gICAgICBuZXcgTCgoKSA9PiByKHQpLCB0aGlzLmNvbnRyb2xsZXIpXG4gICAgXTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBzdHJlYW0gdG8gYSBuZXdsaW5lLXNlcGFyYXRlZCBSZWFkYWJsZVN0cmVhbSBvZlxuICAgKiBKU09OIHN0cmluZ2lmaWVkIHZhbHVlcyBpbiB0aGUgc3RyZWFtXG4gICAqIHdoaWNoIGNhbiBiZSB0dXJuZWQgYmFjayBpbnRvIGEgU3RyZWFtIHdpdGggYFN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0oKWAuXG4gICAqL1xuICB0b1JlYWRhYmxlU3RyZWFtKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzO1xuICAgIGxldCB0O1xuICAgIGNvbnN0IHMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICByZXR1cm4gbmV3IFJ0KHtcbiAgICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICB0ID0gZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBwdWxsKHIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHZhbHVlOiBpLCBkb25lOiBhIH0gPSBhd2FpdCB0Lm5leHQoKTtcbiAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgIHJldHVybiByLmNsb3NlKCk7XG4gICAgICAgICAgY29uc3QgbyA9IHMuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGkpICsgYFxuYCk7XG4gICAgICAgICAgci5lbnF1ZXVlKG8pO1xuICAgICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgICAgci5lcnJvcihpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIGF3YWl0ICgociA9IHQucmV0dXJuKSA9PSBudWxsID8gdm9pZCAwIDogci5jYWxsKHQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgdG4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmV2ZW50ID0gbnVsbCwgdGhpcy5kYXRhID0gW10sIHRoaXMuY2h1bmtzID0gW107XG4gIH1cbiAgZGVjb2RlKGUpIHtcbiAgICBpZiAoZS5lbmRzV2l0aChcIlxcclwiKSAmJiAoZSA9IGUuc3Vic3RyaW5nKDAsIGUubGVuZ3RoIC0gMSkpLCAhZSkge1xuICAgICAgaWYgKCF0aGlzLmV2ZW50ICYmICF0aGlzLmRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGkgPSB7XG4gICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGEuam9pbihgXG5gKSxcbiAgICAgICAgcmF3OiB0aGlzLmNodW5rc1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50ID0gbnVsbCwgdGhpcy5kYXRhID0gW10sIHRoaXMuY2h1bmtzID0gW10sIGk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNodW5rcy5wdXNoKGUpLCBlLnN0YXJ0c1dpdGgoXCI6XCIpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IFt0LCBzLCByXSA9IG5uKGUsIFwiOlwiKTtcbiAgICByZXR1cm4gci5zdGFydHNXaXRoKFwiIFwiKSAmJiAociA9IHIuc3Vic3RyaW5nKDEpKSwgdCA9PT0gXCJldmVudFwiID8gdGhpcy5ldmVudCA9IHIgOiB0ID09PSBcImRhdGFcIiAmJiB0aGlzLmRhdGEucHVzaChyKSwgbnVsbDtcbiAgfVxufVxuY2xhc3MgTiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYnVmZmVyID0gW10sIHRoaXMudHJhaWxpbmdDUiA9ICExO1xuICB9XG4gIGRlY29kZShlKSB7XG4gICAgbGV0IHQgPSB0aGlzLmRlY29kZVRleHQoZSk7XG4gICAgaWYgKHRoaXMudHJhaWxpbmdDUiAmJiAodCA9IFwiXFxyXCIgKyB0LCB0aGlzLnRyYWlsaW5nQ1IgPSAhMSksIHQuZW5kc1dpdGgoXCJcXHJcIikgJiYgKHRoaXMudHJhaWxpbmdDUiA9ICEwLCB0ID0gdC5zbGljZSgwLCAtMSkpLCAhdClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBzID0gTi5ORVdMSU5FX0NIQVJTLmhhcyh0W3QubGVuZ3RoIC0gMV0gfHwgXCJcIik7XG4gICAgbGV0IHIgPSB0LnNwbGl0KE4uTkVXTElORV9SRUdFWFApO1xuICAgIHJldHVybiByLmxlbmd0aCA9PT0gMSAmJiAhcyA/ICh0aGlzLmJ1ZmZlci5wdXNoKHJbMF0pLCBbXSkgOiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCAmJiAociA9IFt0aGlzLmJ1ZmZlci5qb2luKFwiXCIpICsgclswXSwgLi4uci5zbGljZSgxKV0sIHRoaXMuYnVmZmVyID0gW10pLCBzIHx8ICh0aGlzLmJ1ZmZlciA9IFtyLnBvcCgpIHx8IFwiXCJdKSwgcik7XG4gIH1cbiAgZGVjb2RlVGV4dChlKSB7XG4gICAgaWYgKGUgPT0gbnVsbClcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgPCBcInVcIikge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBCdWZmZXIpXG4gICAgICAgIHJldHVybiBlLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShlKS50b1N0cmluZygpO1xuICAgICAgdGhyb3cgbmV3IG0oYFVuZXhwZWN0ZWQ6IHJlY2VpdmVkIG5vbi1VaW50OEFycmF5ICgke2UuY29uc3RydWN0b3IubmFtZX0pIHN0cmVhbSBjaHVuayBpbiBhbiBlbnZpcm9ubWVudCB3aXRoIGEgZ2xvYmFsIFwiQnVmZmVyXCIgZGVmaW5lZCwgd2hpY2ggdGhpcyBsaWJyYXJ5IGFzc3VtZXMgdG8gYmUgTm9kZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIFRleHREZWNvZGVyIDwgXCJ1XCIpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgIHJldHVybiB0aGlzLnRleHREZWNvZGVyID8/ICh0aGlzLnRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmOFwiKSksIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKGUpO1xuICAgICAgdGhyb3cgbmV3IG0oYFVuZXhwZWN0ZWQ6IHJlY2VpdmVkIG5vbi1VaW50OEFycmF5L0FycmF5QnVmZmVyICgke2UuY29uc3RydWN0b3IubmFtZX0pIGluIGEgd2ViIHBsYXRmb3JtLiBQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IuYCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBtKFwiVW5leHBlY3RlZDogbmVpdGhlciBCdWZmZXIgbm9yIFRleHREZWNvZGVyIGFyZSBhdmFpbGFibGUgYXMgZ2xvYmFscy4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yLlwiKTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBpZiAoIXRoaXMuYnVmZmVyLmxlbmd0aCAmJiAhdGhpcy50cmFpbGluZ0NSKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGUgPSBbdGhpcy5idWZmZXIuam9pbihcIlwiKV07XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyID0gW10sIHRoaXMudHJhaWxpbmdDUiA9ICExLCBlO1xuICB9XG59XG5OLk5FV0xJTkVfQ0hBUlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbYFxuYCwgXCJcXHJcIiwgXCJcXHZcIiwgXCJcXGZcIiwgXCJcdTAwMWNcIiwgXCJcdTAwMWRcIiwgXCJcdTAwMWVcIiwgXCLChVwiLCBcIlxcdTIwMjhcIiwgXCJcXHUyMDI5XCJdKTtcbk4uTkVXTElORV9SRUdFWFAgPSAvXFxyXFxufFtcXG5cXHJcXHgwYlxceDBjXFx4MWNcXHgxZFxceDFlXFx4ODVcXHUyMDI4XFx1MjAyOV0vZztcbmZ1bmN0aW9uIG5uKG4sIGUpIHtcbiAgY29uc3QgdCA9IG4uaW5kZXhPZihlKTtcbiAgcmV0dXJuIHQgIT09IC0xID8gW24uc3Vic3RyaW5nKDAsIHQpLCBlLCBuLnN1YnN0cmluZyh0ICsgZS5sZW5ndGgpXSA6IFtuLCBcIlwiLCBcIlwiXTtcbn1cbmZ1bmN0aW9uIGZ0KG4pIHtcbiAgaWYgKG5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKVxuICAgIHJldHVybiBuO1xuICBjb25zdCBlID0gbi5nZXRSZWFkZXIoKTtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdCA9IGF3YWl0IGUucmVhZCgpO1xuICAgICAgICByZXR1cm4gdCAhPSBudWxsICYmIHQuZG9uZSAmJiBlLnJlbGVhc2VMb2NrKCksIHQ7XG4gICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgIHRocm93IGUucmVsZWFzZUxvY2soKSwgdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgIGNvbnN0IHQgPSBlLmNhbmNlbCgpO1xuICAgICAgcmV0dXJuIGUucmVsZWFzZUxvY2soKSwgYXdhaXQgdCwgeyBkb25lOiAhMCwgdmFsdWU6IHZvaWQgMCB9O1xuICAgIH0sXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEJ0ID0gKG4pID0+IG4gIT0gbnVsbCAmJiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBuLnVybCA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBuLmJsb2IgPT0gXCJmdW5jdGlvblwiLCBzbiA9IChuKSA9PiBuICE9IG51bGwgJiYgdHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygbi5uYW1lID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG4ubGFzdE1vZGlmaWVkID09IFwibnVtYmVyXCIgJiYganQobiksIGp0ID0gKG4pID0+IG4gIT0gbnVsbCAmJiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBuLnNpemUgPT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygbi50eXBlID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG4udGV4dCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG4uc2xpY2UgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBuLmFycmF5QnVmZmVyID09IFwiZnVuY3Rpb25cIiwgcm4gPSAobikgPT4gc24obikgfHwgQnQobikgfHwgJHQobik7XG5hc3luYyBmdW5jdGlvbiBOdChuLCBlLCB0ID0ge30pIHtcbiAgdmFyIHI7XG4gIGlmIChuID0gYXdhaXQgbiwgQnQobikpIHtcbiAgICBjb25zdCBpID0gYXdhaXQgbi5ibG9iKCk7XG4gICAgcmV0dXJuIGUgfHwgKGUgPSBuZXcgVVJMKG4udXJsKS5wYXRobmFtZS5zcGxpdCgvW1xcXFwvXS8pLnBvcCgpID8/IFwidW5rbm93bl9maWxlXCIpLCBuZXcgcWUoW2ldLCBlLCB0KTtcbiAgfVxuICBjb25zdCBzID0gYXdhaXQgYW4obik7XG4gIGlmIChlIHx8IChlID0gY24obikgPz8gXCJ1bmtub3duX2ZpbGVcIiksICF0LnR5cGUpIHtcbiAgICBjb25zdCBpID0gKHIgPSBzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogci50eXBlO1xuICAgIHR5cGVvZiBpID09IFwic3RyaW5nXCIgJiYgKHQgPSB7IC4uLnQsIHR5cGU6IGkgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBxZShzLCBlLCB0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFuKG4pIHtcbiAgdmFyIHQ7XG4gIGxldCBlID0gW107XG4gIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiIHx8IEFycmF5QnVmZmVyLmlzVmlldyhuKSB8fCAvLyBpbmNsdWRlcyBVaW50OEFycmF5LCBCdWZmZXIsIGV0Yy5cbiAgbiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgIGUucHVzaChuKTtcbiAgZWxzZSBpZiAoanQobikpXG4gICAgZS5wdXNoKGF3YWl0IG4uYXJyYXlCdWZmZXIoKSk7XG4gIGVsc2UgaWYgKGxuKG4pKVxuICAgIGZvciBhd2FpdCAoY29uc3QgcyBvZiBuKVxuICAgICAgZS5wdXNoKHMpO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGRhdGEgdHlwZTogJHt0eXBlb2Ygbn07IGNvbnN0cnVjdG9yOiAkeyh0ID0gbiA9PSBudWxsID8gdm9pZCAwIDogbi5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IHQubmFtZX07IHByb3BzOiAke29uKG4pfWApO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIG9uKG4pIHtcbiAgcmV0dXJuIGBbJHtPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKS5tYXAoKHQpID0+IGBcIiR7dH1cImApLmpvaW4oXCIsIFwiKX1dYDtcbn1cbmZ1bmN0aW9uIGNuKG4pIHtcbiAgdmFyIGU7XG4gIHJldHVybiBqZShuLm5hbWUpIHx8IGplKG4uZmlsZW5hbWUpIHx8IC8vIEZvciBmcy5SZWFkU3RyZWFtXG4gICgoZSA9IGplKG4ucGF0aCkpID09IG51bGwgPyB2b2lkIDAgOiBlLnNwbGl0KC9bXFxcXC9dLykucG9wKCkpO1xufVxuY29uc3QgamUgPSAobikgPT4ge1xuICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gbjtcbiAgaWYgKHR5cGVvZiBCdWZmZXIgPCBcInVcIiAmJiBuIGluc3RhbmNlb2YgQnVmZmVyKVxuICAgIHJldHVybiBTdHJpbmcobik7XG59LCBsbiA9IChuKSA9PiBuICE9IG51bGwgJiYgdHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT0gXCJmdW5jdGlvblwiLCBtdCA9IChuKSA9PiBuICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCIgJiYgbi5ib2R5ICYmIG5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJNdWx0aXBhcnRCb2R5XCIsIEcgPSBhc3luYyAobikgPT4ge1xuICBjb25zdCBlID0gYXdhaXQgdW4obi5ib2R5KTtcbiAgcmV0dXJuIFN0KGUsIG4pO1xufSwgdW4gPSBhc3luYyAobikgPT4ge1xuICBjb25zdCBlID0gbmV3IFB0KCk7XG4gIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhuIHx8IHt9KS5tYXAoKFt0LCBzXSkgPT4gV2UoZSwgdCwgcykpKSwgZTtcbn0sIFdlID0gYXN5bmMgKG4sIGUsIHQpID0+IHtcbiAgaWYgKHQgIT09IHZvaWQgMCkge1xuICAgIGlmICh0ID09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBSZWNlaXZlZCBudWxsIGZvciBcIiR7ZX1cIjsgdG8gcGFzcyBudWxsIGluIEZvcm1EYXRhLCB5b3UgbXVzdCB1c2UgdGhlIHN0cmluZyAnbnVsbCdgKTtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdCA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB0ID09IFwiYm9vbGVhblwiKVxuICAgICAgbi5hcHBlbmQoZSwgU3RyaW5nKHQpKTtcbiAgICBlbHNlIGlmIChybih0KSkge1xuICAgICAgY29uc3QgcyA9IGF3YWl0IE50KHQpO1xuICAgICAgbi5hcHBlbmQoZSwgcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHQpKVxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodC5tYXAoKHMpID0+IFdlKG4sIGUgKyBcIltdXCIsIHMpKSk7XG4gICAgZWxzZSBpZiAodHlwZW9mIHQgPT0gXCJvYmplY3RcIilcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKHQpLm1hcCgoW3MsIHJdKSA9PiBXZShuLCBgJHtlfVske3N9XWAsIHIpKSk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBnaXZlbiB0byBmb3JtLCBleHBlY3RlZCBhIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvYmplY3QsIEFycmF5LCBGaWxlIG9yIEJsb2IgYnV0IGdvdCAke3R9IGluc3RlYWRgKTtcbiAgfVxufTtcbnZhciBobiA9IGdsb2JhbFRoaXMgJiYgZ2xvYmFsVGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IHx8IGZ1bmN0aW9uKG4sIGUsIHQsIHMsIHIpIHtcbiAgaWYgKHMgPT09IFwibVwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChzID09PSBcImFcIiAmJiAhcilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gbiAhPT0gZSB8fCAhciA6ICFlLmhhcyhuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBzID09PSBcImFcIiA/IHIuY2FsbChuLCB0KSA6IHIgPyByLnZhbHVlID0gdCA6IGUuc2V0KG4sIHQpLCB0O1xufSwgZG4gPSBnbG9iYWxUaGlzICYmIGdsb2JhbFRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCB8fCBmdW5jdGlvbihuLCBlLCB0LCBzKSB7XG4gIGlmICh0ID09PSBcImFcIiAmJiAhcylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gbiAhPT0gZSB8fCAhcyA6ICFlLmhhcyhuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gdCA9PT0gXCJtXCIgPyBzIDogdCA9PT0gXCJhXCIgPyBzLmNhbGwobikgOiBzID8gcy52YWx1ZSA6IGUuZ2V0KG4pO1xufSwgWjtcbmFzeW5jIGZ1bmN0aW9uIER0KG4pIHtcbiAgY29uc3QgeyByZXNwb25zZTogZSB9ID0gbjtcbiAgaWYgKG4ub3B0aW9ucy5zdHJlYW0pXG4gICAgcmV0dXJuIEsoXCJyZXNwb25zZVwiLCBlLnN0YXR1cywgZS51cmwsIGUuaGVhZGVycywgZS5ib2R5KSwgTC5mcm9tU1NFUmVzcG9uc2UoZSwgbi5jb250cm9sbGVyKTtcbiAgaWYgKGUuc3RhdHVzID09PSAyMDQpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChuLm9wdGlvbnMuX19iaW5hcnlSZXNwb25zZSlcbiAgICByZXR1cm4gZTtcbiAgY29uc3QgdCA9IGUuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gIGlmICh0ICE9IG51bGwgJiYgdC5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICBjb25zdCByID0gYXdhaXQgZS5qc29uKCk7XG4gICAgcmV0dXJuIEsoXCJyZXNwb25zZVwiLCBlLnN0YXR1cywgZS51cmwsIGUuaGVhZGVycywgciksIHI7XG4gIH1cbiAgY29uc3QgcyA9IGF3YWl0IGUudGV4dCgpO1xuICByZXR1cm4gSyhcInJlc3BvbnNlXCIsIGUuc3RhdHVzLCBlLnVybCwgZS5oZWFkZXJzLCBzKSwgcztcbn1cbmNsYXNzIE1lIGV4dGVuZHMgUHJvbWlzZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQgPSBEdCkge1xuICAgIHN1cGVyKChzKSA9PiB7XG4gICAgICBzKG51bGwpO1xuICAgIH0pLCB0aGlzLnJlc3BvbnNlUHJvbWlzZSA9IGUsIHRoaXMucGFyc2VSZXNwb25zZSA9IHQ7XG4gIH1cbiAgX3RoZW5VbndyYXAoZSkge1xuICAgIHJldHVybiBuZXcgTWUodGhpcy5yZXNwb25zZVByb21pc2UsIGFzeW5jICh0KSA9PiBlKGF3YWl0IHRoaXMucGFyc2VSZXNwb25zZSh0KSkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSBpbnN0ZWFkIG9mIHBhcnNpbmcgdGhlIHJlc3BvbnNlXG4gICAqIGRhdGEuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIHBhcnNlIHRoZSByZXNwb25zZSBib2R5IGJ1dCBzdGlsbCBnZXQgdGhlIGBSZXNwb25zZWBcbiAgICogaW5zdGFuY2UsIHlvdSBjYW4gdXNlIHtAbGluayB3aXRoUmVzcG9uc2UoKX0uXG4gICAqXG4gICAqIPCfkYsgR2V0dGluZyB0aGUgd3JvbmcgVHlwZVNjcmlwdCB0eXBlIGZvciBgUmVzcG9uc2VgP1xuICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgaWYgeW91IGNhbixcbiAgICogb3IgYWRkIG9uZSBvZiB0aGVzZSBpbXBvcnRzIGJlZm9yZSB5b3VyIGZpcnN0IGBpbXBvcnQg4oCmIGZyb20gJ29wZW5haSdgOlxuICAgKiAtIGBpbXBvcnQgJ29wZW5haS9zaGltcy9ub2RlJ2AgKGlmIHlvdSdyZSBydW5uaW5nIG9uIE5vZGUpXG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL3dlYidgIChvdGhlcndpc2UpXG4gICAqL1xuICBhc1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUHJvbWlzZS50aGVuKChlKSA9PiBlLnJlc3BvbnNlKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcGFyc2VkIHJlc3BvbnNlIGRhdGEgYW5kIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZS5cbiAgICpcbiAgICogSWYgeW91IGp1c3Qgd2FudCB0byBnZXQgdGhlIHJhdyBgUmVzcG9uc2VgIGluc3RhbmNlIHdpdGhvdXQgcGFyc2luZyBpdCxcbiAgICogeW91IGNhbiB1c2Uge0BsaW5rIGFzUmVzcG9uc2UoKX0uXG4gICAqXG4gICAqXG4gICAqIPCfkYsgR2V0dGluZyB0aGUgd3JvbmcgVHlwZVNjcmlwdCB0eXBlIGZvciBgUmVzcG9uc2VgP1xuICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgaWYgeW91IGNhbixcbiAgICogb3IgYWRkIG9uZSBvZiB0aGVzZSBpbXBvcnRzIGJlZm9yZSB5b3VyIGZpcnN0IGBpbXBvcnQg4oCmIGZyb20gJ29wZW5haSdgOlxuICAgKiAtIGBpbXBvcnQgJ29wZW5haS9zaGltcy9ub2RlJ2AgKGlmIHlvdSdyZSBydW5uaW5nIG9uIE5vZGUpXG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL3dlYidgIChvdGhlcndpc2UpXG4gICAqL1xuICBhc3luYyB3aXRoUmVzcG9uc2UoKSB7XG4gICAgY29uc3QgW2UsIHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucGFyc2UoKSwgdGhpcy5hc1Jlc3BvbnNlKCldKTtcbiAgICByZXR1cm4geyBkYXRhOiBlLCByZXNwb25zZTogdCB9O1xuICB9XG4gIHBhcnNlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlZFByb21pc2UgfHwgKHRoaXMucGFyc2VkUHJvbWlzZSA9IHRoaXMucmVzcG9uc2VQcm9taXNlLnRoZW4odGhpcy5wYXJzZVJlc3BvbnNlKSksIHRoaXMucGFyc2VkUHJvbWlzZTtcbiAgfVxuICB0aGVuKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZSgpLnRoZW4oZSwgdCk7XG4gIH1cbiAgY2F0Y2goZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlKCkuY2F0Y2goZSk7XG4gIH1cbiAgZmluYWxseShlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoKS5maW5hbGx5KGUpO1xuICB9XG59XG5jbGFzcyBmbiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVVJMOiBlLFxuICAgIG1heFJldHJpZXM6IHQgPSAyLFxuICAgIHRpbWVvdXQ6IHMgPSA2ZTUsXG4gICAgLy8gMTAgbWludXRlc1xuICAgIGh0dHBBZ2VudDogcixcbiAgICBmZXRjaDogaVxuICB9KSB7XG4gICAgdGhpcy5iYXNlVVJMID0gZSwgdGhpcy5tYXhSZXRyaWVzID0gTmUoXCJtYXhSZXRyaWVzXCIsIHQpLCB0aGlzLnRpbWVvdXQgPSBOZShcInRpbWVvdXRcIiwgcyksIHRoaXMuaHR0cEFnZW50ID0gciwgdGhpcy5mZXRjaCA9IGkgPz8geHQ7XG4gIH1cbiAgYXV0aEhlYWRlcnMoZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gZGVmYXVsdCBoZWFkZXJzLCBmb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHtcbiAgICogICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMoKSxcbiAgICogICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAxMjMnLFxuICAgKiAgfVxuICAgKi9cbiAgZGVmYXVsdEhlYWRlcnMoZSkge1xuICAgIHJldHVybiB7XG4gICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBcIlVzZXItQWdlbnRcIjogdGhpcy5nZXRVc2VyQWdlbnQoKSxcbiAgICAgIC4uLmJuKCksXG4gICAgICAuLi50aGlzLmF1dGhIZWFkZXJzKGUpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gaGVhZGVycyB2YWxpZGF0aW9uOlxuICAgKi9cbiAgdmFsaWRhdGVIZWFkZXJzKGUsIHQpIHtcbiAgfVxuICBkZWZhdWx0SWRlbXBvdGVuY3lLZXkoKSB7XG4gICAgcmV0dXJuIGBzdGFpbmxlc3Mtbm9kZS1yZXRyeS0ke1JuKCl9YDtcbiAgfVxuICBnZXQoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoXCJnZXRcIiwgZSwgdCk7XG4gIH1cbiAgcG9zdChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdChcInBvc3RcIiwgZSwgdCk7XG4gIH1cbiAgcGF0Y2goZSwgdCkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoXCJwYXRjaFwiLCBlLCB0KTtcbiAgfVxuICBwdXQoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoXCJwdXRcIiwgZSwgdCk7XG4gIH1cbiAgZGVsZXRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KFwiZGVsZXRlXCIsIGUsIHQpO1xuICB9XG4gIG1ldGhvZFJlcXVlc3QoZSwgdCwgcykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoUHJvbWlzZS5yZXNvbHZlKHMpLnRoZW4oKHIpID0+ICh7IG1ldGhvZDogZSwgcGF0aDogdCwgLi4uciB9KSkpO1xuICB9XG4gIGdldEFQSUxpc3QoZSwgdCwgcykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RBUElMaXN0KHQsIHsgbWV0aG9kOiBcImdldFwiLCBwYXRoOiBlLCAuLi5zIH0pO1xuICB9XG4gIGNhbGN1bGF0ZUNvbnRlbnRMZW5ndGgoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAodHlwZW9mIEJ1ZmZlciA8IFwidVwiKVxuICAgICAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoZSwgXCJ1dGY4XCIpLnRvU3RyaW5nKCk7XG4gICAgICBpZiAodHlwZW9mIFRleHRFbmNvZGVyIDwgXCJ1XCIpXG4gICAgICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZSkubGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGJ1aWxkUmVxdWVzdChlKSB7XG4gICAgdmFyIGQ7XG4gICAgY29uc3QgeyBtZXRob2Q6IHQsIHBhdGg6IHMsIHF1ZXJ5OiByLCBoZWFkZXJzOiBpID0ge30gfSA9IGUsIGEgPSBtdChlLmJvZHkpID8gZS5ib2R5LmJvZHkgOiBlLmJvZHkgPyBKU09OLnN0cmluZ2lmeShlLmJvZHksIG51bGwsIDIpIDogbnVsbCwgbyA9IHRoaXMuY2FsY3VsYXRlQ29udGVudExlbmd0aChhKSwgYyA9IHRoaXMuYnVpbGRVUkwocywgcik7XG4gICAgXCJ0aW1lb3V0XCIgaW4gZSAmJiBOZShcInRpbWVvdXRcIiwgZS50aW1lb3V0KTtcbiAgICBjb25zdCBwID0gZS50aW1lb3V0ID8/IHRoaXMudGltZW91dCwgZiA9IGUuaHR0cEFnZW50ID8/IHRoaXMuaHR0cEFnZW50ID8/IEF0KGMpLCB3ID0gcCArIDFlMztcbiAgICB0eXBlb2YgKChkID0gZiA9PSBudWxsID8gdm9pZCAwIDogZi5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogZC50aW1lb3V0KSA9PSBcIm51bWJlclwiICYmIHcgPiAoZi5vcHRpb25zLnRpbWVvdXQgPz8gMCkgJiYgKGYub3B0aW9ucy50aW1lb3V0ID0gdyksIHRoaXMuaWRlbXBvdGVuY3lIZWFkZXIgJiYgdCAhPT0gXCJnZXRcIiAmJiAoZS5pZGVtcG90ZW5jeUtleSB8fCAoZS5pZGVtcG90ZW5jeUtleSA9IHRoaXMuZGVmYXVsdElkZW1wb3RlbmN5S2V5KCkpLCBpW3RoaXMuaWRlbXBvdGVuY3lIZWFkZXJdID0gZS5pZGVtcG90ZW5jeUtleSk7XG4gICAgY29uc3QgdSA9IHtcbiAgICAgIC4uLm8gJiYgeyBcIkNvbnRlbnQtTGVuZ3RoXCI6IG8gfSxcbiAgICAgIC4uLnRoaXMuZGVmYXVsdEhlYWRlcnMoZSksXG4gICAgICAuLi5pXG4gICAgfTtcbiAgICBtdChlLmJvZHkpICYmIEogIT09IFwibm9kZVwiICYmIGRlbGV0ZSB1W1wiQ29udGVudC1UeXBlXCJdLCBPYmplY3Qua2V5cyh1KS5mb3JFYWNoKChQKSA9PiB1W1BdID09PSBudWxsICYmIGRlbGV0ZSB1W1BdKTtcbiAgICBjb25zdCBoID0ge1xuICAgICAgbWV0aG9kOiB0LFxuICAgICAgLi4uYSAmJiB7IGJvZHk6IGEgfSxcbiAgICAgIGhlYWRlcnM6IHUsXG4gICAgICAuLi5mICYmIHsgYWdlbnQ6IGYgfSxcbiAgICAgIC8vIEB0cy1pZ25vcmUgbm9kZS1mZXRjaCB1c2VzIGEgY3VzdG9tIEFib3J0U2lnbmFsIHR5cGUgdGhhdCBpc1xuICAgICAgLy8gbm90IGNvbXBhdGlibGUgd2l0aCBzdGFuZGFyZCB3ZWIgdHlwZXNcbiAgICAgIHNpZ25hbDogZS5zaWduYWwgPz8gbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVIZWFkZXJzKHUsIGkpLCB7IHJlcTogaCwgdXJsOiBjLCB0aW1lb3V0OiBwIH07XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgYXMgYSBjYWxsYmFjayBmb3IgbXV0YXRpbmcgdGhlIGdpdmVuIGBSZXF1ZXN0SW5pdGAgb2JqZWN0LlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgeW91IHdhbnQgdG8gYWRkIGNlcnRhaW4gaGVhZGVycyBiYXNlZCBvZmYgb2ZcbiAgICogdGhlIHJlcXVlc3QgcHJvcGVydGllcywgZS5nLiBgbWV0aG9kYCBvciBgdXJsYC5cbiAgICovXG4gIGFzeW5jIHByZXBhcmVSZXF1ZXN0KGUsIHsgdXJsOiB0LCBvcHRpb25zOiBzIH0pIHtcbiAgfVxuICBwYXJzZUhlYWRlcnMoZSkge1xuICAgIHJldHVybiBlID8gU3ltYm9sLml0ZXJhdG9yIGluIGUgPyBPYmplY3QuZnJvbUVudHJpZXMoQXJyYXkuZnJvbShlKS5tYXAoKHQpID0+IFsuLi50XSkpIDogeyAuLi5lIH0gOiB7fTtcbiAgfVxuICBtYWtlU3RhdHVzRXJyb3IoZSwgdCwgcywgcikge1xuICAgIHJldHVybiBfLmdlbmVyYXRlKGUsIHQsIHMsIHIpO1xuICB9XG4gIHJlcXVlc3QoZSwgdCA9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IE1lKHRoaXMubWFrZVJlcXVlc3QoZSwgdCkpO1xuICB9XG4gIGFzeW5jIG1ha2VSZXF1ZXN0KGUsIHQpIHtcbiAgICB2YXIgZiwgdztcbiAgICBjb25zdCBzID0gYXdhaXQgZTtcbiAgICB0ID09IG51bGwgJiYgKHQgPSBzLm1heFJldHJpZXMgPz8gdGhpcy5tYXhSZXRyaWVzKTtcbiAgICBjb25zdCB7IHJlcTogciwgdXJsOiBpLCB0aW1lb3V0OiBhIH0gPSB0aGlzLmJ1aWxkUmVxdWVzdChzKTtcbiAgICBpZiAoYXdhaXQgdGhpcy5wcmVwYXJlUmVxdWVzdChyLCB7IHVybDogaSwgb3B0aW9uczogcyB9KSwgSyhcInJlcXVlc3RcIiwgaSwgcywgci5oZWFkZXJzKSwgKGYgPSBzLnNpZ25hbCkgIT0gbnVsbCAmJiBmLmFib3J0ZWQpXG4gICAgICB0aHJvdyBuZXcgaigpO1xuICAgIGNvbnN0IG8gPSBuZXcgQWJvcnRDb250cm9sbGVyKCksIGMgPSBhd2FpdCB0aGlzLmZldGNoV2l0aFRpbWVvdXQoaSwgciwgYSwgbykuY2F0Y2goWGUpO1xuICAgIGlmIChjIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmICgodyA9IHMuc2lnbmFsKSAhPSBudWxsICYmIHcuYWJvcnRlZClcbiAgICAgICAgdGhyb3cgbmV3IGooKTtcbiAgICAgIGlmICh0KVxuICAgICAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QocywgdCk7XG4gICAgICB0aHJvdyBjLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiID8gbmV3IFplKCkgOiBuZXcgSWUoeyBjYXVzZTogYyB9KTtcbiAgICB9XG4gICAgY29uc3QgcCA9IHBuKGMuaGVhZGVycyk7XG4gICAgaWYgKCFjLm9rKSB7XG4gICAgICBpZiAodCAmJiB0aGlzLnNob3VsZFJldHJ5KGMpKVxuICAgICAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3QocywgdCwgcCk7XG4gICAgICBjb25zdCB1ID0gYXdhaXQgYy50ZXh0KCkuY2F0Y2goKHkpID0+IFhlKHkpLm1lc3NhZ2UpLCBoID0gX24odSksIGQgPSBoID8gdm9pZCAwIDogdTtcbiAgICAgIHRocm93IEsoXCJyZXNwb25zZVwiLCBjLnN0YXR1cywgaSwgcCwgZCksIHRoaXMubWFrZVN0YXR1c0Vycm9yKGMuc3RhdHVzLCBoLCBkLCBwKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVzcG9uc2U6IGMsIG9wdGlvbnM6IHMsIGNvbnRyb2xsZXI6IG8gfTtcbiAgfVxuICByZXF1ZXN0QVBJTGlzdChlLCB0KSB7XG4gICAgY29uc3QgcyA9IHRoaXMubWFrZVJlcXVlc3QodCwgbnVsbCk7XG4gICAgcmV0dXJuIG5ldyBtbih0aGlzLCBzLCBlKTtcbiAgfVxuICBidWlsZFVSTChlLCB0KSB7XG4gICAgY29uc3QgcyA9IHhuKGUpID8gbmV3IFVSTChlKSA6IG5ldyBVUkwodGhpcy5iYXNlVVJMICsgKHRoaXMuYmFzZVVSTC5lbmRzV2l0aChcIi9cIikgJiYgZS5zdGFydHNXaXRoKFwiL1wiKSA/IGUuc2xpY2UoMSkgOiBlKSksIHIgPSB0aGlzLmRlZmF1bHRRdWVyeSgpO1xuICAgIHJldHVybiBxdChyKSB8fCAodCA9IHsgLi4uciwgLi4udCB9KSwgdCAmJiAocy5zZWFyY2ggPSB0aGlzLnN0cmluZ2lmeVF1ZXJ5KHQpKSwgcy50b1N0cmluZygpO1xuICB9XG4gIHN0cmluZ2lmeVF1ZXJ5KGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZSkuZmlsdGVyKChbdCwgc10pID0+IHR5cGVvZiBzIDwgXCJ1XCIpLm1hcCgoW3QsIHNdKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHMgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcyA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KHQpfT0ke2VuY29kZVVSSUNvbXBvbmVudChzKX1gO1xuICAgICAgaWYgKHMgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQodCl9PWA7XG4gICAgICB0aHJvdyBuZXcgbShgQ2Fubm90IHN0cmluZ2lmeSB0eXBlICR7dHlwZW9mIHN9OyBFeHBlY3RlZCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgbnVsbC4gSWYgeW91IG5lZWQgdG8gcGFzcyBuZXN0ZWQgcXVlcnkgcGFyYW1ldGVycywgeW91IGNhbiBtYW51YWxseSBlbmNvZGUgdGhlbSwgZS5nLiB7IHF1ZXJ5OiB7ICdmb29ba2V5MV0nOiB2YWx1ZTEsICdmb29ba2V5Ml0nOiB2YWx1ZTIgfSB9LCBhbmQgcGxlYXNlIG9wZW4gYSBHaXRIdWIgaXNzdWUgcmVxdWVzdGluZyBiZXR0ZXIgc3VwcG9ydCBmb3IgeW91ciB1c2UgY2FzZS5gKTtcbiAgICB9KS5qb2luKFwiJlwiKTtcbiAgfVxuICBhc3luYyBmZXRjaFdpdGhUaW1lb3V0KGUsIHQsIHMsIHIpIHtcbiAgICBjb25zdCB7IHNpZ25hbDogaSwgLi4uYSB9ID0gdCB8fCB7fTtcbiAgICBpICYmIGkuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHIuYWJvcnQoKSk7XG4gICAgY29uc3QgbyA9IHNldFRpbWVvdXQoKCkgPT4gci5hYm9ydCgpLCBzKTtcbiAgICByZXR1cm4gdGhpcy5nZXRSZXF1ZXN0Q2xpZW50KCkuZmV0Y2guY2FsbCh2b2lkIDAsIGUsIHsgc2lnbmFsOiByLnNpZ25hbCwgLi4uYSB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChvKTtcbiAgICB9KTtcbiAgfVxuICBnZXRSZXF1ZXN0Q2xpZW50KCkge1xuICAgIHJldHVybiB7IGZldGNoOiB0aGlzLmZldGNoIH07XG4gIH1cbiAgc2hvdWxkUmV0cnkoZSkge1xuICAgIGNvbnN0IHQgPSBlLmhlYWRlcnMuZ2V0KFwieC1zaG91bGQtcmV0cnlcIik7XG4gICAgcmV0dXJuIHQgPT09IFwidHJ1ZVwiID8gITAgOiB0ID09PSBcImZhbHNlXCIgPyAhMSA6IGUuc3RhdHVzID09PSA0MDggfHwgZS5zdGF0dXMgPT09IDQwOSB8fCBlLnN0YXR1cyA9PT0gNDI5IHx8IGUuc3RhdHVzID49IDUwMDtcbiAgfVxuICBhc3luYyByZXRyeVJlcXVlc3QoZSwgdCwgcykge1xuICAgIGxldCByO1xuICAgIGNvbnN0IGkgPSBzID09IG51bGwgPyB2b2lkIDAgOiBzW1wicmV0cnktYWZ0ZXJcIl07XG4gICAgaWYgKGkpIHtcbiAgICAgIGNvbnN0IGEgPSBwYXJzZUludChpKTtcbiAgICAgIE51bWJlci5pc05hTihhKSA/IHIgPSBEYXRlLnBhcnNlKGkpIC0gRGF0ZS5ub3coKSA6IHIgPSBhICogMWUzO1xuICAgIH1cbiAgICBpZiAoIXIgfHwgIU51bWJlci5pc0ludGVnZXIocikgfHwgciA8PSAwIHx8IHIgPiA2MCAqIDFlMykge1xuICAgICAgY29uc3QgYSA9IGUubWF4UmV0cmllcyA/PyB0aGlzLm1heFJldHJpZXM7XG4gICAgICByID0gdGhpcy5jYWxjdWxhdGVEZWZhdWx0UmV0cnlUaW1lb3V0TWlsbGlzKHQsIGEpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgSHQociksIHRoaXMubWFrZVJlcXVlc3QoZSwgdCAtIDEpO1xuICB9XG4gIGNhbGN1bGF0ZURlZmF1bHRSZXRyeVRpbWVvdXRNaWxsaXMoZSwgdCkge1xuICAgIGNvbnN0IGkgPSB0IC0gZSwgYSA9IE1hdGgubWluKDAuNSAqIE1hdGgucG93KDIsIGkpLCA4KSwgbyA9IDEgLSBNYXRoLnJhbmRvbSgpICogMC4yNTtcbiAgICByZXR1cm4gYSAqIG8gKiAxZTM7XG4gIH1cbiAgZ2V0VXNlckFnZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9L0pTICR7RH1gO1xuICB9XG59XG5jbGFzcyBVdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMsIHIpIHtcbiAgICBaLnNldCh0aGlzLCB2b2lkIDApLCBobih0aGlzLCBaLCBlLCBcImZcIiksIHRoaXMub3B0aW9ucyA9IHIsIHRoaXMucmVzcG9uc2UgPSB0LCB0aGlzLmJvZHkgPSBzO1xuICB9XG4gIGhhc05leHRQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBhZ2luYXRlZEl0ZW1zKCkubGVuZ3RoID8gdGhpcy5uZXh0UGFnZUluZm8oKSAhPSBudWxsIDogITE7XG4gIH1cbiAgYXN5bmMgZ2V0TmV4dFBhZ2UoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMubmV4dFBhZ2VJbmZvKCk7XG4gICAgaWYgKCFlKVxuICAgICAgdGhyb3cgbmV3IG0oXCJObyBuZXh0IHBhZ2UgZXhwZWN0ZWQ7IHBsZWFzZSBjaGVjayBgLmhhc05leHRQYWdlKClgIGJlZm9yZSBjYWxsaW5nIGAuZ2V0TmV4dFBhZ2UoKWAuXCIpO1xuICAgIGNvbnN0IHQgPSB7IC4uLnRoaXMub3B0aW9ucyB9O1xuICAgIGlmIChcInBhcmFtc1wiIGluIGUpXG4gICAgICB0LnF1ZXJ5ID0geyAuLi50LnF1ZXJ5LCAuLi5lLnBhcmFtcyB9O1xuICAgIGVsc2UgaWYgKFwidXJsXCIgaW4gZSkge1xuICAgICAgY29uc3QgcyA9IFsuLi5PYmplY3QuZW50cmllcyh0LnF1ZXJ5IHx8IHt9KSwgLi4uZS51cmwuc2VhcmNoUGFyYW1zLmVudHJpZXMoKV07XG4gICAgICBmb3IgKGNvbnN0IFtyLCBpXSBvZiBzKVxuICAgICAgICBlLnVybC5zZWFyY2hQYXJhbXMuc2V0KHIsIGkpO1xuICAgICAgdC5xdWVyeSA9IHZvaWQgMCwgdC5wYXRoID0gZS51cmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGRuKHRoaXMsIFosIFwiZlwiKS5yZXF1ZXN0QVBJTGlzdCh0aGlzLmNvbnN0cnVjdG9yLCB0KTtcbiAgfVxuICBhc3luYyAqaXRlclBhZ2VzKCkge1xuICAgIGxldCBlID0gdGhpcztcbiAgICBmb3IgKHlpZWxkIGU7IGUuaGFzTmV4dFBhZ2UoKTsgKVxuICAgICAgZSA9IGF3YWl0IGUuZ2V0TmV4dFBhZ2UoKSwgeWllbGQgZTtcbiAgfVxuICBhc3luYyAqWyhaID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFN5bWJvbC5hc3luY0l0ZXJhdG9yKV0oKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBlIG9mIHRoaXMuaXRlclBhZ2VzKCkpXG4gICAgICBmb3IgKGNvbnN0IHQgb2YgZS5nZXRQYWdpbmF0ZWRJdGVtcygpKVxuICAgICAgICB5aWVsZCB0O1xuICB9XG59XG5jbGFzcyBtbiBleHRlbmRzIE1lIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcykge1xuICAgIHN1cGVyKHQsIGFzeW5jIChyKSA9PiBuZXcgcyhlLCByLnJlc3BvbnNlLCBhd2FpdCBEdChyKSwgci5vcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gICAqXG4gICAqICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBjbGllbnQuaXRlbXMubGlzdCgpKSB7XG4gICAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAgICogICAgfVxuICAgKi9cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXM7XG4gICAgZm9yIGF3YWl0IChjb25zdCB0IG9mIGUpXG4gICAgICB5aWVsZCB0O1xuICB9XG59XG5jb25zdCBwbiA9IChuKSA9PiBuZXcgUHJveHkoT2JqZWN0LmZyb21FbnRyaWVzKFxuICAvLyBAdHMtaWdub3JlXG4gIG4uZW50cmllcygpXG4pLCB7XG4gIGdldChlLCB0KSB7XG4gICAgY29uc3QgcyA9IHQudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gZVtzLnRvTG93ZXJDYXNlKCldIHx8IGVbc107XG4gIH1cbn0pLCBnbiA9IHtcbiAgbWV0aG9kOiAhMCxcbiAgcGF0aDogITAsXG4gIHF1ZXJ5OiAhMCxcbiAgYm9keTogITAsXG4gIGhlYWRlcnM6ICEwLFxuICBtYXhSZXRyaWVzOiAhMCxcbiAgc3RyZWFtOiAhMCxcbiAgdGltZW91dDogITAsXG4gIGh0dHBBZ2VudDogITAsXG4gIHNpZ25hbDogITAsXG4gIGlkZW1wb3RlbmN5S2V5OiAhMCxcbiAgX19iaW5hcnlSZXNwb25zZTogITBcbn0sIEkgPSAobikgPT4gdHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiBuICE9PSBudWxsICYmICFxdChuKSAmJiBPYmplY3Qua2V5cyhuKS5ldmVyeSgoZSkgPT4gUG4oZ24sIGUpKSwgd24gPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgRGVubyA8IFwidVwiICYmIERlbm8uYnVpbGQgIT0gbnVsbClcbiAgICByZXR1cm4ge1xuICAgICAgXCJYLVN0YWlubGVzcy1MYW5nXCI6IFwianNcIixcbiAgICAgIFwiWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uXCI6IEQsXG4gICAgICBcIlgtU3RhaW5sZXNzLU9TXCI6IGd0KERlbm8uYnVpbGQub3MpLFxuICAgICAgXCJYLVN0YWlubGVzcy1BcmNoXCI6IHB0KERlbm8uYnVpbGQuYXJjaCksXG4gICAgICBcIlgtU3RhaW5sZXNzLVJ1bnRpbWVcIjogXCJkZW5vXCIsXG4gICAgICBcIlgtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvblwiOiBEZW5vLnZlcnNpb25cbiAgICB9O1xuICBpZiAodHlwZW9mIEVkZ2VSdW50aW1lIDwgXCJ1XCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIFwiWC1TdGFpbmxlc3MtTGFuZ1wiOiBcImpzXCIsXG4gICAgICBcIlgtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvblwiOiBELFxuICAgICAgXCJYLVN0YWlubGVzcy1PU1wiOiBcIlVua25vd25cIixcbiAgICAgIFwiWC1TdGFpbmxlc3MtQXJjaFwiOiBgb3RoZXI6JHtFZGdlUnVudGltZX1gLFxuICAgICAgXCJYLVN0YWlubGVzcy1SdW50aW1lXCI6IFwiZWRnZVwiLFxuICAgICAgXCJYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb25cIjogcHJvY2Vzcy52ZXJzaW9uXG4gICAgfTtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0eXBlb2YgcHJvY2VzcyA8IFwidVwiID8gcHJvY2VzcyA6IDApID09PSBcIltvYmplY3QgcHJvY2Vzc11cIilcbiAgICByZXR1cm4ge1xuICAgICAgXCJYLVN0YWlubGVzcy1MYW5nXCI6IFwianNcIixcbiAgICAgIFwiWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uXCI6IEQsXG4gICAgICBcIlgtU3RhaW5sZXNzLU9TXCI6IGd0KHByb2Nlc3MucGxhdGZvcm0pLFxuICAgICAgXCJYLVN0YWlubGVzcy1BcmNoXCI6IHB0KHByb2Nlc3MuYXJjaCksXG4gICAgICBcIlgtU3RhaW5sZXNzLVJ1bnRpbWVcIjogXCJub2RlXCIsXG4gICAgICBcIlgtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvblwiOiBwcm9jZXNzLnZlcnNpb25cbiAgICB9O1xuICBjb25zdCBuID0geW4oKTtcbiAgcmV0dXJuIG4gPyB7XG4gICAgXCJYLVN0YWlubGVzcy1MYW5nXCI6IFwianNcIixcbiAgICBcIlgtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvblwiOiBELFxuICAgIFwiWC1TdGFpbmxlc3MtT1NcIjogXCJVbmtub3duXCIsXG4gICAgXCJYLVN0YWlubGVzcy1BcmNoXCI6IFwidW5rbm93blwiLFxuICAgIFwiWC1TdGFpbmxlc3MtUnVudGltZVwiOiBgYnJvd3Nlcjoke24uYnJvd3Nlcn1gLFxuICAgIFwiWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uXCI6IG4udmVyc2lvblxuICB9IDoge1xuICAgIFwiWC1TdGFpbmxlc3MtTGFuZ1wiOiBcImpzXCIsXG4gICAgXCJYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb25cIjogRCxcbiAgICBcIlgtU3RhaW5sZXNzLU9TXCI6IFwiVW5rbm93blwiLFxuICAgIFwiWC1TdGFpbmxlc3MtQXJjaFwiOiBcInVua25vd25cIixcbiAgICBcIlgtU3RhaW5sZXNzLVJ1bnRpbWVcIjogXCJ1bmtub3duXCIsXG4gICAgXCJYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb25cIjogXCJ1bmtub3duXCJcbiAgfTtcbn07XG5mdW5jdGlvbiB5bigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPiBcInVcIiB8fCAhbmF2aWdhdG9yKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBuID0gW1xuICAgIHsga2V5OiBcImVkZ2VcIiwgcGF0dGVybjogL0VkZ2UoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogXCJpZVwiLCBwYXR0ZXJuOiAvTVNJRSg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiBcImllXCIsIHBhdHRlcm46IC9UcmlkZW50KD86LipydlxcOihcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6IFwiY2hyb21lXCIsIHBhdHRlcm46IC9DaHJvbWUoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogXCJmaXJlZm94XCIsIHBhdHRlcm46IC9GaXJlZm94KD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6IFwic2FmYXJpXCIsIHBhdHRlcm46IC8oPzpWZXJzaW9uXFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8oPzpcXFcrTW9iaWxlXFxTKik/XFxXK1NhZmFyaS8gfVxuICBdO1xuICBmb3IgKGNvbnN0IHsga2V5OiBlLCBwYXR0ZXJuOiB0IH0gb2Ygbikge1xuICAgIGNvbnN0IHMgPSB0LmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgaWYgKHMpIHtcbiAgICAgIGNvbnN0IHIgPSBzWzFdIHx8IDAsIGkgPSBzWzJdIHx8IDAsIGEgPSBzWzNdIHx8IDA7XG4gICAgICByZXR1cm4geyBicm93c2VyOiBlLCB2ZXJzaW9uOiBgJHtyfS4ke2l9LiR7YX1gIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgcHQgPSAobikgPT4gbiA9PT0gXCJ4MzJcIiA/IFwieDMyXCIgOiBuID09PSBcIng4Nl82NFwiIHx8IG4gPT09IFwieDY0XCIgPyBcIng2NFwiIDogbiA9PT0gXCJhcm1cIiA/IFwiYXJtXCIgOiBuID09PSBcImFhcmNoNjRcIiB8fCBuID09PSBcImFybTY0XCIgPyBcImFybTY0XCIgOiBuID8gYG90aGVyOiR7bn1gIDogXCJ1bmtub3duXCIsIGd0ID0gKG4pID0+IChuID0gbi50b0xvd2VyQ2FzZSgpLCBuLmluY2x1ZGVzKFwiaW9zXCIpID8gXCJpT1NcIiA6IG4gPT09IFwiYW5kcm9pZFwiID8gXCJBbmRyb2lkXCIgOiBuID09PSBcImRhcndpblwiID8gXCJNYWNPU1wiIDogbiA9PT0gXCJ3aW4zMlwiID8gXCJXaW5kb3dzXCIgOiBuID09PSBcImZyZWVic2RcIiA/IFwiRnJlZUJTRFwiIDogbiA9PT0gXCJvcGVuYnNkXCIgPyBcIk9wZW5CU0RcIiA6IG4gPT09IFwibGludXhcIiA/IFwiTGludXhcIiA6IG4gPyBgT3RoZXI6JHtufWAgOiBcIlVua25vd25cIik7XG5sZXQgd3Q7XG5jb25zdCBibiA9ICgpID0+IHd0ID8/ICh3dCA9IHduKCkpLCBfbiA9IChuKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uobik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybjtcbiAgfVxufSwgQ24gPSBuZXcgUmVnRXhwKFwiXig/OlthLXpdKzopPy8vXCIsIFwiaVwiKSwgeG4gPSAobikgPT4gQ24udGVzdChuKSwgSHQgPSAobikgPT4gbmV3IFByb21pc2UoKGUpID0+IHNldFRpbWVvdXQoZSwgbikpLCBOZSA9IChuLCBlKSA9PiB7XG4gIGlmICh0eXBlb2YgZSAhPSBcIm51bWJlclwiIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGUpKVxuICAgIHRocm93IG5ldyBtKGAke259IG11c3QgYmUgYW4gaW50ZWdlcmApO1xuICBpZiAoZSA8IDApXG4gICAgdGhyb3cgbmV3IG0oYCR7bn0gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgKTtcbiAgcmV0dXJuIGU7XG59LCBYZSA9IChuKSA9PiBuIGluc3RhbmNlb2YgRXJyb3IgPyBuIDogbmV3IEVycm9yKG4pLCB5dCA9IChuKSA9PiB7XG4gIHZhciBlLCB0LCBzO1xuICBpZiAodHlwZW9mIHByb2Nlc3MgPCBcInVcIilcbiAgICByZXR1cm4gKChlID0gcHJvY2Vzcy5lbnYpID09IG51bGwgPyB2b2lkIDAgOiBlW25dKSA/PyB2b2lkIDA7XG4gIGlmICh0eXBlb2YgRGVubyA8IFwidVwiKVxuICAgIHJldHVybiAocyA9ICh0ID0gRGVuby5lbnYpID09IG51bGwgPyB2b2lkIDAgOiB0LmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuY2FsbCh0LCBuKTtcbn07XG5mdW5jdGlvbiBxdChuKSB7XG4gIGlmICghbilcbiAgICByZXR1cm4gITA7XG4gIGZvciAoY29uc3QgZSBpbiBuKVxuICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gUG4obiwgZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIGUpO1xufVxuZnVuY3Rpb24gSyhuLCAuLi5lKSB7XG4gIHR5cGVvZiBwcm9jZXNzIDwgXCJ1XCIgJiYgcHJvY2Vzcy5lbnYuREVCVUcgPT09IFwidHJ1ZVwiICYmIGNvbnNvbGUubG9nKGBPcGVuQUk6REVCVUc6JHtufWAsIC4uLmUpO1xufVxuY29uc3QgUm4gPSAoKSA9PiBcInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZywgKG4pID0+IHtcbiAgY29uc3QgZSA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gIHJldHVybiAobiA9PT0gXCJ4XCIgPyBlIDogZSAmIDMgfCA4KS50b1N0cmluZygxNik7XG59KSwgU24gPSAoKSA9PiAoXG4gIC8vIEB0cy1pZ25vcmVcbiAgdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIC8vIEB0cy1pZ25vcmVcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCA8IFwidVwiICYmIC8vIEB0cy1pZ25vcmVcbiAgdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiXG4pO1xuY2xhc3Mga2UgZXh0ZW5kcyBVdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMsIHIpIHtcbiAgICBzdXBlcihlLCB0LCBzLCByKSwgdGhpcy5kYXRhID0gcy5kYXRhLCB0aGlzLm9iamVjdCA9IHMub2JqZWN0O1xuICB9XG4gIGdldFBhZ2luYXRlZEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbiAgLy8gQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgbmV4dFBhZ2VJbmZvKClgIGluc3RlYWRcbiAgLyoqXG4gICAqIFRoaXMgcGFnZSByZXByZXNlbnRzIGEgcmVzcG9uc2UgdGhhdCBpc24ndCBhY3R1YWxseSBwYWdpbmF0ZWQgYXQgdGhlIEFQSSBsZXZlbFxuICAgKiBzbyB0aGVyZSB3aWxsIG5ldmVyIGJlIGFueSBuZXh0IHBhZ2UgcGFyYW1zLlxuICAgKi9cbiAgbmV4dFBhZ2VQYXJhbXMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbmV4dFBhZ2VJbmZvKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5jbGFzcyBrIGV4dGVuZHMgVXQge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzLCByKSB7XG4gICAgc3VwZXIoZSwgdCwgcywgciksIHRoaXMuZGF0YSA9IHMuZGF0YTtcbiAgfVxuICBnZXRQYWdpbmF0ZWRJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG4gIC8vIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYG5leHRQYWdlSW5mbygpYCBpbnN0ZWFkXG4gIG5leHRQYWdlUGFyYW1zKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm5leHRQYWdlSW5mbygpO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChcInBhcmFtc1wiIGluIGUpXG4gICAgICByZXR1cm4gZS5wYXJhbXM7XG4gICAgY29uc3QgdCA9IE9iamVjdC5mcm9tRW50cmllcyhlLnVybC5zZWFyY2hQYXJhbXMpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0KS5sZW5ndGggPyB0IDogbnVsbDtcbiAgfVxuICBuZXh0UGFnZUluZm8oKSB7XG4gICAgdmFyIHQsIHM7XG4gICAgaWYgKCEoKHQgPSB0aGlzLmRhdGEpICE9IG51bGwgJiYgdC5sZW5ndGgpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgZSA9IChzID0gdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuaWQ7XG4gICAgcmV0dXJuIGUgPyB7IHBhcmFtczogeyBhZnRlcjogZSB9IH0gOiBudWxsO1xuICB9XG59XG5jbGFzcyBnIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuY2xpZW50ID0gZSwgdGhpcy5nZXQgPSBlLmdldC5iaW5kKGUpLCB0aGlzLnBvc3QgPSBlLnBvc3QuYmluZChlKSwgdGhpcy5wYXRjaCA9IGUucGF0Y2guYmluZChlKSwgdGhpcy5wdXQgPSBlLnB1dC5iaW5kKGUpLCB0aGlzLmRlbGV0ZSA9IGUuZGVsZXRlLmJpbmQoZSksIHRoaXMuZ2V0QVBJTGlzdCA9IGUuZ2V0QVBJTGlzdC5iaW5kKGUpO1xuICB9XG59XG5sZXQgb2UgPSBjbGFzcyBleHRlbmRzIGcge1xuICBjcmVhdGUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnBvc3QoXCIvY2hhdC9jb21wbGV0aW9uc1wiLCB7IGJvZHk6IGUsIC4uLnQsIHN0cmVhbTogZS5zdHJlYW0gPz8gITEgfSk7XG4gIH1cbn07XG5vZSB8fCAob2UgPSB7fSk7XG5sZXQgY2UgPSBjbGFzcyBleHRlbmRzIGcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmNvbXBsZXRpb25zID0gbmV3IG9lKHRoaXMuY2xpZW50KTtcbiAgfVxufTtcbihmdW5jdGlvbihuKSB7XG4gIG4uQ29tcGxldGlvbnMgPSBvZTtcbn0pKGNlIHx8IChjZSA9IHt9KSk7XG5jbGFzcyBsZSBleHRlbmRzIGcge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGF1ZGlvIGZyb20gdGhlIGlucHV0IHRleHQuXG4gICAqL1xuICBjcmVhdGUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnBvc3QoXCIvYXVkaW8vc3BlZWNoXCIsIHsgYm9keTogZSwgLi4udCwgX19iaW5hcnlSZXNwb25zZTogITAgfSk7XG4gIH1cbn1cbmxlIHx8IChsZSA9IHt9KTtcbmNsYXNzIHVlIGV4dGVuZHMgZyB7XG4gIC8qKlxuICAgKiBUcmFuc2NyaWJlcyBhdWRpbyBpbnRvIHRoZSBpbnB1dCBsYW5ndWFnZS5cbiAgICovXG4gIGNyZWF0ZShlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMucG9zdChcIi9hdWRpby90cmFuc2NyaXB0aW9uc1wiLCBHKHsgYm9keTogZSwgLi4udCB9KSk7XG4gIH1cbn1cbnVlIHx8ICh1ZSA9IHt9KTtcbmNsYXNzIGhlIGV4dGVuZHMgZyB7XG4gIC8qKlxuICAgKiBUcmFuc2xhdGVzIGF1ZGlvIGludG8gRW5nbGlzaC5cbiAgICovXG4gIGNyZWF0ZShlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMucG9zdChcIi9hdWRpby90cmFuc2xhdGlvbnNcIiwgRyh7IGJvZHk6IGUsIC4uLnQgfSkpO1xuICB9XG59XG5oZSB8fCAoaGUgPSB7fSk7XG5jbGFzcyBkZSBleHRlbmRzIGcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnRyYW5zY3JpcHRpb25zID0gbmV3IHVlKHRoaXMuY2xpZW50KSwgdGhpcy50cmFuc2xhdGlvbnMgPSBuZXcgaGUodGhpcy5jbGllbnQpLCB0aGlzLnNwZWVjaCA9IG5ldyBsZSh0aGlzLmNsaWVudCk7XG4gIH1cbn1cbihmdW5jdGlvbihuKSB7XG4gIG4uVHJhbnNjcmlwdGlvbnMgPSB1ZSwgbi5UcmFuc2xhdGlvbnMgPSBoZSwgbi5TcGVlY2ggPSBsZTtcbn0pKGRlIHx8IChkZSA9IHt9KSk7XG5sZXQgZmUgPSBjbGFzcyBleHRlbmRzIGcge1xuICAvKipcbiAgICogQ3JlYXRlIGFuIGFzc2lzdGFudCBmaWxlIGJ5IGF0dGFjaGluZyBhXG4gICAqIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzKSB0byBhblxuICAgKiBbYXNzaXN0YW50XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2Fzc2lzdGFudHMpLlxuICAgKi9cbiAgY3JlYXRlKGUsIHQsIHMpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KGAvYXNzaXN0YW50cy8ke2V9L2ZpbGVzYCwge1xuICAgICAgYm9keTogdCxcbiAgICAgIC4uLnMsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbiBBc3Npc3RhbnRGaWxlLlxuICAgKi9cbiAgcmV0cmlldmUoZSwgdCwgcykge1xuICAgIHJldHVybiB0aGlzLmdldChgL2Fzc2lzdGFudHMvJHtlfS9maWxlcy8ke3R9YCwge1xuICAgICAgLi4ucyxcbiAgICAgIGhlYWRlcnM6IHsgXCJPcGVuQUktQmV0YVwiOiBcImFzc2lzdGFudHM9djFcIiwgLi4ucyA9PSBudWxsID8gdm9pZCAwIDogcy5oZWFkZXJzIH1cbiAgICB9KTtcbiAgfVxuICBsaXN0KGUsIHQgPSB7fSwgcykge1xuICAgIHJldHVybiBJKHQpID8gdGhpcy5saXN0KGUsIHt9LCB0KSA6IHRoaXMuZ2V0QVBJTGlzdChgL2Fzc2lzdGFudHMvJHtlfS9maWxlc2AsIGV0LCB7XG4gICAgICBxdWVyeTogdCxcbiAgICAgIC4uLnMsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBhc3Npc3RhbnQgZmlsZS5cbiAgICovXG4gIGRlbChlLCB0LCBzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsZXRlKGAvYXNzaXN0YW50cy8ke2V9L2ZpbGVzLyR7dH1gLCB7XG4gICAgICAuLi5zLFxuICAgICAgaGVhZGVyczogeyBcIk9wZW5BSS1CZXRhXCI6IFwiYXNzaXN0YW50cz12MVwiLCAuLi5zID09IG51bGwgPyB2b2lkIDAgOiBzLmhlYWRlcnMgfVxuICAgIH0pO1xuICB9XG59O1xuY2xhc3MgZXQgZXh0ZW5kcyBrIHtcbn1cbihmdW5jdGlvbihuKSB7XG4gIG4uQXNzaXN0YW50RmlsZXNQYWdlID0gZXQ7XG59KShmZSB8fCAoZmUgPSB7fSkpO1xuY2xhc3MgbWUgZXh0ZW5kcyBnIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5maWxlcyA9IG5ldyBmZSh0aGlzLmNsaWVudCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhc3Npc3RhbnQgd2l0aCBhIG1vZGVsIGFuZCBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBjcmVhdGUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnBvc3QoXCIvYXNzaXN0YW50c1wiLCB7XG4gICAgICBib2R5OiBlLFxuICAgICAgLi4udCxcbiAgICAgIGhlYWRlcnM6IHsgXCJPcGVuQUktQmV0YVwiOiBcImFzc2lzdGFudHM9djFcIiwgLi4udCA9PSBudWxsID8gdm9pZCAwIDogdC5oZWFkZXJzIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGFuIGFzc2lzdGFudC5cbiAgICovXG4gIHJldHJpZXZlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9hc3Npc3RhbnRzLyR7ZX1gLCB7XG4gICAgICAuLi50LFxuICAgICAgaGVhZGVyczogeyBcIk9wZW5BSS1CZXRhXCI6IFwiYXNzaXN0YW50cz12MVwiLCAuLi50ID09IG51bGwgPyB2b2lkIDAgOiB0LmhlYWRlcnMgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNb2RpZmllcyBhbiBhc3Npc3RhbnQuXG4gICAqL1xuICB1cGRhdGUoZSwgdCwgcykge1xuICAgIHJldHVybiB0aGlzLnBvc3QoYC9hc3Npc3RhbnRzLyR7ZX1gLCB7XG4gICAgICBib2R5OiB0LFxuICAgICAgLi4ucyxcbiAgICAgIGhlYWRlcnM6IHsgXCJPcGVuQUktQmV0YVwiOiBcImFzc2lzdGFudHM9djFcIiwgLi4ucyA9PSBudWxsID8gdm9pZCAwIDogcy5oZWFkZXJzIH1cbiAgICB9KTtcbiAgfVxuICBsaXN0KGUgPSB7fSwgdCkge1xuICAgIHJldHVybiBJKGUpID8gdGhpcy5saXN0KHt9LCBlKSA6IHRoaXMuZ2V0QVBJTGlzdChcIi9hc3Npc3RhbnRzXCIsIHR0LCB7XG4gICAgICBxdWVyeTogZSxcbiAgICAgIC4uLnQsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBhc3Npc3RhbnQuXG4gICAqL1xuICBkZWwoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmRlbGV0ZShgL2Fzc2lzdGFudHMvJHtlfWAsIHtcbiAgICAgIC4uLnQsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIHR0IGV4dGVuZHMgayB7XG59XG4oZnVuY3Rpb24obikge1xuICBuLkFzc2lzdGFudHNQYWdlID0gdHQsIG4uRmlsZXMgPSBmZSwgbi5Bc3Npc3RhbnRGaWxlc1BhZ2UgPSBldDtcbn0pKG1lIHx8IChtZSA9IHt9KSk7XG5mdW5jdGlvbiBidChuKSB7XG4gIHJldHVybiB0eXBlb2Ygbi5wYXJzZSA9PSBcImZ1bmN0aW9uXCI7XG59XG5jb25zdCB6ID0gKG4pID0+IChuID09IG51bGwgPyB2b2lkIDAgOiBuLnJvbGUpID09PSBcImFzc2lzdGFudFwiLCBXdCA9IChuKSA9PiAobiA9PSBudWxsID8gdm9pZCAwIDogbi5yb2xlKSA9PT0gXCJmdW5jdGlvblwiLCBBbiA9IChuKSA9PiAobiA9PSBudWxsID8gdm9pZCAwIDogbi5yb2xlKSA9PT0gXCJ0b29sXCI7XG52YXIgRSA9IGdsb2JhbFRoaXMgJiYgZ2xvYmFsVGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IHx8IGZ1bmN0aW9uKG4sIGUsIHQsIHMsIHIpIHtcbiAgaWYgKHMgPT09IFwibVwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChzID09PSBcImFcIiAmJiAhcilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gbiAhPT0gZSB8fCAhciA6ICFlLmhhcyhuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBzID09PSBcImFcIiA/IHIuY2FsbChuLCB0KSA6IHIgPyByLnZhbHVlID0gdCA6IGUuc2V0KG4sIHQpLCB0O1xufSwgbCA9IGdsb2JhbFRoaXMgJiYgZ2xvYmFsVGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IHx8IGZ1bmN0aW9uKG4sIGUsIHQsIHMpIHtcbiAgaWYgKHQgPT09IFwiYVwiICYmICFzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBuICE9PSBlIHx8ICFzIDogIWUuaGFzKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiB0ID09PSBcIm1cIiA/IHMgOiB0ID09PSBcImFcIiA/IHMuY2FsbChuKSA6IHMgPyBzLnZhbHVlIDogZS5nZXQobik7XG59LCB4LCBuZSwgc2UsIHEsIFcsIHJlLCBYLCBNLCBWLCBpZSwgYWUsIFUsIFZlLCBKZSwgS2UsIEdlLCB6ZSwgUWUsIFh0LCBZZTtcbmNvbnN0IF90ID0gMTA7XG5jbGFzcyBWdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHguYWRkKHRoaXMpLCB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCksIG5lLnNldCh0aGlzLCB2b2lkIDApLCBzZS5zZXQodGhpcywgKCkgPT4ge1xuICAgIH0pLCBxLnNldCh0aGlzLCAoKSA9PiB7XG4gICAgfSksIFcuc2V0KHRoaXMsIHZvaWQgMCksIHJlLnNldCh0aGlzLCAoKSA9PiB7XG4gICAgfSksIFguc2V0KHRoaXMsICgpID0+IHtcbiAgICB9KSwgTS5zZXQodGhpcywge30pLCB0aGlzLl9jaGF0Q29tcGxldGlvbnMgPSBbXSwgdGhpcy5tZXNzYWdlcyA9IFtdLCBWLnNldCh0aGlzLCAhMSksIGllLnNldCh0aGlzLCAhMSksIGFlLnNldCh0aGlzLCAhMSksIFUuc2V0KHRoaXMsICExKSwgUWUuc2V0KHRoaXMsIChlKSA9PiB7XG4gICAgICBpZiAoRSh0aGlzLCBpZSwgITAsIFwiZlwiKSwgZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgJiYgKGUgPSBuZXcgaigpKSwgZSBpbnN0YW5jZW9mIGopXG4gICAgICAgIHJldHVybiBFKHRoaXMsIGFlLCAhMCwgXCJmXCIpLCB0aGlzLl9lbWl0KFwiYWJvcnRcIiwgZSk7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIG0pXG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGNvbnN0IHQgPSBuZXcgbShlLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdC5jYXVzZSA9IGUsIHRoaXMuX2VtaXQoXCJlcnJvclwiLCB0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9lbWl0KFwiZXJyb3JcIiwgbmV3IG0oU3RyaW5nKGUpKSk7XG4gICAgfSksIEUodGhpcywgbmUsIG5ldyBQcm9taXNlKChlLCB0KSA9PiB7XG4gICAgICBFKHRoaXMsIHNlLCBlLCBcImZcIiksIEUodGhpcywgcSwgdCwgXCJmXCIpO1xuICAgIH0pLCBcImZcIiksIEUodGhpcywgVywgbmV3IFByb21pc2UoKGUsIHQpID0+IHtcbiAgICAgIEUodGhpcywgcmUsIGUsIFwiZlwiKSwgRSh0aGlzLCBYLCB0LCBcImZcIik7XG4gICAgfSksIFwiZlwiKSwgbCh0aGlzLCBuZSwgXCJmXCIpLmNhdGNoKCgpID0+IHtcbiAgICB9KSwgbCh0aGlzLCBXLCBcImZcIikuY2F0Y2goKCkgPT4ge1xuICAgIH0pO1xuICB9XG4gIF9ydW4oZSkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbWl0RmluYWwoKSwgdGhpcy5fZW1pdChcImVuZFwiKTtcbiAgICAgIH0sIGwodGhpcywgUWUsIFwiZlwiKSk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX2FkZENoYXRDb21wbGV0aW9uKGUpIHtcbiAgICB2YXIgcztcbiAgICB0aGlzLl9jaGF0Q29tcGxldGlvbnMucHVzaChlKSwgdGhpcy5fZW1pdChcImNoYXRDb21wbGV0aW9uXCIsIGUpO1xuICAgIGNvbnN0IHQgPSAocyA9IGUuY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHMubWVzc2FnZTtcbiAgICByZXR1cm4gdCAmJiB0aGlzLl9hZGRNZXNzYWdlKHQpLCBlO1xuICB9XG4gIF9hZGRNZXNzYWdlKGUsIHQgPSAhMCkge1xuICAgIGlmICh0aGlzLm1lc3NhZ2VzLnB1c2goZSksIHQpIHtcbiAgICAgIGlmICh0aGlzLl9lbWl0KFwibWVzc2FnZVwiLCBlKSwgKFd0KGUpIHx8IEFuKGUpKSAmJiBlLmNvbnRlbnQpXG4gICAgICAgIHRoaXMuX2VtaXQoXCJmdW5jdGlvbkNhbGxSZXN1bHRcIiwgZS5jb250ZW50KTtcbiAgICAgIGVsc2UgaWYgKHooZSkgJiYgZS5mdW5jdGlvbl9jYWxsKVxuICAgICAgICB0aGlzLl9lbWl0KFwiZnVuY3Rpb25DYWxsXCIsIGUuZnVuY3Rpb25fY2FsbCk7XG4gICAgICBlbHNlIGlmICh6KGUpICYmIGUudG9vbF9jYWxscylcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIGUudG9vbF9jYWxscylcbiAgICAgICAgICBzLnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0aGlzLl9lbWl0KFwiZnVuY3Rpb25DYWxsXCIsIHMuZnVuY3Rpb24pO1xuICAgIH1cbiAgfVxuICBfY29ubmVjdGVkKCkge1xuICAgIHRoaXMuZW5kZWQgfHwgKGwodGhpcywgc2UsIFwiZlwiKS5jYWxsKHRoaXMpLCB0aGlzLl9lbWl0KFwiY29ubmVjdFwiKSk7XG4gIH1cbiAgZ2V0IGVuZGVkKCkge1xuICAgIHJldHVybiBsKHRoaXMsIFYsIFwiZlwiKTtcbiAgfVxuICBnZXQgZXJyb3JlZCgpIHtcbiAgICByZXR1cm4gbCh0aGlzLCBpZSwgXCJmXCIpO1xuICB9XG4gIGdldCBhYm9ydGVkKCkge1xuICAgIHJldHVybiBsKHRoaXMsIGFlLCBcImZcIik7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIGV2ZW50LlxuICAgKiBObyBjaGVja3MgYXJlIG1hZGUgdG8gc2VlIGlmIHRoZSBsaXN0ZW5lciBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkLiBNdWx0aXBsZSBjYWxscyBwYXNzaW5nXG4gICAqIHRoZSBzYW1lIGNvbWJpbmF0aW9uIG9mIGV2ZW50IGFuZCBsaXN0ZW5lciB3aWxsIHJlc3VsdCBpbiB0aGUgbGlzdGVuZXIgYmVpbmcgYWRkZWQsIGFuZFxuICAgKiBjYWxsZWQsIG11bHRpcGxlIHRpbWVzLlxuICAgKiBAcmV0dXJucyB0aGlzIENoYXRDb21wbGV0aW9uU3RyZWFtLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkXG4gICAqL1xuICBvbihlLCB0KSB7XG4gICAgcmV0dXJuIChsKHRoaXMsIE0sIFwiZlwiKVtlXSB8fCAobCh0aGlzLCBNLCBcImZcIilbZV0gPSBbXSkpLnB1c2goeyBsaXN0ZW5lcjogdCB9KSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIGZyb20gdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgZXZlbnQuXG4gICAqIG9mZigpIHdpbGwgcmVtb3ZlLCBhdCBtb3N0LCBvbmUgaW5zdGFuY2Ugb2YgYSBsaXN0ZW5lciBmcm9tIHRoZSBsaXN0ZW5lciBhcnJheS4gSWYgYW55IHNpbmdsZVxuICAgKiBsaXN0ZW5lciBoYXMgYmVlbiBhZGRlZCBtdWx0aXBsZSB0aW1lcyB0byB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQsIHRoZW5cbiAgICogb2ZmKCkgbXVzdCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcmVtb3ZlIGVhY2ggaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHRoaXMgQ2hhdENvbXBsZXRpb25TdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICovXG4gIG9mZihlLCB0KSB7XG4gICAgY29uc3QgcyA9IGwodGhpcywgTSwgXCJmXCIpW2VdO1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHIgPSBzLmZpbmRJbmRleCgoaSkgPT4gaS5saXN0ZW5lciA9PT0gdCk7XG4gICAgcmV0dXJuIHIgPj0gMCAmJiBzLnNwbGljZShyLCAxKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG9uZS10aW1lIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciB0aGUgZXZlbnQuIFRoZSBuZXh0IHRpbWUgdGhlIGV2ZW50IGlzIHRyaWdnZXJlZCxcbiAgICogdGhpcyBsaXN0ZW5lciBpcyByZW1vdmVkIGFuZCB0aGVuIGludm9rZWQuXG4gICAqIEByZXR1cm5zIHRoaXMgQ2hhdENvbXBsZXRpb25TdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICovXG4gIG9uY2UoZSwgdCkge1xuICAgIHJldHVybiAobCh0aGlzLCBNLCBcImZcIilbZV0gfHwgKGwodGhpcywgTSwgXCJmXCIpW2VdID0gW10pKS5wdXNoKHsgbGlzdGVuZXI6IHQsIG9uY2U6ICEwIH0pLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGlzIHNpbWlsYXIgdG8gYC5vbmNlKClgLCBidXQgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0aGUgbmV4dCB0aW1lXG4gICAqIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQsIGluc3RlYWQgb2YgY2FsbGluZyBhIGxpc3RlbmVyIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0aGUgbmV4dCB0aW1lIGdpdmVuIGV2ZW50IGlzIHRyaWdnZXJlZCxcbiAgICogb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBpcyBlbWl0dGVkLiAgKElmIHlvdSByZXF1ZXN0IHRoZSAnZXJyb3InIGV2ZW50LFxuICAgKiByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGVycm9yKS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICBjb25zdCBtZXNzYWdlID0gYXdhaXQgc3RyZWFtLmVtaXR0ZWQoJ21lc3NhZ2UnKSAvLyByZWplY3RzIGlmIHRoZSBzdHJlYW0gZXJyb3JzXG4gICAqL1xuICBlbWl0dGVkKGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHQsIHMpID0+IHtcbiAgICAgIEUodGhpcywgVSwgITAsIFwiZlwiKSwgZSAhPT0gXCJlcnJvclwiICYmIHRoaXMub25jZShcImVycm9yXCIsIHMpLCB0aGlzLm9uY2UoZSwgdCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZG9uZSgpIHtcbiAgICBFKHRoaXMsIFUsICEwLCBcImZcIiksIGF3YWl0IGwodGhpcywgVywgXCJmXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBmaW5hbCBDaGF0Q29tcGxldGlvbiwgb3IgcmVqZWN0c1xuICAgKiBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciB0aGUgc3RyZWFtIGVuZGVkIHByZW1hdHVyZWx5IHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb24uXG4gICAqL1xuICBhc3luYyBmaW5hbENoYXRDb21wbGV0aW9uKCkge1xuICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jaGF0Q29tcGxldGlvbnNbdGhpcy5fY2hhdENvbXBsZXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIGlmICghZSlcbiAgICAgIHRocm93IG5ldyBtKFwic3RyZWFtIGVuZGVkIHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb25cIik7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlIGZpbmFsIENoYXRDb21wbGV0aW9uTWVzc2FnZSwgb3IgcmVqZWN0c1xuICAgKiBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciB0aGUgc3RyZWFtIGVuZGVkIHByZW1hdHVyZWx5IHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb25NZXNzYWdlLlxuICAgKi9cbiAgYXN5bmMgZmluYWxDb250ZW50KCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRvbmUoKSwgbCh0aGlzLCB4LCBcIm1cIiwgVmUpLmNhbGwodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHRoZSBmaW5hbCBhc3Npc3RhbnQgQ2hhdENvbXBsZXRpb25NZXNzYWdlIHJlc3BvbnNlLFxuICAgKiBvciByZWplY3RzIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBmaW5hbE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZG9uZSgpLCBsKHRoaXMsIHgsIFwibVwiLCBKZSkuY2FsbCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY29udGVudCBvZiB0aGUgZmluYWwgRnVuY3Rpb25DYWxsLCBvciByZWplY3RzXG4gICAqIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBmaW5hbEZ1bmN0aW9uQ2FsbCgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kb25lKCksIGwodGhpcywgeCwgXCJtXCIsIEtlKS5jYWxsKHRoaXMpO1xuICB9XG4gIGFzeW5jIGZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0KCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRvbmUoKSwgbCh0aGlzLCB4LCBcIm1cIiwgR2UpLmNhbGwodGhpcyk7XG4gIH1cbiAgYXN5bmMgdG90YWxVc2FnZSgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kb25lKCksIGwodGhpcywgeCwgXCJtXCIsIHplKS5jYWxsKHRoaXMpO1xuICB9XG4gIGFsbENoYXRDb21wbGV0aW9ucygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX2NoYXRDb21wbGV0aW9uc107XG4gIH1cbiAgX2VtaXQoZSwgLi4udCkge1xuICAgIGlmIChsKHRoaXMsIFYsIFwiZlwiKSlcbiAgICAgIHJldHVybjtcbiAgICBlID09PSBcImVuZFwiICYmIChFKHRoaXMsIFYsICEwLCBcImZcIiksIGwodGhpcywgcmUsIFwiZlwiKS5jYWxsKHRoaXMpKTtcbiAgICBjb25zdCBzID0gbCh0aGlzLCBNLCBcImZcIilbZV07XG4gICAgaWYgKHMgJiYgKGwodGhpcywgTSwgXCJmXCIpW2VdID0gcy5maWx0ZXIoKHIpID0+ICFyLm9uY2UpLCBzLmZvckVhY2goKHsgbGlzdGVuZXI6IHIgfSkgPT4gciguLi50KSkpLCBlID09PSBcImFib3J0XCIpIHtcbiAgICAgIGNvbnN0IHIgPSB0WzBdO1xuICAgICAgIWwodGhpcywgVSwgXCJmXCIpICYmICEocyAhPSBudWxsICYmIHMubGVuZ3RoKSAmJiBQcm9taXNlLnJlamVjdChyKSwgbCh0aGlzLCBxLCBcImZcIikuY2FsbCh0aGlzLCByKSwgbCh0aGlzLCBYLCBcImZcIikuY2FsbCh0aGlzLCByKSwgdGhpcy5fZW1pdChcImVuZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgY29uc3QgciA9IHRbMF07XG4gICAgICAhbCh0aGlzLCBVLCBcImZcIikgJiYgIShzICE9IG51bGwgJiYgcy5sZW5ndGgpICYmIFByb21pc2UucmVqZWN0KHIpLCBsKHRoaXMsIHEsIFwiZlwiKS5jYWxsKHRoaXMsIHIpLCBsKHRoaXMsIFgsIFwiZlwiKS5jYWxsKHRoaXMsIHIpLCB0aGlzLl9lbWl0KFwiZW5kXCIpO1xuICAgIH1cbiAgfVxuICBfZW1pdEZpbmFsKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jaGF0Q29tcGxldGlvbnNbdGhpcy5fY2hhdENvbXBsZXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIGUgJiYgdGhpcy5fZW1pdChcImZpbmFsQ2hhdENvbXBsZXRpb25cIiwgZSk7XG4gICAgY29uc3QgdCA9IHRoaXMubWVzc2FnZXNbdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICB0ICYmIHRoaXMuX2VtaXQoXCJmaW5hbE1lc3NhZ2VcIiwgdCk7XG4gICAgY29uc3QgcyA9IGwodGhpcywgeCwgXCJtXCIsIFZlKS5jYWxsKHRoaXMpO1xuICAgIHMgJiYgdGhpcy5fZW1pdChcImZpbmFsQ29udGVudFwiLCBzKTtcbiAgICBjb25zdCByID0gbCh0aGlzLCB4LCBcIm1cIiwgS2UpLmNhbGwodGhpcyk7XG4gICAgciAmJiB0aGlzLl9lbWl0KFwiZmluYWxGdW5jdGlvbkNhbGxcIiwgcik7XG4gICAgY29uc3QgaSA9IGwodGhpcywgeCwgXCJtXCIsIEdlKS5jYWxsKHRoaXMpO1xuICAgIGkgIT0gbnVsbCAmJiB0aGlzLl9lbWl0KFwiZmluYWxGdW5jdGlvbkNhbGxSZXN1bHRcIiwgaSksIHRoaXMuX2NoYXRDb21wbGV0aW9ucy5zb21lKChhKSA9PiBhLnVzYWdlKSAmJiB0aGlzLl9lbWl0KFwidG90YWxVc2FnZVwiLCBsKHRoaXMsIHgsIFwibVwiLCB6ZSkuY2FsbCh0aGlzKSk7XG4gIH1cbiAgYXN5bmMgX2NyZWF0ZUNoYXRDb21wbGV0aW9uKGUsIHQsIHMpIHtcbiAgICBjb25zdCByID0gcyA9PSBudWxsID8gdm9pZCAwIDogcy5zaWduYWw7XG4gICAgciAmJiAoci5hYm9ydGVkICYmIHRoaXMuY29udHJvbGxlci5hYm9ydCgpLCByLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSkpLCBsKHRoaXMsIHgsIFwibVwiLCBYdCkuY2FsbCh0aGlzLCB0KTtcbiAgICBjb25zdCBpID0gYXdhaXQgZS5jcmVhdGUoeyAuLi50LCBzdHJlYW06ICExIH0sIHsgLi4ucywgc2lnbmFsOiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWQoKSwgdGhpcy5fYWRkQ2hhdENvbXBsZXRpb24oaSk7XG4gIH1cbiAgYXN5bmMgX3J1bkNoYXRDb21wbGV0aW9uKGUsIHQsIHMpIHtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdC5tZXNzYWdlcylcbiAgICAgIHRoaXMuX2FkZE1lc3NhZ2UociwgITEpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9jcmVhdGVDaGF0Q29tcGxldGlvbihlLCB0LCBzKTtcbiAgfVxuICBhc3luYyBfcnVuRnVuY3Rpb25zKGUsIHQsIHMpIHtcbiAgICB2YXIgdTtcbiAgICBjb25zdCByID0gXCJmdW5jdGlvblwiLCB7IGZ1bmN0aW9uX2NhbGw6IGkgPSBcImF1dG9cIiwgc3RyZWFtOiBhLCAuLi5vIH0gPSB0LCBjID0gdHlwZW9mIGkgIT0gXCJzdHJpbmdcIiAmJiAoaSA9PSBudWxsID8gdm9pZCAwIDogaS5uYW1lKSwgeyBtYXhDaGF0Q29tcGxldGlvbnM6IHAgPSBfdCB9ID0gcyB8fCB7fSwgZiA9IHt9O1xuICAgIGZvciAoY29uc3QgaCBvZiB0LmZ1bmN0aW9ucylcbiAgICAgIGZbaC5uYW1lIHx8IGguZnVuY3Rpb24ubmFtZV0gPSBoO1xuICAgIGNvbnN0IHcgPSB0LmZ1bmN0aW9ucy5tYXAoKGgpID0+ICh7XG4gICAgICBuYW1lOiBoLm5hbWUgfHwgaC5mdW5jdGlvbi5uYW1lLFxuICAgICAgcGFyYW1ldGVyczogaC5wYXJhbWV0ZXJzLFxuICAgICAgZGVzY3JpcHRpb246IGguZGVzY3JpcHRpb25cbiAgICB9KSk7XG4gICAgZm9yIChjb25zdCBoIG9mIHQubWVzc2FnZXMpXG4gICAgICB0aGlzLl9hZGRNZXNzYWdlKGgsICExKTtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IHA7ICsraCkge1xuICAgICAgY29uc3QgUCA9ICh1ID0gKGF3YWl0IHRoaXMuX2NyZWF0ZUNoYXRDb21wbGV0aW9uKGUsIHtcbiAgICAgICAgLi4ubyxcbiAgICAgICAgZnVuY3Rpb25fY2FsbDogaSxcbiAgICAgICAgZnVuY3Rpb25zOiB3LFxuICAgICAgICBtZXNzYWdlczogWy4uLnRoaXMubWVzc2FnZXNdXG4gICAgICB9LCBzKSkuY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHUubWVzc2FnZTtcbiAgICAgIGlmICghUClcbiAgICAgICAgdGhyb3cgbmV3IG0oXCJtaXNzaW5nIG1lc3NhZ2UgaW4gQ2hhdENvbXBsZXRpb24gcmVzcG9uc2VcIik7XG4gICAgICBpZiAoIVAuZnVuY3Rpb25fY2FsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgeyBuYW1lOiB5LCBhcmd1bWVudHM6IEEgfSA9IFAuZnVuY3Rpb25fY2FsbCwgQyA9IGZbeV07XG4gICAgICBpZiAoQykge1xuICAgICAgICBpZiAoYyAmJiBjICE9PSB5KSB7XG4gICAgICAgICAgY29uc3QgdiA9IGBJbnZhbGlkIGZ1bmN0aW9uX2NhbGw6ICR7SlNPTi5zdHJpbmdpZnkoeSl9LiAke0pTT04uc3RyaW5naWZ5KGMpfSByZXF1ZXN0ZWQuIFBsZWFzZSB0cnkgYWdhaW5gO1xuICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlOiByLCBuYW1lOiB5LCBjb250ZW50OiB2IH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2ID0gYEludmFsaWQgZnVuY3Rpb25fY2FsbDogJHtKU09OLnN0cmluZ2lmeSh5KX0uIEF2YWlsYWJsZSBvcHRpb25zIGFyZTogJHt3Lm1hcCgoT2UpID0+IEpTT04uc3RyaW5naWZ5KE9lLm5hbWUpKS5qb2luKFwiLCBcIil9LiBQbGVhc2UgdHJ5IGFnYWluYDtcbiAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGU6IHIsIG5hbWU6IHksIGNvbnRlbnQ6IHYgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IFQ7XG4gICAgICB0cnkge1xuICAgICAgICBUID0gYnQoQykgPyBhd2FpdCBDLnBhcnNlKEEpIDogQTtcbiAgICAgIH0gY2F0Y2ggKHYpIHtcbiAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7XG4gICAgICAgICAgcm9sZTogcixcbiAgICAgICAgICBuYW1lOiB5LFxuICAgICAgICAgIGNvbnRlbnQ6IHYgaW5zdGFuY2VvZiBFcnJvciA/IHYubWVzc2FnZSA6IFN0cmluZyh2KVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBSID0gYXdhaXQgQy5mdW5jdGlvbihULCB0aGlzKSwgUyA9IGwodGhpcywgeCwgXCJtXCIsIFllKS5jYWxsKHRoaXMsIFIpO1xuICAgICAgaWYgKHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlOiByLCBuYW1lOiB5LCBjb250ZW50OiBTIH0pLCBjKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGFzeW5jIF9ydW5Ub29scyhlLCB0LCBzKSB7XG4gICAgdmFyIHUsIGg7XG4gICAgY29uc3QgciA9IFwidG9vbFwiLCB7IHRvb2xfY2hvaWNlOiBpID0gXCJhdXRvXCIsIHN0cmVhbTogYSwgLi4ubyB9ID0gdCwgYyA9IHR5cGVvZiBpICE9IFwic3RyaW5nXCIgJiYgKCh1ID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IHUubmFtZSksIHsgbWF4Q2hhdENvbXBsZXRpb25zOiBwID0gX3QgfSA9IHMgfHwge30sIGYgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGQgb2YgdC50b29scylcbiAgICAgIGQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIChmW2QuZnVuY3Rpb24ubmFtZSB8fCBkLmZ1bmN0aW9uLmZ1bmN0aW9uLm5hbWVdID0gZC5mdW5jdGlvbik7XG4gICAgY29uc3QgdyA9IFwidG9vbHNcIiBpbiB0ID8gdC50b29scy5tYXAoKGQpID0+IGQudHlwZSA9PT0gXCJmdW5jdGlvblwiID8ge1xuICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgbmFtZTogZC5mdW5jdGlvbi5uYW1lIHx8IGQuZnVuY3Rpb24uZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgcGFyYW1ldGVyczogZC5mdW5jdGlvbi5wYXJhbWV0ZXJzLFxuICAgICAgICBkZXNjcmlwdGlvbjogZC5mdW5jdGlvbi5kZXNjcmlwdGlvblxuICAgICAgfVxuICAgIH0gOiBkKSA6IHZvaWQgMDtcbiAgICBmb3IgKGNvbnN0IGQgb2YgdC5tZXNzYWdlcylcbiAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoZCwgITEpO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgcDsgKytkKSB7XG4gICAgICBjb25zdCB5ID0gKGggPSAoYXdhaXQgdGhpcy5fY3JlYXRlQ2hhdENvbXBsZXRpb24oZSwge1xuICAgICAgICAuLi5vLFxuICAgICAgICB0b29sX2Nob2ljZTogaSxcbiAgICAgICAgdG9vbHM6IHcsXG4gICAgICAgIG1lc3NhZ2VzOiBbLi4udGhpcy5tZXNzYWdlc11cbiAgICAgIH0sIHMpKS5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogaC5tZXNzYWdlO1xuICAgICAgaWYgKCF5KVxuICAgICAgICB0aHJvdyBuZXcgbShcIm1pc3NpbmcgbWVzc2FnZSBpbiBDaGF0Q29tcGxldGlvbiByZXNwb25zZVwiKTtcbiAgICAgIGlmICgheS50b29sX2NhbGxzKVxuICAgICAgICByZXR1cm47XG4gICAgICBmb3IgKGNvbnN0IEEgb2YgeS50b29sX2NhbGxzKSB7XG4gICAgICAgIGlmIChBLnR5cGUgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgQyA9IEEuaWQsIHsgbmFtZTogVCwgYXJndW1lbnRzOiBSIH0gPSBBLmZ1bmN0aW9uLCBTID0gZltUXTtcbiAgICAgICAgaWYgKFMpIHtcbiAgICAgICAgICBpZiAoYyAmJiBjICE9PSBUKSB7XG4gICAgICAgICAgICBjb25zdCBCID0gYEludmFsaWQgdG9vbF9jYWxsOiAke0pTT04uc3RyaW5naWZ5KFQpfS4gJHtKU09OLnN0cmluZ2lmeShjKX0gcmVxdWVzdGVkLiBQbGVhc2UgdHJ5IGFnYWluYDtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlOiByLCB0b29sX2NhbGxfaWQ6IEMsIGNvbnRlbnQ6IEIgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgQiA9IGBJbnZhbGlkIHRvb2xfY2FsbDogJHtKU09OLnN0cmluZ2lmeShUKX0uIEF2YWlsYWJsZSBvcHRpb25zIGFyZTogJHt3Lm1hcCgoTGUpID0+IEpTT04uc3RyaW5naWZ5KExlLmZ1bmN0aW9uLm5hbWUpKS5qb2luKFwiLCBcIil9LiBQbGVhc2UgdHJ5IGFnYWluYDtcbiAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZTogciwgdG9vbF9jYWxsX2lkOiBDLCBjb250ZW50OiBCIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHYgPSBidChTKSA/IGF3YWl0IFMucGFyc2UoUikgOiBSO1xuICAgICAgICB9IGNhdGNoIChCKSB7XG4gICAgICAgICAgY29uc3QgTGUgPSBCIGluc3RhbmNlb2YgRXJyb3IgPyBCLm1lc3NhZ2UgOiBTdHJpbmcoQik7XG4gICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGU6IHIsIHRvb2xfY2FsbF9pZDogQywgY29udGVudDogTGUgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgT2UgPSBhd2FpdCBTLmZ1bmN0aW9uKHYsIHRoaXMpLCBHdCA9IGwodGhpcywgeCwgXCJtXCIsIFllKS5jYWxsKHRoaXMsIE9lKTtcbiAgICAgICAgaWYgKHRoaXMuX2FkZE1lc3NhZ2UoeyByb2xlOiByLCB0b29sX2NhbGxfaWQ6IEMsIGNvbnRlbnQ6IEd0IH0pLCBjKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbm5lID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIHNlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIHEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCByZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBYID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIE0gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBpZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBhZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBVID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFFlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIHggPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSwgVmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGwodGhpcywgeCwgXCJtXCIsIEplKS5jYWxsKHRoaXMpLmNvbnRlbnQ7XG59LCBKZSA9IGZ1bmN0aW9uKCkge1xuICBsZXQgZSA9IHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuICBmb3IgKDsgZS0tID4gMDsgKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubWVzc2FnZXNbZV07XG4gICAgaWYgKHoodCkpXG4gICAgICByZXR1cm4gdDtcbiAgfVxuICB0aHJvdyBuZXcgbShcInN0cmVhbSBlbmRlZCB3aXRob3V0IHByb2R1Y2luZyBhIENoYXRDb21wbGV0aW9uTWVzc2FnZSB3aXRoIHJvbGU9YXNzaXN0YW50XCIpO1xufSwgS2UgPSBmdW5jdGlvbigpIHtcbiAgZm9yIChsZXQgZSA9IHRoaXMubWVzc2FnZXMubGVuZ3RoIC0gMTsgZSA+PSAwOyBlLS0pIHtcbiAgICBjb25zdCB0ID0gdGhpcy5tZXNzYWdlc1tlXTtcbiAgICBpZiAoeih0KSAmJiAodCAhPSBudWxsICYmIHQuZnVuY3Rpb25fY2FsbCkpXG4gICAgICByZXR1cm4gdC5mdW5jdGlvbl9jYWxsO1xuICB9XG59LCBHZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKGxldCBlID0gdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxOyBlID49IDA7IGUtLSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm1lc3NhZ2VzW2VdO1xuICAgIGlmIChXdCh0KSAmJiB0LmNvbnRlbnQgIT0gbnVsbClcbiAgICAgIHJldHVybiB0LmNvbnRlbnQ7XG4gIH1cbn0sIHplID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGUgPSB7XG4gICAgY29tcGxldGlvbl90b2tlbnM6IDAsXG4gICAgcHJvbXB0X3Rva2VuczogMCxcbiAgICB0b3RhbF90b2tlbnM6IDBcbiAgfTtcbiAgZm9yIChjb25zdCB7IHVzYWdlOiB0IH0gb2YgdGhpcy5fY2hhdENvbXBsZXRpb25zKVxuICAgIHQgJiYgKGUuY29tcGxldGlvbl90b2tlbnMgKz0gdC5jb21wbGV0aW9uX3Rva2VucywgZS5wcm9tcHRfdG9rZW5zICs9IHQucHJvbXB0X3Rva2VucywgZS50b3RhbF90b2tlbnMgKz0gdC50b3RhbF90b2tlbnMpO1xuICByZXR1cm4gZTtcbn0sIFh0ID0gZnVuY3Rpb24oZSkge1xuICBpZiAoZS5uICE9IG51bGwgJiYgZS5uID4gMSlcbiAgICB0aHJvdyBuZXcgbShcIkNoYXRDb21wbGV0aW9uIGNvbnZlbmllbmNlIGhlbHBlcnMgb25seSBzdXBwb3J0IG49MSBhdCB0aGlzIHRpbWUuIFRvIHVzZSBuPjEsIHBsZWFzZSB1c2UgY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoKSBkaXJlY3RseS5cIik7XG59LCBZZSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogZSA9PT0gdm9pZCAwID8gXCJ1bmRlZmluZWRcIiA6IEpTT04uc3RyaW5naWZ5KGUpO1xufTtcbmNsYXNzIFEgZXh0ZW5kcyBWdCB7XG4gIHN0YXRpYyBydW5GdW5jdGlvbnMoZSwgdCwgcykge1xuICAgIGNvbnN0IHIgPSBuZXcgUSgpO1xuICAgIHJldHVybiByLl9ydW4oKCkgPT4gci5fcnVuRnVuY3Rpb25zKGUsIHQsIHMpKSwgcjtcbiAgfVxuICBzdGF0aWMgcnVuVG9vbHMoZSwgdCwgcykge1xuICAgIGNvbnN0IHIgPSBuZXcgUSgpO1xuICAgIHJldHVybiByLl9ydW4oKCkgPT4gci5fcnVuVG9vbHMoZSwgdCwgcykpLCByO1xuICB9XG4gIF9hZGRNZXNzYWdlKGUpIHtcbiAgICBzdXBlci5fYWRkTWVzc2FnZShlKSwgeihlKSAmJiBlLmNvbnRlbnQgJiYgdGhpcy5fZW1pdChcImNvbnRlbnRcIiwgZS5jb250ZW50KTtcbiAgfVxufVxudmFyICQgPSBnbG9iYWxUaGlzICYmIGdsb2JhbFRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCB8fCBmdW5jdGlvbihuLCBlLCB0LCBzKSB7XG4gIGlmICh0ID09PSBcImFcIiAmJiAhcylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gbiAhPT0gZSB8fCAhcyA6ICFlLmhhcyhuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gdCA9PT0gXCJtXCIgPyBzIDogdCA9PT0gXCJhXCIgPyBzLmNhbGwobikgOiBzID8gcy52YWx1ZSA6IGUuZ2V0KG4pO1xufSwgRGUgPSBnbG9iYWxUaGlzICYmIGdsb2JhbFRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCB8fCBmdW5jdGlvbihuLCBlLCB0LCBzLCByKSB7XG4gIGlmIChzID09PSBcIm1cIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICBpZiAocyA9PT0gXCJhXCIgJiYgIXIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IG4gIT09IGUgfHwgIXIgOiAhZS5oYXMobikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gcyA9PT0gXCJhXCIgPyByLmNhbGwobiwgdCkgOiByID8gci52YWx1ZSA9IHQgOiBlLnNldChuLCB0KSwgdDtcbn0sIEYsIE8sIFVlLCBIZSwgZWUsIEN0O1xuY2xhc3MgWSBleHRlbmRzIFZ0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgRi5hZGQodGhpcyksIE8uc2V0KHRoaXMsIHZvaWQgMCk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90KCkge1xuICAgIHJldHVybiAkKHRoaXMsIE8sIFwiZlwiKTtcbiAgfVxuICAvKipcbiAgICogSW50ZW5kZWQgZm9yIHVzZSBvbiB0aGUgZnJvbnRlbmQsIGNvbnN1bWluZyBhIHN0cmVhbSBwcm9kdWNlZCB3aXRoXG4gICAqIGAudG9SZWFkYWJsZVN0cmVhbSgpYCBvbiB0aGUgYmFja2VuZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IG1lc3NhZ2VzIHNlbnQgdG8gdGhlIG1vZGVsIGRvIG5vdCBhcHBlYXIgaW4gYC5vbignbWVzc2FnZScpYFxuICAgKiBpbiB0aGlzIGNvbnRleHQuXG4gICAqL1xuICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtKGUpIHtcbiAgICBjb25zdCB0ID0gbmV3IFkoKTtcbiAgICByZXR1cm4gdC5fcnVuKCgpID0+IHQuX2Zyb21SZWFkYWJsZVN0cmVhbShlKSksIHQ7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUNoYXRDb21wbGV0aW9uKGUsIHQsIHMpIHtcbiAgICBjb25zdCByID0gbmV3IFkoKTtcbiAgICByZXR1cm4gci5fcnVuKCgpID0+IHIuX3J1bkNoYXRDb21wbGV0aW9uKGUsIHsgLi4udCwgc3RyZWFtOiAhMCB9LCBzKSksIHI7XG4gIH1cbiAgYXN5bmMgX2NyZWF0ZUNoYXRDb21wbGV0aW9uKGUsIHQsIHMpIHtcbiAgICB2YXIgYTtcbiAgICBjb25zdCByID0gcyA9PSBudWxsID8gdm9pZCAwIDogcy5zaWduYWw7XG4gICAgciAmJiAoci5hYm9ydGVkICYmIHRoaXMuY29udHJvbGxlci5hYm9ydCgpLCByLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSkpLCAkKHRoaXMsIEYsIFwibVwiLCBVZSkuY2FsbCh0aGlzKTtcbiAgICBjb25zdCBpID0gYXdhaXQgZS5jcmVhdGUoeyAuLi50LCBzdHJlYW06ICEwIH0sIHsgLi4ucywgc2lnbmFsOiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgbyBvZiBpKVxuICAgICAgJCh0aGlzLCBGLCBcIm1cIiwgSGUpLmNhbGwodGhpcywgbyk7XG4gICAgaWYgKChhID0gaS5jb250cm9sbGVyLnNpZ25hbCkgIT0gbnVsbCAmJiBhLmFib3J0ZWQpXG4gICAgICB0aHJvdyBuZXcgaigpO1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGF0Q29tcGxldGlvbigkKHRoaXMsIEYsIFwibVwiLCBlZSkuY2FsbCh0aGlzKSk7XG4gIH1cbiAgYXN5bmMgX2Zyb21SZWFkYWJsZVN0cmVhbShlLCB0KSB7XG4gICAgdmFyIGE7XG4gICAgY29uc3QgcyA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuc2lnbmFsO1xuICAgIHMgJiYgKHMuYWJvcnRlZCAmJiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSwgcy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpKSwgJCh0aGlzLCBGLCBcIm1cIiwgVWUpLmNhbGwodGhpcyksIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgIGNvbnN0IHIgPSBMLmZyb21SZWFkYWJsZVN0cmVhbShlLCB0aGlzLmNvbnRyb2xsZXIpO1xuICAgIGxldCBpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgbyBvZiByKVxuICAgICAgaSAmJiBpICE9PSBvLmlkICYmIHRoaXMuX2FkZENoYXRDb21wbGV0aW9uKCQodGhpcywgRiwgXCJtXCIsIGVlKS5jYWxsKHRoaXMpKSwgJCh0aGlzLCBGLCBcIm1cIiwgSGUpLmNhbGwodGhpcywgbyksIGkgPSBvLmlkO1xuICAgIGlmICgoYSA9IHIuY29udHJvbGxlci5zaWduYWwpICE9IG51bGwgJiYgYS5hYm9ydGVkKVxuICAgICAgdGhyb3cgbmV3IGooKTtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hhdENvbXBsZXRpb24oJCh0aGlzLCBGLCBcIm1cIiwgZWUpLmNhbGwodGhpcykpO1xuICB9XG4gIFsoTyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBGID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCksIFVlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbmRlZCB8fCBEZSh0aGlzLCBPLCB2b2lkIDAsIFwiZlwiKTtcbiAgfSwgSGUgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGEsIG8sIGM7XG4gICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9ICQodGhpcywgRiwgXCJtXCIsIEN0KS5jYWxsKHRoaXMsIHQpO1xuICAgIHRoaXMuX2VtaXQoXCJjaHVua1wiLCB0LCBzKTtcbiAgICBjb25zdCByID0gKG8gPSAoYSA9IHQuY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBvLmNvbnRlbnQsIGkgPSAoYyA9IHMuY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IGMubWVzc2FnZTtcbiAgICByICE9IG51bGwgJiYgKGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkucm9sZSkgPT09IFwiYXNzaXN0YW50XCIgJiYgKGkgIT0gbnVsbCAmJiBpLmNvbnRlbnQpICYmIHRoaXMuX2VtaXQoXCJjb250ZW50XCIsIHIsIGkuY29udGVudCk7XG4gIH0sIGVlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICB0aHJvdyBuZXcgbShcInN0cmVhbSBoYXMgZW5kZWQsIHRoaXMgc2hvdWxkbid0IGhhcHBlblwiKTtcbiAgICBjb25zdCB0ID0gJCh0aGlzLCBPLCBcImZcIik7XG4gICAgaWYgKCF0KVxuICAgICAgdGhyb3cgbmV3IG0oXCJyZXF1ZXN0IGVuZGVkIHdpdGhvdXQgc2VuZGluZyBhbnkgY2h1bmtzXCIpO1xuICAgIHJldHVybiBEZSh0aGlzLCBPLCB2b2lkIDAsIFwiZlwiKSwgRW4odCk7XG4gIH0sIEN0ID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBzLCByO1xuICAgIGxldCBpID0gJCh0aGlzLCBPLCBcImZcIik7XG4gICAgY29uc3QgeyBjaG9pY2VzOiBhLCAuLi5vIH0gPSB0O1xuICAgIGkgPyBPYmplY3QuYXNzaWduKGksIG8pIDogaSA9IERlKHRoaXMsIE8sIHtcbiAgICAgIC4uLm8sXG4gICAgICBjaG9pY2VzOiBbXVxuICAgIH0sIFwiZlwiKTtcbiAgICBmb3IgKGNvbnN0IHsgZGVsdGE6IGMsIGZpbmlzaF9yZWFzb246IHAsIGluZGV4OiBmLCAuLi53IH0gb2YgdC5jaG9pY2VzKSB7XG4gICAgICBsZXQgdSA9IGkuY2hvaWNlc1tmXTtcbiAgICAgIGlmICghdSkge1xuICAgICAgICBpLmNob2ljZXNbZl0gPSB7IGZpbmlzaF9yZWFzb246IHAsIGluZGV4OiBmLCBtZXNzYWdlOiBjLCAuLi53IH07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHAgJiYgKHUuZmluaXNoX3JlYXNvbiA9IHApLCBPYmplY3QuYXNzaWduKHUsIHcpLCAhYylcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB7IGNvbnRlbnQ6IGgsIGZ1bmN0aW9uX2NhbGw6IGQsIHJvbGU6IFAsIHRvb2xfY2FsbHM6IHkgfSA9IGM7XG4gICAgICBpZiAoaCAmJiAodS5tZXNzYWdlLmNvbnRlbnQgPSAodS5tZXNzYWdlLmNvbnRlbnQgfHwgXCJcIikgKyBoKSwgUCAmJiAodS5tZXNzYWdlLnJvbGUgPSBQKSwgZCAmJiAodS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPyAoZC5uYW1lICYmICh1Lm1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5uYW1lID0gZC5uYW1lKSwgZC5hcmd1bWVudHMgJiYgKChzID0gdS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwpLmFyZ3VtZW50cyA/PyAocy5hcmd1bWVudHMgPSBcIlwiKSwgdS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICs9IGQuYXJndW1lbnRzKSkgOiB1Lm1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9IGQpLCB5KSB7XG4gICAgICAgIHUubWVzc2FnZS50b29sX2NhbGxzIHx8ICh1Lm1lc3NhZ2UudG9vbF9jYWxscyA9IFtdKTtcbiAgICAgICAgZm9yIChjb25zdCB7IGluZGV4OiBBLCBpZDogQywgdHlwZTogVCwgZnVuY3Rpb246IFIgfSBvZiB5KSB7XG4gICAgICAgICAgY29uc3QgUyA9IChyID0gdS5tZXNzYWdlLnRvb2xfY2FsbHMpW0FdID8/IChyW0FdID0ge30pO1xuICAgICAgICAgIEMgJiYgKFMuaWQgPSBDKSwgVCAmJiAoUy50eXBlID0gVCksIFIgJiYgKFMuZnVuY3Rpb24gPz8gKFMuZnVuY3Rpb24gPSB7IGFyZ3VtZW50czogXCJcIiB9KSksIFIgIT0gbnVsbCAmJiBSLm5hbWUgJiYgKFMuZnVuY3Rpb24ubmFtZSA9IFIubmFtZSksIFIgIT0gbnVsbCAmJiBSLmFyZ3VtZW50cyAmJiAoUy5mdW5jdGlvbi5hcmd1bWVudHMgKz0gUi5hcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9LCBTeW1ib2wuYXN5bmNJdGVyYXRvcildKCkge1xuICAgIGNvbnN0IGUgPSBbXSwgdCA9IFtdO1xuICAgIGxldCBzID0gITE7XG4gICAgcmV0dXJuIHRoaXMub24oXCJjaHVua1wiLCAocikgPT4ge1xuICAgICAgY29uc3QgaSA9IHQuc2hpZnQoKTtcbiAgICAgIGkgPyBpKHIpIDogZS5wdXNoKHIpO1xuICAgIH0pLCB0aGlzLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHMgPSAhMDtcbiAgICAgIGZvciAoY29uc3QgciBvZiB0KVxuICAgICAgICByKHZvaWQgMCk7XG4gICAgICB0Lmxlbmd0aCA9IDA7XG4gICAgfSksIHtcbiAgICAgIG5leHQ6IGFzeW5jICgpID0+IGUubGVuZ3RoID8geyB2YWx1ZTogZS5zaGlmdCgpLCBkb25lOiAhMSB9IDogcyA/IHsgdmFsdWU6IHZvaWQgMCwgZG9uZTogITAgfSA6IG5ldyBQcm9taXNlKChpKSA9PiB0LnB1c2goaSkpLnRoZW4oKGkpID0+IGkgPyB7IHZhbHVlOiBpLCBkb25lOiAhMSB9IDogeyB2YWx1ZTogdm9pZCAwLCBkb25lOiAhMCB9KVxuICAgIH07XG4gIH1cbiAgdG9SZWFkYWJsZVN0cmVhbSgpIHtcbiAgICByZXR1cm4gbmV3IEwodGhpc1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0uYmluZCh0aGlzKSwgdGhpcy5jb250cm9sbGVyKS50b1JlYWRhYmxlU3RyZWFtKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEVuKG4pIHtcbiAgY29uc3QgeyBpZDogZSwgY2hvaWNlczogdCwgY3JlYXRlZDogcywgbW9kZWw6IHIgfSA9IG47XG4gIHJldHVybiB7XG4gICAgaWQ6IGUsXG4gICAgY2hvaWNlczogdC5tYXAoKHsgbWVzc2FnZTogaSwgZmluaXNoX3JlYXNvbjogYSwgaW5kZXg6IG8gfSkgPT4ge1xuICAgICAgaWYgKCFhKVxuICAgICAgICB0aHJvdyBuZXcgbShgbWlzc2luZyBmaW5pc2hfcmVhc29uIGZvciBjaG9pY2UgJHtvfWApO1xuICAgICAgY29uc3QgeyBjb250ZW50OiBjID0gbnVsbCwgZnVuY3Rpb25fY2FsbDogcCwgdG9vbF9jYWxsczogZiB9ID0gaSwgdyA9IGkucm9sZTtcbiAgICAgIGlmICghdylcbiAgICAgICAgdGhyb3cgbmV3IG0oYG1pc3Npbmcgcm9sZSBmb3IgY2hvaWNlICR7b31gKTtcbiAgICAgIGlmIChwKSB7XG4gICAgICAgIGNvbnN0IHsgYXJndW1lbnRzOiB1LCBuYW1lOiBoIH0gPSBwO1xuICAgICAgICBpZiAodSA9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBtKGBtaXNzaW5nIGZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzIGZvciBjaG9pY2UgJHtvfWApO1xuICAgICAgICBpZiAoIWgpXG4gICAgICAgICAgdGhyb3cgbmV3IG0oYG1pc3NpbmcgZnVuY3Rpb25fY2FsbC5uYW1lIGZvciBjaG9pY2UgJHtvfWApO1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiB7IGNvbnRlbnQ6IGMsIGZ1bmN0aW9uX2NhbGw6IHsgYXJndW1lbnRzOiB1LCBuYW1lOiBoIH0sIHJvbGU6IHcgfSwgZmluaXNoX3JlYXNvbjogYSwgaW5kZXg6IG8gfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmID8ge1xuICAgICAgICBpbmRleDogbyxcbiAgICAgICAgZmluaXNoX3JlYXNvbjogYSxcbiAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgIHJvbGU6IHcsXG4gICAgICAgICAgY29udGVudDogYyxcbiAgICAgICAgICB0b29sX2NhbGxzOiBmLm1hcCgodSwgaCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBmdW5jdGlvbjogZCwgdHlwZTogUCwgaWQ6IHkgfSA9IHUsIHsgYXJndW1lbnRzOiBBLCBuYW1lOiBDIH0gPSBkIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHkgPT0gbnVsbClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IG0oYG1pc3NpbmcgY2hvaWNlc1ske299XS50b29sX2NhbGxzWyR7aH1dLmlkXG4ke3RlKG4pfWApO1xuICAgICAgICAgICAgaWYgKFAgPT0gbnVsbClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IG0oYG1pc3NpbmcgY2hvaWNlc1ske299XS50b29sX2NhbGxzWyR7aH1dLnR5cGVcbiR7dGUobil9YCk7XG4gICAgICAgICAgICBpZiAoQyA9PSBudWxsKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgbShgbWlzc2luZyBjaG9pY2VzWyR7b31dLnRvb2xfY2FsbHNbJHtofV0uZnVuY3Rpb24ubmFtZVxuJHt0ZShuKX1gKTtcbiAgICAgICAgICAgIGlmIChBID09IG51bGwpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBtKGBtaXNzaW5nIGNob2ljZXNbJHtvfV0udG9vbF9jYWxsc1ske2h9XS5mdW5jdGlvbi5hcmd1bWVudHNcbiR7dGUobil9YCk7XG4gICAgICAgICAgICByZXR1cm4geyBpZDogeSwgdHlwZTogUCwgZnVuY3Rpb246IHsgbmFtZTogQywgYXJndW1lbnRzOiBBIH0gfTtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IDogeyBtZXNzYWdlOiB7IGNvbnRlbnQ6IGMsIHJvbGU6IHcgfSwgZmluaXNoX3JlYXNvbjogYSwgaW5kZXg6IG8gfTtcbiAgICB9KSxcbiAgICBjcmVhdGVkOiBzLFxuICAgIG1vZGVsOiByLFxuICAgIG9iamVjdDogXCJjaGF0LmNvbXBsZXRpb25cIlxuICB9O1xufVxuZnVuY3Rpb24gdGUobikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobik7XG59XG5jbGFzcyBIIGV4dGVuZHMgWSB7XG4gIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0oZSkge1xuICAgIGNvbnN0IHQgPSBuZXcgSCgpO1xuICAgIHJldHVybiB0Ll9ydW4oKCkgPT4gdC5fZnJvbVJlYWRhYmxlU3RyZWFtKGUpKSwgdDtcbiAgfVxuICBzdGF0aWMgcnVuRnVuY3Rpb25zKGUsIHQsIHMpIHtcbiAgICBjb25zdCByID0gbmV3IEgoKTtcbiAgICByZXR1cm4gci5fcnVuKCgpID0+IHIuX3J1bkZ1bmN0aW9ucyhlLCB0LCBzKSksIHI7XG4gIH1cbiAgc3RhdGljIHJ1blRvb2xzKGUsIHQsIHMpIHtcbiAgICBjb25zdCByID0gbmV3IEgoKTtcbiAgICByZXR1cm4gci5fcnVuKCgpID0+IHIuX3J1blRvb2xzKGUsIHQsIHMpKSwgcjtcbiAgfVxufVxubGV0IEp0ID0gY2xhc3MgZXh0ZW5kcyBnIHtcbiAgcnVuRnVuY3Rpb25zKGUsIHQpIHtcbiAgICByZXR1cm4gZS5zdHJlYW0gPyBILnJ1bkZ1bmN0aW9ucyh0aGlzLmNsaWVudC5jaGF0LmNvbXBsZXRpb25zLCBlLCB0KSA6IFEucnVuRnVuY3Rpb25zKHRoaXMuY2xpZW50LmNoYXQuY29tcGxldGlvbnMsIGUsIHQpO1xuICB9XG4gIHJ1blRvb2xzKGUsIHQpIHtcbiAgICByZXR1cm4gZS5zdHJlYW0gPyBILnJ1blRvb2xzKHRoaXMuY2xpZW50LmNoYXQuY29tcGxldGlvbnMsIGUsIHQpIDogUS5ydW5Ub29scyh0aGlzLmNsaWVudC5jaGF0LmNvbXBsZXRpb25zLCBlLCB0KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNoYXQgY29tcGxldGlvbiBzdHJlYW1cbiAgICovXG4gIHN0cmVhbShlLCB0KSB7XG4gICAgcmV0dXJuIFkuY3JlYXRlQ2hhdENvbXBsZXRpb24odGhpcy5jbGllbnQuY2hhdC5jb21wbGV0aW9ucywgZSwgdCk7XG4gIH1cbn07XG5jbGFzcyBwZSBleHRlbmRzIGcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmNvbXBsZXRpb25zID0gbmV3IEp0KHRoaXMuY2xpZW50KTtcbiAgfVxufVxuKGZ1bmN0aW9uKG4pIHtcbiAgbi5Db21wbGV0aW9ucyA9IEp0O1xufSkocGUgfHwgKHBlID0ge30pKTtcbmxldCBnZSA9IGNsYXNzIGV4dGVuZHMgZyB7XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBtZXNzYWdlIGZpbGUuXG4gICAqL1xuICByZXRyaWV2ZShlLCB0LCBzLCByKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAvdGhyZWFkcy8ke2V9L21lc3NhZ2VzLyR7dH0vZmlsZXMvJHtzfWAsIHtcbiAgICAgIC4uLnIsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbiAgbGlzdChlLCB0LCBzID0ge30sIHIpIHtcbiAgICByZXR1cm4gSShzKSA/IHRoaXMubGlzdChlLCB0LCB7fSwgcykgOiB0aGlzLmdldEFQSUxpc3QoYC90aHJlYWRzLyR7ZX0vbWVzc2FnZXMvJHt0fS9maWxlc2AsIG50LCB7XG4gICAgICBxdWVyeTogcyxcbiAgICAgIC4uLnIsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbn07XG5jbGFzcyBudCBleHRlbmRzIGsge1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgbi5NZXNzYWdlRmlsZXNQYWdlID0gbnQ7XG59KShnZSB8fCAoZ2UgPSB7fSkpO1xuY2xhc3Mgd2UgZXh0ZW5kcyBnIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5maWxlcyA9IG5ldyBnZSh0aGlzLmNsaWVudCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lc3NhZ2UuXG4gICAqL1xuICBjcmVhdGUoZSwgdCwgcykge1xuICAgIHJldHVybiB0aGlzLnBvc3QoYC90aHJlYWRzLyR7ZX0vbWVzc2FnZXNgLCB7XG4gICAgICBib2R5OiB0LFxuICAgICAgLi4ucyxcbiAgICAgIGhlYWRlcnM6IHsgXCJPcGVuQUktQmV0YVwiOiBcImFzc2lzdGFudHM9djFcIiwgLi4ucyA9PSBudWxsID8gdm9pZCAwIDogcy5oZWFkZXJzIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmUgYSBtZXNzYWdlLlxuICAgKi9cbiAgcmV0cmlldmUoZSwgdCwgcykge1xuICAgIHJldHVybiB0aGlzLmdldChgL3RocmVhZHMvJHtlfS9tZXNzYWdlcy8ke3R9YCwge1xuICAgICAgLi4ucyxcbiAgICAgIGhlYWRlcnM6IHsgXCJPcGVuQUktQmV0YVwiOiBcImFzc2lzdGFudHM9djFcIiwgLi4ucyA9PSBudWxsID8gdm9pZCAwIDogcy5oZWFkZXJzIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTW9kaWZpZXMgYSBtZXNzYWdlLlxuICAgKi9cbiAgdXBkYXRlKGUsIHQsIHMsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KGAvdGhyZWFkcy8ke2V9L21lc3NhZ2VzLyR7dH1gLCB7XG4gICAgICBib2R5OiBzLFxuICAgICAgLi4ucixcbiAgICAgIGhlYWRlcnM6IHsgXCJPcGVuQUktQmV0YVwiOiBcImFzc2lzdGFudHM9djFcIiwgLi4uciA9PSBudWxsID8gdm9pZCAwIDogci5oZWFkZXJzIH1cbiAgICB9KTtcbiAgfVxuICBsaXN0KGUsIHQgPSB7fSwgcykge1xuICAgIHJldHVybiBJKHQpID8gdGhpcy5saXN0KGUsIHt9LCB0KSA6IHRoaXMuZ2V0QVBJTGlzdChgL3RocmVhZHMvJHtlfS9tZXNzYWdlc2AsIHN0LCB7XG4gICAgICBxdWVyeTogdCxcbiAgICAgIC4uLnMsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIHN0IGV4dGVuZHMgayB7XG59XG4oZnVuY3Rpb24obikge1xuICBuLlRocmVhZE1lc3NhZ2VzUGFnZSA9IHN0LCBuLkZpbGVzID0gZ2UsIG4uTWVzc2FnZUZpbGVzUGFnZSA9IG50O1xufSkod2UgfHwgKHdlID0ge30pKTtcbmNsYXNzIHllIGV4dGVuZHMgZyB7XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBydW4gc3RlcC5cbiAgICovXG4gIHJldHJpZXZlKGUsIHQsIHMsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC90aHJlYWRzLyR7ZX0vcnVucy8ke3R9L3N0ZXBzLyR7c31gLCB7XG4gICAgICAuLi5yLFxuICAgICAgaGVhZGVyczogeyBcIk9wZW5BSS1CZXRhXCI6IFwiYXNzaXN0YW50cz12MVwiLCAuLi5yID09IG51bGwgPyB2b2lkIDAgOiByLmhlYWRlcnMgfVxuICAgIH0pO1xuICB9XG4gIGxpc3QoZSwgdCwgcyA9IHt9LCByKSB7XG4gICAgcmV0dXJuIEkocykgPyB0aGlzLmxpc3QoZSwgdCwge30sIHMpIDogdGhpcy5nZXRBUElMaXN0KGAvdGhyZWFkcy8ke2V9L3J1bnMvJHt0fS9zdGVwc2AsIHJ0LCB7XG4gICAgICBxdWVyeTogcyxcbiAgICAgIC4uLnIsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIHJ0IGV4dGVuZHMgayB7XG59XG4oZnVuY3Rpb24obikge1xuICBuLlJ1blN0ZXBzUGFnZSA9IHJ0O1xufSkoeWUgfHwgKHllID0ge30pKTtcbmNsYXNzIGJlIGV4dGVuZHMgZyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuc3RlcHMgPSBuZXcgeWUodGhpcy5jbGllbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBydW4uXG4gICAqL1xuICBjcmVhdGUoZSwgdCwgcykge1xuICAgIHJldHVybiB0aGlzLnBvc3QoYC90aHJlYWRzLyR7ZX0vcnVuc2AsIHtcbiAgICAgIGJvZHk6IHQsXG4gICAgICAuLi5zLFxuICAgICAgaGVhZGVyczogeyBcIk9wZW5BSS1CZXRhXCI6IFwiYXNzaXN0YW50cz12MVwiLCAuLi5zID09IG51bGwgPyB2b2lkIDAgOiBzLmhlYWRlcnMgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBydW4uXG4gICAqL1xuICByZXRyaWV2ZShlLCB0LCBzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAvdGhyZWFkcy8ke2V9L3J1bnMvJHt0fWAsIHtcbiAgICAgIC4uLnMsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgcnVuLlxuICAgKi9cbiAgdXBkYXRlKGUsIHQsIHMsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KGAvdGhyZWFkcy8ke2V9L3J1bnMvJHt0fWAsIHtcbiAgICAgIGJvZHk6IHMsXG4gICAgICAuLi5yLFxuICAgICAgaGVhZGVyczogeyBcIk9wZW5BSS1CZXRhXCI6IFwiYXNzaXN0YW50cz12MVwiLCAuLi5yID09IG51bGwgPyB2b2lkIDAgOiByLmhlYWRlcnMgfVxuICAgIH0pO1xuICB9XG4gIGxpc3QoZSwgdCA9IHt9LCBzKSB7XG4gICAgcmV0dXJuIEkodCkgPyB0aGlzLmxpc3QoZSwge30sIHQpIDogdGhpcy5nZXRBUElMaXN0KGAvdGhyZWFkcy8ke2V9L3J1bnNgLCBpdCwge1xuICAgICAgcXVlcnk6IHQsXG4gICAgICAuLi5zLFxuICAgICAgaGVhZGVyczogeyBcIk9wZW5BSS1CZXRhXCI6IFwiYXNzaXN0YW50cz12MVwiLCAuLi5zID09IG51bGwgPyB2b2lkIDAgOiBzLmhlYWRlcnMgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcnVuIHRoYXQgaXMgYGluX3Byb2dyZXNzYC5cbiAgICovXG4gIGNhbmNlbChlLCB0LCBzKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zdChgL3RocmVhZHMvJHtlfS9ydW5zLyR7dH0vY2FuY2VsYCwge1xuICAgICAgLi4ucyxcbiAgICAgIGhlYWRlcnM6IHsgXCJPcGVuQUktQmV0YVwiOiBcImFzc2lzdGFudHM9djFcIiwgLi4ucyA9PSBudWxsID8gdm9pZCAwIDogcy5oZWFkZXJzIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogV2hlbiBhIHJ1biBoYXMgdGhlIGBzdGF0dXM6IFwicmVxdWlyZXNfYWN0aW9uXCJgIGFuZCBgcmVxdWlyZWRfYWN0aW9uLnR5cGVgIGlzXG4gICAqIGBzdWJtaXRfdG9vbF9vdXRwdXRzYCwgdGhpcyBlbmRwb2ludCBjYW4gYmUgdXNlZCB0byBzdWJtaXQgdGhlIG91dHB1dHMgZnJvbSB0aGVcbiAgICogdG9vbCBjYWxscyBvbmNlIHRoZXkncmUgYWxsIGNvbXBsZXRlZC4gQWxsIG91dHB1dHMgbXVzdCBiZSBzdWJtaXR0ZWQgaW4gYSBzaW5nbGVcbiAgICogcmVxdWVzdC5cbiAgICovXG4gIHN1Ym1pdFRvb2xPdXRwdXRzKGUsIHQsIHMsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KGAvdGhyZWFkcy8ke2V9L3J1bnMvJHt0fS9zdWJtaXRfdG9vbF9vdXRwdXRzYCwge1xuICAgICAgYm9keTogcyxcbiAgICAgIC4uLnIsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIGl0IGV4dGVuZHMgayB7XG59XG4oZnVuY3Rpb24obikge1xuICBuLlJ1bnNQYWdlID0gaXQsIG4uU3RlcHMgPSB5ZSwgbi5SdW5TdGVwc1BhZ2UgPSBydDtcbn0pKGJlIHx8IChiZSA9IHt9KSk7XG5jbGFzcyBfZSBleHRlbmRzIGcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnJ1bnMgPSBuZXcgYmUodGhpcy5jbGllbnQpLCB0aGlzLm1lc3NhZ2VzID0gbmV3IHdlKHRoaXMuY2xpZW50KTtcbiAgfVxuICBjcmVhdGUoZSA9IHt9LCB0KSB7XG4gICAgcmV0dXJuIEkoZSkgPyB0aGlzLmNyZWF0ZSh7fSwgZSkgOiB0aGlzLnBvc3QoXCIvdGhyZWFkc1wiLCB7XG4gICAgICBib2R5OiBlLFxuICAgICAgLi4udCxcbiAgICAgIGhlYWRlcnM6IHsgXCJPcGVuQUktQmV0YVwiOiBcImFzc2lzdGFudHM9djFcIiwgLi4udCA9PSBudWxsID8gdm9pZCAwIDogdC5oZWFkZXJzIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdGhyZWFkLlxuICAgKi9cbiAgcmV0cmlldmUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmdldChgL3RocmVhZHMvJHtlfWAsIHtcbiAgICAgIC4uLnQsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgdGhyZWFkLlxuICAgKi9cbiAgdXBkYXRlKGUsIHQsIHMpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KGAvdGhyZWFkcy8ke2V9YCwge1xuICAgICAgYm9keTogdCxcbiAgICAgIC4uLnMsXG4gICAgICBoZWFkZXJzOiB7IFwiT3BlbkFJLUJldGFcIjogXCJhc3Npc3RhbnRzPXYxXCIsIC4uLnMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuaGVhZGVycyB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHRocmVhZC5cbiAgICovXG4gIGRlbChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsZXRlKGAvdGhyZWFkcy8ke2V9YCwge1xuICAgICAgLi4udCxcbiAgICAgIGhlYWRlcnM6IHsgXCJPcGVuQUktQmV0YVwiOiBcImFzc2lzdGFudHM9djFcIiwgLi4udCA9PSBudWxsID8gdm9pZCAwIDogdC5oZWFkZXJzIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgdGhyZWFkIGFuZCBydW4gaXQgaW4gb25lIHJlcXVlc3QuXG4gICAqL1xuICBjcmVhdGVBbmRSdW4oZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnBvc3QoXCIvdGhyZWFkcy9ydW5zXCIsIHtcbiAgICAgIGJvZHk6IGUsXG4gICAgICAuLi50LFxuICAgICAgaGVhZGVyczogeyBcIk9wZW5BSS1CZXRhXCI6IFwiYXNzaXN0YW50cz12MVwiLCAuLi50ID09IG51bGwgPyB2b2lkIDAgOiB0LmhlYWRlcnMgfVxuICAgIH0pO1xuICB9XG59XG4oZnVuY3Rpb24obikge1xuICBuLlJ1bnMgPSBiZSwgbi5SdW5zUGFnZSA9IGl0LCBuLk1lc3NhZ2VzID0gd2UsIG4uVGhyZWFkTWVzc2FnZXNQYWdlID0gc3Q7XG59KShfZSB8fCAoX2UgPSB7fSkpO1xuY2xhc3MgQ2UgZXh0ZW5kcyBnIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5jaGF0ID0gbmV3IHBlKHRoaXMuY2xpZW50KSwgdGhpcy5hc3Npc3RhbnRzID0gbmV3IG1lKHRoaXMuY2xpZW50KSwgdGhpcy50aHJlYWRzID0gbmV3IF9lKHRoaXMuY2xpZW50KTtcbiAgfVxufVxuKGZ1bmN0aW9uKG4pIHtcbiAgbi5DaGF0ID0gcGUsIG4uQXNzaXN0YW50cyA9IG1lLCBuLkFzc2lzdGFudHNQYWdlID0gdHQsIG4uVGhyZWFkcyA9IF9lO1xufSkoQ2UgfHwgKENlID0ge30pKTtcbmNsYXNzIHhlIGV4dGVuZHMgZyB7XG4gIGNyZWF0ZShlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMucG9zdChcIi9jb21wbGV0aW9uc1wiLCB7IGJvZHk6IGUsIC4uLnQsIHN0cmVhbTogZS5zdHJlYW0gPz8gITEgfSk7XG4gIH1cbn1cbnhlIHx8ICh4ZSA9IHt9KTtcbmNsYXNzIFBlIGV4dGVuZHMgZyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVtYmVkZGluZyB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCB0ZXh0LlxuICAgKi9cbiAgY3JlYXRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KFwiL2VtYmVkZGluZ3NcIiwgeyBib2R5OiBlLCAuLi50IH0pO1xuICB9XG59XG5QZSB8fCAoUGUgPSB7fSk7XG5jbGFzcyBSZSBleHRlbmRzIGcge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBlZGl0IGZvciB0aGUgcHJvdmlkZWQgaW5wdXQsIGluc3RydWN0aW9uLCBhbmQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhlIEVkaXRzIEFQSSBpcyBkZXByZWNhdGVkOyBwbGVhc2UgdXNlIENoYXQgQ29tcGxldGlvbnMgaW5zdGVhZC5cbiAgICpcbiAgICogaHR0cHM6Ly9vcGVuYWkuY29tL2Jsb2cvZ3B0LTQtYXBpLWdlbmVyYWwtYXZhaWxhYmlsaXR5I2RlcHJlY2F0aW9uLW9mLXRoZS1lZGl0cy1hcGlcbiAgICovXG4gIGNyZWF0ZShlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMucG9zdChcIi9lZGl0c1wiLCB7IGJvZHk6IGUsIC4uLnQgfSk7XG4gIH1cbn1cblJlIHx8IChSZSA9IHt9KTtcbmNsYXNzIFNlIGV4dGVuZHMgZyB7XG4gIC8qKlxuICAgKiBVcGxvYWQgYSBmaWxlIHRoYXQgY2FuIGJlIHVzZWQgYWNyb3NzIHZhcmlvdXMgZW5kcG9pbnRzL2ZlYXR1cmVzLiBUaGUgc2l6ZSBvZlxuICAgKiBhbGwgdGhlIGZpbGVzIHVwbG9hZGVkIGJ5IG9uZSBvcmdhbml6YXRpb24gY2FuIGJlIHVwIHRvIDEwMCBHQi5cbiAgICpcbiAgICogVGhlIHNpemUgb2YgaW5kaXZpZHVhbCBmaWxlcyBmb3IgY2FuIGJlIGEgbWF4aW11bSBvZiA1MTJNQi4gU2VlIHRoZVxuICAgKiBbQXNzaXN0YW50cyBUb29scyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scykgdG9cbiAgICogbGVhcm4gbW9yZSBhYm91dCB0aGUgdHlwZXMgb2YgZmlsZXMgc3VwcG9ydGVkLiBUaGUgRmluZS10dW5pbmcgQVBJIG9ubHkgc3VwcG9ydHNcbiAgICogYC5qc29ubGAgZmlsZXMuXG4gICAqXG4gICAqIFBsZWFzZSBbY29udGFjdCB1c10oaHR0cHM6Ly9oZWxwLm9wZW5haS5jb20vKSBpZiB5b3UgbmVlZCB0byBpbmNyZWFzZSB0aGVzZVxuICAgKiBzdG9yYWdlIGxpbWl0cy5cbiAgICovXG4gIGNyZWF0ZShlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMucG9zdChcIi9maWxlc1wiLCBHKHsgYm9keTogZSwgLi4udCB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgYSBzcGVjaWZpYyBmaWxlLlxuICAgKi9cbiAgcmV0cmlldmUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmdldChgL2ZpbGVzLyR7ZX1gLCB0KTtcbiAgfVxuICBsaXN0KGUgPSB7fSwgdCkge1xuICAgIHJldHVybiBJKGUpID8gdGhpcy5saXN0KHt9LCBlKSA6IHRoaXMuZ2V0QVBJTGlzdChcIi9maWxlc1wiLCBhdCwgeyBxdWVyeTogZSwgLi4udCB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgZmlsZS5cbiAgICovXG4gIGRlbChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsZXRlKGAvZmlsZXMvJHtlfWAsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgc3BlY2lmaWVkIGZpbGUuXG4gICAqL1xuICBjb250ZW50KGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9maWxlcy8ke2V9L2NvbnRlbnRgLCB7IC4uLnQsIF9fYmluYXJ5UmVzcG9uc2U6ICEwIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgc3BlY2lmaWVkIGZpbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBgLmNvbnRlbnQoKWAgbWV0aG9kIHNob3VsZCBiZSB1c2VkIGluc3RlYWRcbiAgICovXG4gIHJldHJpZXZlQ29udGVudChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAvZmlsZXMvJHtlfS9jb250ZW50YCwge1xuICAgICAgLi4udCxcbiAgICAgIGhlYWRlcnM6IHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiwgLi4udCA9PSBudWxsID8gdm9pZCAwIDogdC5oZWFkZXJzIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBnaXZlbiBmaWxlIHRvIGJlIHByb2Nlc3NlZCwgZGVmYXVsdCB0aW1lb3V0IGlzIDMwIG1pbnMuXG4gICAqL1xuICBhc3luYyB3YWl0Rm9yUHJvY2Vzc2luZyhlLCB7IHBvbGxJbnRlcnZhbDogdCA9IDVlMywgbWF4V2FpdDogcyA9IDMwICogNjAgKiAxZTMgfSA9IHt9KSB7XG4gICAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInByb2Nlc3NlZFwiLCBcImVycm9yXCIsIFwiZGVsZXRlZFwiXSksIGkgPSBEYXRlLm5vdygpO1xuICAgIGxldCBhID0gYXdhaXQgdGhpcy5yZXRyaWV2ZShlKTtcbiAgICBmb3IgKDsgIWEuc3RhdHVzIHx8ICFyLmhhcyhhLnN0YXR1cyk7IClcbiAgICAgIGlmIChhd2FpdCBIdCh0KSwgYSA9IGF3YWl0IHRoaXMucmV0cmlldmUoZSksIERhdGUubm93KCkgLSBpID4gcylcbiAgICAgICAgdGhyb3cgbmV3IFplKHtcbiAgICAgICAgICBtZXNzYWdlOiBgR2l2aW5nIHVwIG9uIHdhaXRpbmcgZm9yIGZpbGUgJHtlfSB0byBmaW5pc2ggcHJvY2Vzc2luZyBhZnRlciAke3N9IG1pbGxpc2Vjb25kcy5gXG4gICAgICAgIH0pO1xuICAgIHJldHVybiBhO1xuICB9XG59XG5jbGFzcyBhdCBleHRlbmRzIGtlIHtcbn1cbihmdW5jdGlvbihuKSB7XG4gIG4uRmlsZU9iamVjdHNQYWdlID0gYXQ7XG59KShTZSB8fCAoU2UgPSB7fSkpO1xuY2xhc3MgQWUgZXh0ZW5kcyBnIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBqb2IgdGhhdCBmaW5lLXR1bmVzIGEgc3BlY2lmaWVkIG1vZGVsIGZyb20gYSBnaXZlbiBkYXRhc2V0LlxuICAgKlxuICAgKiBSZXNwb25zZSBpbmNsdWRlcyBkZXRhaWxzIG9mIHRoZSBlbnF1ZXVlZCBqb2IgaW5jbHVkaW5nIGpvYiBzdGF0dXMgYW5kIHRoZSBuYW1lXG4gICAqIG9mIHRoZSBmaW5lLXR1bmVkIG1vZGVscyBvbmNlIGNvbXBsZXRlLlxuICAgKlxuICAgKiBbTGVhcm4gbW9yZSBhYm91dCBmaW5lLXR1bmluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZylcbiAgICovXG4gIGNyZWF0ZShlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMucG9zdChcIi9maW5lLXR1bmVzXCIsIHsgYm9keTogZSwgLi4udCB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBpbmZvIGFib3V0IHRoZSBmaW5lLXR1bmUgam9iLlxuICAgKlxuICAgKiBbTGVhcm4gbW9yZSBhYm91dCBmaW5lLXR1bmluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZylcbiAgICovXG4gIHJldHJpZXZlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9maW5lLXR1bmVzLyR7ZX1gLCB0KTtcbiAgfVxuICAvKipcbiAgICogTGlzdCB5b3VyIG9yZ2FuaXphdGlvbidzIGZpbmUtdHVuaW5nIGpvYnNcbiAgICovXG4gIGxpc3QoZSkge1xuICAgIHJldHVybiB0aGlzLmdldEFQSUxpc3QoXCIvZmluZS10dW5lc1wiLCBvdCwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IGNhbmNlbCBhIGZpbmUtdHVuZSBqb2IuXG4gICAqL1xuICBjYW5jZWwoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnBvc3QoYC9maW5lLXR1bmVzLyR7ZX0vY2FuY2VsYCwgdCk7XG4gIH1cbiAgbGlzdEV2ZW50cyhlLCB0LCBzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAvZmluZS10dW5lcy8ke2V9L2V2ZW50c2AsIHtcbiAgICAgIHF1ZXJ5OiB0LFxuICAgICAgdGltZW91dDogODY0ZTUsXG4gICAgICAuLi5zLFxuICAgICAgc3RyZWFtOiAodCA9PSBudWxsID8gdm9pZCAwIDogdC5zdHJlYW0pID8/ICExXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIG90IGV4dGVuZHMga2Uge1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgbi5GaW5lVHVuZXNQYWdlID0gb3Q7XG59KShBZSB8fCAoQWUgPSB7fSkpO1xuY2xhc3MgRWUgZXh0ZW5kcyBnIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBqb2IgdGhhdCBmaW5lLXR1bmVzIGEgc3BlY2lmaWVkIG1vZGVsIGZyb20gYSBnaXZlbiBkYXRhc2V0LlxuICAgKlxuICAgKiBSZXNwb25zZSBpbmNsdWRlcyBkZXRhaWxzIG9mIHRoZSBlbnF1ZXVlZCBqb2IgaW5jbHVkaW5nIGpvYiBzdGF0dXMgYW5kIHRoZSBuYW1lXG4gICAqIG9mIHRoZSBmaW5lLXR1bmVkIG1vZGVscyBvbmNlIGNvbXBsZXRlLlxuICAgKlxuICAgKiBbTGVhcm4gbW9yZSBhYm91dCBmaW5lLXR1bmluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nKVxuICAgKi9cbiAgY3JlYXRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KFwiL2ZpbmVfdHVuaW5nL2pvYnNcIiwgeyBib2R5OiBlLCAuLi50IH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5mbyBhYm91dCBhIGZpbmUtdHVuaW5nIGpvYi5cbiAgICpcbiAgICogW0xlYXJuIG1vcmUgYWJvdXQgZmluZS10dW5pbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9maW5lLXR1bmluZylcbiAgICovXG4gIHJldHJpZXZlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9maW5lX3R1bmluZy9qb2JzLyR7ZX1gLCB0KTtcbiAgfVxuICBsaXN0KGUgPSB7fSwgdCkge1xuICAgIHJldHVybiBJKGUpID8gdGhpcy5saXN0KHt9LCBlKSA6IHRoaXMuZ2V0QVBJTGlzdChcIi9maW5lX3R1bmluZy9qb2JzXCIsIGN0LCB7IHF1ZXJ5OiBlLCAuLi50IH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbW1lZGlhdGVseSBjYW5jZWwgYSBmaW5lLXR1bmUgam9iLlxuICAgKi9cbiAgY2FuY2VsKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KGAvZmluZV90dW5pbmcvam9icy8ke2V9L2NhbmNlbGAsIHQpO1xuICB9XG4gIGxpc3RFdmVudHMoZSwgdCA9IHt9LCBzKSB7XG4gICAgcmV0dXJuIEkodCkgPyB0aGlzLmxpc3RFdmVudHMoZSwge30sIHQpIDogdGhpcy5nZXRBUElMaXN0KGAvZmluZV90dW5pbmcvam9icy8ke2V9L2V2ZW50c2AsIGx0LCB7XG4gICAgICBxdWVyeTogdCxcbiAgICAgIC4uLnNcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgY3QgZXh0ZW5kcyBrIHtcbn1cbmNsYXNzIGx0IGV4dGVuZHMgayB7XG59XG4oZnVuY3Rpb24obikge1xuICBuLkZpbmVUdW5pbmdKb2JzUGFnZSA9IGN0LCBuLkZpbmVUdW5pbmdKb2JFdmVudHNQYWdlID0gbHQ7XG59KShFZSB8fCAoRWUgPSB7fSkpO1xuY2xhc3MgJGUgZXh0ZW5kcyBnIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5qb2JzID0gbmV3IEVlKHRoaXMuY2xpZW50KTtcbiAgfVxufVxuKGZ1bmN0aW9uKG4pIHtcbiAgbi5Kb2JzID0gRWUsIG4uRmluZVR1bmluZ0pvYnNQYWdlID0gY3QsIG4uRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UgPSBsdDtcbn0pKCRlIHx8ICgkZSA9IHt9KSk7XG5jbGFzcyBUZSBleHRlbmRzIGcge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIHZhcmlhdGlvbiBvZiBhIGdpdmVuIGltYWdlLlxuICAgKi9cbiAgY3JlYXRlVmFyaWF0aW9uKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KFwiL2ltYWdlcy92YXJpYXRpb25zXCIsIEcoeyBib2R5OiBlLCAuLi50IH0pKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlZGl0ZWQgb3IgZXh0ZW5kZWQgaW1hZ2UgZ2l2ZW4gYW4gb3JpZ2luYWwgaW1hZ2UgYW5kIGEgcHJvbXB0LlxuICAgKi9cbiAgZWRpdChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMucG9zdChcIi9pbWFnZXMvZWRpdHNcIiwgRyh7IGJvZHk6IGUsIC4uLnQgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGltYWdlIGdpdmVuIGEgcHJvbXB0LlxuICAgKi9cbiAgZ2VuZXJhdGUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnBvc3QoXCIvaW1hZ2VzL2dlbmVyYXRpb25zXCIsIHsgYm9keTogZSwgLi4udCB9KTtcbiAgfVxufVxuVGUgfHwgKFRlID0ge30pO1xuY2xhc3MgdmUgZXh0ZW5kcyBnIHtcbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIG1vZGVsIGluc3RhbmNlLCBwcm92aWRpbmcgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1vZGVsIHN1Y2ggYXNcbiAgICogdGhlIG93bmVyIGFuZCBwZXJtaXNzaW9uaW5nLlxuICAgKi9cbiAgcmV0cmlldmUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmdldChgL21vZGVscy8ke2V9YCwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIG1vZGVscywgYW5kIHByb3ZpZGVzIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGVhY2hcbiAgICogb25lIHN1Y2ggYXMgdGhlIG93bmVyIGFuZCBhdmFpbGFiaWxpdHkuXG4gICAqL1xuICBsaXN0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBUElMaXN0KFwiL21vZGVsc1wiLCB1dCwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGZpbmUtdHVuZWQgbW9kZWwuIFlvdSBtdXN0IGhhdmUgdGhlIE93bmVyIHJvbGUgaW4geW91ciBvcmdhbml6YXRpb24gdG9cbiAgICogZGVsZXRlIGEgbW9kZWwuXG4gICAqL1xuICBkZWwoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmRlbGV0ZShgL21vZGVscy8ke2V9YCwgdCk7XG4gIH1cbn1cbmNsYXNzIHV0IGV4dGVuZHMga2Uge1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgbi5Nb2RlbHNQYWdlID0gdXQ7XG59KSh2ZSB8fCAodmUgPSB7fSkpO1xuY2xhc3MgRmUgZXh0ZW5kcyBnIHtcbiAgLyoqXG4gICAqIENsYXNzaWZpZXMgaWYgdGV4dCB2aW9sYXRlcyBPcGVuQUkncyBDb250ZW50IFBvbGljeVxuICAgKi9cbiAgY3JlYXRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KFwiL21vZGVyYXRpb25zXCIsIHsgYm9keTogZSwgLi4udCB9KTtcbiAgfVxufVxuRmUgfHwgKEZlID0ge30pO1xudmFyIEt0O1xuY2xhc3MgYiBleHRlbmRzIGZuIHtcbiAgLyoqXG4gICAqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIE9wZW5BSSBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5hcGlLZXk9PXByb2Nlc3MuZW52WydPUEVOQUlfQVBJX0tFWSddID8/IHVuZGVmaW5lZF1cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBbb3B0cy5vcmdhbml6YXRpb249PXByb2Nlc3MuZW52WydPUEVOQUlfT1JHX0lEJ10gPz8gbnVsbF1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhc2VVUkxdIC0gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmFzZSBVUkwgZm9yIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0PTEwIG1pbnV0ZXNdIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhlIGNsaWVudCB3aWxsIHdhaXQgZm9yIGEgcmVzcG9uc2UgYmVmb3JlIHRpbWluZyBvdXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5odHRwQWdlbnRdIC0gQW4gSFRUUCBhZ2VudCB1c2VkIHRvIG1hbmFnZSBIVFRQKHMpIGNvbm5lY3Rpb25zLlxuICAgKiBAcGFyYW0ge0NvcmUuRmV0Y2h9IFtvcHRzLmZldGNoXSAtIFNwZWNpZnkgYSBjdXN0b20gYGZldGNoYCBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLm1heFJldHJpZXM9Ml0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgdGltZXMgdGhlIGNsaWVudCB3aWxsIHJldHJ5IGEgcmVxdWVzdC5cbiAgICogQHBhcmFtIHtDb3JlLkhlYWRlcnN9IG9wdHMuZGVmYXVsdEhlYWRlcnMgLSBEZWZhdWx0IGhlYWRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICogQHBhcmFtIHtDb3JlLkRlZmF1bHRRdWVyeX0gb3B0cy5kZWZhdWx0UXVlcnkgLSBEZWZhdWx0IHF1ZXJ5IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5kYW5nZXJvdXNseUFsbG93QnJvd3Nlcj1mYWxzZV0gLSBCeSBkZWZhdWx0LCBjbGllbnQtc2lkZSB1c2Ugb2YgdGhpcyBsaWJyYXJ5IGlzIG5vdCBhbGxvd2VkLCBhcyBpdCByaXNrcyBleHBvc2luZyB5b3VyIHNlY3JldCBBUEkgY3JlZGVudGlhbHMgdG8gYXR0YWNrZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGlLZXk6IGUgPSB5dChcIk9QRU5BSV9BUElfS0VZXCIpLCBvcmdhbml6YXRpb246IHQgPSB5dChcIk9QRU5BSV9PUkdfSURcIikgPz8gbnVsbCwgLi4ucyB9ID0ge30pIHtcbiAgICBpZiAoZSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IG0oXCJUaGUgT1BFTkFJX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWlzc2luZyBvciBlbXB0eTsgZWl0aGVyIHByb3ZpZGUgaXQsIG9yIGluc3RhbnRpYXRlIHRoZSBPcGVuQUkgY2xpZW50IHdpdGggYW4gYXBpS2V5IG9wdGlvbiwgbGlrZSBuZXcgT3BlbkFJKHsgYXBpS2V5OiAnTXkgQVBJIEtleScgfSkuXCIpO1xuICAgIGNvbnN0IHIgPSB7XG4gICAgICBhcGlLZXk6IGUsXG4gICAgICBvcmdhbml6YXRpb246IHQsXG4gICAgICAuLi5zLFxuICAgICAgYmFzZVVSTDogcy5iYXNlVVJMID8/IFwiaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MVwiXG4gICAgfTtcbiAgICBpZiAoIXIuZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXIgJiYgU24oKSlcbiAgICAgIHRocm93IG5ldyBtKGBJdCBsb29rcyBsaWtlIHlvdSdyZSBydW5uaW5nIGluIGEgYnJvd3Nlci1saWtlIGVudmlyb25tZW50LlxuXG5UaGlzIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXG5JZiB5b3UgdW5kZXJzdGFuZCB0aGUgcmlza3MgYW5kIGhhdmUgYXBwcm9wcmlhdGUgbWl0aWdhdGlvbnMgaW4gcGxhY2UsXG55b3UgY2FuIHNldCB0aGUgXFxgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXJcXGAgb3B0aW9uIHRvIFxcYHRydWVcXGAsIGUuZy4sXG5cbm5ldyBPcGVuQUkoeyBhcGlLZXksIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlIH0pO1xuXG5odHRwczovL2hlbHAub3BlbmFpLmNvbS9lbi9hcnRpY2xlcy81MTEyNTk1LWJlc3QtcHJhY3RpY2VzLWZvci1hcGkta2V5LXNhZmV0eVxuYCk7XG4gICAgc3VwZXIoe1xuICAgICAgYmFzZVVSTDogci5iYXNlVVJMLFxuICAgICAgdGltZW91dDogci50aW1lb3V0ID8/IDZlNSxcbiAgICAgIGh0dHBBZ2VudDogci5odHRwQWdlbnQsXG4gICAgICBtYXhSZXRyaWVzOiByLm1heFJldHJpZXMsXG4gICAgICBmZXRjaDogci5mZXRjaFxuICAgIH0pLCB0aGlzLmNvbXBsZXRpb25zID0gbmV3IHhlKHRoaXMpLCB0aGlzLmNoYXQgPSBuZXcgY2UodGhpcyksIHRoaXMuZWRpdHMgPSBuZXcgUmUodGhpcyksIHRoaXMuZW1iZWRkaW5ncyA9IG5ldyBQZSh0aGlzKSwgdGhpcy5maWxlcyA9IG5ldyBTZSh0aGlzKSwgdGhpcy5pbWFnZXMgPSBuZXcgVGUodGhpcyksIHRoaXMuYXVkaW8gPSBuZXcgZGUodGhpcyksIHRoaXMubW9kZXJhdGlvbnMgPSBuZXcgRmUodGhpcyksIHRoaXMubW9kZWxzID0gbmV3IHZlKHRoaXMpLCB0aGlzLmZpbmVUdW5pbmcgPSBuZXcgJGUodGhpcyksIHRoaXMuZmluZVR1bmVzID0gbmV3IEFlKHRoaXMpLCB0aGlzLmJldGEgPSBuZXcgQ2UodGhpcyksIHRoaXMuX29wdGlvbnMgPSByLCB0aGlzLmFwaUtleSA9IGUsIHRoaXMub3JnYW5pemF0aW9uID0gdDtcbiAgfVxuICBkZWZhdWx0UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZGVmYXVsdFF1ZXJ5O1xuICB9XG4gIGRlZmF1bHRIZWFkZXJzKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMoZSksXG4gICAgICBcIk9wZW5BSS1Pcmdhbml6YXRpb25cIjogdGhpcy5vcmdhbml6YXRpb24sXG4gICAgICAuLi50aGlzLl9vcHRpb25zLmRlZmF1bHRIZWFkZXJzXG4gICAgfTtcbiAgfVxuICBhdXRoSGVhZGVycyhlKSB7XG4gICAgcmV0dXJuIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYXBpS2V5fWAgfTtcbiAgfVxufVxuS3QgPSBiO1xuYi5PcGVuQUkgPSBLdDtcbmIuT3BlbkFJRXJyb3IgPSBtO1xuYi5BUElFcnJvciA9IF87XG5iLkFQSUNvbm5lY3Rpb25FcnJvciA9IEllO1xuYi5BUElDb25uZWN0aW9uVGltZW91dEVycm9yID0gWmU7XG5iLkFQSVVzZXJBYm9ydEVycm9yID0gajtcbmIuTm90Rm91bmRFcnJvciA9IEl0O1xuYi5Db25mbGljdEVycm9yID0gTXQ7XG5iLlJhdGVMaW1pdEVycm9yID0gT3Q7XG5iLkJhZFJlcXVlc3RFcnJvciA9IFR0O1xuYi5BdXRoZW50aWNhdGlvbkVycm9yID0gdnQ7XG5iLkludGVybmFsU2VydmVyRXJyb3IgPSBMdDtcbmIuUGVybWlzc2lvbkRlbmllZEVycm9yID0gRnQ7XG5iLlVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciA9IGt0O1xuKGZ1bmN0aW9uKG4pIHtcbiAgbi50b0ZpbGUgPSBOdCwgbi5maWxlRnJvbVBhdGggPSBFdCwgbi5QYWdlID0ga2UsIG4uQ3Vyc29yUGFnZSA9IGssIG4uQ29tcGxldGlvbnMgPSB4ZSwgbi5DaGF0ID0gY2UsIG4uRWRpdHMgPSBSZSwgbi5FbWJlZGRpbmdzID0gUGUsIG4uRmlsZXMgPSBTZSwgbi5GaWxlT2JqZWN0c1BhZ2UgPSBhdCwgbi5JbWFnZXMgPSBUZSwgbi5BdWRpbyA9IGRlLCBuLk1vZGVyYXRpb25zID0gRmUsIG4uTW9kZWxzID0gdmUsIG4uTW9kZWxzUGFnZSA9IHV0LCBuLkZpbmVUdW5pbmcgPSAkZSwgbi5GaW5lVHVuZXMgPSBBZSwgbi5GaW5lVHVuZXNQYWdlID0gb3QsIG4uQmV0YSA9IENlO1xufSkoYiB8fCAoYiA9IHt9KSk7XG5jb25zdCAkbiA9IGI7XG4oZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA8IFwidVwiKSB7XG4gICAgICB2YXIgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIG4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuY2UtcGFyYWdyYXBoe2xpbmUtaGVpZ2h0OjEuNmVtO291dGxpbmU6bm9uZX0uY2UtcGFyYWdyYXBoW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmJlZm9yZXtjb250ZW50OmF0dHIoZGF0YS1wbGFjZWhvbGRlcik7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo0MDA7b3BhY2l0eTowfS5jb2RleC1lZGl0b3ItLWVtcHR5IC5jZS1ibG9jazpmaXJzdC1jaGlsZCAuY2UtcGFyYWdyYXBoW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmJlZm9yZXtvcGFjaXR5OjF9LmNvZGV4LWVkaXRvci0tdG9vbGJveC1vcGVuZWQgLmNlLWJsb2NrOmZpcnN0LWNoaWxkIC5jZS1wYXJhZ3JhcGhbZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6YmVmb3JlLC5jb2RleC1lZGl0b3ItLWVtcHR5IC5jZS1ibG9jazpmaXJzdC1jaGlsZCAuY2UtcGFyYWdyYXBoW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmZvY3VzOmJlZm9yZXtvcGFjaXR5OjB9LmNlLXBhcmFncmFwaCBwOmZpcnN0LW9mLXR5cGV7bWFyZ2luLXRvcDowfS5jZS1wYXJhZ3JhcGggcDpsYXN0LW9mLXR5cGV7bWFyZ2luLWJvdHRvbTowfVwiKSksIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLCBlKTtcbiAgfVxufSkoKTtcbmNvbnN0IFRuID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk04IDlWNy4yQzggNy4wODk1NCA4LjA4OTU0IDcgOC4yIDdMMTIgN00xNiA5VjcuMkMxNiA3LjA4OTU0IDE1LjkxMDUgNyAxNS44IDdMMTIgN00xMiA3TDEyIDE3TTEyIDE3SDEwTTEyIDE3SDE0XCIvPjwvc3ZnPic7XG4vKipcbiAqIEJhc2UgUGFyYWdyYXBoIEJsb2NrIGZvciB0aGUgRWRpdG9yLmpzLlxuICogUmVwcmVzZW50cyBhIHJlZ3VsYXIgdGV4dCBibG9ja1xuICpcbiAqIEBhdXRob3IgQ29kZVggKHRlYW1AY29kZXguc28pXG4gKiBAY29weXJpZ2h0IENvZGVYIDIwMThcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICovXG5jbGFzcyBodCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHBsYWNlaG9sZGVyIGZvciBQYXJhZ3JhcGggVG9vbFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAY2xhc3NcbiAgICovXG4gIHN0YXRpYyBnZXQgREVGQVVMVF9QTEFDRUhPTERFUigpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHBsdWdpbmBzIG1haW4gRWxlbWVudCBhbmQgZmlsbCBpdCB3aXRoIHNhdmVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIGNvbnN0cnVjdG9yIHBhcmFtc1xuICAgKiBAcGFyYW0ge1BhcmFncmFwaERhdGF9IHBhcmFtcy5kYXRhIC0gcHJldmlvdXNseSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoQ29uZmlnfSBwYXJhbXMuY29uZmlnIC0gdXNlciBjb25maWcgZm9yIFRvb2xcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5hcGkgLSBlZGl0b3IuanMgYXBpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHkgLSByZWFkIG9ubHkgbW9kZSBmbGFnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IGUsIGNvbmZpZzogdCwgYXBpOiBzLCByZWFkT25seTogciB9KSB7XG4gICAgdGhpcy5hcGkgPSBzLCB0aGlzLnJlYWRPbmx5ID0gciwgdGhpcy5fQ1NTID0ge1xuICAgICAgYmxvY2s6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcbiAgICAgIHdyYXBwZXI6IFwiY2UtcGFyYWdyYXBoXCJcbiAgICB9LCB0aGlzLnJlYWRPbmx5IHx8ICh0aGlzLm9uS2V5VXAgPSB0aGlzLm9uS2V5VXAuYmluZCh0aGlzKSksIHRoaXMuX3BsYWNlaG9sZGVyID0gdC5wbGFjZWhvbGRlciA/IHQucGxhY2Vob2xkZXIgOiBodC5ERUZBVUxUX1BMQUNFSE9MREVSLCB0aGlzLl9kYXRhID0ge30sIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9wcmVzZXJ2ZUJsYW5rID0gdC5wcmVzZXJ2ZUJsYW5rICE9PSB2b2lkIDAgPyB0LnByZXNlcnZlQmxhbmsgOiAhMSwgdGhpcy5kYXRhID0gZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGV4dCBjb250ZW50IGlzIGVtcHR5IGFuZCBzZXQgZW1wdHkgc3RyaW5nIHRvIGlubmVyIGh0bWwuXG4gICAqIFdlIG5lZWQgdGhpcyBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgKGUuZy4gU2FmYXJpKSBpbnNlcnQgPGJyPiBpbnRvIGVtcHR5IGNvbnRlbnRlZGl0YW5sZSBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUgLSBrZXkgdXAgZXZlbnRcbiAgICovXG4gIG9uS2V5VXAoZSkge1xuICAgIGlmIChlLmNvZGUgIT09IFwiQmFja3NwYWNlXCIgJiYgZS5jb2RlICE9PSBcIkRlbGV0ZVwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgdGV4dENvbnRlbnQ6IHQgfSA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgdCA9PT0gXCJcIiAmJiAodGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIFRvb2wncyB2aWV3XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRyYXdWaWV3KCkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgIHJldHVybiBlLmNsYXNzTGlzdC5hZGQodGhpcy5fQ1NTLndyYXBwZXIsIHRoaXMuX0NTUy5ibG9jayksIGUuY29udGVudEVkaXRhYmxlID0gITEsIGUuZGF0YXNldC5wbGFjZWhvbGRlciA9IHRoaXMuYXBpLmkxOG4udCh0aGlzLl9wbGFjZWhvbGRlciksIHRoaXMuX2RhdGEudGV4dCAmJiAoZS5pbm5lckhUTUwgPSB0aGlzLl9kYXRhLnRleHQpLCB0aGlzLnJlYWRPbmx5IHx8IChlLmNvbnRlbnRFZGl0YWJsZSA9ICEwLCBlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLm9uS2V5VXApKSwgZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFRvb2wncyB2aWV3XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudCA9IHRoaXMuZHJhd1ZpZXcoKSwgdGhpcy5fZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgc3BlY2lmaWVkIGhvdyB0byBtZXJnZSB0d28gVGV4dCBibG9ja3MuXG4gICAqIENhbGxlZCBieSBFZGl0b3IuanMgYnkgYmFja3NwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoRGF0YX0gZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBtZXJnZShlKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHRleHQ6IHRoaXMuZGF0YS50ZXh0ICsgZS50ZXh0XG4gICAgfTtcbiAgICB0aGlzLmRhdGEgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBQYXJhZ3JhcGggYmxvY2sgZGF0YTpcbiAgICogLSBjaGVjayBmb3IgZW1wdGluZXNzXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoRGF0YX0gc2F2ZWREYXRhIOKAlCBkYXRhIHJlY2VpdmVkIGFmdGVyIHNhdmluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgc2F2ZWQgZGF0YSBpcyBub3QgY29ycmVjdCwgb3RoZXJ3aXNlIHRydWVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdmFsaWRhdGUoZSkge1xuICAgIHJldHVybiAhKGUudGV4dC50cmltKCkgPT09IFwiXCIgJiYgIXRoaXMuX3ByZXNlcnZlQmxhbmspO1xuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0IFRvb2wncyBkYXRhIGZyb20gdGhlIHZpZXdcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gdG9vbHNDb250ZW50IC0gUGFyYWdyYXBoIHRvb2xzIHJlbmRlcmVkIHZpZXdcbiAgICogQHJldHVybnMge1BhcmFncmFwaERhdGF9IC0gc2F2ZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzYXZlKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogZS5pbm5lckhUTUxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPbiBwYXN0ZSBjYWxsYmFjayBmaXJlZCBmcm9tIEVkaXRvci5cbiAgICpcbiAgICogQHBhcmFtIHtQYXN0ZUV2ZW50fSBldmVudCAtIGV2ZW50IHdpdGggcGFzdGVkIGRhdGFcbiAgICovXG4gIG9uUGFzdGUoZSkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICB0ZXh0OiBlLmRldGFpbC5kYXRhLmlubmVySFRNTFxuICAgIH07XG4gICAgdGhpcy5kYXRhID0gdDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIENvbnZlcnNpb24gVG9vbGJhci4gUGFyYWdyYXBoIGNhbiBiZSBjb252ZXJ0ZWQgdG8vZnJvbSBvdGhlciB0b29sc1xuICAgKi9cbiAgc3RhdGljIGdldCBjb252ZXJzaW9uQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBleHBvcnQ6IFwidGV4dFwiLFxuICAgICAgLy8gdG8gY29udmVydCBQYXJhZ3JhcGggdG8gb3RoZXIgYmxvY2ssIHVzZSAndGV4dCcgcHJvcGVydHkgb2Ygc2F2ZWQgZGF0YVxuICAgICAgaW1wb3J0OiBcInRleHRcIlxuICAgICAgLy8gdG8gY292ZXJ0IG90aGVyIGJsb2NrJ3MgZXhwb3J0ZWQgc3RyaW5nIHRvIFBhcmFncmFwaCwgZmlsbCAndGV4dCcgcHJvcGVydHkgb2YgdG9vbCBkYXRhXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FuaXRpemVyIHJ1bGVzXG4gICAqL1xuICBzdGF0aWMgZ2V0IHNhbml0aXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB7XG4gICAgICAgIGJyOiAhMFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSB0byBub3RpZnkgdGhlIGNvcmUgdGhhdCByZWFkLW9ubHkgbW9kZSBpcyBzdXBwb3J0ZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBUb29sc2BzIGRhdGFcbiAgICpcbiAgICogQHJldHVybnMge1BhcmFncmFwaERhdGF9IEN1cnJlbnQgZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9lbGVtZW50LmlubmVySFRNTDtcbiAgICAgIHRoaXMuX2RhdGEudGV4dCA9IGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBTdG9yZSBkYXRhIGluIHBsdWdpbjpcbiAgICogLSBhdCB0aGUgdGhpcy5fZGF0YSBwcm9wZXJ0eVxuICAgKiAtIGF0IHRoZSBIVE1MXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoRGF0YX0gZGF0YSDigJQgZGF0YSB0byBzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldCBkYXRhKGUpIHtcbiAgICB0aGlzLl9kYXRhID0gZSB8fCB7fSwgdGhpcy5fZWxlbWVudCAhPT0gbnVsbCAmJiB0aGlzLmh5ZHJhdGUoKTtcbiAgfVxuICAvKipcbiAgICogRmlsbCB0b29sJ3MgdmlldyB3aXRoIGRhdGFcbiAgICovXG4gIGh5ZHJhdGUoKSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCB8fCBcIlwiO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIGJ5IEVkaXRvciBwYXN0ZSBoYW5kbGluZyBBUEkuXG4gICAqIFByb3ZpZGVzIGNvbmZpZ3VyYXRpb24gdG8gaGFuZGxlIFAgdGFncy5cbiAgICpcbiAgICogQHJldHVybnMge3t0YWdzOiBzdHJpbmdbXX19XG4gICAqL1xuICBzdGF0aWMgZ2V0IHBhc3RlQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWdzOiBbXCJQXCJdXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSWNvbiBhbmQgdGl0bGUgZm9yIGRpc3BsYXlpbmcgYXQgdGhlIFRvb2xib3hcbiAgICpcbiAgICogQHJldHVybnMge3tpY29uOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBUbixcbiAgICAgIHRpdGxlOiBcIlRleHRcIlxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHZuKG4sIGUgPSAyZTMpIHtcbiAgbGV0IHQ7XG4gIHJldHVybiAoLi4ucykgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0KSwgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbi5hcHBseSh0aGlzLCBzKTtcbiAgICB9LCBlKTtcbiAgfTtcbn1cbmNsYXNzIFVuIGV4dGVuZHMgaHQge1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogdCwgYmxvY2s6IHMsIGNvbmZpZzogciwgZGF0YTogaSB9KSB7XG4gICAgY29uc29sZS5sb2cocik7XG4gICAgc3VwZXIoe1xuICAgICAgYXBpOiB0LFxuICAgICAgYmxvY2s6IHMsXG4gICAgICBjb25maWc6IHIsXG4gICAgICBkYXRhOiBpXG4gICAgfSk7XG4gICAgQmUodGhpcywgXCJvcGVuYWlcIik7XG4gICAgQmUodGhpcywgXCJvbklucHV0XCIsIHZuKCh0KSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYWktc3VnZ2VzdGlvbnNcIikgfHwgdC5pbnB1dFR5cGUgPT09IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIgfHwgdC5pbnB1dFR5cGUgPT09IFwiZGVsZXRlQ29udGVudEZvcndhcmRcIiB8fCB0LmlucHV0VHlwZSA9PT0gXCJpbnNlcnRQYXJhZ3JhcGhcIiB8fCB0LmlucHV0VHlwZSA9PT0gXCJpbnNlcnRGcm9tUGFzdGVcIiB8fCB0LmlucHV0VHlwZSA9PT0gXCJpbnNlcnRGcm9tRHJvcFwiIHx8ICF0LnRhcmdldC5pbm5lckhUTUwgfHwgdGhpcy5nZXRBSUNvbXBsZXRpb24odC50YXJnZXQuaW5uZXJIVE1MKTtcbiAgICB9KSk7XG4gICAgaWYgKCFyLm9wZW5haUtleSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wZW5BSSBrZXkgaXMgcmVxdWlyZWQgZm9yIEFJIFRleHRcIik7XG4gICAgdGhpcy5vcGVuYWkgPSBuZXcgJG4oe1xuICAgICAgYXBpS2V5OiByLm9wZW5haUtleSxcbiAgICAgIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiAhMFxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgdG9vbGJveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGl0bGU6IFwiQUkgVEVYVCAoZXhwZXJpbWVudGFsKVwiLFxuICAgICAgaWNvbjogYDxzdmcgd2lkdGg9XCI4MDBweFwiIGhlaWdodD1cIjgwMHB4XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgPHBhdGggZD1cIk04IDRWMjBNMTcgMTJWMjBNNiAyMEgxME0xNSAyMEgxOU0xMyA3VjRIM1Y3TTIxIDE0VjEySDEzVjE0XCIgc3Ryb2tlPVwiIzAwMDAwMFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIi8+XG4gICAgICA8L3N2Zz5gXG4gICAgfTtcbiAgfVxuICBnZXRBSUNvbXBsZXRpb24odCkge1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBzLmlubmVySFRNTCA9IGA8c3ZnIHdpZHRoPVwiODAwcHhcIiBoZWlnaHQ9XCI4MDBweFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICA8cGF0aCBkPVwiTTEyIDIuOTk5ODhWNS45OTk4OE0xMiAyMC45OTk5VjE3Ljk5OTlNNC4yMDU3NyAxNi40OTk5TDYuODAzODUgMTQuOTk5OU0yMSAxMS45OTk5SDE4TTE2LjUgMTkuNzk0MUwxNSAxNy4xOTZNMyAxMS45OTk5SDZNNy41IDQuMjA1NjVMOSA2LjgwMzczTTcuNSAxOS43OTQxTDkgMTcuMTk2TTE5Ljc5NDIgMTYuNDk5OUwxNy4xOTYyIDE0Ljk5OTlNNC4yMDU3NyA3LjQ5OTg4TDYuODAzODUgOC45OTk4OFwiIHN0cm9rZT1cIiMwMDAwMDBcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPlxuICAgIDwvc3ZnPmAsIHMuaWQgPSBcImFpLXN1Z2dlc3Rpb25zLWxvYWRlclwiLCBzLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1mbGV4XCIsIHMuc3R5bGUuYWxpZ25JdGVtcyA9IFwiY2VudGVyXCIsIHMuc3R5bGUud2lkdGggPSBcIjI0cHhcIiwgcy5zdHlsZS5oZWlnaHQgPSBcIjI0cHhcIiwgcy5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiNHB4XCIsIHMuc3R5bGUuY29sb3IgPSBcImxpZ2h0Z3JheVwiLCBzLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiLCBzLmFuaW1hdGUoXG4gICAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IFwicm90YXRlKDBkZWcpXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoMzYwZGVnKVwiXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB7XG4gICAgICAgIGR1cmF0aW9uOiAyZTMsXG4gICAgICAgIGl0ZXJhdGlvbnM6IDEgLyAwXG4gICAgICB9XG4gICAgKSwgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZChzKSwgdGhpcy5vcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGBCZWhhdmUgeW91cnNlbGYgYXMgYSBwcm9mZXNzaW9uYWwgam91cm5hbGlzdCBhbmQgZmluaXNoIHRoaXMgdGV4dCBpbiBzaW1pbGFyIHN0eWxlOiAke3QubGVuZ3RoID4gMTAwID8gdCA6IHQuc2xpY2UodC5sZW5ndGggLSAxMDApfWBcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG1heF90b2tlbnM6IDI1NixcbiAgICAgIG1vZGVsOiBcImdwdC0zLjUtdHVyYm9cIlxuICAgIH0pLnRoZW4oKHIpID0+IHtcbiAgICAgIHZhciBhO1xuICAgICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgaS5pbm5lckhUTUwgPSBcIlwiLCBpLmlkID0gXCJhaS1zdWdnZXN0aW9uc1wiLCBpLnN0eWxlLmNvbG9yID0gXCJsaWdodGdyYXlcIiwgaS5pbm5lckhUTUwgPSByLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50LCB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKGkpLCAoYSA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihcIiNhaS1zdWdnZXN0aW9ucy1sb2FkZXJcIikpID09IG51bGwgfHwgYS5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICBvbktleVVwKHQpIHtcbiAgICB2YXIgcjtcbiAgICBpZiAodC5jb2RlID09PSBcIkVzY2FwZVwiIHx8IHQuY29kZSA9PT0gXCJCYWNrc3BhY2VcIikge1xuICAgICAgKHIgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYWktc3VnZ2VzdGlvbnNcIikpID09IG51bGwgfHwgci5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHQuY29kZSA9PT0gXCJBbHRMZWZ0XCIgfHwgdC5jb2RlID09PSBcIkFsdFJpZ2h0XCIpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYWktc3VnZ2VzdGlvbnNcIiksIGEgPSBpID09IG51bGwgPyB2b2lkIDAgOiBpLnRleHRDb250ZW50O1xuICAgICAgaWYgKCFhKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgICAgIGFcbiAgICAgICk7XG4gICAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKG8pLCBpLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodC5jb2RlICE9PSBcIkJhY2tzcGFjZVwiICYmIHQuY29kZSAhPT0gXCJEZWxldGVcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRleHRDb250ZW50OiBzIH0gPSB0aGlzLl9lbGVtZW50O1xuICAgIHMgPT09IFwiXCIgJiYgKHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gXCJcIik7XG4gIH1cbiAgZHJhd1ZpZXcoKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gICAgcmV0dXJuIHQuY2xhc3NMaXN0LmFkZCh0aGlzLl9DU1Mud3JhcHBlciwgdGhpcy5fQ1NTLmJsb2NrKSwgdC5jb250ZW50RWRpdGFibGUgPSAhMSwgdC5kYXRhc2V0LnBsYWNlaG9sZGVyID0gdGhpcy5hcGkuaTE4bi50KHRoaXMuX3BsYWNlaG9sZGVyKSwgdGhpcy5fZGF0YS50ZXh0ICYmICh0LmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCksIHRoaXMucmVhZE9ubHkgfHwgKHQuY29udGVudEVkaXRhYmxlID0gITAsIHQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMub25LZXlVcCksIHQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMub25JbnB1dCkpLCB0O1xuICB9XG59XG5leHBvcnQge1xuICBVbiBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@alkhipce/editorjs-aitext/dist/aitext.mjs\n");

/***/ })

};
;